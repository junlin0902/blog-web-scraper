"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  default: () => redwoodPluginVite
});
module.exports = __toCommonJS(src_exports);
var import_fs = __toESM(require("fs"), 1);
var import_path = __toESM(require("path"), 1);
var import_plugin_react = __toESM(require("@vitejs/plugin-react"), 1);
var import_vite = require("vite");
var import_vite_plugin_node_polyfills = require("vite-plugin-node-polyfills");
var import_babel_config = require("@redwoodjs/babel-config");
var import_project_config = require("@redwoodjs/project-config");
var import_getMergedConfig = require("./lib/getMergedConfig.js");
var import_vite_plugin_jsx_loader = require("./plugins/vite-plugin-jsx-loader.js");
var import_vite_plugin_remove_from_bundle = require("./plugins/vite-plugin-remove-from-bundle.js");
var import_vite_plugin_swap_apollo_provider = require("./plugins/vite-plugin-swap-apollo-provider.js");
function redwoodPluginVite() {
  const rwPaths = (0, import_project_config.getPaths)();
  const rwConfig = (0, import_project_config.getConfig)();
  const clientEntryPath = rwPaths.web.entryClient;
  if (!clientEntryPath) {
    throw new Error(
      "Vite client entry point not found. Please check that your project has an entry.client.{jsx,tsx} file in the web/src directory."
    );
  }
  const relativeEntryPath = import_path.default.relative(rwPaths.web.src, clientEntryPath);
  const apiPackageJsonPath = import_path.default.join(rwPaths.api.base, "package.json");
  const realtimeEnabled = import_fs.default.existsSync(apiPackageJsonPath) && import_fs.default.readFileSync(apiPackageJsonPath, "utf-8").includes("@redwoodjs/realtime");
  const streamingEnabled = rwConfig.experimental.streamingSsr.enabled;
  const rscEnabled = rwConfig.experimental?.rsc?.enabled;
  const webSideDefaultBabelConfig = (0, import_babel_config.getWebSideDefaultBabelConfig)();
  const babelConfig = {
    ...webSideDefaultBabelConfig,
    // For RSC we don't want to include the routes auto-loader plugin as we
    // handle that differently in each specific RSC build stage
    overrides: rscEnabled ? webSideDefaultBabelConfig.overrides.filter((override) => {
      return !override.plugins?.some((plugin) => {
        return Array.isArray(plugin) && plugin[2] === "babel-plugin-redwood-routes-auto-loader";
      });
    }) : webSideDefaultBabelConfig.overrides
  };
  return [
    {
      name: "redwood-plugin-vite-html-env",
      // Vite can support replacing environment variables in index.html but
      // there are currently two issues with that:
      // 1. It requires the environment variables to be exposed on
      //    `import.meta.env`, but we expose them on `process.env` in Redwood.
      // 2. There's an open issue on Vite where it adds extra quotes around
      //    the replaced values, which breaks trying to use environment
      //    variables in src attributes for example.
      // Until those issues are resolved, we'll do the replacement ourselves
      // instead using transformIndexHtml. Doing it this was was also the
      // recommended way until Vite added built-in support for it.
      //
      // Extra quotes issue: https://github.com/vitejs/vite/issues/13424
      // transformIndexHtml being the recommended way:
      //   https://github.com/vitejs/vite/issues/3105#issuecomment-1059975023
      transformIndexHtml: {
        // Setting order: 'pre' so that it runs before the built-in
        // html env replacement.
        order: "pre",
        handler: (html) => {
          let newHtml = html;
          rwConfig.web.includeEnvironmentVariables.map((envName) => {
            newHtml = newHtml.replaceAll(
              `%${envName}%`,
              process.env[envName] || ""
            );
          });
          Object.entries(process.env).forEach(([envName, value]) => {
            if (envName.startsWith("REDWOOD_ENV_")) {
              newHtml = newHtml.replaceAll(`%${envName}%`, value || "");
            }
          });
          return newHtml;
        }
      }
    },
    {
      name: "redwood-plugin-vite",
      // ---------- Bundle injection ----------
      // Used by Vite during dev, to inject the entrypoint.
      transformIndexHtml: {
        order: "pre",
        handler: (html) => {
          if (import_fs.default.existsSync(clientEntryPath)) {
            return html.replace(
              "</head>",
              // @NOTE the slash in front, for windows compatibility and for pages in subdirectories
              `<script type="module" src="/${relativeEntryPath}"></script>
        </head>`
            );
          } else {
            return html;
          }
        }
      },
      // Used by rollup during build to inject the entrypoint
      // but note index.html does not come through as an id during dev
      transform: (code, id) => {
        if (import_fs.default.existsSync(clientEntryPath) && (0, import_vite.normalizePath)(id) === (0, import_vite.normalizePath)(rwPaths.web.html)) {
          return {
            code: code.replace(
              "</head>",
              `<script type="module" src="/${relativeEntryPath}"></script>
        </head>`
            ),
            map: null
          };
        } else {
          return {
            code,
            map: null
            // Returning null here preserves the original sourcemap
          };
        }
      },
      // ---------- End Bundle injection ----------
      // @MARK: Using the config hook here let's us modify the config
      // but returning plugins will **not** work
      config: (0, import_getMergedConfig.getMergedConfig)(rwConfig, rwPaths)
    },
    // We can remove when streaming is stable
    streamingEnabled && (0, import_vite_plugin_swap_apollo_provider.swapApolloProvider)(),
    (0, import_vite_plugin_jsx_loader.handleJsAsJsx)(),
    // Remove the splash-page from the bundle.
    (0, import_vite_plugin_remove_from_bundle.removeFromBundle)(
      [
        {
          id: /@redwoodjs\/router\/dist\/splash-page/
        }
      ],
      ["SplashPage"]
    ),
    !realtimeEnabled && (0, import_vite_plugin_remove_from_bundle.removeFromBundle)([
      {
        id: /@redwoodjs\/web\/dist\/apollo\/sseLink/
      }
    ]),
    (0, import_plugin_react.default)({
      babel: babelConfig
    }),
    // Only include the Buffer polyfill for non-rsc dev, for DevFatalErrorPage
    // Including the polyfill plugin in any form in RSC breaks
    !rscEnabled && {
      ...(0, import_vite_plugin_node_polyfills.nodePolyfills)({
        include: ["buffer"],
        globals: {
          Buffer: true
        }
      }),
      apply: "serve"
    }
  ];
}
