"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createReactStreamingHandler_exports = {};
__export(createReactStreamingHandler_exports, {
  createReactStreamingHandler: () => createReactStreamingHandler
});
module.exports = __toCommonJS(createReactStreamingHandler_exports);
var import_path = __toESM(require("path"), 1);
var import_fetch = require("@whatwg-node/fetch");
var import_isbot = require("isbot");
var import_AuthProviderState = require("@redwoodjs/auth/dist/AuthProvider/AuthProviderState.js");
var import_project_config = require("@redwoodjs/project-config");
var import_util = require("@redwoodjs/router/util");
var import_middleware = require("@redwoodjs/web/middleware");
var import_invokeMiddleware = require("../middleware/invokeMiddleware.js");
var import_utils = require("../utils.js");
var import_streamHelpers = require("./streamHelpers.js");
var import_triggerRouteHooks = require("./triggerRouteHooks.js");
const isbot = (0, import_isbot.createIsbotFromList)(
  import_isbot.list.filter((record) => !record.includes("chrome-lighthouse"))
);
const createReactStreamingHandler = async ({
  routes,
  clientEntryPath,
  getStylesheetLinks,
  getMiddlewareRouter
}, viteDevServer) => {
  const rwPaths = (0, import_project_config.getPaths)();
  const rwConfig = (0, import_project_config.getConfig)();
  const isProd = !viteDevServer;
  const middlewareRouter = await getMiddlewareRouter();
  let entryServerImport;
  let fallbackDocumentImport;
  const rscEnabled = rwConfig.experimental?.rsc?.enabled;
  if (isProd) {
    if (rscEnabled) {
      entryServerImport = await import((0, import_utils.makeFilePath)(rwPaths.web.distSsrEntryServer));
    } else {
      entryServerImport = await import((0, import_utils.makeFilePath)(rwPaths.web.distSsrEntryServer));
    }
    fallbackDocumentImport = await import((0, import_utils.makeFilePath)(rwPaths.web.distSsrDocument));
  }
  return async (req) => {
    let mwResponse = import_middleware.MiddlewareResponse.next();
    let decodedAuthState = {
      ...import_AuthProviderState.middlewareDefaultAuthProviderState,
      cookieHeader: req.headers.get("cookie"),
      roles: []
    };
    let currentRoute;
    let parsedParams = {};
    const currentUrl = new URL(req.url);
    for (const route of routes) {
      const { match, ...rest } = (0, import_util.matchPath)(
        route.pathDefinition,
        currentUrl.pathname
      );
      if (match) {
        currentRoute = route;
        parsedParams = rest;
        break;
      }
    }
    const cssLinks = getStylesheetLinks(currentRoute);
    if (middlewareRouter) {
      const matchedMw = middlewareRouter.find(req.method, req.url);
      [mwResponse, decodedAuthState] = await (0, import_invokeMiddleware.invoke)(
        req,
        matchedMw?.handler,
        {
          route: currentRoute,
          cssPaths: cssLinks,
          params: matchedMw?.params,
          viteDevServer
        }
      );
      if (mwResponse.isRedirect() || mwResponse.body) {
        return mwResponse.toResponse();
      }
    }
    if (!currentRoute) {
      throw new Error("404 handling not implemented");
    }
    if (currentRoute.redirect) {
      return new import_fetch.Response(null, {
        status: 302,
        headers: {
          Location: currentRoute.redirect.to
        }
      });
    }
    if (!isProd) {
      entryServerImport = await (0, import_utils.ssrLoadEntryServer)(viteDevServer);
      fallbackDocumentImport = await viteDevServer.ssrLoadModule(
        rwPaths.web.document
      );
    }
    const ServerEntry = entryServerImport.ServerEntry || entryServerImport.default;
    const FallbackDocument = fallbackDocumentImport.Document || fallbackDocumentImport.default;
    let metaTags = [];
    let routeHookPath = currentRoute.routeHooks;
    if (isProd) {
      routeHookPath = currentRoute.routeHooks ? import_path.default.join(rwPaths.web.distRouteHooks, currentRoute.routeHooks) : null;
    }
    const routeHookOutput = await (0, import_triggerRouteHooks.loadAndRunRouteHooks)({
      paths: [(0, import_project_config.getAppRouteHook)(isProd), routeHookPath],
      reqMeta: {
        req,
        parsedParams
      },
      viteDevServer
    });
    metaTags = routeHookOutput.meta;
    const jsBundles = [viteDevServer ? clientEntryPath : "/" + clientEntryPath];
    if (currentRoute.bundle) {
      jsBundles.push("/" + currentRoute.bundle);
    }
    const isSeoCrawler = isbot(req.headers.get("user-agent") || "");
    const reactResponse = await (0, import_streamHelpers.reactRenderToStreamResponse)(
      mwResponse,
      {
        ServerEntry,
        FallbackDocument,
        currentUrl,
        metaTags,
        cssLinks,
        isProd,
        jsBundles,
        authState: decodedAuthState
      },
      {
        waitForAllReady: isSeoCrawler,
        onError: (err) => {
          if (!isProd && viteDevServer) {
            viteDevServer.ssrFixStacktrace(err);
          }
          console.error(err);
        }
      }
    );
    return reactResponse;
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createReactStreamingHandler
});
