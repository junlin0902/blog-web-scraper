"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var streamHelpers_exports = {};
__export(streamHelpers_exports, {
  importModule: () => importModule,
  reactRenderToStreamResponse: () => reactRenderToStreamResponse
});
module.exports = __toCommonJS(streamHelpers_exports);
var import_node_path = __toESM(require("node:path"), 1);
var import_project_config = require("@redwoodjs/project-config");
var import_utils = require("../utils.js");
var import_bufferedTransform = require("./transforms/bufferedTransform.js");
var import_cancelTimeoutTransform = require("./transforms/cancelTimeoutTransform.js");
var import_serverInjectionTransform = require("./transforms/serverInjectionTransform.js");
const import_meta = {};
const rscWebpackShims = `globalThis.__rw_module_cache__ ||= new Map();

globalThis.__webpack_chunk_load__ ||= (id) => {
  console.log('rscWebpackShims chunk load id', id)
  return import(id).then((mod) => {
    console.log('rscWebpackShims chunk load mod', mod)

    // checking mod.default to better support CJS. If it's an object, it's
    // likely a CJS module. Otherwise it's probably an ES module with a
    // default export
    if (mod.default && typeof mod.default === 'object') {
      return globalThis.__rw_module_cache__.set(id, mod.default)
    }

    return globalThis.__rw_module_cache__.set(id, mod)
  })
};

globalThis.__webpack_require__ ||= (id) => {
  console.log('rscWebpackShims require id', id)
  return globalThis.__rw_module_cache__.get(id)
};
`;
async function reactRenderToStreamResponse(mwRes, renderOptions, streamOptions) {
  const { waitForAllReady = false } = streamOptions;
  const {
    ServerEntry,
    FallbackDocument,
    currentUrl,
    metaTags,
    cssLinks,
    isProd,
    jsBundles = [],
    authState
  } = renderOptions;
  if (!isProd) {
    jsBundles.push(
      new URL("../../inject/reactRefresh.js", import_meta.url).pathname
    );
  }
  const assetMap = JSON.stringify({
    css: cssLinks,
    meta: metaTags
  });
  const rscEnabled = (0, import_project_config.getConfig)().experimental?.rsc?.enabled;
  const { createElement } = rscEnabled ? await importModule("__rwjs__react") : await import("react");
  const {
    createInjector,
    ServerHtmlProvider,
    ServerInjectedHtml
  } = rscEnabled ? await importModule("__rwjs__server_inject") : await import("@redwoodjs/web/serverInject");
  const { renderToString } = rscEnabled ? await importModule("rd-server") : await import("react-dom/server");
  const { injectionState, injectToPage } = createInjector();
  const bufferTransform = (0, import_bufferedTransform.createBufferedTransformStream)();
  const serverInjectionTransform = (0, import_serverInjectionTransform.createServerInjectionTransform)({
    injectionState,
    createElement,
    ServerInjectedHtml,
    renderToString,
    onlyOnFlush: waitForAllReady
  });
  const controller = new AbortController();
  const timeoutHandle = setTimeout(() => {
    controller.abort();
  }, 1e4);
  const timeoutTransform = (0, import_cancelTimeoutTransform.createTimeoutTransform)(timeoutHandle);
  const { ServerAuthProvider } = rscEnabled ? await importModule("__rwjs__server_auth_provider") : await import("@redwoodjs/auth/dist/AuthProvider/ServerAuthProvider.js");
  const { LocationProvider } = rscEnabled ? await importModule("__rwjs__location") : await import("@redwoodjs/router/location");
  const renderRoot = (url) => {
    return createElement(
      ServerAuthProvider,
      {
        value: authState
      },
      createElement(
        LocationProvider,
        {
          location: url
        },
        createElement(
          ServerHtmlProvider,
          {
            value: injectToPage
          },
          createElement(ServerEntry, {
            css: cssLinks,
            meta: metaTags
          })
        )
      )
    );
  };
  const bootstrapOptions = {
    bootstrapScriptContent: (
      // Only insert assetMap if client side JS will be loaded
      jsBundles.length > 0 ? `window.__REDWOOD__ASSET_MAP = ${assetMap}; ${rscWebpackShims}` : void 0
    ),
    bootstrapModules: jsBundles
  };
  const { renderToReadableStream } = rscEnabled ? await importModule("rd-server") : await import("react-dom/server.edge");
  try {
    let didErrorOutsideShell = false;
    const renderToStreamOptions = {
      ...bootstrapOptions,
      signal: controller.signal,
      onError: (err) => {
        didErrorOutsideShell = true;
        console.error("\u{1F53B} Caught error outside shell");
        streamOptions.onError?.(err);
      }
    };
    const root = renderRoot(currentUrl);
    const reactStream = await renderToReadableStream(root, renderToStreamOptions);
    if (waitForAllReady) {
      await reactStream.allReady;
    }
    const transformsToApply = [
      !waitForAllReady && bufferTransform,
      serverInjectionTransform,
      !waitForAllReady && timeoutTransform
    ];
    const outputStream = applyStreamTransforms(
      reactStream,
      transformsToApply
    );
    mwRes.status = didErrorOutsideShell ? 500 : 200;
    mwRes.body = outputStream;
    mwRes.headers.set("content-type", "text/html");
    return mwRes.toResponse();
  } catch (e) {
    console.error("\u{1F53B} Failed to render shell");
    streamOptions.onError?.(e);
    const fallbackShell = await renderToReadableStream(
      FallbackDocument({
        children: null,
        css: cssLinks,
        meta: metaTags
      }),
      bootstrapOptions
    );
    mwRes.status = 500;
    mwRes.body = fallbackShell;
    mwRes.headers.set("content-type", "text/html");
    return mwRes.toResponse();
  } finally {
    clearTimeout(timeoutHandle);
  }
}
function applyStreamTransforms(reactStream, transformsToApply) {
  let outputStream = reactStream;
  for (const transform of transformsToApply) {
    if (!transform) {
      continue;
    }
    outputStream = outputStream.pipeThrough(transform);
  }
  return outputStream;
}
async function importModule(mod) {
  const distSsr = (0, import_project_config.getPaths)().web.distSsr;
  const rdServerPath = (0, import_utils.makeFilePath)(import_node_path.default.join(distSsr, "rd-server.mjs"));
  const reactPath = (0, import_utils.makeFilePath)(import_node_path.default.join(distSsr, "__rwjs__react.mjs"));
  const locationPath = (0, import_utils.makeFilePath)(import_node_path.default.join(distSsr, "__rwjs__location.mjs"));
  const ServerAuthProviderPath = (0, import_utils.makeFilePath)(
    import_node_path.default.join(distSsr, "__rwjs__server_auth_provider.mjs")
  );
  const ServerInjectPath = (0, import_utils.makeFilePath)(
    import_node_path.default.join(distSsr, "__rwjs__server_inject.mjs")
  );
  if (mod === "rd-server") {
    return (await import(rdServerPath)).default;
  } else if (mod === "__rwjs__react") {
    return (await import(reactPath)).default;
  } else if (mod === "__rwjs__location") {
    return await import(locationPath);
  } else if (mod === "__rwjs__server_auth_provider") {
    return await import(ServerAuthProviderPath);
  } else if (mod === "__rwjs__server_inject") {
    return await import(ServerInjectPath);
  }
  throw new Error("Unknown module " + mod);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  importModule,
  reactRenderToStreamResponse
});
