"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var rscRenderer_exports = {};
__export(rscRenderer_exports, {
  renderRscToStream: () => renderRscToStream,
  setClientEntries: () => setClientEntries
});
module.exports = __toCommonJS(rscRenderer_exports);
var import_node_path = __toESM(require("node:path"), 1);
var import_react = require("react");
var import_server = require("react-server-dom-webpack/server.edge");
var import_project_config = require("@redwoodjs/project-config");
var import_entries = require("../lib/entries.js");
var import_StatusError = require("../lib/StatusError.js");
let absoluteClientEntries = {};
function renderRscToStream(input) {
  return input.rscId ? renderRsc(input) : executeRsa(input);
}
async function loadServerFile(filePath) {
  console.log("rscRenderer.ts loadServerFile filePath", filePath);
  return import(`file://${filePath}`);
}
const getRoutesComponent = async () => {
  const serverEntries = await (0, import_entries.getEntriesFromDist)();
  console.log("rscRenderer.ts serverEntries", serverEntries);
  const routesPath = import_node_path.default.join(
    (0, import_project_config.getPaths)().web.distRsc,
    serverEntries["__rwjs__Routes"]
  );
  if (!routesPath) {
    throw new import_StatusError.StatusError("No entry found for __rwjs__Routes", 404);
  }
  const routes = await loadServerFile(routesPath);
  return routes.default;
};
async function setClientEntries() {
  const entriesFile = (0, import_project_config.getPaths)().web.distRscEntries;
  console.log("setClientEntries :: entriesFile", entriesFile);
  const { clientEntries } = await loadServerFile(entriesFile);
  console.log("setClientEntries :: clientEntries", clientEntries);
  if (!clientEntries) {
    throw new Error("Failed to load clientEntries");
  }
  const baseDir = import_node_path.default.dirname(entriesFile);
  absoluteClientEntries = Object.fromEntries(
    Object.entries(clientEntries).map(([key, val]) => {
      let fullKey = import_node_path.default.join(baseDir, key);
      if (process.platform === "win32") {
        fullKey = fullKey.replaceAll("\\", "/");
      }
      return [fullKey, "/" + val];
    })
  );
  console.log(
    "setClientEntries :: absoluteClientEntries",
    absoluteClientEntries
  );
}
function getBundlerConfig() {
  const bundlerConfig = new Proxy(
    {},
    {
      get(_target, encodedId) {
        console.log("Proxy get encodedId", encodedId);
        const [filePath, name] = encodedId.split("#");
        const filePathSlash = filePath.replaceAll("\\", "/");
        const id = absoluteClientEntries[filePathSlash];
        console.log("absoluteClientEntries", absoluteClientEntries);
        console.log("filePath", filePathSlash);
        if (!id) {
          throw new Error("No client entry found for " + filePathSlash);
        }
        console.log("rscRenderer proxy id", id);
        return { id, chunks: [id], name, async: true };
      }
    }
  );
  return bundlerConfig;
}
async function renderRsc(input) {
  if (input.rsaId || !input.args) {
    throw new Error(
      "Unexpected input. Can't request both RSCs and execute RSAs at the same time."
    );
  }
  if (!input.rscId) {
    throw new Error("Unexpected input. Missing rscId or props.");
  }
  console.log("renderRsc input", input);
  const serverRoutes = await getRoutesComponent();
  const model = {
    __rwjs__Routes: (0, import_react.createElement)(serverRoutes)
  };
  console.log("rscRenderer.ts renderRsc model", model);
  return (0, import_server.renderToReadableStream)(model, getBundlerConfig());
}
function isSerializedFormData(data) {
  return !!data && data?.__formData__;
}
async function executeRsa(input) {
  console.log("executeRsa input", input);
  if (!input.rsaId || !input.args) {
    throw new Error("Unexpected input");
  }
  const [fileName, actionName] = input.rsaId.split("#");
  console.log("Server Action fileName", fileName, "actionName", actionName);
  const module2 = await loadServerFile(fileName);
  if (isSerializedFormData(input.args[0])) {
    const formData = new FormData();
    Object.entries(input.args[0].state).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => {
          formData.append(key, v);
        });
      } else {
        formData.append(key, value);
      }
    });
    input.args[0] = formData;
  }
  const method = module2[actionName] || module2;
  console.log("rscRenderer.ts method", method);
  console.log("rscRenderer.ts args", ...input.args);
  const data = await method(...input.args);
  console.log("rscRenderer.ts rsa return data", data);
  const serverRoutes = await getRoutesComponent();
  console.log("rscRenderer.ts executeRsa serverRoutes", serverRoutes);
  const model = {
    __rwjs__Routes: (0, import_react.createElement)(serverRoutes),
    __rwjs__rsa_data: data
  };
  console.log("rscRenderer.ts executeRsa model", model);
  return (0, import_server.renderToReadableStream)(model, getBundlerConfig());
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  renderRscToStream,
  setClientEntries
});
