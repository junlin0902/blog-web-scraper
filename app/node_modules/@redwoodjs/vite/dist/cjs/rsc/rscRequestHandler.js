"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var rscRequestHandler_exports = {};
__export(rscRequestHandler_exports, {
  createRscRequestHandler: () => createRscRequestHandler
});
module.exports = __toCommonJS(rscRequestHandler_exports);
var import_node_stream = require("node:stream");
var DefaultFetchAPI = __toESM(require("@whatwg-node/fetch"), 1);
var import_server = require("@whatwg-node/server");
var import_busboy = __toESM(require("busboy"), 1);
var import_react_server_dom_webpack_server = require("../bundled/react-server-dom-webpack.server.js");
var import_StatusError = require("../lib/StatusError.js");
var import_invokeMiddleware = require("../middleware/invokeMiddleware.js");
var import_rscRenderer = require("./rscRenderer.js");
var import_rscStudioHandlers = require("./rscStudioHandlers.js");
const BASE_PATH = "/rw-rsc/";
function createRscRequestHandler(options) {
  return async (req, res, next) => {
    console.log("BASE_PATH", BASE_PATH);
    console.log("req.originalUrl", req.originalUrl, "req.url", req.url);
    console.log("req.headers.host", req.headers.host);
    console.log("req.headers['rw-rsc']", req.headers["rw-rsc"]);
    const mwRouter = await options.getMiddlewareRouter();
    if (mwRouter) {
      const webReq = (0, import_server.normalizeNodeRequest)(req, DefaultFetchAPI.Request);
      const matchedMw = mwRouter.find(webReq.method, webReq.url);
      const [mwResponse] = await (0, import_invokeMiddleware.invoke)(
        webReq,
        matchedMw?.handler,
        {
          params: matchedMw?.params,
          viteDevServer: options.viteDevServer
        }
      );
      const webRes = mwResponse.toResponse();
      webRes.headers.forEach((value, key) => {
        res.setHeader(key, value);
      });
      if (mwResponse.isRedirect() || mwResponse.body) {
        throw new Error(
          "Not Implemented: What should happen if this RSC handler fails? And which part - Client side router?"
        );
      }
    }
    if (req.headers["rw-rsc"] !== "1") {
      return next();
    }
    const url = new URL(req.originalUrl || "", "http://" + req.headers.host);
    let rscId;
    let rsaId;
    let args = [];
    if (url.pathname.startsWith(BASE_PATH)) {
      rscId = url.pathname.split("/").pop();
      rsaId = url.searchParams.get("action_id") || void 0;
      console.log("rscId", rscId);
      console.log("rsaId", rsaId);
      if (rscId && rscId !== "_") {
        res.setHeader("Content-Type", "text/x-component");
      } else {
        rscId = void 0;
      }
      if (rsaId) {
        if (req.headers["content-type"]?.startsWith("multipart/form-data")) {
          console.log("RSA: multipart/form-data");
          const bb = (0, import_busboy.default)({ headers: req.headers });
          const reply = (0, import_react_server_dom_webpack_server.decodeReplyFromBusboy)(bb);
          req.pipe(bb);
          args = await reply;
          if (args[0] instanceof FormData) {
            const serializedFormData = {};
            for (const [key, value] of args[0]) {
              if (serializedFormData[key] !== void 0) {
                if (!Array.isArray(serializedFormData[key])) {
                  serializedFormData[key] = [serializedFormData[key]];
                }
                serializedFormData[key].push(value);
              } else {
                serializedFormData[key] = value;
              }
            }
            args[0] = {
              __formData__: true,
              state: serializedFormData
            };
          }
        } else {
          console.log("RSA: regular body");
          let body = "";
          for await (const chunk of req) {
            body += chunk;
          }
          if (body) {
            args = await (0, import_react_server_dom_webpack_server.decodeReply)(body);
          }
        }
      }
    }
    console.log("rscRequestHandler: args", args);
    if (rscId || rsaId) {
      const handleError = (err) => {
        console.log("handleError() err", err);
        if ((0, import_StatusError.hasStatusCode)(err)) {
          res.statusCode = err.statusCode;
        } else {
          console.info("Cannot render RSC", err);
          res.statusCode = 500;
        }
        res.end(String(err));
      };
      try {
        const readable = await (0, import_rscRenderer.renderRscToStream)({ rscId, rsaId, args });
        import_node_stream.Readable.fromWeb(readable).pipe(res);
        await (0, import_rscStudioHandlers.sendRscFlightToStudio)({
          rscId,
          rsaId,
          args,
          basePath: BASE_PATH,
          req,
          handleError
        });
      } catch (e) {
        handleError(e);
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createRscRequestHandler
});
