"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getMergedConfig_exports = {};
__export(getMergedConfig_exports, {
  getMergedConfig: () => getMergedConfig
});
module.exports = __toCommonJS(getMergedConfig_exports);
var import_node_path = __toESM(require("node:path"), 1);
var import_vite = require("vite");
var import_project_config = require("@redwoodjs/project-config");
var import_envVarDefinitions = require("./envVarDefinitions.js");
function getMergedConfig(rwConfig, rwPaths) {
  return (userConfig, env) => {
    let apiHost = process.env.REDWOOD_API_HOST;
    apiHost ??= rwConfig.api.host;
    apiHost ??= process.env.NODE_ENV === "production" ? "0.0.0.0" : "[::]";
    const streamingSsrEnabled = rwConfig.experimental.streamingSsr?.enabled;
    const rscEnabled = rwConfig.experimental.rsc?.enabled;
    let apiPort;
    if (process.env.REDWOOD_API_PORT) {
      apiPort = parseInt(process.env.REDWOOD_API_PORT);
    } else {
      apiPort = rwConfig.api.port;
    }
    const defaultRwViteConfig = {
      root: rwPaths.web.src,
      // @MARK: when we have these aliases, the warnings from the FE server go
      // away BUT, if you have imports like this:
      // ```
      // import RandomNumberServerCell from
      //   'src/components/RandomNumberServerCell/RandomNumberServerCell'
      // ```
      // they start failing (can't have the double
      // `/RandomNumberServerCell/RandomNumberServerCell` at the end)
      //
      // resolve: {
      //   alias: [
      //     {
      //       find: 'src',
      //       replacement: rwPaths.web.src,
      //     },
      //   ],
      // },
      envPrefix: "REDWOOD_ENV_",
      publicDir: import_node_path.default.join(rwPaths.web.base, "public"),
      define: (0, import_envVarDefinitions.getEnvVarDefinitions)(),
      css: {
        // @NOTE config path is relative to where vite.config.js is if you use
        // a relative path
        postcss: rwPaths.web.config
      },
      server: {
        open: rwConfig.browser.open,
        port: rwConfig.web.port,
        host: true,
        // Listen to all hosts
        proxy: {
          [rwConfig.web.apiUrl]: {
            target: `http://${apiHost}:${apiPort}`,
            changeOrigin: false,
            // Remove the `.redwood/functions` part, but leave the `/graphql`
            rewrite: (path2) => path2.replace(rwConfig.web.apiUrl, ""),
            configure: (proxy) => {
              let waitingForApiServer = true;
              setTimeout(() => {
                waitingForApiServer = false;
              }, 2500);
              proxy.on("error", (err, _req, res) => {
                if (waitingForApiServer && err.message.includes("ECONNREFUSED")) {
                  err.stack = "\u231B API Server launching, please refresh your page...";
                }
                const msg = {
                  errors: [
                    {
                      message: "The RedwoodJS API server is not available or is currently reloading. Please refresh."
                    }
                  ]
                };
                res.writeHead(203, {
                  "Content-Type": "application/json",
                  "Cache-Control": "no-cache"
                });
                res.write(JSON.stringify(msg));
                res.end();
              });
            }
          }
        }
      },
      build: {
        // TODO (RSC): Remove `minify: false` when we don't need to debug as often
        minify: false,
        // NOTE this gets overridden when build gets called anyway!
        outDir: streamingSsrEnabled || rscEnabled ? rwPaths.web.distBrowser : rwPaths.web.dist,
        emptyOutDir: true,
        manifest: !env.isSsrBuild ? "client-build-manifest.json" : void 0,
        // Note that sourcemap can be boolean or 'inline'
        sourcemap: !env.isSsrBuild && rwConfig.web.sourceMap,
        rollupOptions: {
          input: getRollupInput(!!env.isSsrBuild)
        }
      },
      // @MARK: do not set buildSsrCjsExternalHeuristics here
      // because rsc builds want false, client and server build wants true
      optimizeDeps: {
        esbuildOptions: {
          // @MARK this is because JS projects in Redwood don't have .jsx
          // extensions
          loader: {
            ".js": "jsx"
          },
          // Node.js global to browser globalThis
          // @MARK unsure why we need this, but required for DevFatalErrorPage
          // at least
          define: {
            global: "globalThis"
          }
        }
      }
    };
    return (0, import_vite.mergeConfig)(defaultRwViteConfig, userConfig);
  };
}
function getRollupInput(ssr) {
  const rwConfig = (0, import_project_config.getConfig)();
  const rwPaths = (0, import_project_config.getPaths)();
  if (!rwPaths.web.entryClient) {
    throw new Error("entryClient not defined");
  }
  const streamingEnabled = rwConfig.experimental?.streamingSsr?.enabled;
  const rscEnabled = rwConfig.experimental?.rsc?.enabled;
  if (streamingEnabled) {
    if (ssr) {
      if (!rwPaths.web.entryServer) {
        throw new Error("entryServer not defined");
      }
      if (rscEnabled) {
        return {
          Document: rwPaths.web.document,
          "entry.server": rwPaths.web.entryServer
        };
      }
      return {
        // NOTE: We're building the server entry *without* the react-server
        // condition when we include it here. This works when only SSR is
        // enabled, but not when RSC + SSR are both enabled
        // For RSC we have this configured in rscBuildForServer.ts to get a
        // build with the proper resolution conditions set.
        "entry.server": rwPaths.web.entryServer,
        // We need the document for React's fallback
        Document: rwPaths.web.document
      };
    }
    return rwPaths.web.entryClient;
  }
  return rwPaths.web.html;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getMergedConfig
});
