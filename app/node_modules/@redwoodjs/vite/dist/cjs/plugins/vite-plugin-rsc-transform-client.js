"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var vite_plugin_rsc_transform_client_exports = {};
__export(vite_plugin_rsc_transform_client_exports, {
  rscTransformUseClientPlugin: () => rscTransformUseClientPlugin
});
module.exports = __toCommonJS(vite_plugin_rsc_transform_client_exports);
var import_node_path = __toESM(require("node:path"), 1);
var acorn = __toESM(require("acorn-loose"), 1);
var import_vite = require("vite");
var import_project_config = require("@redwoodjs/project-config");
function rscTransformUseClientPlugin(clientEntryFiles) {
  return {
    name: "rsc-transform-use-client-plugin",
    transform: async function(code, id) {
      if (!code.includes("use client")) {
        return code;
      }
      if (code.includes("$$id")) {
        return code;
      }
      let body;
      try {
        body = acorn.parse(code, {
          ecmaVersion: 2024,
          sourceType: "module"
        }).body;
      } catch (x) {
        console.error("Error parsing %s %s", id, x.message);
        return code;
      }
      let useClient = false;
      let useServer = false;
      for (const node of body) {
        if (node.type !== "ExpressionStatement" || !node.directive) {
          break;
        }
        if (node.directive === "use client") {
          useClient = true;
        }
        if (node.directive === "use server") {
          useServer = true;
        }
      }
      if (!useClient) {
        return code;
      }
      if (useClient && useServer) {
        throw new Error(
          'Cannot have both "use client" and "use server" directives in the same file.'
        );
      }
      const transformedCode = await transformClientModule(
        code,
        body,
        id,
        clientEntryFiles
      );
      return transformedCode;
    }
  };
}
function addExportNames(names, node) {
  switch (node.type) {
    case "Identifier":
      names.push(node.name);
      return;
    case "ObjectPattern":
      for (const property of node.properties) {
        addExportNames(names, property);
      }
      return;
    case "ArrayPattern":
      for (const element of node.elements) {
        if (element) {
          addExportNames(names, element);
        }
      }
      return;
    case "Property":
      addExportNames(names, node.value);
      return;
    case "AssignmentPattern":
      addExportNames(names, node.left);
      return;
    case "RestElement":
      addExportNames(names, node.argument);
      return;
    case "ParenthesizedExpression":
      addExportNames(names, node.expression);
      return;
  }
}
async function parseExportNamesIntoNames(code, body, names) {
  for (const node of body) {
    switch (node.type) {
      case "ExportAllDeclaration":
        if (node.exported) {
          addExportNames(names, node.exported);
          continue;
        } else {
          let childBody;
          try {
            childBody = acorn.parse(code, {
              ecmaVersion: 2024,
              sourceType: "module"
            }).body;
          } catch (x) {
            console.error("Error parsing %s %s", "", x.message);
            continue;
          }
          await parseExportNamesIntoNames(code, childBody, names);
          continue;
        }
      case "ExportDefaultDeclaration":
        names.push("default");
        continue;
      case "ExportNamedDeclaration":
        if (node.declaration) {
          if (node.declaration.type === "VariableDeclaration") {
            const declarations = node.declaration.declarations;
            for (const declaration of declarations) {
              addExportNames(names, declaration.id);
            }
          } else {
            addExportNames(names, node.declaration.id);
          }
        }
        if (node.specifiers) {
          const specifiers = node.specifiers;
          for (const specifier of specifiers) {
            addExportNames(names, specifier.exported);
          }
        }
        continue;
      // For CJS support
      case "ExpressionStatement": {
        let assignmentExpression = null;
        if (node.expression.type === "AssignmentExpression") {
          assignmentExpression = node.expression;
        } else if (node.expression.type === "LogicalExpression" && node.expression.right.type === "AssignmentExpression") {
          assignmentExpression = node.expression.right;
        }
        if (!assignmentExpression) {
          continue;
        }
        if (assignmentExpression.left.type !== "MemberExpression") {
          continue;
        }
        if (assignmentExpression.left.object.type !== "Identifier") {
          continue;
        }
        if (assignmentExpression.left.object.name === "exports" && assignmentExpression.left.property.type === "Identifier") {
          if (!names.includes(assignmentExpression.left.property.name)) {
            names.push(assignmentExpression.left.property.name);
          }
        } else if (assignmentExpression.left.object.name === "module" && assignmentExpression.left.property.type === "Identifier" && assignmentExpression.left.property.name === "exports" && assignmentExpression.right.type === "ObjectExpression") {
          assignmentExpression.right.properties.forEach((property) => {
            if (property.type === "Property" && property.key.type === "Identifier") {
              if (!names.includes(property.key.name)) {
                names.push(property.key.name);
              }
            }
          });
        }
        continue;
      }
    }
  }
}
async function transformClientModule(code, body, url, clientEntryFiles) {
  const names = [];
  await parseExportNamesIntoNames(code, body, names);
  console.log("transformClientModule names", names);
  const entryRecord = Object.entries(clientEntryFiles).find(
    ([_key, value]) => value === url
  );
  const loadId = (0, import_vite.normalizePath)(
    entryRecord ? import_node_path.default.join((0, import_project_config.getPaths)().web.distRsc, "assets", `${entryRecord[0]}.mjs`) : url
  );
  let newSrc = 'import {registerClientReference} from "react-server-dom-webpack/server";\n';
  for (const name of names) {
    if (name === "default") {
      newSrc += "export default registerClientReference(function() {";
      newSrc += "throw new Error(" + JSON.stringify(
        "Attempted to call the default export of " + url + " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
      ) + ");";
    } else {
      newSrc += "export const " + name + " = ";
      newSrc += "registerClientReference(function() {";
      newSrc += "throw new Error(" + JSON.stringify(
        "Attempted to call " + name + "() from the server but " + name + " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
      ) + ");";
    }
    newSrc += `},${JSON.stringify(loadId)},${JSON.stringify(name)})
;`;
  }
  return newSrc;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  rscTransformUseClientPlugin
});
