"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var vite_plugin_rsc_transform_server_exports = {};
__export(vite_plugin_rsc_transform_server_exports, {
  rscTransformUseServerPlugin: () => rscTransformUseServerPlugin
});
module.exports = __toCommonJS(vite_plugin_rsc_transform_server_exports);
var import_node_path = __toESM(require("node:path"), 1);
var babel = __toESM(require("@babel/core"), 1);
var swc = __toESM(require("@swc/core"), 1);
function rscTransformUseServerPlugin(outDir, serverEntryFiles) {
  return {
    name: "rsc-transform-use-server-plugin",
    transform: async function(code, id) {
      if (!code.includes("use server")) {
        return code;
      }
      let mod;
      const isTypescript = id.endsWith(".ts") || id.endsWith(".tsx");
      try {
        mod = swc.parseSync(code, {
          target: "es2022",
          syntax: isTypescript ? "typescript" : "ecmascript",
          tsx: id.endsWith(".tsx"),
          jsx: id.endsWith(".jsx")
        });
      } catch (e) {
        console.error("Error parsing", id, e.message);
        return code;
      }
      let useClient = false;
      let moduleScopedUseServer = false;
      for (const node of mod.body) {
        if (node.type !== "ExpressionStatement" || node.expression.type !== "StringLiteral") {
          continue;
        }
        if (node.expression.value === "use client") {
          useClient = true;
        }
        if (node.expression.value === "use server") {
          moduleScopedUseServer = true;
        }
      }
      if (useClient && moduleScopedUseServer) {
        throw new Error(
          'Cannot have both "use client" and "use server" directives in the same file.'
        );
      }
      let builtFileName = id;
      const serverEntryKey = Object.entries(serverEntryFiles).find(
        ([_key, value]) => value === id
      )?.[0];
      if (serverEntryKey) {
        builtFileName = import_node_path.default.join(outDir, "assets", serverEntryKey + ".mjs");
        if (process.platform === "win32") {
          builtFileName = builtFileName.replaceAll("\\", "/");
        }
      }
      if (!builtFileName) {
        throw new Error(
          `Could not find ${id} in serverEntryFiles: ` + JSON.stringify(serverEntryFiles)
        );
      }
      let transformedCode = code;
      if (moduleScopedUseServer) {
        transformedCode = transformServerModule(mod, builtFileName, code);
      } else {
        const result = babel.transformSync(code, {
          filename: id,
          presets: ["@babel/preset-typescript"],
          plugins: [[babelPluginTransformServerAction, { url: builtFileName }]]
        });
        if (!result) {
          console.error("Failed to transform code", id, code);
          throw new Error("Failed to transform code");
        }
        if (!result.code) {
          console.error("Failed to transform code", id, code);
          throw new Error("Transform didn't return any code");
        }
        transformedCode = result.code;
      }
      return transformedCode;
    }
  };
}
function transformServerModule(mod, url, code) {
  const localNames = /* @__PURE__ */ new Map();
  const localTypes = /* @__PURE__ */ new Map();
  for (const node of mod.body) {
    switch (node.type) {
      // TODO (RSC): Add code comments with examples of each type of node
      case "ExportDeclaration":
        if (node.declaration.type === "FunctionDeclaration") {
          const name = node.declaration.identifier.value;
          localNames.set(name, name);
          localTypes.set(name, "function");
        } else if (node.declaration.type === "VariableDeclaration") {
          for (const declaration of node.declaration.declarations) {
            if (declaration.id.type === "Identifier") {
              const name = declaration.id.value;
              localNames.set(name, name);
            }
          }
        }
        break;
      case "ExportDefaultDeclaration":
        if (node.decl.type === "FunctionExpression") {
          const identifier = node.decl.identifier;
          if (identifier) {
            localNames.set(identifier.value, "default");
            localTypes.set(identifier.value, "function");
          }
        }
        break;
      case "ExportNamedDeclaration":
        for (const specifier of node.specifiers) {
          if (specifier.type === "ExportSpecifier") {
            const name = specifier.orig.value;
            if (specifier.exported?.type === "Identifier") {
              const exportedName = specifier.exported.value;
              localNames.set(name, exportedName);
            } else if (specifier.orig.type === "Identifier") {
              localNames.set(name, name);
            }
          }
        }
        break;
      case "ExportDefaultExpression":
        if (node.expression.type === "Identifier") {
          localNames.set(node.expression.value, "default");
        }
        break;
    }
  }
  let newSrc = code + '\n\nimport {registerServerReference} from "react-server-dom-webpack/server";\n';
  localNames.forEach(function(exported, local) {
    if (localTypes.get(local) !== "function") {
      newSrc += "if (typeof " + local + ' === "function") ';
    }
    const urlStr = JSON.stringify(url);
    const exportedStr = JSON.stringify(exported);
    newSrc += `registerServerReference(${local},${urlStr},${exportedStr});
`;
  });
  return newSrc;
}
function babelPluginTransformServerAction({
  types: t
}) {
  const localNames = /* @__PURE__ */ new Map();
  const localTypes = /* @__PURE__ */ new Map();
  const serverActionNodes = [];
  const topLevelFunctions = [];
  return {
    name: "babel-plugin-redwood-transform-server-action",
    visitor: {
      Program: {
        enter(path2) {
          path2.node.body.forEach((statement) => {
            if (t.isFunctionDeclaration(statement)) {
              if (hasUseServerDirective(statement)) {
                const name = statement.id?.name;
                if (!name) {
                  throw new Error("Function declaration must have a name");
                }
                topLevelFunctions.push(name);
                localTypes.set(name, "function");
              }
            }
            if (t.isVariableDeclaration(statement)) {
              statement.declarations.forEach((declarator) => {
                if (t.isFunctionExpression(declarator.init)) {
                  if (hasUseServerDirective(declarator.init)) {
                    const name = declarator.id.type === "Identifier" ? declarator.id.name : void 0;
                    if (!name) {
                      throw new Error("Function declaration must have a name");
                    }
                    topLevelFunctions.push(name);
                    localTypes.set(name, "function");
                  }
                } else if (t.isArrowFunctionExpression(declarator.init)) {
                  if (hasUseServerDirective(declarator.init)) {
                    const name = declarator.id.type === "Identifier" ? declarator.id.name : void 0;
                    if (!name) {
                      throw new Error("Function declaration must have a name");
                    }
                    topLevelFunctions.push(name);
                    localTypes.set(name, "function");
                  }
                }
              });
            }
          });
        },
        exit(path2, state) {
          if (serverActionNodes.length === 0 && localTypes.size === 0) {
            return;
          }
          const body = path2.node.body;
          body.push(
            t.importDeclaration(
              [
                t.importSpecifier(
                  t.identifier("registerServerReference"),
                  t.identifier("registerServerReference")
                )
              ],
              t.stringLiteral("react-server-dom-webpack/server")
            )
          );
          serverActionNodes.forEach((functionDeclaration) => {
            body.push(t.exportNamedDeclaration(functionDeclaration));
            const name = functionDeclaration.id?.name || "";
            body.push(registerServerRef(name, state.opts.url, name));
          });
          localNames.forEach((exportedName, localName) => {
            if (!localTypes.get(localName)) {
              return;
            }
            const localType = localTypes.get(localName);
            if (localType === "function") {
              body.push(
                registerServerRef(localName, state.opts.url, exportedName)
              );
            } else {
              body.push(
                t.ifStatement(
                  t.binaryExpression(
                    "===",
                    t.unaryExpression("typeof", t.identifier(localName)),
                    t.stringLiteral("function")
                  ),
                  registerServerRef(localName, state.opts.url, exportedName)
                )
              );
            }
          });
        }
      },
      ExportNamedDeclaration(path2) {
        const declaration = path2.node.declaration;
        const specifiers = path2.node.specifiers;
        if (t.isFunctionDeclaration(declaration)) {
          if (hasUseServerDirective(declaration)) {
            const identifier = declaration.id?.name;
            if (identifier) {
              localNames.set(identifier, identifier);
              localTypes.set(identifier, "function");
            }
          } else {
            const body = declaration.body;
            const serverActionNodeIndex = indexOfServerActionNode(body);
            if (serverActionNodeIndex >= 0) {
              const serverActionNode = body.body[serverActionNodeIndex];
              if (serverActionNode && t.isFunctionDeclaration(serverActionNode)) {
                const name = serverActionNode.id?.name;
                if (!name) {
                }
                serverActionNodes.push(serverActionNode);
              }
            }
          }
        } else if (t.isVariableDeclaration(declaration)) {
          for (const declarator of declaration.declarations) {
            const init = declarator.init;
            if (!t.isArrowFunctionExpression(init) || !t.isBlockStatement(init.body)) {
              continue;
            }
            if (hasUseServerDirective(init)) {
              if (declarator.id.type === "Identifier") {
                localNames.set(declarator.id.name, declarator.id.name);
                localTypes.set(declarator.id.name, "function");
              }
            } else {
              const serverActionNodeIndex = indexOfServerActionNode(init.body);
              if (serverActionNodeIndex >= 0) {
                const serverActionNode = init.body.body[serverActionNodeIndex];
                if (t.isFunctionDeclaration(serverActionNode)) {
                  const name = serverActionNode.id?.name;
                  if (!name) {
                    throw new Error("Server action must have a name");
                  }
                  const uniqueName = `__rwjs__rsa${serverActionNodes.length}_${name}`;
                  serverActionNode.id = t.identifier(uniqueName);
                  serverActionNodes.push(serverActionNode);
                  init.body.body[serverActionNodeIndex] = t.variableDeclaration(
                    "const",
                    [
                      t.variableDeclarator(
                        t.identifier(name),
                        t.identifier(uniqueName)
                      )
                    ]
                  );
                }
              }
            }
          }
        } else if (specifiers.length) {
          specifiers.forEach((specifier) => {
            if (t.isExportSpecifier(specifier)) {
              const exportedName = t.isStringLiteral(specifier.exported) ? specifier.exported.value : specifier.exported.name;
              localNames.set(specifier.local.name, exportedName);
            }
          });
        }
      },
      ExportDefaultDeclaration(path2) {
        const declaration = path2.node.declaration;
        if (t.isFunctionDeclaration(declaration)) {
          if (hasUseServerDirective(declaration)) {
            const identifier = declaration.id?.name;
            if (identifier) {
              localNames.set(identifier, "default");
              localTypes.set(identifier, "function");
            }
          } else {
            const body = declaration.body;
            const serverActionNodeIndex = indexOfServerActionNode(body);
            if (serverActionNodeIndex >= 0) {
              const serverActionNode = body.body[serverActionNodeIndex];
              if (serverActionNode && t.isFunctionDeclaration(serverActionNode)) {
                const name = serverActionNode.id?.name;
                if (!name) {
                  throw new Error("Server action must have a name");
                }
                const uniqueName = `__rwjs__rsa${serverActionNodes.length}_${name}`;
                serverActionNode.id = t.identifier(uniqueName);
                serverActionNodes.push(serverActionNode);
                body.body[serverActionNodeIndex] = t.variableDeclaration(
                  "const",
                  [
                    t.variableDeclarator(
                      t.identifier(name),
                      t.identifier(uniqueName)
                    )
                  ]
                );
              }
            }
          }
        }
      }
    }
  };
  function hasUseServerDirective(statement) {
    return "directives" in statement.body && statement.body.directives.some(
      (directive) => directive.value.value === "use server"
    );
  }
  function indexOfServerActionNode(blockStatement) {
    return blockStatement.body.findIndex(
      (node) => {
        return t.isFunctionDeclaration(node) && hasUseServerDirective(node);
      }
    );
  }
  function registerServerRef(localName, url, exportedName) {
    return t.expressionStatement(
      t.callExpression(t.identifier("registerServerReference"), [
        t.identifier(localName),
        t.stringLiteral(url),
        t.stringLiteral(exportedName)
      ])
    );
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  rscTransformUseServerPlugin
});
