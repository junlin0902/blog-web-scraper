import path from "node:path";
import { createElement } from "react";
import { renderToReadableStream } from "react-server-dom-webpack/server.edge";
import { getPaths } from "@redwoodjs/project-config";
import { getEntriesFromDist } from "../lib/entries.js";
import { StatusError } from "../lib/StatusError.js";
let absoluteClientEntries = {};
function renderRscToStream(input) {
  return input.rscId ? renderRsc(input) : executeRsa(input);
}
async function loadServerFile(filePath) {
  console.log("rscRenderer.ts loadServerFile filePath", filePath);
  return import(`file://${filePath}`);
}
const getRoutesComponent = async () => {
  const serverEntries = await getEntriesFromDist();
  console.log("rscRenderer.ts serverEntries", serverEntries);
  const routesPath = path.join(
    getPaths().web.distRsc,
    serverEntries["__rwjs__Routes"]
  );
  if (!routesPath) {
    throw new StatusError("No entry found for __rwjs__Routes", 404);
  }
  const routes = await loadServerFile(routesPath);
  return routes.default;
};
async function setClientEntries() {
  const entriesFile = getPaths().web.distRscEntries;
  console.log("setClientEntries :: entriesFile", entriesFile);
  const { clientEntries } = await loadServerFile(entriesFile);
  console.log("setClientEntries :: clientEntries", clientEntries);
  if (!clientEntries) {
    throw new Error("Failed to load clientEntries");
  }
  const baseDir = path.dirname(entriesFile);
  absoluteClientEntries = Object.fromEntries(
    Object.entries(clientEntries).map(([key, val]) => {
      let fullKey = path.join(baseDir, key);
      if (process.platform === "win32") {
        fullKey = fullKey.replaceAll("\\", "/");
      }
      return [fullKey, "/" + val];
    })
  );
  console.log(
    "setClientEntries :: absoluteClientEntries",
    absoluteClientEntries
  );
}
function getBundlerConfig() {
  const bundlerConfig = new Proxy(
    {},
    {
      get(_target, encodedId) {
        console.log("Proxy get encodedId", encodedId);
        const [filePath, name] = encodedId.split("#");
        const filePathSlash = filePath.replaceAll("\\", "/");
        const id = absoluteClientEntries[filePathSlash];
        console.log("absoluteClientEntries", absoluteClientEntries);
        console.log("filePath", filePathSlash);
        if (!id) {
          throw new Error("No client entry found for " + filePathSlash);
        }
        console.log("rscRenderer proxy id", id);
        return { id, chunks: [id], name, async: true };
      }
    }
  );
  return bundlerConfig;
}
async function renderRsc(input) {
  if (input.rsaId || !input.args) {
    throw new Error(
      "Unexpected input. Can't request both RSCs and execute RSAs at the same time."
    );
  }
  if (!input.rscId) {
    throw new Error("Unexpected input. Missing rscId or props.");
  }
  console.log("renderRsc input", input);
  const serverRoutes = await getRoutesComponent();
  const model = {
    __rwjs__Routes: createElement(serverRoutes)
  };
  console.log("rscRenderer.ts renderRsc model", model);
  return renderToReadableStream(model, getBundlerConfig());
}
function isSerializedFormData(data) {
  return !!data && data?.__formData__;
}
async function executeRsa(input) {
  console.log("executeRsa input", input);
  if (!input.rsaId || !input.args) {
    throw new Error("Unexpected input");
  }
  const [fileName, actionName] = input.rsaId.split("#");
  console.log("Server Action fileName", fileName, "actionName", actionName);
  const module = await loadServerFile(fileName);
  if (isSerializedFormData(input.args[0])) {
    const formData = new FormData();
    Object.entries(input.args[0].state).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => {
          formData.append(key, v);
        });
      } else {
        formData.append(key, value);
      }
    });
    input.args[0] = formData;
  }
  const method = module[actionName] || module;
  console.log("rscRenderer.ts method", method);
  console.log("rscRenderer.ts args", ...input.args);
  const data = await method(...input.args);
  console.log("rscRenderer.ts rsa return data", data);
  const serverRoutes = await getRoutesComponent();
  console.log("rscRenderer.ts executeRsa serverRoutes", serverRoutes);
  const model = {
    __rwjs__Routes: createElement(serverRoutes),
    __rwjs__rsa_data: data
  };
  console.log("rscRenderer.ts executeRsa model", model);
  return renderToReadableStream(model, getBundlerConfig());
}
export {
  renderRscToStream,
  setClientEntries
};
