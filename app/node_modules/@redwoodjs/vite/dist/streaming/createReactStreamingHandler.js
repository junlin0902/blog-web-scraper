import path from "path";
import { Response } from "@whatwg-node/fetch";
import { createIsbotFromList, list as isbotList } from "isbot";
import { middlewareDefaultAuthProviderState } from "@redwoodjs/auth/dist/AuthProvider/AuthProviderState.js";
import { getAppRouteHook, getConfig, getPaths } from "@redwoodjs/project-config";
import { matchPath } from "@redwoodjs/router/util";
import { MiddlewareResponse } from "@redwoodjs/web/middleware";
import { invoke } from "../middleware/invokeMiddleware.js";
import { makeFilePath, ssrLoadEntryServer } from "../utils.js";
import { reactRenderToStreamResponse } from "./streamHelpers.js";
import { loadAndRunRouteHooks } from "./triggerRouteHooks.js";
const isbot = createIsbotFromList(
  isbotList.filter((record) => !record.includes("chrome-lighthouse"))
);
const createReactStreamingHandler = async ({
  routes,
  clientEntryPath,
  getStylesheetLinks,
  getMiddlewareRouter
}, viteDevServer) => {
  const rwPaths = getPaths();
  const rwConfig = getConfig();
  const isProd = !viteDevServer;
  const middlewareRouter = await getMiddlewareRouter();
  let entryServerImport;
  let fallbackDocumentImport;
  const rscEnabled = rwConfig.experimental?.rsc?.enabled;
  if (isProd) {
    if (rscEnabled) {
      entryServerImport = await import(makeFilePath(rwPaths.web.distSsrEntryServer));
    } else {
      entryServerImport = await import(makeFilePath(rwPaths.web.distSsrEntryServer));
    }
    fallbackDocumentImport = await import(makeFilePath(rwPaths.web.distSsrDocument));
  }
  return async (req) => {
    let mwResponse = MiddlewareResponse.next();
    let decodedAuthState = {
      ...middlewareDefaultAuthProviderState,
      cookieHeader: req.headers.get("cookie"),
      roles: []
    };
    let currentRoute;
    let parsedParams = {};
    const currentUrl = new URL(req.url);
    for (const route of routes) {
      const { match, ...rest } = matchPath(
        route.pathDefinition,
        currentUrl.pathname
      );
      if (match) {
        currentRoute = route;
        parsedParams = rest;
        break;
      }
    }
    const cssLinks = getStylesheetLinks(currentRoute);
    if (middlewareRouter) {
      const matchedMw = middlewareRouter.find(req.method, req.url);
      [mwResponse, decodedAuthState] = await invoke(
        req,
        matchedMw?.handler,
        {
          route: currentRoute,
          cssPaths: cssLinks,
          params: matchedMw?.params,
          viteDevServer
        }
      );
      if (mwResponse.isRedirect() || mwResponse.body) {
        return mwResponse.toResponse();
      }
    }
    if (!currentRoute) {
      throw new Error("404 handling not implemented");
    }
    if (currentRoute.redirect) {
      return new Response(null, {
        status: 302,
        headers: {
          Location: currentRoute.redirect.to
        }
      });
    }
    if (!isProd) {
      entryServerImport = await ssrLoadEntryServer(viteDevServer);
      fallbackDocumentImport = await viteDevServer.ssrLoadModule(
        rwPaths.web.document
      );
    }
    const ServerEntry = entryServerImport.ServerEntry || entryServerImport.default;
    const FallbackDocument = fallbackDocumentImport.Document || fallbackDocumentImport.default;
    let metaTags = [];
    let routeHookPath = currentRoute.routeHooks;
    if (isProd) {
      routeHookPath = currentRoute.routeHooks ? path.join(rwPaths.web.distRouteHooks, currentRoute.routeHooks) : null;
    }
    const routeHookOutput = await loadAndRunRouteHooks({
      paths: [getAppRouteHook(isProd), routeHookPath],
      reqMeta: {
        req,
        parsedParams
      },
      viteDevServer
    });
    metaTags = routeHookOutput.meta;
    const jsBundles = [viteDevServer ? clientEntryPath : "/" + clientEntryPath];
    if (currentRoute.bundle) {
      jsBundles.push("/" + currentRoute.bundle);
    }
    const isSeoCrawler = isbot(req.headers.get("user-agent") || "");
    const reactResponse = await reactRenderToStreamResponse(
      mwResponse,
      {
        ServerEntry,
        FallbackDocument,
        currentUrl,
        metaTags,
        cssLinks,
        isProd,
        jsBundles,
        authState: decodedAuthState
      },
      {
        waitForAllReady: isSeoCrawler,
        onError: (err) => {
          if (!isProd && viteDevServer) {
            viteDevServer.ssrFixStacktrace(err);
          }
          console.error(err);
        }
      }
    );
    return reactResponse;
  };
};
export {
  createReactStreamingHandler
};
