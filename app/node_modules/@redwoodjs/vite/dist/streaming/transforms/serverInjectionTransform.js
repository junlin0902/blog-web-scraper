import { encodeText } from "./encode-decode.js";
function createServerInjectionTransform({
  injectionState,
  createElement,
  ServerInjectedHtml,
  renderToString,
  onlyOnFlush = false
}) {
  const transformStream = new TransformStream({
    transform(chunk, controller) {
      if (onlyOnFlush) {
        controller.enqueue(chunk);
      } else {
        const mergedBytes = insertHtml(chunk);
        controller.enqueue(mergedBytes);
      }
    },
    flush(controller) {
      const mergedBytes = insertHtml();
      controller.enqueue(mergedBytes);
      const moveTagsScript = encodeText(`<script>document.querySelectorAll('body [data-rwjs-head]').forEach((el) => {
        document.querySelectorAll('head ' + el.tagName).forEach((e) => {
          if (
            el.tagName === 'TITLE' ||
            (el.tagName === 'META' &&
              el.getAttribute('name') === e.getAttribute('name') &&
              el.getAttribute('property') === e.getAttribute('property'))
          ) {
            e.remove();
          }
          document.head.appendChild(el);
        });
      });
        </script>`);
      controller.enqueue(moveTagsScript);
    }
  });
  return transformStream;
  function insertHtml(chunk) {
    const serverHtmlOutput = renderToString(
      createElement(ServerInjectedHtml, {
        injectionState
      })
    );
    const injectedBytes = encodeText(serverHtmlOutput);
    if (chunk !== void 0) {
      const mergedBytes = new Uint8Array(chunk.length + injectedBytes.length);
      mergedBytes.set(chunk);
      mergedBytes.set(injectedBytes, chunk.length);
      return mergedBytes;
    } else {
      const injectedHtmlOutput = new Uint8Array(injectedBytes.length);
      injectedHtmlOutput.set(injectedBytes);
      return injectedHtmlOutput;
    }
  }
}
export {
  createServerInjectionTransform
};
