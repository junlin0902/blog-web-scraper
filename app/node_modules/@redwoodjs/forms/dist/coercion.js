"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var coercion_exports = {};
__export(coercion_exports, {
  setCoercion: () => setCoercion
});
module.exports = __toCommonJS(coercion_exports);
const isValueEmpty = (val) => val === "";
const SET_VALUE_AS_FUNCTIONS = {
  // valueAsBoolean is commented out as r-h-f does not currently support
  // setValueAs functionality for checkboxes.  May investigate future
  // integration
  /*  valueAsBoolean: {
    // r-h-f returns a boolean if a checkBox type, but also handle string case in case valueAsBoolean is used
    base: (val: boolean | string): boolean => !!val,
    emptyAsNull: (val: boolean | string): boolean | null => (val ? true : null),
    emptyAsUndefined: (val: boolean | string): boolean | undefined =>
      val ? true : undefined,
  },*/
  valueAsDate: {
    emptyAsNull: (val) => isValueEmpty(val) ? null : new Date(val),
    emptyAsUndefined: (val) => isValueEmpty(val) ? void 0 : new Date(val),
    emptyAsString: (val) => isValueEmpty(val) ? "" : new Date(val),
    emptyAsZero: (val) => isValueEmpty(val) ? 0 : new Date(val)
  },
  valueAsJSON: {
    emptyAsNull: (val) => {
      if (isValueEmpty(val)) {
        return null;
      }
      try {
        return JSON.parse(val);
      } catch {
        return NaN;
      }
    },
    emptyAsString: (val) => {
      if (isValueEmpty(val)) {
        return "";
      }
      try {
        return JSON.parse(val);
      } catch {
        return NaN;
      }
    },
    emptyAsUndefined: (val) => {
      if (isValueEmpty(val)) {
        return void 0;
      }
      try {
        return JSON.parse(val);
      } catch {
        return NaN;
      }
    },
    emptyAsZero: (val) => {
      if (isValueEmpty(val)) {
        return 0;
      }
      try {
        return JSON.parse(val);
      } catch {
        return NaN;
      }
    }
  },
  valueAsNumber: {
    emptyAsNull: (val) => isValueEmpty(val) ? null : +val,
    emptyAsUndefined: (val) => isValueEmpty(val) ? void 0 : +val,
    emptyAsNaN: (val) => isValueEmpty(val) ? NaN : +val,
    emptyAsString: (val) => isValueEmpty(val) ? "" : +val,
    emptyAsZero: (val) => isValueEmpty(val) ? 0 : +val
  },
  valueAsString: {
    emptyAsNull: (val) => isValueEmpty(val) ? null : val,
    emptyAsUndefined: (val) => isValueEmpty(val) ? void 0 : val,
    emptyAsString: (val) => isValueEmpty(val) ? "" : val,
    emptyAsZero: (val) => isValueEmpty(val) ? 0 : val
  }
};
const getSetValueAsFn = (type, emptyAs, required, isId) => {
  const typeObj = SET_VALUE_AS_FUNCTIONS[type];
  if (typeObj === void 0) {
    throw Error(`Type ${type} is unsupported.`);
  }
  let fn;
  switch (emptyAs) {
    case null:
      fn = typeObj["emptyAsNull"];
      break;
    case "undefined":
      fn = typeObj["emptyAsUndefined"];
      break;
    case 0:
      fn = typeObj["emptyAsZero"];
      break;
    case "":
      fn = typeObj["emptyAsString"];
      break;
    case void 0:
    default:
      if (required || isId) {
        fn = typeObj.emptyAsNull;
      } else {
        switch (type) {
          case "valueAsNumber":
            fn = typeObj.emptyAsNaN;
            break;
          case "valueAsDate":
          case "valueAsJSON":
            fn = typeObj.emptyAsNull;
            break;
          case "valueAsString":
            fn = typeObj.emptyAsString;
            break;
        }
      }
      break;
  }
  if (fn === void 0) {
    console.error(`emptyAs prop of ${emptyAs} is unsupported for this type.`);
  }
  return fn;
};
const JSONValidation = (val) => typeof val === "number" ? !isNaN(val) : true;
const setCoercion = (validation, { type, name, emptyAs }) => {
  if (validation.setValueAs) {
    return;
  }
  let valueAs;
  if (validation.valueAsBoolean || type === "checkbox") {
    return;
  } else if (validation.valueAsJSON) {
    validation.validate = JSONValidation;
    delete validation.valueAsJSON;
    valueAs = "valueAsJSON";
  } else if (type === "date" || type === "datetime-local" || validation.valueAsDate) {
    valueAs = "valueAsDate";
  } else if (type === "number" || validation.valueAsNumber) {
    valueAs = "valueAsNumber";
    if (validation.valueAsNumber && emptyAs !== void 0) {
      delete validation.valueAsNumber;
    }
  } else {
    valueAs = "valueAsString";
  }
  validation.setValueAs = getSetValueAsFn(
    valueAs,
    // type
    emptyAs,
    // emptyAs
    validation.required !== void 0 && validation.required !== false,
    // required
    (name || "").endsWith("Id")
    // isId
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  setCoercion
});
