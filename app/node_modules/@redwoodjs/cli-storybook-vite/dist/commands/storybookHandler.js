"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var storybookHandler_exports = {};
__export(storybookHandler_exports, {
  handler: () => handler
});
module.exports = __toCommonJS(storybookHandler_exports);
var import_node_fs = __toESM(require("node:fs"));
var import_node_path = __toESM(require("node:path"));
var import_execa = __toESM(require("execa"));
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_project_config = require("@redwoodjs/project-config");
var import_telemetry = require("@redwoodjs/telemetry");
var import_colors = __toESM(require("../lib/colors"));
const readFile = (target) => import_node_fs.default.readFileSync(target, { encoding: "utf8" });
const writeFile = (target, contents) => {
  const { base } = (0, import_project_config.getPaths)();
  if (import_node_fs.default.existsSync(target)) {
    throw new Error(`${target} already exists.`);
  }
  const filename = import_node_path.default.basename(target);
  const targetDir = target.replace(filename, "");
  import_node_fs.default.mkdirSync(targetDir, { recursive: true });
  import_node_fs.default.writeFileSync(target, contents);
  console.log(`Successfully wrote file \`./${import_node_path.default.relative(base, target)}\``);
};
async function handler({
  build,
  buildDirectory,
  ci,
  open,
  port,
  smokeTest
}) {
  console.log(
    import_colors.default.bold(
      `
Please find documentation and links to provide feedback for this new command at:
 -> https://community.redwoodjs.com/t/7212

`
    )
  );
  import_node_fs.default.rmSync(
    import_node_path.default.join((0, import_project_config.getPaths)().generated.types.includes, "web-storybook.d.ts"),
    { force: true }
  );
  if (build && smokeTest) {
    throw new Error('Can not provide both "--build" and "--smoke-test"');
  }
  if (build && open) {
    console.warn(
      import_colors.default.warning(
        "Warning: --open option has no effect when running Storybook build"
      )
    );
  }
  const cwd = (0, import_project_config.getPaths)().web.base;
  const staticAssetsFolder = import_node_path.default.join(cwd, "public");
  const execaOptions = {
    stdio: "inherit",
    shell: true,
    cwd
  };
  await import_execa.default.command(
    `yarn msw init "${staticAssetsFolder}" --no-save`,
    execaOptions
  );
  const usingTS = (0, import_cli_helpers.isTypeScriptProject)();
  const mainFileName = usingTS ? "main.ts" : "main.js";
  const redwoodProjectPaths = (0, import_project_config.getPaths)();
  const storybookConfigPath = import_node_path.default.dirname(
    `${redwoodProjectPaths.web.storybook}/${mainFileName}`
  );
  const storybookMainFilePath = import_node_path.default.join(storybookConfigPath, mainFileName);
  const storybookPreviewBodyFilePath = import_node_path.default.join(
    storybookConfigPath,
    "preview-body.html"
  );
  if (!import_node_fs.default.existsSync(storybookMainFilePath)) {
    const isTSProject = (0, import_cli_helpers.isTypeScriptProject)();
    console.log(`Storybook's ${mainFileName} not found. Creating it now...`);
    const mainConfigTemplatePath = import_node_path.default.join(
      __dirname,
      "templates/main.ts.template"
      // The template is TS, and we'll convert it to JS if needed
    );
    const mainConfigContentTS = readFile(mainConfigTemplatePath);
    if (isTSProject) {
      writeFile(storybookMainFilePath, mainConfigContentTS);
    } else {
      const mainConfigContentJS = await (0, import_cli_helpers.transformTSToJS)(
        storybookMainFilePath,
        mainConfigContentTS
      );
      writeFile(storybookMainFilePath, mainConfigContentJS);
    }
    console.log(`${mainFileName} created!`);
  }
  if (!import_node_fs.default.existsSync(storybookPreviewBodyFilePath)) {
    console.log("Storybook's preview-body.html not found. Creating it now...");
    const previewBodyTemplatePath = import_node_path.default.join(
      __dirname,
      "templates/preview-body.html.template"
    );
    const previewBodyConfigContent = readFile(previewBodyTemplatePath);
    writeFile(storybookPreviewBodyFilePath, previewBodyConfigContent);
    console.log("preview-body.html created!");
  }
  let command = "";
  const flags = [`--config-dir "${storybookConfigPath}"`];
  if (build) {
    command = `yarn storybook build ${[
      ...flags,
      `--output-dir "${buildDirectory}"`
    ].filter(Boolean).join(" ")}`;
  } else if (smokeTest) {
    command = `yarn storybook dev ${[
      ...flags,
      `--port ${port}`,
      `--smoke-test`,
      `--ci`,
      `--no-version-updates`
    ].filter(Boolean).join(" ")}`;
  } else {
    command = `yarn storybook dev ${[
      ...flags,
      `--port ${port}`,
      `--no-version-updates`,
      ci && "--ci",
      !open && `--no-open`
    ].filter(Boolean).join(" ")}`;
  }
  try {
    await import_execa.default.command(command, execaOptions);
  } catch (e) {
    if (e.signal !== "SIGINT") {
      console.log(import_colors.default.error(e.message));
      (0, import_telemetry.errorTelemetry)(process.argv, e.message);
    }
    process.exit(e.exitCode ?? 1);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
