import { use, useState, useEffect } from "react";
import { createFromFetch, encodeReply } from "react-server-dom-webpack/client";
import { RscCache } from "./RscCache.js";
const BASE_PATH = "/rw-rsc/";
const rscCache = new RscCache();
let updateCurrentRscCacheKey = (key) => {
  console.error("updateCurrentRscCacheKey called before it was set");
  console.error("updateCurrentRscCacheKey key", key);
};
function onStreamFinished(fetchPromise, onFinished) {
  return fetchPromise.then((response) => response.clone().text()).then(onFinished);
}
async function rsaFetch(serializedLocation, rsaId, rsaArgs) {
  const rscId = "_";
  const searchParams = new URLSearchParams();
  searchParams.set("action_id", rsaId);
  const url = BASE_PATH + rscId + "?" + searchParams + "&" + serializedLocation;
  let body = "";
  try {
    body = await encodeReply(rsaArgs);
  } catch (e) {
    console.error("Error encoding Server Action arguments", e);
  }
  return fetch(url, {
    method: "POST",
    body,
    headers: { "rw-rsc": "1" }
  });
}
function rscFetch(serializedLocation) {
  const rscId = "__rwjs__Routes";
  return fetch(BASE_PATH + rscId + "?" + serializedLocation, {
    headers: { "rw-rsc": "1" }
  });
}
function rscFetchRoutes(serializedLocation) {
  console.log(
    "rscFetchRoutes :: args:\n    serializedProps: " + serializedLocation
  );
  const rscCacheKey = serializedLocation;
  const cached = rscCache.get(rscCacheKey);
  if (cached) {
    console.log("rscFetchRoutes :: cache hit for", rscCacheKey);
    return cached;
  } else {
    console.log("rscFetchRoutes :: cache miss for", rscCacheKey);
  }
  const options = {
    // React will hold on to `callServer` and use that when it detects a server
    // action is invoked (like `action={onSubmit}` in a <form> element). So for
    // now at least we need to send it with every RSC request, so React knows
    // what `callServer` method to use for server actions inside the RSC.
    // TODO (RSC): Need to figure out the types for callServer
    // @ts-expect-error types
    callServer: async function(rsaId, args) {
      console.log("RscRoutes :: callServer rsaId", rsaId, "args", args);
      const rscCacheKey2 = `${serializedLocation}::${rsaId}::${Date.now()}`;
      const responsePromise = rsaFetch(serializedLocation, rsaId, args);
      onStreamFinished(responsePromise, () => {
        updateCurrentRscCacheKey(rscCacheKey2);
      });
      const modelPromise2 = createFromFetch(responsePromise, options);
      rscCache.set(rscCacheKey2, modelPromise2);
      const model = await modelPromise2;
      return model.__rwjs__rsa_data;
    }
  };
  const modelPromise = createFromFetch(rscFetch(serializedLocation), options);
  rscCache.set(rscCacheKey, modelPromise);
  return modelPromise;
}
const RscRoutes = ({ pathname, search }) => {
  const serializedLocation = `__rwjs__pathname=${pathname}&__rwjs__search=${search}`;
  const [currentRscCacheKey, setCurrentRscCacheKey] = useState(() => {
    console.log("RscRoutes :: useState initial value");
    rscFetchRoutes(serializedLocation);
    return serializedLocation;
  });
  useEffect(() => {
    console.log("RscRoutes :: useEffect set updateCurrentRscCacheKey");
    updateCurrentRscCacheKey = (key) => {
      console.log("RscRoutes inside updateCurrentRscCacheKey", key);
      setCurrentRscCacheKey(key);
    };
  }, []);
  useEffect(() => {
    console.log("RscRoutes :: useEffect about to call rscFetchRoutes");
    rscFetchRoutes(serializedLocation);
    setCurrentRscCacheKey(serializedLocation);
  }, [serializedLocation]);
  console.log("RscRoutes :: rendering cache entry for\n" + currentRscCacheKey);
  const rscModelPromise = rscCache.get(currentRscCacheKey);
  if (!rscModelPromise) {
    throw new Error("Missing RSC cache entry for " + currentRscCacheKey);
  }
  return use(rscModelPromise).__rwjs__Routes[0];
};
export {
  RscRoutes
};
