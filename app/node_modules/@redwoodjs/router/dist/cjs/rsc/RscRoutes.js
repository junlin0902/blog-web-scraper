"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var RscRoutes_exports = {};
__export(RscRoutes_exports, {
  RscRoutes: () => RscRoutes
});
module.exports = __toCommonJS(RscRoutes_exports);
var import_react = require("react");
var import_client = require("react-server-dom-webpack/client");
var import_RscCache = require("./RscCache.js");
const BASE_PATH = "/rw-rsc/";
const rscCache = new import_RscCache.RscCache();
let updateCurrentRscCacheKey = (key) => {
  console.error("updateCurrentRscCacheKey called before it was set");
  console.error("updateCurrentRscCacheKey key", key);
};
function onStreamFinished(fetchPromise, onFinished) {
  return fetchPromise.then((response) => response.clone().text()).then(onFinished);
}
async function rsaFetch(serializedLocation, rsaId, rsaArgs) {
  const rscId = "_";
  const searchParams = new URLSearchParams();
  searchParams.set("action_id", rsaId);
  const url = BASE_PATH + rscId + "?" + searchParams + "&" + serializedLocation;
  let body = "";
  try {
    body = await (0, import_client.encodeReply)(rsaArgs);
  } catch (e) {
    console.error("Error encoding Server Action arguments", e);
  }
  return fetch(url, {
    method: "POST",
    body,
    headers: { "rw-rsc": "1" }
  });
}
function rscFetch(serializedLocation) {
  const rscId = "__rwjs__Routes";
  return fetch(BASE_PATH + rscId + "?" + serializedLocation, {
    headers: { "rw-rsc": "1" }
  });
}
function rscFetchRoutes(serializedLocation) {
  console.log(
    "rscFetchRoutes :: args:\n    serializedProps: " + serializedLocation
  );
  const rscCacheKey = serializedLocation;
  const cached = rscCache.get(rscCacheKey);
  if (cached) {
    console.log("rscFetchRoutes :: cache hit for", rscCacheKey);
    return cached;
  } else {
    console.log("rscFetchRoutes :: cache miss for", rscCacheKey);
  }
  const options = {
    // React will hold on to `callServer` and use that when it detects a server
    // action is invoked (like `action={onSubmit}` in a <form> element). So for
    // now at least we need to send it with every RSC request, so React knows
    // what `callServer` method to use for server actions inside the RSC.
    // TODO (RSC): Need to figure out the types for callServer
    // @ts-expect-error types
    callServer: async function(rsaId, args) {
      console.log("RscRoutes :: callServer rsaId", rsaId, "args", args);
      const rscCacheKey2 = `${serializedLocation}::${rsaId}::${Date.now()}`;
      const responsePromise = rsaFetch(serializedLocation, rsaId, args);
      onStreamFinished(responsePromise, () => {
        updateCurrentRscCacheKey(rscCacheKey2);
      });
      const modelPromise2 = (0, import_client.createFromFetch)(responsePromise, options);
      rscCache.set(rscCacheKey2, modelPromise2);
      const model = await modelPromise2;
      return model.__rwjs__rsa_data;
    }
  };
  const modelPromise = (0, import_client.createFromFetch)(rscFetch(serializedLocation), options);
  rscCache.set(rscCacheKey, modelPromise);
  return modelPromise;
}
const RscRoutes = ({ pathname, search }) => {
  const serializedLocation = `__rwjs__pathname=${pathname}&__rwjs__search=${search}`;
  const [currentRscCacheKey, setCurrentRscCacheKey] = (0, import_react.useState)(() => {
    console.log("RscRoutes :: useState initial value");
    rscFetchRoutes(serializedLocation);
    return serializedLocation;
  });
  (0, import_react.useEffect)(() => {
    console.log("RscRoutes :: useEffect set updateCurrentRscCacheKey");
    updateCurrentRscCacheKey = (key) => {
      console.log("RscRoutes inside updateCurrentRscCacheKey", key);
      setCurrentRscCacheKey(key);
    };
  }, []);
  (0, import_react.useEffect)(() => {
    console.log("RscRoutes :: useEffect about to call rscFetchRoutes");
    rscFetchRoutes(serializedLocation);
    setCurrentRscCacheKey(serializedLocation);
  }, [serializedLocation]);
  console.log("RscRoutes :: rendering cache entry for\n" + currentRscCacheKey);
  const rscModelPromise = rscCache.get(currentRscCacheKey);
  if (!rscModelPromise) {
    throw new Error("Missing RSC cache entry for " + currentRscCacheKey);
  }
  return (0, import_react.use)(rscModelPromise).__rwjs__Routes[0];
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RscRoutes
});
