"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var apollo_exports = {};
__export(apollo_exports, {
  RedwoodApolloProvider: () => RedwoodApolloProvider,
  fragmentRegistry: () => import_fragmentRegistry.fragmentRegistry,
  registerFragment: () => import_fragmentRegistry.registerFragment,
  registerFragments: () => import_fragmentRegistry.registerFragments,
  useCache: () => import_useCache.useCache
});
module.exports = __toCommonJS(apollo_exports);
var import_react = __toESM(require("react"), 1);
var import_client = require("@apollo/client");
var import_core = require("@apollo/client/core/core.cjs");
var import_context = require("@apollo/client/link/context/context.cjs");
var import_persisted_queries = require("@apollo/client/link/persisted-queries/persisted-queries.cjs");
var import_hooks = require("@apollo/client/react/hooks/hooks.cjs");
var import_utilities = require("@apollo/client/utilities/utilities.cjs");
var import_printer = require("graphql/language/printer.js");
var import_auth = require("@redwoodjs/auth");
var import_typeOverride = require("./typeOverride.js");
var import_apollo_upload_client = require("../bundled/apollo-upload-client.js");
var import_FetchConfigProvider = require("../components/FetchConfigProvider.js");
var import_GraphQLHooksProvider = require("../components/GraphQLHooksProvider.js");
var import_fragmentRegistry = require("./fragmentRegistry.js");
var SSELinkExports = __toESM(require("./sseLink.js"), 1);
var import_useCache = require("./useCache.js");
const { SSELink, isSubscription, isLiveQuery } = SSELinkExports;
const ApolloProviderWithFetchConfig = ({ config, children, useAuth = import_auth.useNoAuth, logLevel }) => {
  (0, import_core.setLogVerbosity)(logLevel);
  const { getToken, type: authProviderType } = useAuth();
  const data = {
    mostRecentRequest: void 0,
    mostRecentResponse: void 0
  };
  const updateDataApolloLink = new import_client.ApolloLink((operation, forward) => {
    const { operationName, query, variables } = operation;
    data.mostRecentRequest = {};
    data.mostRecentRequest.operationName = operationName;
    data.mostRecentRequest.operationKind = query?.kind.toString();
    data.mostRecentRequest.variables = variables;
    data.mostRecentRequest.query = query && (0, import_printer.print)(operation.query);
    return forward(operation).map((result) => {
      data.mostRecentResponse = result;
      return result;
    });
  });
  const withToken = (0, import_context.setContext)(async () => {
    const token = await getToken();
    return { token };
  });
  const { headers, uri } = (0, import_FetchConfigProvider.useFetchConfig)();
  const authMiddleware = new import_client.ApolloLink((operation, forward) => {
    const { token } = operation.getContext();
    const authHeaders = token ? {
      "auth-provider": authProviderType,
      authorization: `Bearer ${token}`
    } : {};
    operation.setContext(() => ({
      headers: {
        ...operation.getContext().headers,
        ...headers,
        // Duped auth headers, because we may remove the `FetchConfigProvider` at a later date.
        ...authHeaders
      }
    }));
    return forward(operation);
  });
  const { httpLinkConfig, link: redwoodApolloLink, ...rest } = config ?? {};
  const uploadLink = (0, import_apollo_upload_client.createUploadLink)({
    uri,
    ...httpLinkConfig
    // The upload link types don't match the ApolloLink types, even though it comes from Apollo
    // because they use ESM imports and we're using the default ones.
  });
  const uploadOrSSELink = typeof SSELink !== "undefined" ? (0, import_client.split)(
    ({ query }) => {
      const definition = (0, import_utilities.getMainDefinition)(query);
      return isSubscription(definition) || isLiveQuery(definition);
    },
    new SSELink({
      url: uri,
      auth: { authProviderType, tokenFn: getToken },
      httpLinkConfig,
      headers
    }),
    uploadLink
  ) : uploadLink;
  const terminatingLink = (0, import_client.split)(
    ({ query }) => {
      const documentQuery = query;
      return documentQuery?.["__meta__"]?.["hash"] !== void 0;
    },
    (0, import_persisted_queries.createPersistedQueryLink)({
      generateHash: (document) => document["__meta__"]["hash"]
    }).concat(uploadOrSSELink),
    uploadOrSSELink
  );
  const redwoodApolloLinks = [
    { name: "withToken", link: withToken },
    { name: "authMiddleware", link: authMiddleware },
    { name: "updateDataApolloLink", link: updateDataApolloLink },
    { name: "httpLink", link: terminatingLink }
  ];
  let link = redwoodApolloLink;
  link ??= import_client.ApolloLink.from(redwoodApolloLinks.map((l) => l.link));
  if (typeof link === "function") {
    link = link(redwoodApolloLinks);
  }
  const client = new import_client.ApolloClient({
    // Default options for every Cell. Better to specify them here than in `beforeQuery` where it's too easy to overwrite them.
    // See https://www.apollographql.com/docs/react/api/core/ApolloClient/#example-defaultoptions-object.
    defaultOptions: {
      watchQuery: {
        // The `fetchPolicy` we expect:
        //
        // > Apollo Client executes the full query against both the cache and your GraphQL server.
        // > The query automatically updates if the result of the server-side query modifies cached fields.
        //
        // See https://www.apollographql.com/docs/react/data/queries/#cache-and-network.
        fetchPolicy: "cache-and-network",
        // So that Cells rerender when refetching.
        // See https://www.apollographql.com/docs/react/data/queries/#inspecting-loading-states.
        notifyOnNetworkStatusChange: true
      }
    },
    link,
    ...rest
  });
  const extendErrorAndRethrow = (error, _errorInfo) => {
    error["mostRecentRequest"] = data.mostRecentRequest;
    error["mostRecentResponse"] = data.mostRecentResponse;
    throw error;
  };
  return /* @__PURE__ */ import_react.default.createElement(import_client.ApolloProvider, { client }, /* @__PURE__ */ import_react.default.createElement(ErrorBoundary, { onError: extendErrorAndRethrow }, children));
};
class ErrorBoundary extends import_react.default.Component {
  componentDidCatch(...args) {
    this.setState({});
    this.props.onError(...args);
  }
  render() {
    return this.props.children;
  }
}
const RedwoodApolloProvider = ({
  graphQLClientConfig,
  fragments,
  useAuth = import_auth.useNoAuth,
  logLevel = "debug",
  children
}) => {
  const { cacheConfig, ...config } = graphQLClientConfig ?? {};
  if (fragments) {
    import_fragmentRegistry.fragmentRegistry.register(...fragments);
  }
  const cache = new import_client.InMemoryCache({
    fragments: import_fragmentRegistry.fragmentRegistry,
    possibleTypes: cacheConfig?.possibleTypes,
    ...cacheConfig
  }).restore(globalThis?.__REDWOOD__APOLLO_STATE ?? {});
  return /* @__PURE__ */ import_react.default.createElement(import_FetchConfigProvider.FetchConfigProvider, { useAuth }, /* @__PURE__ */ import_react.default.createElement(
    ApolloProviderWithFetchConfig,
    {
      config: { cache, ...config },
      useAuth,
      logLevel
    },
    /* @__PURE__ */ import_react.default.createElement(
      import_GraphQLHooksProvider.GraphQLHooksProvider,
      {
        useQuery: import_hooks.useQuery,
        useMutation: import_hooks.useMutation,
        useSubscription: import_hooks.useSubscription,
        useBackgroundQuery: import_hooks.useBackgroundQuery,
        useReadQuery: import_hooks.useReadQuery,
        useSuspenseQuery: import_hooks.useSuspenseQuery
      },
      children
    )
  ));
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RedwoodApolloProvider,
  fragmentRegistry,
  registerFragment,
  registerFragments,
  useCache
});
