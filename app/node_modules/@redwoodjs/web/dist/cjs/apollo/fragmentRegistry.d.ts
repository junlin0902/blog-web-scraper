import type { UseFragmentResult } from '@apollo/client';
import type { FragmentRegistryAPI } from '@apollo/client/cache/index.js';
import type { DocumentNode } from 'graphql';
export type FragmentIdentifier = string | number;
export type CacheKey = {
    __typename: string;
    id: FragmentIdentifier;
};
export type RegisterFragmentResult = {
    fragment: DocumentNode;
    typename: string;
    getCacheKey: (id: FragmentIdentifier) => CacheKey;
    useRegisteredFragment: <TData = any>(id: FragmentIdentifier) => UseFragmentResult<TData>;
};
/**
 * Creates a fragment registry for Apollo Client's InMemoryCache so that they
 * can be referred to by name in any query or InMemoryCache operation
 * (such as cache.readFragment, cache.readQuery and cache.watch)
 * without needing to interpolate their declaration.
 *
 * @see https://www.apollographql.com/docs/react/data/fragments/#registering-named-fragments-using-createfragmentregistry
 **/
export declare const fragmentRegistry: FragmentRegistryAPI;
/**
 * Registers a list of fragments with the fragment registry.
 */
export declare const registerFragments: (fragments: DocumentNode[]) => RegisterFragmentResult[];
/**
 * Registers a fragment with the fragment registry.
 *
 * It returns a set of utilities for working with the fragment, including:
 * - the fragment itself
 * - the typename of the fragment
 * - a function to get the cache key for a given id
 * - a hook to use the registered fragment in a component by id
 * that returns cached data for the fragment
 *
 * Note: one does not need to use the hook, cacheKey to use the fragment in queries.
 *
 * @see https://www.apollographql.com/docs/react/data/fragments/#registering-named-fragments-using-createfragmentregistry
 */
export declare const registerFragment: (fragment: DocumentNode) => RegisterFragmentResult;
//# sourceMappingURL=fragmentRegistry.d.ts.map