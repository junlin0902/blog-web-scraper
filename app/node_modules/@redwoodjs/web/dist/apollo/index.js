import React from "react";
import {
  ApolloProvider,
  ApolloClient,
  InMemoryCache,
  split,
  ApolloLink
} from "@apollo/client";
import { setLogVerbosity as apolloSetLogVerbosity } from "@apollo/client/core/core.cjs";
import { setContext } from "@apollo/client/link/context/context.cjs";
import { createPersistedQueryLink } from "@apollo/client/link/persisted-queries/persisted-queries.cjs";
import {
  useQuery,
  useMutation,
  useSubscription,
  useBackgroundQuery,
  useReadQuery,
  useSuspenseQuery
} from "@apollo/client/react/hooks/hooks.cjs";
import { getMainDefinition } from "@apollo/client/utilities/utilities.cjs";
import { print } from "graphql/language/printer.js";
import { useNoAuth } from "@redwoodjs/auth";
import "./typeOverride.js";
import { createUploadLink } from "../bundled/apollo-upload-client.js";
import {
  FetchConfigProvider,
  useFetchConfig
} from "../components/FetchConfigProvider.js";
import { GraphQLHooksProvider } from "../components/GraphQLHooksProvider.js";
import {
  fragmentRegistry,
  registerFragment,
  registerFragments
} from "./fragmentRegistry.js";
import * as SSELinkExports from "./sseLink.js";
import { useCache } from "./useCache.js";
const { SSELink, isSubscription, isLiveQuery } = SSELinkExports;
const ApolloProviderWithFetchConfig = ({ config, children, useAuth = useNoAuth, logLevel }) => {
  apolloSetLogVerbosity(logLevel);
  const { getToken, type: authProviderType } = useAuth();
  const data = {
    mostRecentRequest: void 0,
    mostRecentResponse: void 0
  };
  const updateDataApolloLink = new ApolloLink((operation, forward) => {
    const { operationName, query, variables } = operation;
    data.mostRecentRequest = {};
    data.mostRecentRequest.operationName = operationName;
    data.mostRecentRequest.operationKind = query?.kind.toString();
    data.mostRecentRequest.variables = variables;
    data.mostRecentRequest.query = query && print(operation.query);
    return forward(operation).map((result) => {
      data.mostRecentResponse = result;
      return result;
    });
  });
  const withToken = setContext(async () => {
    const token = await getToken();
    return { token };
  });
  const { headers, uri } = useFetchConfig();
  const authMiddleware = new ApolloLink((operation, forward) => {
    const { token } = operation.getContext();
    const authHeaders = token ? {
      "auth-provider": authProviderType,
      authorization: `Bearer ${token}`
    } : {};
    operation.setContext(() => ({
      headers: {
        ...operation.getContext().headers,
        ...headers,
        // Duped auth headers, because we may remove the `FetchConfigProvider` at a later date.
        ...authHeaders
      }
    }));
    return forward(operation);
  });
  const { httpLinkConfig, link: redwoodApolloLink, ...rest } = config ?? {};
  const uploadLink = createUploadLink({
    uri,
    ...httpLinkConfig
    // The upload link types don't match the ApolloLink types, even though it comes from Apollo
    // because they use ESM imports and we're using the default ones.
  });
  const uploadOrSSELink = typeof SSELink !== "undefined" ? split(
    ({ query }) => {
      const definition = getMainDefinition(query);
      return isSubscription(definition) || isLiveQuery(definition);
    },
    new SSELink({
      url: uri,
      auth: { authProviderType, tokenFn: getToken },
      httpLinkConfig,
      headers
    }),
    uploadLink
  ) : uploadLink;
  const terminatingLink = split(
    ({ query }) => {
      const documentQuery = query;
      return documentQuery?.["__meta__"]?.["hash"] !== void 0;
    },
    createPersistedQueryLink({
      generateHash: (document) => document["__meta__"]["hash"]
    }).concat(uploadOrSSELink),
    uploadOrSSELink
  );
  const redwoodApolloLinks = [
    { name: "withToken", link: withToken },
    { name: "authMiddleware", link: authMiddleware },
    { name: "updateDataApolloLink", link: updateDataApolloLink },
    { name: "httpLink", link: terminatingLink }
  ];
  let link = redwoodApolloLink;
  link ??= ApolloLink.from(redwoodApolloLinks.map((l) => l.link));
  if (typeof link === "function") {
    link = link(redwoodApolloLinks);
  }
  const client = new ApolloClient({
    // Default options for every Cell. Better to specify them here than in `beforeQuery` where it's too easy to overwrite them.
    // See https://www.apollographql.com/docs/react/api/core/ApolloClient/#example-defaultoptions-object.
    defaultOptions: {
      watchQuery: {
        // The `fetchPolicy` we expect:
        //
        // > Apollo Client executes the full query against both the cache and your GraphQL server.
        // > The query automatically updates if the result of the server-side query modifies cached fields.
        //
        // See https://www.apollographql.com/docs/react/data/queries/#cache-and-network.
        fetchPolicy: "cache-and-network",
        // So that Cells rerender when refetching.
        // See https://www.apollographql.com/docs/react/data/queries/#inspecting-loading-states.
        notifyOnNetworkStatusChange: true
      }
    },
    link,
    ...rest
  });
  const extendErrorAndRethrow = (error, _errorInfo) => {
    error["mostRecentRequest"] = data.mostRecentRequest;
    error["mostRecentResponse"] = data.mostRecentResponse;
    throw error;
  };
  return /* @__PURE__ */ React.createElement(ApolloProvider, { client }, /* @__PURE__ */ React.createElement(ErrorBoundary, { onError: extendErrorAndRethrow }, children));
};
class ErrorBoundary extends React.Component {
  componentDidCatch(...args) {
    this.setState({});
    this.props.onError(...args);
  }
  render() {
    return this.props.children;
  }
}
const RedwoodApolloProvider = ({
  graphQLClientConfig,
  fragments,
  useAuth = useNoAuth,
  logLevel = "debug",
  children
}) => {
  const { cacheConfig, ...config } = graphQLClientConfig ?? {};
  if (fragments) {
    fragmentRegistry.register(...fragments);
  }
  const cache = new InMemoryCache({
    fragments: fragmentRegistry,
    possibleTypes: cacheConfig?.possibleTypes,
    ...cacheConfig
  }).restore(globalThis?.__REDWOOD__APOLLO_STATE ?? {});
  return /* @__PURE__ */ React.createElement(FetchConfigProvider, { useAuth }, /* @__PURE__ */ React.createElement(
    ApolloProviderWithFetchConfig,
    {
      config: { cache, ...config },
      useAuth,
      logLevel
    },
    /* @__PURE__ */ React.createElement(
      GraphQLHooksProvider,
      {
        useQuery,
        useMutation,
        useSubscription,
        useBackgroundQuery,
        useReadQuery,
        useSuspenseQuery
      },
      children
    )
  ));
};
export {
  RedwoodApolloProvider,
  fragmentRegistry,
  registerFragment,
  registerFragments,
  useCache
};
