"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var plugin_exports = {};
__export(plugin_exports, {
  loadPlugins: () => loadPlugins
});
module.exports = __toCommonJS(plugin_exports);
var import_lib = require("./lib");
var import_plugin = require("./lib/plugin");
async function loadPlugins(yargs) {
  const namespaceIsExplicit = process.argv[2]?.startsWith("@");
  const namespaceInUse = (namespaceIsExplicit ? process.argv[2] : "@redwoodjs") ?? "@redwoodjs";
  const commandString = namespaceIsExplicit ? process.argv.slice(3).join(" ") : process.argv.slice(2).join(" ");
  const commandFirstWord = commandString.split(" ")[0];
  if (commandFirstWord === "--version" && namespaceInUse === "@redwoodjs") {
    return yargs;
  }
  const pluginCommandCache = (0, import_plugin.loadCommandCache)();
  if (pluginCommandCache._builtin.includes(commandFirstWord) && namespaceInUse === "@redwoodjs") {
    return yargs;
  }
  const { plugins, autoInstall } = (0, import_lib.getConfig)().experimental.cli;
  const enabledPlugins = plugins.filter(
    (p) => p.package !== void 0 && (p.enabled ?? true)
  );
  (0, import_plugin.checkPluginListAndWarn)(enabledPlugins);
  const redwoodPackages = /* @__PURE__ */ new Set();
  const thirdPartyPackages = /* @__PURE__ */ new Set();
  for (const plugin of enabledPlugins) {
    if (!plugin.package) {
      continue;
    }
    if (!plugin.package.startsWith("@")) {
      continue;
    }
    if (plugin.package.startsWith("@redwoodjs/")) {
      redwoodPackages.add(plugin.package);
    } else {
      thirdPartyPackages.add(plugin.package);
    }
  }
  const namespaces = Array.from(thirdPartyPackages).map((p) => p.split("/")[0]).sort();
  if (redwoodPackages.size > 0) {
    namespaces.unshift("@redwoodjs");
  }
  const showingHelpAtRootLevel = !namespaceIsExplicit && (commandFirstWord === "--help" || commandFirstWord === "-h" || commandFirstWord === "");
  const namespaceIsUnknown = !namespaces.includes(namespaceInUse);
  if (showingHelpAtRootLevel || namespaceIsUnknown) {
    for (const namespace of namespaces) {
      if (namespace === "@redwoodjs") {
        for (const redwoodPluginPackage of redwoodPackages) {
          const commands = await loadCommandsFromCacheOrPackage(
            redwoodPluginPackage,
            pluginCommandCache,
            autoInstall,
            true
          );
          yargs.command(commands);
        }
      } else {
        yargs.command({
          command: `${namespace} <command>`,
          describe: `Commands from ${namespace}`,
          builder: () => {
          },
          handler: () => {
          }
        });
      }
    }
    (0, import_plugin.saveCommandCache)(pluginCommandCache);
    return yargs;
  }
  const showingHelpAtNamespaceLevel = namespaceIsExplicit && (commandFirstWord === "--help" || commandFirstWord === "-h" || commandFirstWord === "");
  if (showingHelpAtNamespaceLevel) {
    if (namespaceInUse === "@redwoodjs") {
      for (const redwoodPluginPackage of redwoodPackages) {
        const commands = await loadCommandsFromCacheOrPackage(
          redwoodPluginPackage,
          pluginCommandCache,
          autoInstall,
          true
        );
        yargs.command(commands);
      }
    } else {
      const packagesForNamespace = Array.from(thirdPartyPackages).filter(
        (p) => p.startsWith(namespaceInUse)
      );
      for (const packageForNamespace of packagesForNamespace) {
        const commands = await loadCommandsFromCacheOrPackage(
          packageForNamespace,
          pluginCommandCache,
          autoInstall,
          true
        );
        yargs.command({
          command: `${namespaceInUse} <command>`,
          describe: `Commands from ${namespaceInUse}`,
          builder: (yargs2) => {
            yargs2.command(commands).demandCommand();
          },
          handler: () => {
          }
        });
      }
    }
    (0, import_plugin.saveCommandCache)(pluginCommandCache);
    return yargs;
  }
  const packagesToLoad = /* @__PURE__ */ new Set();
  for (const [packageName, cacheEntry] of Object.entries(pluginCommandCache)) {
    if (packageName === "_builtin") {
      continue;
    }
    const commandFirstWords = [];
    for (const [command, info] of Object.entries(cacheEntry)) {
      commandFirstWords.push(command.split(" ")[0]);
      commandFirstWords.push(
        ...info.aliases?.map((a) => a.split(" ")[0]) ?? []
      );
    }
    if (commandFirstWords.includes(commandFirstWord) && packageName.startsWith(namespaceInUse)) {
      packagesToLoad.add(packageName);
      break;
    }
  }
  const foundMatchingPackage = packagesToLoad.size > 0;
  if (!foundMatchingPackage) {
    for (const plugin of enabledPlugins) {
      if (plugin.package.startsWith(namespaceInUse)) {
        packagesToLoad.add(plugin.package);
      }
    }
  }
  const commandsToRegister = [];
  if (foundMatchingPackage) {
    const packageToLoad = packagesToLoad.values().next().value;
    const commands = await loadCommandsFromCacheOrPackage(
      packageToLoad,
      pluginCommandCache,
      autoInstall,
      false
    );
    commandsToRegister.push(...commands);
  } else {
    for (const packageToLoad of packagesToLoad) {
      const commands = await loadCommandsFromCacheOrPackage(
        packageToLoad,
        pluginCommandCache,
        autoInstall,
        true
      );
      commandsToRegister.push(...commands);
    }
  }
  if (namespaceInUse === "@redwoodjs") {
    yargs.command(commandsToRegister);
  } else {
    yargs.command({
      command: `${namespaceInUse} <command>`,
      describe: `Commands from ${namespaceInUse}`,
      builder: (yargs2) => {
        yargs2.command(commandsToRegister).demandCommand();
      },
      handler: () => {
      }
    });
  }
  if (!namespaceIsExplicit) {
    for (const namespace of namespaces) {
      if (namespace === "@redwoodjs") {
        continue;
      }
      yargs.command({
        command: `${namespace} <command>`,
        describe: `Commands from ${namespace}`,
        builder: () => {
        },
        handler: () => {
        }
      });
    }
  }
  (0, import_plugin.saveCommandCache)(pluginCommandCache);
  return yargs;
}
async function loadCommandsFromCacheOrPackage(packageName, cache, autoInstall, readFromCache) {
  let cacheEntry = void 0;
  if (readFromCache) {
    cacheEntry = cache !== void 0 ? cache[packageName] : void 0;
  }
  if (cacheEntry !== void 0) {
    const commands = Object.entries(cacheEntry).map(([command, info]) => {
      return {
        command,
        describe: info.description,
        aliases: info.aliases
      };
    });
    return commands;
  }
  const plugin = await (0, import_plugin.loadPluginPackage)(packageName, void 0, autoInstall);
  if (plugin) {
    const commands = plugin.commands ?? [];
    const cacheUpdate = {};
    for (const command of commands) {
      const info = {
        aliases: command.aliases,
        description: command.description
      };
      if (Object.values(info).some((value) => value !== void 0)) {
        cacheUpdate[command.command] = info;
      }
    }
    if (Object.keys(cacheUpdate).length > 0) {
      cache[packageName] = cacheUpdate;
    }
    return commands;
  }
  return [];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  loadPlugins
});
