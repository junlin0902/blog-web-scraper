"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var lib_exports = {};
__export(lib_exports, {
  _getPaths: () => _getPaths,
  addPackagesTask: () => addPackagesTask,
  addRoutesToRouterTask: () => addRoutesToRouterTask,
  addScaffoldImport: () => addScaffoldImport,
  bytes: () => bytes,
  cleanupEmptyDirsTask: () => cleanupEmptyDirsTask,
  deleteFile: () => deleteFile,
  deleteFilesTask: () => deleteFilesTask,
  existsAnyExtensionSync: () => existsAnyExtensionSync,
  findUp: () => import_project_config.findUp,
  generateTemplate: () => generateTemplate,
  getConfig: () => getConfig,
  getDefaultArgs: () => getDefaultArgs,
  getGraphqlPath: () => getGraphqlPath,
  getInstalledRedwoodVersion: () => getInstalledRedwoodVersion,
  getPaths: () => getPaths,
  getPrettierOptions: () => getPrettierOptions,
  graphFunctionDoesExist: () => graphFunctionDoesExist,
  nameVariants: () => nameVariants,
  prettify: () => prettify,
  printSetupNotes: () => printSetupNotes,
  readFile: () => readFile,
  removeRoutesFromRouterTask: () => removeRoutesFromRouterTask,
  resolveFile: () => resolveFile,
  runCommandTask: () => runCommandTask,
  saveRemoteFileToDisk: () => saveRemoteFileToDisk,
  transformTSToJS: () => transformTSToJS,
  usingVSCode: () => usingVSCode,
  writeFile: () => writeFile,
  writeFilesTask: () => writeFilesTask
});
module.exports = __toCommonJS(lib_exports);
var import_child_process = require("child_process");
var import_https = __toESM(require("https"));
var import_path = __toESM(require("path"));
var babel = __toESM(require("@babel/core"));
var import_boxen = __toESM(require("boxen"));
var import_camelcase = __toESM(require("camelcase"));
var import_change_case = require("change-case");
var import_decamelize = __toESM(require("decamelize"));
var import_execa = __toESM(require("execa"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_listr2 = require("listr2");
var import_lodash = require("lodash");
var import_pascalcase = __toESM(require("pascalcase"));
var import_prettier = require("prettier");
var import_project_config = require("@redwoodjs/project-config");
var import_colors = __toESM(require("./colors"));
var import_rollback = require("./rollback");
var import_rwPluralize = require("./rwPluralize");
const nameVariants = (name) => {
  const normalizedName = (0, import_pascalcase.default)((0, import_change_case.paramCase)((0, import_rwPluralize.singularize)(name)));
  return {
    pascalName: (0, import_pascalcase.default)((0, import_change_case.paramCase)(name)),
    camelName: (0, import_camelcase.default)(name),
    singularPascalName: normalizedName,
    pluralPascalName: (0, import_rwPluralize.pluralize)(normalizedName),
    singularCamelName: (0, import_camelcase.default)(normalizedName),
    pluralCamelName: (0, import_camelcase.default)((0, import_rwPluralize.pluralize)(normalizedName)),
    singularParamName: (0, import_change_case.paramCase)(normalizedName),
    pluralParamName: (0, import_change_case.paramCase)((0, import_rwPluralize.pluralize)(normalizedName)),
    singularConstantName: (0, import_decamelize.default)(normalizedName).toUpperCase(),
    pluralConstantName: (0, import_decamelize.default)((0, import_rwPluralize.pluralize)(normalizedName)).toUpperCase()
  };
};
const generateTemplate = async (templateFilename, { name, ...rest }) => {
  try {
    const templateFn = (0, import_lodash.template)(readFile(templateFilename).toString());
    const renderedTemplate = templateFn({
      name,
      ...nameVariants(name),
      ...rest
    });
    return prettify(templateFilename, renderedTemplate);
  } catch (error) {
    error.message = `Error applying template at ${templateFilename} for ${name}: ${error.message}`;
    throw error;
  }
};
const prettify = async (templateFilename, renderedTemplate) => {
  const parser = {
    ".css": "css",
    ".js": "babel",
    ".jsx": "babel",
    ".ts": "babel-ts",
    ".tsx": "babel-ts"
  }[import_path.default.extname(templateFilename.replace(".template", ""))];
  if (typeof parser === "undefined") {
    return renderedTemplate;
  }
  const prettierOptions = await getPrettierOptions();
  return (0, import_prettier.format)(renderedTemplate, {
    ...prettierOptions,
    parser
  });
};
const readFile = (target) => import_fs_extra.default.readFileSync(target, { encoding: "utf8" });
const SUPPORTED_EXTENSIONS = [".js", ".jsx", ".ts", ".tsx"];
const deleteFile = (file) => {
  const extension = import_path.default.extname(file);
  if (SUPPORTED_EXTENSIONS.includes(extension)) {
    const baseFile = getBaseFile(file);
    SUPPORTED_EXTENSIONS.forEach((ext) => {
      const f = baseFile + ext;
      if (import_fs_extra.default.existsSync(f)) {
        import_fs_extra.default.unlinkSync(f);
      }
    });
  } else {
    import_fs_extra.default.unlinkSync(file);
  }
};
const getBaseFile = (file) => file.replace(/\.\w*$/, "");
const existsAnyExtensionSync = (file) => {
  const extension = import_path.default.extname(file);
  if (SUPPORTED_EXTENSIONS.includes(extension)) {
    const baseFile = getBaseFile(file);
    return SUPPORTED_EXTENSIONS.some((ext) => import_fs_extra.default.existsSync(baseFile + ext));
  }
  return import_fs_extra.default.existsSync(file);
};
const writeFile = (target, contents, { overwriteExisting = false } = {}, task = {}) => {
  const { base } = getPaths();
  task.title = `Writing \`./${import_path.default.relative(base, target)}\``;
  if (!overwriteExisting && import_fs_extra.default.existsSync(target)) {
    throw new Error(`${target} already exists.`);
  }
  (0, import_rollback.addFileToRollback)(target);
  const filename = import_path.default.basename(target);
  const targetDir = target.replace(filename, "");
  import_fs_extra.default.mkdirSync(targetDir, { recursive: true });
  import_fs_extra.default.writeFileSync(target, contents);
  task.title = `Successfully wrote file \`./${import_path.default.relative(base, target)}\``;
};
const saveRemoteFileToDisk = (url, localPath, { overwriteExisting = false } = {}) => {
  if (!overwriteExisting && import_fs_extra.default.existsSync(localPath)) {
    throw new Error(`${localPath} already exists.`);
  }
  const downloadPromise = new Promise(
    (resolve, reject) => import_https.default.get(url, (response) => {
      if (response.statusCode === 200) {
        response.pipe(import_fs_extra.default.createWriteStream(localPath));
        resolve();
      } else {
        reject(
          new Error(`${url} responded with status code ${response.statusCode}`)
        );
      }
    })
  );
  return downloadPromise;
};
const getInstalledRedwoodVersion = () => {
  try {
    const packageJson = require("../../package.json");
    return packageJson.version;
  } catch (e) {
    console.error(import_colors.default.error("Could not find installed redwood version"));
    process.exit(1);
  }
};
const bytes = (contents) => Buffer.byteLength(contents, "utf8");
const _getPaths = () => {
  try {
    return (0, import_project_config.getPaths)();
  } catch (e) {
    console.error(import_colors.default.error(e.message));
    process.exit(1);
  }
};
const getPaths = (0, import_lodash.memoize)(_getPaths);
const resolveFile = import_project_config.resolveFile;
const getGraphqlPath = () => resolveFile(import_path.default.join(getPaths().api.functions, "graphql"));
const graphFunctionDoesExist = () => {
  return import_fs_extra.default.existsSync(getGraphqlPath());
};
const getConfig = () => {
  try {
    return (0, import_project_config.getConfig)();
  } catch (e) {
    console.error(import_colors.default.error(e.message));
    process.exit(1);
  }
};
const getPrettierOptions = async () => {
  try {
    const { default: prettierOptions } = await import(`file://${import_path.default.join(getPaths().base, "prettier.config.js")}`);
    return prettierOptions;
  } catch (e) {
    if (process.env.VITEST_POOL_ID !== void 0) {
      return {
        trailingComma: "es5",
        bracketSpacing: true,
        tabWidth: 2,
        semi: false,
        singleQuote: true,
        arrowParens: "always",
        overrides: [
          {
            files: "Routes.*",
            options: {
              printWidth: 999
            }
          }
        ]
      };
    }
    return void 0;
  }
};
const transformTSToJS = async (filename, content) => {
  const { code } = babel.transform(content, {
    filename,
    // If you ran `yarn rw generate` in `./web` transformSync would import the `.babelrc.js` file,
    // in `./web`? despite us setting `configFile: false`.
    cwd: process.env.NODE_ENV === "test" ? void 0 : getPaths().base,
    configFile: false,
    plugins: [
      [
        "@babel/plugin-transform-typescript",
        {
          isTSX: true,
          allExtensions: true
        }
      ]
    ],
    retainLines: true
  });
  return prettify(filename.replace(/\.ts(x)?$/, ".js$1"), code);
};
const writeFilesTask = (files, options) => {
  const { base } = getPaths();
  return new import_listr2.Listr(
    Object.keys(files).map((file) => {
      const contents = files[file];
      return {
        title: `...waiting to write file \`./${import_path.default.relative(base, file)}\`...`,
        task: (ctx, task) => writeFile(file, contents, options, task)
      };
    })
  );
};
const deleteFilesTask = (files) => {
  const { base } = getPaths();
  return new import_listr2.Listr([
    ...Object.keys(files).map((file) => {
      return {
        title: `Destroying \`./${import_path.default.relative(base, getBaseFile(file))}\`...`,
        skip: () => !existsAnyExtensionSync(file) && `File doesn't exist`,
        task: () => deleteFile(file)
      };
    }),
    {
      title: "Cleaning up empty directories...",
      task: () => cleanupEmptyDirsTask(files)
    }
  ]);
};
const cleanupEmptyDirsTask = (files) => {
  const { base } = getPaths();
  const endDirs = Object.keys(files).map((file) => import_path.default.dirname(file));
  const uniqueEndDirs = [...new Set(endDirs)];
  const pathDirs = [];
  uniqueEndDirs.forEach((dir) => {
    const relDir = import_path.default.relative(base, dir);
    const splitDir = relDir.split(import_path.default.sep);
    splitDir.pop();
    while (splitDir.length > 3) {
      const subDir = import_path.default.join(base, splitDir.join("/"));
      pathDirs.push(subDir);
      splitDir.pop();
    }
  });
  const uniqueDirs = uniqueEndDirs.concat([...new Set(pathDirs)]);
  return new import_listr2.Listr(
    uniqueDirs.map((dir) => {
      return {
        title: `Removing empty \`./${import_path.default.relative(base, dir)}\`...`,
        task: () => import_fs_extra.default.rmdirSync(dir),
        skip: () => {
          if (!import_fs_extra.default.existsSync(dir)) {
            return `Doesn't exist`;
          }
          if (import_fs_extra.default.readdirSync(dir).length > 0) {
            return "Not empty";
          }
          return false;
        }
      };
    })
  );
};
const wrapWithSet = (routesContent, layout, routes, newLineAndIndent, props = {}) => {
  const [_, indentOne, indentTwo] = routesContent.match(
    /([ \t]*)<Router.*?>[^<]*[\r\n]+([ \t]+)/
  ) || ["", 0, 2];
  const oneLevelIndent = indentTwo.slice(0, indentTwo.length - indentOne.length);
  const newRoutesWithExtraIndent = routes.map((route) => oneLevelIndent + route);
  const propsString = Object.entries(props).map((values) => `${values[0]}="${values[1]}"`).join(" ");
  return [
    `<Set wrap={${layout}}${propsString && " " + propsString}>`,
    ...newRoutesWithExtraIndent,
    `</Set>`
  ].join(newLineAndIndent);
};
const addRoutesToRouterTask = (routes, layout, setProps = {}) => {
  const redwoodPaths = getPaths();
  const routesContent = readFile(redwoodPaths.web.routes).toString();
  let newRoutes = routes.filter((route) => !routesContent.match(route));
  if (newRoutes.length) {
    const [routerStart, routerParams, newLineAndIndent] = routesContent.match(
      /\s*<Router(.*?)>(\s*)/s
    );
    if (/trailingSlashes={?(["'])always\1}?/.test(routerParams)) {
      newRoutes = newRoutes.map((route) => {
        if (route.length > 2e3) {
          throw new Error(`Route is too long to process:
${route}`);
        }
        return route.replace(/ path="(.+?)" /, ' path="$1/" ');
      });
    }
    const routesBatch = layout ? wrapWithSet(
      routesContent,
      layout,
      newRoutes,
      newLineAndIndent,
      setProps
    ) : newRoutes.join(newLineAndIndent);
    const newRoutesContent = routesContent.replace(
      routerStart,
      `${routerStart + routesBatch + newLineAndIndent}`
    );
    writeFile(redwoodPaths.web.routes, newRoutesContent, {
      overwriteExisting: true
    });
  }
};
const addScaffoldImport = () => {
  const appJsPath = getPaths().web.app;
  let appJsContents = readFile(appJsPath).toString();
  if (appJsContents.match("./scaffold.css")) {
    return "Skipping scaffold style include";
  }
  appJsContents = appJsContents.replace(
    /import ['"]\.\/index\.css['"]/,
    "import './index.css'\nimport './scaffold.css'\n"
  );
  writeFile(appJsPath, appJsContents, { overwriteExisting: true });
  return "Added scaffold import to App.{jsx,tsx}";
};
const removeEmtpySet = (routesContent, layout) => {
  const setWithLayoutReg = new RegExp(
    `\\s*<Set[^>]*wrap={${layout}}[^<]*>([^<]*)</Set>`
  );
  const [matchedSet, childContent] = routesContent.match(setWithLayoutReg) || [];
  if (!matchedSet) {
    return routesContent;
  }
  const child = childContent.replace(/\s/g, "");
  if (child.length > 0) {
    return routesContent;
  }
  return routesContent.replace(setWithLayoutReg, "");
};
const removeRoutesFromRouterTask = (routes, layout) => {
  const redwoodPaths = getPaths();
  const routesContent = readFile(redwoodPaths.web.routes).toString();
  const newRoutesContent = routes.reduce((content, route) => {
    const matchRouteByName = new RegExp(`\\s*<Route[^>]*name="${route}"[^>]*/>`);
    return content.replace(matchRouteByName, "");
  }, routesContent);
  const routesWithoutEmptySet = layout ? removeEmtpySet(newRoutesContent, layout) : newRoutesContent;
  writeFile(redwoodPaths.web.routes, routesWithoutEmptySet, {
    overwriteExisting: true
  });
};
const addPackagesTask = ({
  packages,
  side = "project",
  devDependency = false
}) => {
  const packagesWithSameRWVersion = packages.map((pkg) => {
    if (pkg.includes("@redwoodjs")) {
      return `${pkg}@${getInstalledRedwoodVersion()}`;
    } else {
      return pkg;
    }
  });
  let installCommand;
  if (side !== "project") {
    installCommand = [
      "yarn",
      [
        "workspace",
        side,
        "add",
        devDependency && "--dev",
        ...packagesWithSameRWVersion
      ].filter(Boolean)
    ];
  } else {
    const stdout = (0, import_child_process.execSync)("yarn --version");
    const yarnVersion = stdout.toString().trim();
    installCommand = [
      "yarn",
      [
        yarnVersion.startsWith("1") && "-W",
        "add",
        devDependency && "--dev",
        ...packagesWithSameRWVersion
      ].filter(Boolean)
    ];
  }
  return {
    title: `Adding dependencies to ${side}`,
    task: async () => {
      await (0, import_execa.default)(...installCommand);
    }
  };
};
const runCommandTask = async (commands, { verbose }) => {
  const tasks = new import_listr2.Listr(
    commands.map(({ title, cmd, args, opts = {}, cwd = getPaths().base }) => ({
      title,
      task: async () => {
        return (0, import_execa.default)(cmd, args, {
          shell: true,
          cwd,
          stdio: verbose ? "inherit" : "pipe",
          extendEnv: true,
          cleanup: true,
          ...opts
        });
      }
    })),
    {
      renderer: verbose && "verbose",
      rendererOptions: { collapseSubtasks: false, dateFormat: false }
    }
  );
  try {
    await tasks.run();
    return true;
  } catch (e) {
    console.log(import_colors.default.error(e.message));
    return false;
  }
};
const getDefaultArgs = (builder) => {
  return Object.entries(builder).reduce(
    (options, [optionName, optionConfig]) => {
      options[optionName] = optionConfig.default;
      return options;
    },
    {}
  );
};
const usingVSCode = () => {
  const redwoodPaths = getPaths();
  const VS_CODE_PATH = import_path.default.join(redwoodPaths.base, ".vscode");
  return import_fs_extra.default.existsSync(VS_CODE_PATH);
};
const printSetupNotes = (notes) => {
  return {
    title: "One more thing...",
    task: (_ctx, task) => {
      task.title = `One more thing...

 ${(0, import_boxen.default)(notes.join("\n"), {
        padding: { top: 1, bottom: 1, right: 1, left: 1 },
        margin: 1,
        borderColour: "gray"
      })}  
`;
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  _getPaths,
  addPackagesTask,
  addRoutesToRouterTask,
  addScaffoldImport,
  bytes,
  cleanupEmptyDirsTask,
  deleteFile,
  deleteFilesTask,
  existsAnyExtensionSync,
  findUp,
  generateTemplate,
  getConfig,
  getDefaultArgs,
  getGraphqlPath,
  getInstalledRedwoodVersion,
  getPaths,
  getPrettierOptions,
  graphFunctionDoesExist,
  nameVariants,
  prettify,
  printSetupNotes,
  readFile,
  removeRoutesFromRouterTask,
  resolveFile,
  runCommandTask,
  saveRemoteFileToDisk,
  transformTSToJS,
  usingVSCode,
  writeFile,
  writeFilesTask
});
