"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var plugin_exports = {};
__export(plugin_exports, {
  PLUGIN_CACHE_BUILTIN: () => PLUGIN_CACHE_BUILTIN,
  PLUGIN_CACHE_DEFAULT: () => PLUGIN_CACHE_DEFAULT,
  PLUGIN_CACHE_FILENAME: () => PLUGIN_CACHE_FILENAME,
  checkPluginListAndWarn: () => checkPluginListAndWarn,
  loadCommandCache: () => loadCommandCache,
  loadPluginPackage: () => loadPluginPackage,
  saveCommandCache: () => saveCommandCache
});
module.exports = __toCommonJS(plugin_exports);
var import_path = __toESM(require("path"));
var import_chalk = __toESM(require("chalk"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_packages = require("./packages");
var import_index = require("./index");
const { Select } = require("enquirer");
const PLUGIN_CACHE_FILENAME = "commandCache.json";
const PLUGIN_CACHE_DEFAULT = {
  "@redwoodjs/cli-storybook-vite": {
    storybook: {
      aliases: ["sb"],
      description: "Launch Storybook: a tool for building UI components and pages in isolation"
    }
  },
  "@redwoodjs/cli-data-migrate": {
    "data-migrate <command>": {
      aliases: ["dataMigrate", "dm"],
      description: "Migrate the data in your database"
    }
  }
};
const PLUGIN_CACHE_BUILTIN = [
  "build",
  "check",
  "diagnostics",
  "console",
  "c",
  "deploy",
  "destroy",
  "d",
  "dev",
  "exec",
  "experimental",
  "exp",
  "generate",
  "g",
  "info",
  "lint",
  "prerender",
  "render",
  "prisma",
  "record",
  "serve",
  "setup",
  "test",
  "ts-to-js",
  "type-check",
  "tsc",
  "tc",
  "upgrade"
];
function loadCommandCache() {
  let pluginCommandCache = PLUGIN_CACHE_DEFAULT;
  const commandCachePath = import_path.default.join(
    (0, import_index.getPaths)().generated.base,
    PLUGIN_CACHE_FILENAME
  );
  try {
    const localCommandCache = JSON.parse(import_fs_extra.default.readFileSync(commandCachePath));
    let valid = true;
    for (const [key, value] of Object.entries(localCommandCache)) {
      if (key === "_builtin") {
        continue;
      }
      valid &&= !Array.isArray(value);
    }
    if (valid) {
      pluginCommandCache = {
        ...localCommandCache,
        ...PLUGIN_CACHE_DEFAULT
      };
    }
  } catch (error) {
    if (error.code !== "ENOENT") {
      console.error(`Error loading plugin command cache at ${commandCachePath}`);
      console.error(error);
    }
  }
  pluginCommandCache._builtin = PLUGIN_CACHE_BUILTIN;
  return pluginCommandCache;
}
function saveCommandCache(pluginCommandCache) {
  const commandCachePath = import_path.default.join(
    (0, import_index.getPaths)().generated.base,
    PLUGIN_CACHE_FILENAME
  );
  try {
    import_fs_extra.default.writeFileSync(
      commandCachePath,
      JSON.stringify(pluginCommandCache, void 0, 2)
    );
  } catch (error) {
    console.error(`Error saving plugin command cache at ${commandCachePath}`);
    console.error(error);
  }
}
function checkPluginListAndWarn(plugins) {
  for (const plugin of plugins) {
    if (!plugin.package) {
      console.warn(
        import_chalk.default.yellow(`\u26A0\uFE0F  A plugin is missing a package, it cannot be loaded.`)
      );
    }
  }
  const pluginPackages = plugins.map((p) => p.package).filter((p) => p !== void 0);
  if (pluginPackages.length !== new Set(pluginPackages).size) {
    console.warn(
      import_chalk.default.yellow(
        "\u26A0\uFE0F  Duplicate plugin packages found in redwood.toml, duplicates will be ignored."
      )
    );
  }
  const namespaces = plugins.map((p) => p.package?.split("/")[0]);
  namespaces.forEach((ns) => {
    if (ns !== void 0 && !ns.startsWith("@")) {
      console.warn(
        import_chalk.default.yellow(
          `\u26A0\uFE0F  Plugin "${ns}" is missing a scope/namespace, it will not be loaded.`
        )
      );
    }
  });
}
async function loadPluginPackage(packageName, packageVersion, autoInstall) {
  if ((0, import_packages.isModuleInstalled)(packageName)) {
    return await import(packageName);
  }
  if (!autoInstall) {
    console.warn(
      import_chalk.default.yellow(
        `\u26A0\uFE0F  Plugin "${packageName}" cannot be loaded because it is not installed and "autoInstall" is disabled.`
      )
    );
    return null;
  }
  console.log(import_chalk.default.green(`Installing plugin "${packageName}"...`));
  const installed = await installPluginPackage(packageName, packageVersion);
  if (installed) {
    return await import(packageName);
  }
  return null;
}
async function installPluginPackage(packageName, packageVersion) {
  let versionToInstall = packageVersion;
  const isRedwoodPackage = packageName.startsWith("@redwoodjs/");
  if (!isRedwoodPackage && versionToInstall === void 0) {
    versionToInstall = "latest";
    try {
      const compatibilityData = await (0, import_cli_helpers.getCompatibilityData)(
        packageName,
        versionToInstall
      );
      versionToInstall = compatibilityData.compatible.version;
      console.log(
        import_chalk.default.green(
          `Installing the latest compatible version: ${versionToInstall}`
        )
      );
    } catch (error) {
      console.log(
        "The following error occurred while checking plugin compatibility for automatic installation:"
      );
      const errorMessage = error.message ?? error;
      console.log(errorMessage);
      if (errorMessage.includes("does not have a tag") || errorMessage.includes("does not have a version")) {
        process.exit(1);
      }
      const prompt = new Select({
        name: "versionDecision",
        message: "What would you like to do?",
        choices: [
          {
            name: "cancel",
            message: "Cancel"
          },
          {
            name: "continue",
            message: "Continue and install the 'latest' version"
          }
        ]
      });
      const decision = await prompt.run();
      if (decision === "cancel") {
        process.exit(1);
      }
    }
  }
  try {
    await (0, import_packages.installModule)(packageName, versionToInstall);
    return true;
  } catch (error) {
    console.error(error);
    return false;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PLUGIN_CACHE_BUILTIN,
  PLUGIN_CACHE_DEFAULT,
  PLUGIN_CACHE_FILENAME,
  checkPluginListAndWarn,
  loadCommandCache,
  loadPluginPackage,
  saveCommandCache
});
