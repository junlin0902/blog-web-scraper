"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var strategy_exports = {};
__export(strategy_exports, {
  concat: () => concat,
  concatUnique: () => concatUnique,
  interleave: () => interleave,
  isOpaque: () => isOpaque,
  keepBase: () => keepBase,
  keepBoth: () => keepBoth,
  keepBothStatementParents: () => keepBothStatementParents,
  keepExtension: () => keepExtension,
  opaquely: () => opaquely
});
module.exports = __toCommonJS(strategy_exports);
var t = __toESM(require("@babel/types"));
var import_lodash = __toESM(require("lodash"));
var import_algorithms = require("./algorithms");
const OPAQUE_UID_TAG = "RW_MERGE_OPAQUE_UID_Q2xldmVyIHlvdSEgSGF2ZSBhIGNvb2tpZS4=";
function requireSameType(base, ext) {
  if (base.path.type !== ext.path.type) {
    throw new Error(
      "Attempting to merge nodes with different types. This is not yet supported."
    );
  }
}
function requireStrategyExists(base, _ext, strategy, strategyName) {
  if (!(base.path.type in strategy)) {
    throw new Error(
      `Attempting to ${strategyName} nodes that do not have an ${strategyName} strategy.`
    );
  }
}
const strictEquality = (lhs, rhs) => lhs === rhs;
const byName = (lhs, rhs) => lhs.name === rhs.name;
const byKeyName = (lhs, rhs) => lhs.key.name === rhs.key.name;
const byValue = (lhs, rhs) => lhs.value === rhs.value;
function defaultEquality(baseContainer, extContainer) {
  const sample = baseContainer.length && baseContainer[0] || extContainer.length && extContainer[0];
  const defaults = {
    BigIntLiteral: byValue,
    BooleanLiteral: byValue,
    Identifier: byName,
    NumericLiteral: byValue,
    ObjectProperty: byKeyName,
    StringLiteral: byValue
  };
  return sample && sample.type in defaults ? defaults[sample.type] : strictEquality;
}
function opaquely(strategy) {
  strategy[OPAQUE_UID_TAG] = true;
  return strategy;
}
function isOpaque(strategy) {
  return strategy[OPAQUE_UID_TAG] === true;
}
const keepBase = opaquely(() => {
});
const keepBoth = opaquely((base, ext) => {
  base.path.insertAfter(ext.path.node);
});
const keepExtension = opaquely((base, ext) => {
  base.path.replaceWith(ext.path);
});
const keepBothStatementParents = opaquely((base, ext) => {
  base.path.getStatementParent().insertAfter(ext.path.getStatementParent().node);
});
const interleaveStrategy = {
  ImportDeclaration(baseImport, extImport) {
    const baseSpecs = baseImport.specifiers;
    const extSpecs = extImport.specifiers;
    const importSpecifierEquality = (lhs, rhs) => lhs.type === rhs.type && lhs.imported?.name === rhs.imported?.name && lhs.local?.name == rhs.local?.name;
    const uniqueSpecifiersOfType = (type) => import_lodash.default.uniqWith(
      [...baseSpecs, ...extSpecs].filter((0, import_algorithms.nodeIs)(type)),
      importSpecifierEquality
    );
    if (!baseSpecs.length !== !extSpecs.length) {
      return keepBothStatementParents(baseImport, extImport);
    }
    const defaultPosition = (specs) => specs.some((0, import_algorithms.nodeIs)("ImportDefaultSpecifier")) ? -1 : 0;
    const namespacePosition = (specs) => specs.some((0, import_algorithms.nodeIs)("ImportNamespaceSpecifier")) || specs.some((0, import_algorithms.nodeIs)("ImportSpecifier")) ? -1 : specs.length;
    const importPosition = (specs) => specs.some((0, import_algorithms.nodeIs)("ImportNamespaceIdentifier")) ? -1 : specs.length;
    const [firstSpecifierList, ...rest] = (0, import_algorithms.sieve)(
      [uniqueSpecifiersOfType("ImportDefaultSpecifier"), defaultPosition],
      [uniqueSpecifiersOfType("ImportNamespaceSpecifier"), namespacePosition],
      [uniqueSpecifiersOfType("ImportSpecifier"), importPosition]
    );
    baseImport.specifiers = firstSpecifierList;
    if (rest.length) {
      baseImport.path.insertAfter(
        rest.map((specs) => t.importDeclaration(specs, baseImport.source))
      );
    }
  }
};
function interleave(base, ext) {
  requireSameType(base, ext);
  requireStrategyExists(base, ext, interleaveStrategy, "interleave");
  return interleaveStrategy[base.path.type](base, ext);
}
const concatStrategy = {
  ArrayExpression(base, ext) {
    base.elements = [...base.elements, ...ext.elements];
  },
  ObjectExpression(base, ext) {
    base.properties = [...base.properties, ...ext.properties];
  },
  StringLiteral(base, ext) {
    base.value = base.value.concat(ext.value);
  }
};
function concat(base, ext) {
  requireSameType(base, ext);
  requireStrategyExists(base, ext, concatStrategy, "concat");
  return concatStrategy[base.path.type](base, ext);
}
const concatUniqueStrategy = {
  ArrayExpression(base, ext, eq) {
    eq ||= defaultEquality(base.elements, ext.elements);
    base.elements = import_lodash.default.uniqWith([...base.elements, ...ext.elements], eq);
  },
  ObjectExpression(base, ext, eq) {
    eq ||= defaultEquality(base.properties, ext.properties);
    base.properties = import_lodash.default.uniqWith([...base.properties, ...ext.properties], eq);
  }
};
function concatUnique(baseOrEq, ext) {
  if (arguments.length === 1) {
    return (base, ext2) => {
      requireSameType(base, ext2);
      requireStrategyExists(base, ext2, concatUniqueStrategy, "concatUnique");
      return concatUniqueStrategy[base.path.type](base, ext2, baseOrEq);
    };
  }
  if (arguments.length === 2) {
    requireSameType(baseOrEq, ext);
    requireStrategyExists(baseOrEq, ext, concatUniqueStrategy, "concatUnique");
    return concatUniqueStrategy[baseOrEq.path.type](baseOrEq, ext);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  concat,
  concatUnique,
  interleave,
  isOpaque,
  keepBase,
  keepBoth,
  keepBothStatementParents,
  keepExtension,
  opaquely
});
