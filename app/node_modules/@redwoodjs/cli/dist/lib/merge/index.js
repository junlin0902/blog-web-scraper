"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var merge_exports = {};
__export(merge_exports, {
  merge: () => merge
});
module.exports = __toCommonJS(merge_exports);
var import_core = require("@babel/core");
var import_generator = __toESM(require("@babel/generator"));
var import_types = require("@babel/types");
var import_lodash = require("lodash");
var import_prettier = __toESM(require("prettier"));
var import_algorithms = require("./algorithms");
var import_semanticIdentity = require("./semanticIdentity");
var import_strategy = require("./strategy");
function extractProperty(property, fromObject) {
  if (property === void 0) {
    return void 0;
  }
  const tmp = fromObject[property];
  delete fromObject[property];
  return tmp;
}
function getProgramPath(ast) {
  let programPath;
  (0, import_core.traverse)(ast, {
    Program(path) {
      programPath = path;
      return;
    }
  });
  if (programPath === void 0) {
    throw new Error("Unable to find Program node in AST");
  }
  return programPath;
}
function skipChildren(path) {
  for (const key of import_types.VISITOR_KEYS[path.type]) {
    path.skipKey(key);
  }
}
function makeProxy(path) {
  return new Proxy(path, {
    get(target, property) {
      if (property === "path") {
        return target;
      } else {
        return target.node[property];
      }
    },
    set(target, property, value) {
      if (property === "path") {
        throw new Error("You can't set a path on a proxy!");
      } else {
        target.node[property] = value;
        return true;
      }
    },
    has(target, property) {
      return property in target.node;
    }
  });
}
function expressionUses(exp, ...ids) {
  let result = false;
  exp.traverse({
    Identifier(path) {
      if (!path.parentPath.isNodeType("VariableDeclarator") && ids.includes(path.node.name)) {
        result = true;
        return;
      }
    }
  });
  return result;
}
function insertBeforeFirstUsage(expression, program) {
  const body = program.get("body");
  const pos = body.findIndex(
    (exp) => expressionUses(exp, ...Object.keys(expression.getBindingIdentifiers()))
  );
  return pos !== -1 ? body[pos].insertBefore(expression.node) : program.pushContainer("body", expression.node);
}
function insertAfterLastImport(expression, program) {
  const body = program.get("body");
  return body[body.findLastIndex((bodyExpr) => bodyExpr.isNodeType("ImportDeclaration"))].insertAfter(expression.node);
}
function prune(path) {
  switch (path.parentPath.type) {
    // If pruning 'path' would yield an ill-formed parent (e.g, '{foo:}' or 'const x;'), prune it.
    case "ObjectProperty":
    case "VariableDeclarator":
      return path.parentPath.remove();
    default:
      console.log(`Warning: default prune strategy for ${path.parentPath.type}`);
    // eslint-disable-next-line no-fallthrough
    case "Program":
    case "ArrayExpression":
      return path.remove();
  }
}
function stripTrailingCommentsStrategy() {
  return {
    enter(path) {
      path.node.trailingComments = [];
    }
  };
}
function mergeAST(baseAST, extAST, strategy = {}) {
  const identity = extractProperty("identity", strategy) ?? import_semanticIdentity.semanticIdentity;
  const identities = {};
  const baseVisitor = { ...stripTrailingCommentsStrategy() };
  const extVisitor = { ...stripTrailingCommentsStrategy() };
  (0, import_algorithms.forEachFunctionOn)(strategy, (typename, strat) => {
    extVisitor[typename] = {
      enter(path) {
        const id = identity(path);
        id && (identities[id] ||= []).push(path);
      }
    };
    baseVisitor[typename] = {
      enter(path) {
        if ((0, import_strategy.isOpaque)(strat)) {
          skipChildren(path);
        }
      },
      exit(path) {
        const exts = extractProperty(identity(path), identities);
        if (exts) {
          const proxyPath = makeProxy(path);
          exts.map(makeProxy).forEach((ext) => {
            strat(proxyPath, ext);
            prune(ext.path);
          });
        }
      }
    };
  });
  (0, import_core.traverse)(extAST, extVisitor);
  (0, import_core.traverse)(baseAST, baseVisitor);
  const baseProgram = getProgramPath(baseAST);
  const [imports, others] = (0, import_lodash.partition)(
    getProgramPath(extAST).get("body"),
    (0, import_algorithms.nodeIs)("ImportDeclaration")
  );
  imports.forEach((exp) => insertAfterLastImport(exp, baseProgram));
  (0, import_lodash.forEachRight)(others, (exp) => insertBeforeFirstUsage(exp, baseProgram));
}
async function merge(base, extension, strategy) {
  function parseReact(code2) {
    return (0, import_core.parse)(code2, {
      filename: "merged.tsx",
      // required to prevent babel error. The .tsx is relevant
      presets: ["@babel/preset-typescript"]
    });
  }
  const baseAST = parseReact(base);
  const extAST = parseReact(extension);
  mergeAST(baseAST, extAST, strategy);
  const { code } = (0, import_generator.default)(baseAST);
  return process.env.VITEST_POOL_ID ? await import_prettier.default.format(code, {
    parser: "babel-ts",
    bracketSpacing: true,
    tabWidth: 2,
    semi: false,
    singleQuote: true
  }) : code;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  merge
});
