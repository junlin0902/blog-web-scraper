"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var schemaHelpers_exports = {};
__export(schemaHelpers_exports, {
  getDataModel: () => getDataModel,
  getEnum: () => getEnum,
  getSchema: () => getSchema,
  getSchemaConfig: () => getSchemaConfig,
  getSchemaDefinitions: () => getSchemaDefinitions,
  verifyModelName: () => verifyModelName
});
module.exports = __toCommonJS(schemaHelpers_exports);
var import_internals = require("@prisma/internals");
var import_pluralHelpers = require("./pluralHelpers");
var import_rwPluralize = require("./rwPluralize");
var import__ = require("./");
const schemaMemo = {};
const getExistingModelName = async (name) => {
  if (!name) {
    return void 0;
  }
  const modelName = name.replace(/[_-]/g, "").toLowerCase();
  for (let model of Object.values(schemaMemo)) {
    if (model.name.toLowerCase() === modelName) {
      return model.name;
    }
  }
  const schema = await getSchemaDefinitions();
  for (let model of schema.datamodel.models) {
    if (model.name.toLowerCase() === modelName) {
      return model.name;
    }
  }
  return void 0;
};
const getSchema = async (name) => {
  if (name) {
    const modelName = await getExistingModelName(name);
    if (!modelName) {
      throw new Error(
        `No schema definition found for \`${name}\` in schema.prisma file`
      );
    }
    if (!schemaMemo[modelName]) {
      const schema = await getSchemaDefinitions();
      const model = schema.datamodel.models.find((model2) => {
        return model2.name === modelName;
      });
      if (model) {
        model.fields.forEach((field) => {
          const fieldEnum = schema.datamodel.enums.find((e) => {
            return field.type === e.name;
          });
          if (fieldEnum) {
            field.enumValues = fieldEnum.values;
          }
        });
        schemaMemo[modelName] = model;
      }
    }
    return schemaMemo[modelName];
  } else {
    return (await getSchemaDefinitions()).datamodel;
  }
};
const getEnum = async (name) => {
  const schema = await getSchemaDefinitions();
  if (name) {
    const model = schema.datamodel.enums.find((model2) => {
      return model2.name === name;
    });
    if (model) {
      return model;
    } else {
      throw new Error(
        `No enum schema definition found for \`${name}\` in schema.prisma file`
      );
    }
  }
  return schema.metadata.datamodel.enums;
};
const getDataModel = (path = (0, import__.getPaths)().api.dbSchema) => {
  return (0, import_internals.getSchema)(path);
};
const getSchemaDefinitions = () => {
  return (0, import_internals.getDMMF)({ datamodel: getDataModel() });
};
const getSchemaConfig = () => {
  return (0, import_internals.getConfig)({
    datamodel: getDataModel()
  });
};
async function verifyModelName(options) {
  const modelName = await getExistingModelName(options.name) || await getExistingModelName((0, import_rwPluralize.singularize)(options.name));
  if (modelName === void 0) {
    throw new Error(
      `"${options.name}" model not found, check if it exists in "./api/db/schema.prisma"`
    );
  }
  await (0, import_pluralHelpers.ensureUniquePlural)({
    model: modelName,
    isDestroyer: options.isDestroyer,
    forcePrompt: (0, import_rwPluralize.isPlural)(modelName)
  });
  return { ...options, name: modelName };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getDataModel,
  getEnum,
  getSchema,
  getSchemaConfig,
  getSchemaDefinitions,
  verifyModelName
});
