"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var devHandler_exports = {};
__export(devHandler_exports, {
  getDevNodeOptions: () => getDevNodeOptions,
  handler: () => handler
});
module.exports = __toCommonJS(devHandler_exports);
var import_process = require("process");
var import_concurrently = __toESM(require("concurrently"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_dev = require("@redwoodjs/internal/dist/dev");
var import_project_config = require("@redwoodjs/project-config");
var import_telemetry = require("@redwoodjs/telemetry");
var import_lib = require("../lib");
var import_colors = __toESM(require("../lib/colors"));
var import_exit = require("../lib/exit");
var import_generatePrismaClient = require("../lib/generatePrismaClient");
var import_ports = require("../lib/ports");
var import_project = require("../lib/project");
const defaultApiDebugPort = 18911;
const handler = async ({
  side = ["api", "web"],
  forward = "",
  generate = true,
  apiDebugPort
}) => {
  (0, import_cli_helpers.recordTelemetryAttributes)({
    command: "dev",
    side: JSON.stringify(side),
    generate
  });
  const rwjsPaths = (0, import_lib.getPaths)();
  const serverFile = (0, import_project.serverFileExists)();
  let apiPreferredPort = parseInt((0, import_project_config.getConfig)().api.port);
  let webPreferredPort = parseInt((0, import_project_config.getConfig)().web.port);
  let apiAvailablePort = apiPreferredPort;
  let apiPortChangeNeeded = false;
  let webAvailablePort = webPreferredPort;
  let webPortChangeNeeded = false;
  if (side.includes("api") && !serverFile) {
    apiAvailablePort = await (0, import_ports.getFreePort)(apiPreferredPort);
    if (apiAvailablePort === -1) {
      (0, import_exit.exitWithError)(void 0, {
        message: `Could not determine a free port for the api server`
      });
    }
    apiPortChangeNeeded = apiAvailablePort !== apiPreferredPort;
  }
  if (side.includes("web")) {
    const forwardedPortMatches = [
      ...forward.matchAll(/\-\-port(\=|\s)(?<port>[^\s]*)/g)
    ];
    if (forwardedPortMatches.length) {
      webPreferredPort = parseInt(forwardedPortMatches.pop().groups.port);
    }
    webAvailablePort = await (0, import_ports.getFreePort)(webPreferredPort, [
      apiPreferredPort,
      apiAvailablePort
    ]);
    if (webAvailablePort === -1) {
      (0, import_exit.exitWithError)(void 0, {
        message: `Could not determine a free port for the web server`
      });
    }
    webPortChangeNeeded = webAvailablePort !== webPreferredPort;
  }
  if (apiPortChangeNeeded || webPortChangeNeeded) {
    const message = [
      "The currently configured ports for the development server are",
      "unavailable. Suggested changes to your ports, which can be changed in",
      "redwood.toml, are:\n",
      apiPortChangeNeeded && ` - API to use port ${apiAvailablePort} instead`,
      apiPortChangeNeeded && "of your currently configured",
      apiPortChangeNeeded && `${apiPreferredPort}
`,
      webPortChangeNeeded && ` - Web to use port ${webAvailablePort} instead`,
      webPortChangeNeeded && "of your currently configured",
      webPortChangeNeeded && `${webPreferredPort}
`,
      "\nCannot run the development server until your configured ports are",
      "changed or become available."
    ].filter(Boolean).join(" ");
    (0, import_exit.exitWithError)(void 0, { message });
  }
  if (side.includes("api")) {
    try {
      await (0, import_generatePrismaClient.generatePrismaClient)({
        verbose: false,
        force: false,
        schema: rwjsPaths.api.dbSchema
      });
    } catch (e) {
      (0, import_telemetry.errorTelemetry)(
        process.argv,
        `Error generating prisma client: ${e.message}`
      );
      console.error(import_colors.default.error(e.message));
    }
    if (!serverFile) {
      try {
        await (0, import_dev.shutdownPort)(apiAvailablePort);
      } catch (e) {
        (0, import_telemetry.errorTelemetry)(process.argv, `Error shutting down "api": ${e.message}`);
        console.error(
          `Error whilst shutting down "api" port: ${import_colors.default.error(e.message)}`
        );
      }
    }
  }
  if (side.includes("web")) {
    try {
      await (0, import_dev.shutdownPort)(webAvailablePort);
    } catch (e) {
      (0, import_telemetry.errorTelemetry)(process.argv, `Error shutting down "web": ${e.message}`);
      console.error(
        `Error whilst shutting down "web" port: ${import_colors.default.error(e.message)}`
      );
    }
  }
  const getApiDebugFlag = () => {
    if (apiDebugPort) {
      return `--debug-port ${apiDebugPort}`;
    } else if (import_process.argv.includes("--apiDebugPort")) {
      return `--debug-port ${defaultApiDebugPort}`;
    }
    const apiDebugPortInToml = (0, import_project_config.getConfig)().api.debugPort;
    if (apiDebugPortInToml) {
      return `--debug-port ${apiDebugPortInToml}`;
    }
    return "";
  };
  const redwoodConfigPath = (0, import_project_config.getConfigPath)();
  const streamingSsrEnabled = (0, import_project_config.getConfig)().experimental.streamingSsr?.enabled;
  process.env.VITE_CJS_IGNORE_WARNING = "true";
  let webCommand = `yarn cross-env NODE_ENV=development rw-vite-dev ${forward}`;
  if (streamingSsrEnabled) {
    webCommand = `yarn cross-env NODE_ENV=development rw-dev-fe ${forward}`;
  }
  const jobs = {
    api: {
      name: "api",
      command: [
        "yarn nodemon",
        "  --quiet",
        `  --watch "${redwoodConfigPath}"`,
        '  --exec "yarn rw-api-server-watch',
        `    --port ${apiAvailablePort}`,
        `    ${getApiDebugFlag()}`,
        '    | rw-log-formatter"'
      ].join(" "),
      env: {
        NODE_ENV: "development",
        NODE_OPTIONS: getDevNodeOptions()
      },
      prefixColor: "cyan",
      runWhen: () => import_fs_extra.default.existsSync(rwjsPaths.api.src)
    },
    web: {
      name: "web",
      command: webCommand,
      prefixColor: "blue",
      cwd: rwjsPaths.web.base,
      runWhen: () => import_fs_extra.default.existsSync(rwjsPaths.web.src)
    },
    gen: {
      name: "gen",
      command: "yarn rw-gen-watch",
      prefixColor: "green",
      runWhen: () => generate
    }
  };
  const { result } = (0, import_concurrently.default)(
    Object.keys(jobs).map((job) => {
      if (side.includes(job) || job === "gen") {
        return jobs[job];
      }
    }).filter((job) => job && job.runWhen()),
    {
      prefix: "{name} |",
      timestampFormat: "HH:mm:ss",
      handleInput: true
    }
  );
  result.catch((e) => {
    if (typeof e?.message !== "undefined") {
      (0, import_telemetry.errorTelemetry)(
        process.argv,
        `Error concurrently starting sides: ${e.message}`
      );
      (0, import_exit.exitWithError)(e);
    }
  });
};
function getDevNodeOptions() {
  const { NODE_OPTIONS } = process.env;
  const enableSourceMapsOption = "--enable-source-maps";
  if (!NODE_OPTIONS) {
    return enableSourceMapsOption;
  }
  if (NODE_OPTIONS.includes(enableSourceMapsOption)) {
    return NODE_OPTIONS;
  }
  return `${NODE_OPTIONS} ${enableSourceMapsOption}`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getDevNodeOptions,
  handler
});
