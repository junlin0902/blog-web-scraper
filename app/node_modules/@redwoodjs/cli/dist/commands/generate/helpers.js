"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var helpers_exports = {};
__export(helpers_exports, {
  createYargsForComponentGeneration: () => createYargsForComponentGeneration,
  customOrDefaultTemplatePath: () => customOrDefaultTemplatePath,
  forcePluralizeWord: () => forcePluralizeWord,
  intForeignKeysForModel: () => intForeignKeysForModel,
  mapPrismaScalarToPagePropTsType: () => mapPrismaScalarToPagePropTsType,
  mapRouteParamTypeToTsType: () => mapRouteParamTypeToTsType,
  pathName: () => pathName,
  relationsForModel: () => relationsForModel,
  removeGeneratorName: () => removeGeneratorName,
  templateForComponentFile: () => templateForComponentFile,
  validateName: () => validateName,
  yargsDefaults: () => yargsDefaults
});
module.exports = __toCommonJS(helpers_exports);
var import_path = __toESM(require("path"));
var import_change_case = require("change-case");
var import_fs_extra = __toESM(require("fs-extra"));
var import_listr2 = require("listr2");
var import_pascalcase = __toESM(require("pascalcase"));
var import_terminal_link = __toESM(require("terminal-link"));
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_project_config = require("@redwoodjs/project-config");
var import_telemetry = require("@redwoodjs/telemetry");
var import_lib = require("../../lib");
var import_colors = __toESM(require("../../lib/colors"));
var import_rollback = require("../../lib/rollback");
var import_rwPluralize = require("../../lib/rwPluralize");
const customOrDefaultTemplatePath = ({
  side,
  generator,
  templatePath
}) => {
  const defaultPath = import_path.default.join(__dirname, generator, "templates", templatePath);
  const customPath = import_path.default.join(
    (0, import_lib.getPaths)()[side].generators,
    generator,
    templatePath
  );
  if (import_fs_extra.default.existsSync(customPath)) {
    return customPath;
  } else {
    return defaultPath;
  }
};
const templateForComponentFile = async ({
  name,
  suffix = "",
  extension = ".js",
  webPathSection,
  apiPathSection,
  generator,
  templatePath,
  templateVars,
  componentName,
  outputPath
}) => {
  const basePath = webPathSection ? (0, import_lib.getPaths)().web[webPathSection] : (0, import_lib.getPaths)().api[apiPathSection];
  const outputComponentName = componentName || (0, import_pascalcase.default)(name) + suffix;
  const componentOutputPath = outputPath || import_path.default.join(basePath, outputComponentName, outputComponentName + extension);
  const fullTemplatePath = customOrDefaultTemplatePath({
    generator,
    templatePath,
    side: webPathSection ? "web" : "api"
  });
  const content = await (0, import_lib.generateTemplate)(fullTemplatePath, {
    name,
    outputPath: (0, import_project_config.ensurePosixPath)(
      `./${import_path.default.relative((0, import_lib.getPaths)().base, componentOutputPath)}`
    ),
    ...templateVars
  });
  return [componentOutputPath, content];
};
const pathName = (path2, name) => {
  let routePath = path2;
  if (path2 && path2.startsWith("{") && path2.endsWith("}")) {
    routePath = `/${(0, import_change_case.paramCase)(name)}/${path2}`;
  }
  if (!routePath) {
    routePath = `/${(0, import_change_case.paramCase)(name)}`;
  }
  return routePath;
};
const appendPositionalsToCmd = (commandString, positionalsObj) => {
  if (Object.keys(positionalsObj).length > 0) {
    const positionalNames = Object.keys(positionalsObj).map((positionalName) => `[${positionalName}]`).join(" ");
    return `${commandString} ${positionalNames}`;
  } else {
    return commandString;
  }
};
function removeGeneratorName(name, generatorName) {
  const pascalComponentName = (0, import_pascalcase.default)(generatorName);
  const coercedName = name.replace(new RegExp(pascalComponentName + "$"), "");
  return coercedName;
}
const yargsDefaults = {
  force: {
    alias: "f",
    default: false,
    description: "Overwrite existing files",
    type: "boolean"
  },
  typescript: {
    alias: "ts",
    default: (0, import_cli_helpers.isTypeScriptProject)(),
    description: "Generate TypeScript files",
    type: "boolean"
  }
};
const validateName = (name) => {
  if (name.match(/^\W/)) {
    throw new Error(
      "The <name> argument must start with a letter, number or underscore."
    );
  }
};
const createYargsForComponentGeneration = ({
  componentName,
  preTasksFn = (options) => options,
  /** filesFn is not used if generator implements its own `handler` */
  filesFn = () => ({}),
  optionsObj = yargsDefaults,
  positionalsObj = {},
  /** function that takes the options object and returns an array of listr tasks */
  includeAdditionalTasks = () => []
}) => {
  return {
    command: appendPositionalsToCmd(`${componentName} <name>`, positionalsObj),
    description: `Generate a ${componentName} component`,
    builder: (yargs) => {
      yargs.positional("name", {
        description: `Name of the ${componentName}`,
        type: "string"
      }).epilogue(
        `Also see the ${(0, import_terminal_link.default)(
          "Redwood CLI Reference",
          `https://redwoodjs.com/docs/cli-commands#generate-${componentName}`
        )}`
      ).option("tests", {
        description: "Generate test files",
        type: "boolean"
      }).option("stories", {
        description: "Generate storybook files",
        type: "boolean"
      }).option("verbose", {
        description: "Print all logs",
        type: "boolean",
        default: false
      }).option("rollback", {
        description: "Revert all generator actions if an error occurs",
        type: "boolean",
        default: true
      });
      Object.entries(positionalsObj).forEach(([option, config]) => {
        yargs.positional(option, config);
      });
      Object.entries(optionsObj).forEach(([option, config]) => {
        yargs.option(option, config);
      });
    },
    handler: async (options) => {
      (0, import_cli_helpers.recordTelemetryAttributes)({
        command: `generate ${componentName}`,
        tests: options.tests,
        stories: options.stories,
        verbose: options.verbose,
        rollback: options.rollback,
        force: options.force
        // TODO: This does not cover the specific options that each generator might pass in
      });
      if (options.tests === void 0) {
        options.tests = (0, import_project_config.getConfig)().generate.tests;
      }
      if (options.stories === void 0) {
        options.stories = (0, import_project_config.getConfig)().generate.stories;
      }
      validateName(options.name);
      try {
        options = await preTasksFn(options);
        const tasks = new import_listr2.Listr(
          [
            {
              title: `Generating ${componentName} files...`,
              task: async () => {
                const f = await filesFn(options);
                return (0, import_lib.writeFilesTask)(f, { overwriteExisting: options.force });
              }
            },
            ...includeAdditionalTasks(options)
          ],
          {
            rendererOptions: { collapseSubtasks: false },
            exitOnError: true,
            renderer: options.verbose && "verbose"
          }
        );
        if (options.rollback && !options.force) {
          (0, import_rollback.prepareForRollback)(tasks);
        }
        await tasks.run();
      } catch (e) {
        (0, import_telemetry.errorTelemetry)(process.argv, e.message);
        console.error(import_colors.default.error(e.message));
        process.exit(e?.exitCode || 1);
      }
    }
  };
};
const relationsForModel = (model) => {
  return model.fields.filter((f) => f.relationName).map((field) => {
    return field.name;
  });
};
const intForeignKeysForModel = (model) => {
  return model.fields.filter((f) => f.name.match(/Id$/) && f.type === "Int").map((f) => f.name);
};
const forcePluralizeWord = (word) => {
  if ((0, import_rwPluralize.isPlural)(word) && (0, import_rwPluralize.isSingular)(word)) {
    return (0, import_pascalcase.default)(`${word}_list`);
  }
  return (0, import_rwPluralize.pluralize)(word);
};
const mapRouteParamTypeToTsType = (paramType) => {
  const routeParamToTsType = {
    Int: "number",
    Float: "number",
    Boolean: "boolean",
    String: "string"
  };
  return routeParamToTsType[paramType] || "unknown";
};
const mapPrismaScalarToPagePropTsType = (scalarType) => {
  const prismaScalarToTsType = {
    String: "string",
    Boolean: "boolean",
    Int: "number",
    BigInt: "number",
    Float: "number",
    Decimal: "number",
    DateTime: "string",
    Bytes: "Buffer"
  };
  return prismaScalarToTsType[scalarType] || "unknown";
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createYargsForComponentGeneration,
  customOrDefaultTemplatePath,
  forcePluralizeWord,
  intForeignKeysForModel,
  mapPrismaScalarToPagePropTsType,
  mapRouteParamTypeToTsType,
  pathName,
  relationsForModel,
  removeGeneratorName,
  templateForComponentFile,
  validateName,
  yargsDefaults
});
