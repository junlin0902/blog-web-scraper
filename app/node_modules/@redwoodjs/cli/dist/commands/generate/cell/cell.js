"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var cell_exports = {};
__export(cell_exports, {
  builder: () => builder,
  command: () => command,
  description: () => description,
  files: () => files,
  handler: () => handler
});
module.exports = __toCommonJS(cell_exports);
var import_pascalcase = __toESM(require("pascalcase"));
var import_generate = require("@redwoodjs/internal/dist/generate/generate");
var import_lib = require("../../../lib");
var import_pluralHelpers = require("../../../lib/pluralHelpers");
var import_rollback = require("../../../lib/rollback");
var import_rwPluralize = require("../../../lib/rwPluralize");
var import_schemaHelpers = require("../../../lib/schemaHelpers");
var import_helpers = require("../helpers");
var import_helpers2 = require("../helpers");
var import_utils = require("./utils/utils");
const COMPONENT_SUFFIX = "Cell";
const REDWOOD_WEB_PATH_NAME = "components";
const files = async ({ name, typescript, ...options }) => {
  let cellName = (0, import_helpers2.removeGeneratorName)(name, "cell");
  let idName = "id";
  let idType, mockIdValues = [42, 43, 44], model = null;
  let templateNameSuffix = "";
  let typeName = cellName;
  const shouldGenerateList = ((0, import_pluralHelpers.isWordPluralizable)(cellName) ? (0, import_rwPluralize.isPlural)(cellName) : options.list) || options.list;
  try {
    model = await (0, import_schemaHelpers.getSchema)((0, import_pascalcase.default)((0, import_rwPluralize.singularize)(cellName)));
    idName = (0, import_utils.getIdName)(model);
    idType = (0, import_utils.getIdType)(model);
    typeName = model.name;
    mockIdValues = idType === "String" ? mockIdValues.map((value) => `'${value}'`) : mockIdValues;
  } catch {
    idType = "Int";
  }
  if (shouldGenerateList) {
    cellName = (0, import_helpers2.forcePluralizeWord)(cellName);
    templateNameSuffix = "List";
  }
  let operationName = options.query;
  if (operationName) {
    const userSpecifiedOperationNameIsUnique = await (0, import_utils.operationNameIsUnique)(operationName);
    if (!userSpecifiedOperationNameIsUnique) {
      throw new Error(`Specified query name: "${operationName}" is not unique!`);
    }
  } else {
    operationName = await (0, import_utils.uniqueOperationName)(cellName, {
      list: shouldGenerateList
    });
  }
  const extension = typescript ? ".tsx" : ".jsx";
  const cellFile = await (0, import_helpers2.templateForComponentFile)({
    name: cellName,
    suffix: COMPONENT_SUFFIX,
    extension,
    webPathSection: REDWOOD_WEB_PATH_NAME,
    generator: "cell",
    templatePath: `cell${templateNameSuffix}.tsx.template`,
    templateVars: {
      operationName,
      idName,
      idType
    }
  });
  const testFile = await (0, import_helpers2.templateForComponentFile)({
    name: cellName,
    suffix: COMPONENT_SUFFIX,
    extension: `.test${extension}`,
    webPathSection: REDWOOD_WEB_PATH_NAME,
    generator: "cell",
    templatePath: "test.js.template"
  });
  const storiesFile = await (0, import_helpers2.templateForComponentFile)({
    name: cellName,
    suffix: COMPONENT_SUFFIX,
    extension: `.stories${extension}`,
    webPathSection: REDWOOD_WEB_PATH_NAME,
    generator: "cell",
    templatePath: "stories.tsx.template"
  });
  const mockFile = await (0, import_helpers2.templateForComponentFile)({
    name: cellName,
    suffix: COMPONENT_SUFFIX,
    extension: typescript ? ".mock.ts" : ".mock.js",
    webPathSection: REDWOOD_WEB_PATH_NAME,
    generator: "cell",
    templatePath: `mock${templateNameSuffix}.ts.template`,
    templateVars: {
      idName,
      mockIdValues,
      typeName
    }
  });
  const files2 = [cellFile];
  if (options.stories) {
    files2.push(storiesFile);
  }
  if (options.tests) {
    files2.push(testFile);
  }
  if (options.stories || options.tests) {
    files2.push(mockFile);
  }
  return files2.reduce(async (accP, [outputPath, content]) => {
    const acc = await accP;
    const template = typescript ? content : await (0, import_lib.transformTSToJS)(outputPath, content);
    return {
      [outputPath]: template,
      ...acc
    };
  }, Promise.resolve({}));
};
const { command, description, builder, handler } = (0, import_helpers2.createYargsForComponentGeneration)({
  componentName: "cell",
  filesFn: files,
  optionsObj: {
    ...import_helpers.yargsDefaults,
    list: {
      alias: "l",
      default: false,
      description: "Use when you want to generate a cell for a list of the model name.",
      type: "boolean"
    },
    query: {
      default: "",
      description: "Use to enforce a specific query name within the generated cell - must be unique.",
      type: "string"
    }
  },
  includeAdditionalTasks: ({ name: cellName }) => {
    return [
      {
        title: `Generating types ...`,
        task: async (_ctx, task) => {
          const queryFieldName = (0, import_lib.nameVariants)(
            (0, import_helpers2.removeGeneratorName)(cellName, "cell")
          ).camelName;
          const projectHasSdl = await (0, import_utils.checkProjectForQueryField)(queryFieldName);
          if (projectHasSdl) {
            const { errors } = await (0, import_generate.generate)();
            for (const { message, error } of errors) {
              console.error(message);
              console.log();
              console.error(error);
              console.log();
            }
            (0, import_rollback.addFunctionToRollback)(import_generate.generate, true);
          } else {
            task.skip(
              `Skipping type generation: no SDL defined for "${queryFieldName}". To generate types, run 'yarn rw g sdl ${queryFieldName}'.`
            );
          }
        }
      }
    ];
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  builder,
  command,
  description,
  files,
  handler
});
