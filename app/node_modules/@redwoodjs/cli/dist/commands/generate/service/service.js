"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var service_exports = {};
__export(service_exports, {
  buildScenario: () => buildScenario,
  buildStringifiedScenario: () => buildStringifiedScenario,
  builder: () => builder,
  command: () => command,
  defaults: () => defaults,
  description: () => description,
  fieldTypes: () => fieldTypes,
  fieldsToInput: () => fieldsToInput,
  fieldsToScenario: () => fieldsToScenario,
  fieldsToUpdate: () => fieldsToUpdate,
  files: () => files,
  handler: () => handler,
  parseSchema: () => parseSchema,
  scenarioFieldValue: () => scenarioFieldValue
});
module.exports = __toCommonJS(service_exports);
var import_camelcase = __toESM(require("camelcase"));
var import_terminal_link = __toESM(require("terminal-link"));
var import_lib = require("../../../lib");
var import_rwPluralize = require("../../../lib/rwPluralize");
var import_schemaHelpers = require("../../../lib/schemaHelpers");
var import_helpers = require("../helpers");
var import_helpers2 = require("../helpers");
const DEFAULT_SCENARIO_NAMES = ["one", "two"];
const parseSchema = async (model) => {
  const schema = await (0, import_schemaHelpers.getSchema)(model);
  const relations = {};
  let foreignKeys = [];
  let scalarFields = schema.fields.filter((field) => {
    if (field.relationFromFields) {
      if (field.isRequired && field.relationFromFields.length !== 0) {
        relations[field.name] = {
          foreignKey: field.relationFromFields,
          type: field.type
        };
      }
      foreignKeys = foreignKeys.concat(field.relationFromFields);
    }
    return field.isRequired && !field.hasDefaultValue && // don't include fields that the database will default
    !field.relationName;
  });
  return { scalarFields, relations, foreignKeys };
};
const scenarioFieldValue = (field) => {
  const randFloat = Math.random() * 1e7;
  const randInt = parseInt(Math.random() * 1e7);
  const randIntArray = [
    parseInt(Math.random() * 300),
    parseInt(Math.random() * 300),
    parseInt(Math.random() * 300)
  ];
  switch (field.type) {
    case "BigInt":
      return `${BigInt(randInt)}n`;
    case "Boolean":
      return true;
    case "DateTime":
      return /* @__PURE__ */ new Date();
    case "Decimal":
    case "Float":
      return randFloat;
    case "Int":
      return randInt;
    case "Json":
      return { foo: "bar" };
    case "String":
      return field.isUnique ? `String${randInt}` : "String";
    case "Bytes":
      return `Buffer.from([${randIntArray}])`;
    default: {
      if (field.kind === "enum" && field.enumValues[0]) {
        return field.enumValues[0].dbName || field.enumValues[0].name;
      }
    }
  }
};
const fieldsToScenario = async (scalarFields, relations, foreignKeys) => {
  const data = {};
  scalarFields.forEach((field) => {
    if (!foreignKeys.length || !foreignKeys.includes(field.name)) {
      data[field.name] = scenarioFieldValue(field);
    }
  });
  for (const [relationName, relData] of Object.entries(relations)) {
    const relationModelName = relData.type;
    const {
      scalarFields: relScalarFields,
      relations: relRelations,
      foreignKeys: relForeignKeys
    } = await parseSchema(relationModelName);
    data[relationName] = {
      create: await fieldsToScenario(
        relScalarFields,
        relRelations,
        relForeignKeys
      )
    };
  }
  return data;
};
const buildScenario = async (model) => {
  const scenarioModelName = (0, import_camelcase.default)(model);
  const standardScenario = {
    [scenarioModelName]: {}
  };
  const { scalarFields, relations, foreignKeys } = await parseSchema(model);
  for (const name of DEFAULT_SCENARIO_NAMES) {
    standardScenario[scenarioModelName][name] = {};
    const scenarioData = await fieldsToScenario(
      scalarFields,
      relations,
      foreignKeys
    );
    Object.keys(scenarioData).forEach((key) => {
      const value = scenarioData[key];
      if (value && typeof value === "string" && value.match(/^\d+n$/)) {
        scenarioData[key] = `${value.slice(0, value.length - 1)}n`;
      }
    });
    standardScenario[scenarioModelName][name].data = scenarioData;
  }
  return standardScenario;
};
const buildStringifiedScenario = async (model) => {
  const scenario = await buildScenario(model);
  const jsonString = JSON.stringify(scenario, (_key, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    if (typeof value === "string" && value.match(/^\d+n$/)) {
      return Number(value.slice(0, value.length - 1));
    }
    return value;
  });
  return jsonString.replace(/"Buffer\.from\(([^)]+)\)"/g, "Buffer.from($1)");
};
const fieldTypes = async (model) => {
  const { scalarFields } = await parseSchema(model);
  return scalarFields.reduce((acc, value) => {
    acc[value.name] = value.type;
    return acc;
  }, {});
};
const fieldsToInput = async (model) => {
  const { scalarFields, foreignKeys } = await parseSchema(model);
  const modelName = (0, import_camelcase.default)((0, import_rwPluralize.singularize)(model));
  let inputObj = {};
  scalarFields.forEach((field) => {
    if (foreignKeys.includes(field.name)) {
      inputObj[field.name] = `scenario.${modelName}.two.${field.name}`;
    } else {
      inputObj[field.name] = scenarioFieldValue(field);
    }
  });
  if (Object.keys(inputObj).length > 0) {
    return inputObj;
  } else {
    return false;
  }
};
const fieldsToUpdate = async (model) => {
  const { scalarFields, relations, foreignKeys } = await parseSchema(model);
  const modelName = (0, import_camelcase.default)((0, import_rwPluralize.singularize)(model));
  let field, newValue, fieldName;
  field = scalarFields.find((scalar) => !foreignKeys.includes(scalar.name));
  if (!field) {
    field = scalarFields[0];
  }
  if (!field) {
    return false;
  }
  if (foreignKeys.includes(field.name)) {
    fieldName = Object.values(relations)[0].foreignKey;
    newValue = `scenario.${modelName}.two.${field.name}`;
  } else {
    fieldName = field.name;
    const value = scenarioFieldValue(field);
    newValue = value;
    switch (field.type) {
      case "BigInt":
        newValue = `${newValue + 1n}`;
        break;
      case "Boolean": {
        newValue = !value;
        break;
      }
      case "DateTime": {
        let date = /* @__PURE__ */ new Date();
        date.setDate(date.getDate() + 1);
        newValue = date;
        break;
      }
      case "Decimal":
      case "Float": {
        newValue = newValue + 1.1;
        break;
      }
      case "Int": {
        newValue = newValue + 1;
        break;
      }
      case "Json": {
        newValue = { foo: "baz" };
        break;
      }
      case "String": {
        newValue = newValue + "2";
        break;
      }
      default: {
        if (field.kind === "enum" && field.enumValues[field.enumValues.length - 1]) {
          const enumVal = field.enumValues[field.enumValues.length - 1];
          newValue = enumVal.dbName || enumVal.name;
        }
        break;
      }
    }
  }
  return { [fieldName]: newValue };
};
const getIdName = async (model) => {
  const schema = await (0, import_schemaHelpers.getSchema)(model);
  return schema.fields.find((field) => field.isId)?.name;
};
const files = async ({
  name,
  tests,
  relations,
  typescript,
  ...rest
}) => {
  const componentName = (0, import_camelcase.default)((0, import_rwPluralize.pluralize)(name));
  const model = name;
  const idName = await getIdName(model);
  const extension = "ts";
  const modelRelations = relations || (0, import_helpers.relationsForModel)(await (0, import_schemaHelpers.getSchema)(model));
  const serviceFile = await (0, import_helpers2.templateForComponentFile)({
    name,
    componentName,
    extension: `.${extension}`,
    apiPathSection: "services",
    generator: "service",
    templatePath: `service.${extension}.template`,
    templateVars: { relations: modelRelations, idName, ...rest }
  });
  const testFile = await (0, import_helpers2.templateForComponentFile)({
    name,
    componentName,
    extension: `.test.${extension}`,
    apiPathSection: "services",
    generator: "service",
    templatePath: `test.${extension}.template`,
    templateVars: {
      relations: relations || [],
      create: await fieldsToInput(model),
      update: await fieldsToUpdate(model),
      types: await fieldTypes(model),
      prismaImport: (await parseSchema(model)).scalarFields.some(
        (field) => field.type === "Decimal"
      ),
      prismaModel: model,
      idName,
      ...rest
    }
  });
  const scenariosFile = await (0, import_helpers2.templateForComponentFile)({
    name,
    componentName,
    extension: `.scenarios.${extension}`,
    apiPathSection: "services",
    generator: "service",
    templatePath: `scenarios.${extension}.template`,
    templateVars: {
      scenario: await buildScenario(model),
      stringifiedScenario: await buildStringifiedScenario(model),
      prismaModel: model,
      idName,
      relations: modelRelations,
      ...rest
    }
  });
  const files2 = [serviceFile];
  if (tests) {
    files2.push(testFile);
    files2.push(scenariosFile);
  }
  return files2.reduce(async (accP, [outputPath, content]) => {
    const acc = await accP;
    if (!typescript) {
      content = await (0, import_lib.transformTSToJS)(outputPath, content);
      outputPath = outputPath.replace(".ts", ".js");
    }
    return {
      [outputPath]: content,
      ...acc
    };
  }, Promise.resolve({}));
};
const defaults = {
  ...import_helpers.yargsDefaults,
  tests: {
    description: "Generate test files",
    type: "boolean"
  },
  crud: {
    default: true,
    description: "Create CRUD functions",
    type: "boolean"
  }
};
const builder = (yargs) => {
  yargs.positional("name", {
    description: "Name of the service",
    type: "string"
  }).option("rollback", {
    description: "Revert all generator actions if an error occurs",
    type: "boolean",
    default: true
  }).epilogue(
    `Also see the ${(0, import_terminal_link.default)(
      "Redwood CLI Reference",
      "https://redwoodjs.com/docs/cli-commands#generate-service"
    )}`
  );
  Object.entries(defaults).forEach(([option, config]) => {
    yargs.option(option, config);
  });
};
const { command, description, handler } = (0, import_helpers2.createYargsForComponentGeneration)({
  componentName: "service",
  preTasksFn: import_schemaHelpers.verifyModelName,
  filesFn: files
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  buildScenario,
  buildStringifiedScenario,
  builder,
  command,
  defaults,
  description,
  fieldTypes,
  fieldsToInput,
  fieldsToScenario,
  fieldsToUpdate,
  files,
  handler,
  parseSchema,
  scenarioFieldValue
});
