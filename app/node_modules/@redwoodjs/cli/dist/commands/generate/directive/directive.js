"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var directive_exports = {};
__export(directive_exports, {
  builder: () => builder,
  command: () => command,
  description: () => description,
  files: () => files,
  handler: () => handler
});
module.exports = __toCommonJS(directive_exports);
var import_path = __toESM(require("path"));
var import_camelcase = __toESM(require("camelcase"));
var import_execa = __toESM(require("execa"));
var import_listr2 = require("listr2");
var import_prompts = __toESM(require("prompts"));
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_project_config = require("@redwoodjs/project-config");
var import_lib = require("../../../lib");
var import_colors = __toESM(require("../../../lib/colors"));
var import_rollback = require("../../../lib/rollback");
var import_helpers = require("../helpers");
var import_helpers2 = require("../helpers");
const files = async ({ name, typescript = false, type, tests }) => {
  if (tests === void 0) {
    tests = (0, import_project_config.getConfig)().generate.tests;
  }
  if (!type) {
    throw new Error("You must specify a directive type");
  }
  const camelName = (0, import_camelcase.default)(name);
  const outputFilename = `${camelName}.${typescript ? "ts" : "js"}`;
  const directiveFile = await (0, import_helpers2.templateForComponentFile)({
    name,
    extension: typescript ? ".ts" : ".js",
    generator: "directive",
    templatePath: `${type}.directive.ts.template`,
    outputPath: import_path.default.join((0, import_lib.getPaths)().api.directives, camelName, outputFilename),
    templateVars: { camelName }
  });
  const files2 = [directiveFile];
  if (tests) {
    const testOutputFilename = `${(0, import_camelcase.default)(name)}.test.${typescript ? "ts" : "js"}`;
    const testFile = await (0, import_helpers2.templateForComponentFile)({
      name,
      extension: typescript ? ".test.ts" : ".test.js",
      generator: "directive",
      templatePath: `${type}.directive.test.ts.template`,
      outputPath: import_path.default.join(
        (0, import_lib.getPaths)().api.directives,
        camelName,
        testOutputFilename
      ),
      templateVars: { camelName }
    });
    files2.push(testFile);
  }
  return files2.reduce(async (accP, [outputPath, content]) => {
    const acc = await accP;
    const template = typescript ? content : await (0, import_lib.transformTSToJS)(outputPath, content);
    return {
      [outputPath]: template,
      ...acc
    };
  }, Promise.resolve({}));
};
const positionalsObj = {
  name: {
    description: "Name of your directive",
    type: "string"
  }
};
const { command, description, builder } = (0, import_helpers2.createYargsForComponentGeneration)({
  componentName: "directive",
  filesFn: files,
  positionalsObj,
  optionsObj: {
    ...import_helpers.yargsDefaults,
    type: {
      type: "string",
      choices: ["validator", "transformer"],
      description: "Whether to generate a validator or transformer directive"
    }
  }
});
const handler = async (args) => {
  (0, import_cli_helpers.recordTelemetryAttributes)({
    command: "generate directive",
    type: args.type,
    force: args.force,
    rollback: args.rollback
  });
  let notes = "";
  const POST_RUN_INSTRUCTIONS = `
   ${import_colors.default.note("After modifying your directive, you can add it to your SDLs e.g.:")}

    ${import_colors.default.info("// example todo.sdl.js")}
    ${import_colors.default.info("# Option A: Add it to a field")}
    type Todo {
      id: Int!
      body: String! ${import_colors.default.tip(`@${args.name}`)}
    }

    ${import_colors.default.info("# Option B: Add it to query/mutation")}
    type Query {
      todos: [Todo] ${import_colors.default.tip(`@${args.name}`)}
    }
`;
  (0, import_helpers2.validateName)(args.name);
  let directiveType = args.type;
  if (!directiveType) {
    const response = await (0, import_prompts.default)({
      type: "select",
      name: "directiveType",
      choices: [
        {
          value: "validator",
          title: "Validator",
          description: "Implement a validation: throw an error if criteria not met to stop execution"
        },
        {
          value: "transformer",
          title: "Transformer",
          description: "Modify values of fields or query responses"
        }
      ],
      message: "What type of directive would you like to generate?"
    });
    directiveType = response.directiveType;
  }
  const tasks = new import_listr2.Listr(
    [
      {
        title: "Generating directive file ...",
        task: async () => {
          const f = await files({ ...args, type: directiveType });
          return (0, import_lib.writeFilesTask)(f, {
            overwriteExisting: args.force
          });
        }
      },
      {
        title: "Generating TypeScript definitions and GraphQL schemas ...",
        task: () => {
          (0, import_rollback.addFunctionToRollback)(async () => {
            await (0, import_execa.default)("yarn rw-gen", [], {
              stdio: "pipe",
              shell: true
            });
          }, true);
          return (0, import_execa.default)("yarn rw-gen", [], {
            stdio: "inherit",
            shell: true
          });
        }
      },
      {
        title: "Next steps...",
        task: () => {
          notes = POST_RUN_INSTRUCTIONS;
        }
      }
    ].filter(Boolean),
    { rendererOptions: { collapseSubtasks: false } }
  );
  try {
    if (args.rollback && !args.force) {
      (0, import_rollback.prepareForRollback)(tasks);
    }
    await tasks.run();
    if (notes) {
      console.log(notes);
    }
  } catch (e) {
    console.log(import_colors.default.error(e.message));
    process.exit(1);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  builder,
  command,
  description,
  files,
  handler
});
