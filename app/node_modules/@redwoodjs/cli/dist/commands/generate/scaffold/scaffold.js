"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var scaffold_exports = {};
__export(scaffold_exports, {
  builder: () => builder,
  command: () => command,
  description: () => description,
  files: () => files,
  handler: () => handler,
  routes: () => routes,
  shouldUseTailwindCSS: () => shouldUseTailwindCSS,
  splitPathAndModel: () => splitPathAndModel,
  tasks: () => tasks
});
module.exports = __toCommonJS(scaffold_exports);
var import_path = __toESM(require("path"));
var import_camelcase = __toESM(require("camelcase"));
var import_change_case = require("change-case");
var import_execa = __toESM(require("execa"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_humanize_string = __toESM(require("humanize-string"));
var import_listr2 = require("listr2");
var import_pascalcase = __toESM(require("pascalcase"));
var import_terminal_link = __toESM(require("terminal-link"));
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_generate = require("@redwoodjs/internal/dist/generate/generate");
var import_project_config = require("@redwoodjs/project-config");
var import_lib = require("../../../lib");
var import_colors = __toESM(require("../../../lib/colors"));
var import_rollback = require("../../../lib/rollback");
var import_rwPluralize = require("../../../lib/rwPluralize");
var import_schemaHelpers = require("../../../lib/schemaHelpers");
var import_helpers = require("../helpers");
var import_helpers2 = require("../helpers");
var import_sdl = require("../sdl/sdl");
var import_service = require("../service/service");
const NON_EDITABLE_COLUMNS = ["id", "createdAt", "updatedAt"];
const SKIPPABLE_ASSETS = ["scaffold.css"];
const PACKAGE_SET = "Set";
const getIdType = (model) => {
  return model.fields.find((field) => field.isId)?.type;
};
const getIdName = (model) => {
  return model.fields.find((field) => field.isId)?.name;
};
const filterAutoGeneratedColumnsForScaffold = (column) => {
  const autoGeneratedFunctions = ["now", "autoincrement"];
  return !(column.isId || column.isUpdatedAt || autoGeneratedFunctions.includes(column?.default?.name));
};
const getImportComponentNames = (name, scaffoldPath, nestScaffoldByModel = true) => {
  const pluralName = (0, import_pascalcase.default)((0, import_rwPluralize.pluralize)(name));
  const singularName = (0, import_pascalcase.default)((0, import_rwPluralize.singularize)(name));
  let componentPath;
  if (scaffoldPath === "") {
    componentPath = nestScaffoldByModel ? `src/components/${singularName}` : `src/components`;
  } else {
    const sP = scaffoldPath.split("/").map(import_pascalcase.default).join("/");
    componentPath = nestScaffoldByModel ? `src/components/${sP}/${singularName}` : `src/components/${sP}`;
  }
  return {
    importComponentName: `${componentPath}/${singularName}`,
    importComponentNameCell: `${componentPath}/${singularName}Cell`,
    importComponentEditNameCell: `${componentPath}/Edit${singularName}Cell`,
    importComponentNameForm: `${componentPath}/${singularName}Form`,
    importComponentNewName: `${componentPath}/New${singularName}`,
    importComponentNames: `${componentPath}/${pluralName}`,
    importComponentNamesCell: `${componentPath}/${pluralName}Cell`,
    importLayoutNames: `src/layouts/ScaffoldLayout`
  };
};
const getTemplateStrings = (name, scaffoldPath, nestScaffoldByModel = true) => {
  const nameVars = (0, import_lib.nameVariants)(name);
  const camelScaffoldPath = (0, import_camelcase.default)((0, import_pascalcase.default)(scaffoldPath));
  return {
    pluralRouteName: scaffoldPath === "" ? nameVars.pluralCamelName : `${camelScaffoldPath}${nameVars.pluralPascalName}`,
    editRouteName: scaffoldPath === "" ? `edit${nameVars.singularPascalName}` : `${camelScaffoldPath}Edit${nameVars.singularPascalName}`,
    singularRouteName: scaffoldPath === "" ? nameVars.singularCamelName : `${camelScaffoldPath}${nameVars.singularPascalName}`,
    newRouteName: scaffoldPath === "" ? `new${nameVars.singularPascalName}` : `${camelScaffoldPath}New${nameVars.singularPascalName}`,
    ...getImportComponentNames(name, scaffoldPath, nestScaffoldByModel)
  };
};
const shouldUseTailwindCSS = (flag) => {
  if (flag === void 0) {
    return import_fs_extra.default.existsSync(import_path.default.join((0, import_lib.getPaths)().web.config, "tailwind.config.js"));
  } else {
    return flag;
  }
};
const files = async ({
  docs,
  model: name,
  path: scaffoldPath = "",
  tests = true,
  typescript = false,
  tailwind = false,
  force = false,
  nestScaffoldByModel
}) => {
  const model = await (0, import_schemaHelpers.getSchema)(name);
  if (typeof nestScaffoldByModel === "undefined") {
    nestScaffoldByModel = (0, import_project_config.getConfig)().generate.nestScaffoldByModel;
  }
  const templateStrings = getTemplateStrings(
    name,
    scaffoldPath,
    nestScaffoldByModel
  );
  const pascalScaffoldPath = scaffoldPath === "" ? scaffoldPath : scaffoldPath.split("/").map(import_pascalcase.default).join("/") + "/";
  return {
    ...await componentFiles(
      name,
      pascalScaffoldPath,
      typescript,
      nestScaffoldByModel,
      templateStrings
    ),
    ...await (0, import_sdl.files)({
      ...(0, import_lib.getDefaultArgs)(import_sdl.builder),
      docs,
      name,
      typescript
    }),
    ...await (0, import_service.files)({
      ...(0, import_lib.getDefaultArgs)(import_service.builder),
      name,
      crud: true,
      relations: (0, import_helpers2.relationsForModel)(model),
      tests,
      typescript
    }),
    ...await assetFiles(name, tailwind),
    ...await formatters(name, typescript),
    ...await layoutFiles(name, force, typescript, templateStrings),
    ...await pageFiles(
      name,
      pascalScaffoldPath,
      typescript,
      nestScaffoldByModel,
      templateStrings
    )
  };
};
const assetFiles = async (name, tailwind) => {
  let fileList = {};
  const assets = import_fs_extra.default.readdirSync(
    (0, import_helpers2.customOrDefaultTemplatePath)({
      side: "web",
      generator: "scaffold",
      templatePath: "assets"
    })
  );
  for (const asset of assets) {
    if (tailwind && asset.match(/tailwind/) || !tailwind && !asset.match(/tailwind/)) {
      const outputAssetName = asset.replace(/\.template/, "").replace(/\.tailwind/, "");
      const outputPath = import_path.default.join((0, import_lib.getPaths)().web.src, outputAssetName);
      if (!SKIPPABLE_ASSETS.includes(import_path.default.basename(outputPath)) || !import_fs_extra.default.existsSync(outputPath)) {
        const template = await (0, import_lib.generateTemplate)(
          (0, import_helpers2.customOrDefaultTemplatePath)({
            side: "web",
            generator: "scaffold",
            templatePath: import_path.default.join("assets", asset)
          }),
          {
            name
          }
        );
        fileList[outputPath] = template;
      }
    }
  }
  return fileList;
};
const formatters = async (name, isTypescript) => {
  const outputPath = import_path.default.join(
    (0, import_lib.getPaths)().web.src,
    "lib",
    isTypescript ? "formatters.tsx" : "formatters.jsx"
  );
  const outputPathTest = import_path.default.join(
    (0, import_lib.getPaths)().web.src,
    "lib",
    isTypescript ? "formatters.test.tsx" : "formatters.test.jsx"
  );
  if (import_fs_extra.default.existsSync(outputPath)) {
    return;
  }
  const template = await (0, import_lib.generateTemplate)(
    (0, import_helpers2.customOrDefaultTemplatePath)({
      side: "web",
      generator: "scaffold",
      templatePath: import_path.default.join("lib", "formatters.tsx.template")
    }),
    {
      name
    }
  );
  const templateTest = await (0, import_lib.generateTemplate)(
    (0, import_helpers2.customOrDefaultTemplatePath)({
      side: "web",
      generator: "scaffold",
      templatePath: import_path.default.join("lib", "formatters.test.tsx.template")
    }),
    {
      name
    }
  );
  return {
    [outputPath]: isTypescript ? template : await (0, import_lib.transformTSToJS)(outputPath, template),
    [outputPathTest]: isTypescript ? templateTest : await (0, import_lib.transformTSToJS)(outputPathTest, templateTest)
  };
};
const modelRelatedVariables = (model) => {
  const componentMetadata = {
    Enum: {
      componentName: "RadioField",
      defaultProp: "defaultChecked",
      validation: () => false,
      listDisplayFunction: "formatEnum",
      displayFunction: "formatEnum"
    },
    EnumList: {
      componentName: "CheckboxField",
      defaultProp: "defaultChecked",
      validation: () => false,
      listDisplayFunction: "formatEnum",
      displayFunction: "formatEnum"
    },
    Boolean: {
      componentName: "CheckboxField",
      defaultProp: "defaultChecked",
      validation: () => false,
      listDisplayFunction: "checkboxInputTag",
      displayFunction: "checkboxInputTag"
    },
    DateTime: {
      componentName: "DatetimeLocalField",
      deserializeFunction: "formatDatetime",
      listDisplayFunction: "timeTag",
      displayFunction: "timeTag"
    },
    Int: {
      componentName: "NumberField"
    },
    Json: {
      componentName: "TextAreaField",
      validation: (isRequired) => `{{ valueAsJSON: true${isRequired ? ", required: true" : ""} }}`,
      displayFunction: "jsonDisplay",
      listDisplayFunction: "jsonTruncate",
      deserializeFunction: "JSON.stringify"
    },
    Float: {
      validation: (isRequired) => `{{ valueAsNumber: true${isRequired ? ", required: true" : ""} }}`
    },
    Decimal: {
      validation: (isRequired) => `{{ valueAsNumber: true${isRequired ? ", required: true" : ""} }}`
    },
    default: {
      componentName: "TextField",
      defaultProp: "defaultValue",
      deserializeFunction: "",
      validation: "{{ required: true }}",
      displayFunction: void 0,
      listDisplayFunction: "truncate"
    }
  };
  const relations = (0, import_helpers2.relationsForModel)(model).map((relation) => relation);
  const columns = model.fields.filter((field) => field.kind !== "object").map((column) => {
    let validation;
    if (componentMetadata[column.type]?.validation) {
      validation = componentMetadata[column.type]?.validation(
        column?.isRequired
      );
    } else {
      validation = column?.isRequired ? componentMetadata.default.validation : null;
    }
    const isRelationalField = column.name.endsWith("Id") && relations.some((relation) => column.name.includes(relation));
    const isRequired = column.isRequired;
    const isEnum = column.kind === "enum";
    const isList = column.isList;
    const enumType = isEnum && isList ? "EnumList" : "Enum";
    const metadataKey = isEnum ? enumType : column.type;
    return {
      ...column,
      label: (0, import_humanize_string.default)(column.name),
      component: componentMetadata[metadataKey]?.componentName || componentMetadata.default.componentName,
      defaultProp: componentMetadata[metadataKey]?.defaultProp || componentMetadata.default.defaultProp,
      deserializeFunction: componentMetadata[metadataKey]?.deserializeFunction || componentMetadata.default.deserializeFunction,
      validation,
      listDisplayFunction: componentMetadata[metadataKey]?.listDisplayFunction || componentMetadata.default.listDisplayFunction,
      displayFunction: componentMetadata[metadataKey]?.displayFunction || componentMetadata.default.displayFunction,
      values: column.enumValues || [],
      isList,
      isEnum,
      isRequired,
      isRelationalField
    };
  });
  const editableColumns = columns.filter((column) => {
    return NON_EDITABLE_COLUMNS.indexOf(column.name) === -1;
  }).filter(filterAutoGeneratedColumnsForScaffold);
  const fieldsToImport = Object.keys(
    editableColumns.reduce((accumulator, column) => {
      accumulator[column.component] = true;
      return accumulator;
    }, {})
  );
  if (!fieldsToImport.length) {
    throw new Error(`There are no editable fields in the ${model.name} model`);
  }
  const formattersImports = columns.map((column) => column.displayFunction).sort().filter((name, index, array) => array.indexOf(name) === index).join(", ");
  const listFormattersImports = columns.map((column) => column.listDisplayFunction).sort().filter((name, index, array) => array.indexOf(name) === index).join(", ");
  return {
    columns,
    fieldsToImport,
    editableColumns,
    listFormattersImports,
    formattersImports
  };
};
const layoutFiles = async (name, force, generateTypescript, templateStrings) => {
  let fileList = {};
  const layouts = import_fs_extra.default.readdirSync(
    (0, import_helpers2.customOrDefaultTemplatePath)({
      side: "web",
      generator: "scaffold",
      templatePath: "layouts"
    })
  );
  for (const layout of layouts) {
    const outputLayoutName = layout.replace(
      /\.tsx\.template/,
      generateTypescript ? ".tsx" : ".jsx"
    );
    const outputPath = import_path.default.join(
      (0, import_lib.getPaths)().web.layouts,
      "ScaffoldLayout",
      outputLayoutName
    );
    if (!import_fs_extra.default.existsSync(outputPath) || force) {
      const template = await (0, import_lib.generateTemplate)(
        (0, import_helpers2.customOrDefaultTemplatePath)({
          side: "web",
          generator: "scaffold",
          templatePath: import_path.default.join("layouts", layout)
        }),
        {
          name,
          pascalScaffoldPath: "",
          ...templateStrings
        }
      );
      fileList[outputPath] = generateTypescript ? template : await (0, import_lib.transformTSToJS)(outputPath, template);
    }
  }
  return fileList;
};
const pageFiles = async (name, pascalScaffoldPath = "", generateTypescript, nestScaffoldByModel = true, templateStrings) => {
  const pluralName = (0, import_pascalcase.default)((0, import_rwPluralize.pluralize)(name));
  const singularName = (0, import_pascalcase.default)((0, import_rwPluralize.singularize)(name));
  const model = await (0, import_schemaHelpers.getSchema)(singularName);
  const idType = getIdType(model);
  const idTsType = (0, import_helpers2.mapPrismaScalarToPagePropTsType)(idType);
  const idName = getIdName(model);
  let fileList = {};
  const pages = import_fs_extra.default.readdirSync(
    (0, import_helpers2.customOrDefaultTemplatePath)({
      side: "web",
      generator: "scaffold",
      templatePath: "pages"
    })
  );
  for (const page of pages) {
    const outputPageName = page.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.tsx\.template/, generateTypescript ? ".tsx" : ".jsx");
    const finalFolder = (nestScaffoldByModel ? singularName + "/" : "") + outputPageName.replace(/\.[jt]sx?/, "");
    const outputPath = import_path.default.join(
      (0, import_lib.getPaths)().web.pages,
      pascalScaffoldPath,
      finalFolder,
      outputPageName
    );
    const template = await (0, import_lib.generateTemplate)(
      (0, import_helpers2.customOrDefaultTemplatePath)({
        side: "web",
        generator: "scaffold",
        templatePath: import_path.default.join("pages", page)
      }),
      {
        idTsType,
        idName,
        name,
        pascalScaffoldPath,
        ...templateStrings,
        ...modelRelatedVariables(model)
      }
    );
    fileList[outputPath] = generateTypescript ? template : await (0, import_lib.transformTSToJS)(outputPath, template);
  }
  return fileList;
};
const componentFiles = async (name, pascalScaffoldPath = "", generateTypescript, nestScaffoldByModel = true, templateStrings) => {
  const pluralName = (0, import_pascalcase.default)((0, import_rwPluralize.pluralize)(name));
  const singularName = (0, import_pascalcase.default)((0, import_rwPluralize.singularize)(name));
  const model = await (0, import_schemaHelpers.getSchema)(singularName);
  const idType = getIdType(model);
  const idName = getIdName(model);
  const pascalIdName = (0, import_pascalcase.default)(idName);
  const intForeignKeys = (0, import_helpers2.intForeignKeysForModel)(model);
  let fileList = {};
  const components = import_fs_extra.default.readdirSync(
    (0, import_helpers2.customOrDefaultTemplatePath)({
      side: "web",
      generator: "scaffold",
      templatePath: "components"
    })
  );
  for (const component of components) {
    const outputComponentName = component.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.tsx\.template/, generateTypescript ? ".tsx" : ".jsx");
    const finalFolder = (nestScaffoldByModel ? singularName + "/" : "") + outputComponentName.replace(/\.[jt]sx?/, "");
    const outputPath = import_path.default.join(
      (0, import_lib.getPaths)().web.components,
      pascalScaffoldPath,
      finalFolder,
      outputComponentName
    );
    const useClientDirective = (0, import_project_config.getConfig)().experimental?.rsc?.enabled ? "'use client'\n\n" : "";
    const template = await (0, import_lib.generateTemplate)(
      (0, import_helpers2.customOrDefaultTemplatePath)({
        side: "web",
        generator: "scaffold",
        templatePath: import_path.default.join("components", component)
      }),
      {
        name,
        idType,
        idName,
        pascalIdName,
        intForeignKeys,
        pascalScaffoldPath,
        useClientDirective,
        ...templateStrings,
        ...modelRelatedVariables(model)
      }
    );
    fileList[outputPath] = generateTypescript ? template : await (0, import_lib.transformTSToJS)(outputPath, template);
  }
  return fileList;
};
const routes = async ({
  model: name,
  path: scaffoldPath = "",
  nestScaffoldByModel
}) => {
  if (typeof nestScaffoldByModel === "undefined") {
    nestScaffoldByModel = (0, import_project_config.getConfig)().generate.nestScaffoldByModel;
  }
  const templateNames = getTemplateStrings(name, scaffoldPath);
  const nameVars = (0, import_lib.nameVariants)(name);
  const model = await (0, import_schemaHelpers.getSchema)(nameVars.singularPascalName);
  const idRouteParam = getIdType(model) === "Int" ? ":Int" : "";
  const idName = getIdName(model);
  const paramScaffoldPath = scaffoldPath === "" ? scaffoldPath : scaffoldPath.split("/").map(import_change_case.paramCase).join("/") + "/";
  const pascalScaffoldPath = (0, import_pascalcase.default)(scaffoldPath);
  const pageRoot = pascalScaffoldPath + (nestScaffoldByModel ? nameVars.singularPascalName : "");
  return [
    // new
    `<Route path="/${paramScaffoldPath}${nameVars.pluralParamName}/new" page={${pageRoot}New${nameVars.singularPascalName}Page} name="${templateNames.newRouteName}" />`,
    // edit
    `<Route path="/${paramScaffoldPath}${nameVars.pluralParamName}/{${idName}${idRouteParam}}/edit" page={${pageRoot}Edit${nameVars.singularPascalName}Page} name="${templateNames.editRouteName}" />`,
    // singular
    `<Route path="/${paramScaffoldPath}${nameVars.pluralParamName}/{${idName}${idRouteParam}}" page={${pageRoot}${nameVars.singularPascalName}Page} name="${templateNames.singularRouteName}" />`,
    // plural
    `<Route path="/${paramScaffoldPath}${nameVars.pluralParamName}" page={${pageRoot}${nameVars.pluralPascalName}Page} name="${templateNames.pluralRouteName}" />`
  ];
};
const addLayoutImport = () => {
  const importLayout = `import ScaffoldLayout from 'src/layouts/ScaffoldLayout'`;
  const routesPath = (0, import_lib.getPaths)().web.routes;
  const routesContent = (0, import_lib.readFile)(routesPath).toString();
  if (!routesContent.match(importLayout)) {
    const newRoutesContent = routesContent.replace(
      /['"]@redwoodjs\/router['"](\s*)/,
      `'@redwoodjs/router'

${importLayout}$1`
    );
    (0, import_lib.writeFile)(routesPath, newRoutesContent, { overwriteExisting: true });
    return "Added layout import to Routes.{jsx,tsx}";
  } else {
    return "Layout import already exists in Routes.{jsx,tsx}";
  }
};
const addHelperPackages = async (task) => {
  const packageJsonPath = import_path.default.join((0, import_lib.getPaths)().web.base, "package.json");
  const packageJson = require(packageJsonPath);
  if (packageJson.dependencies["humanize-string"]) {
    return task.skip("Skipping. Already installed");
  }
  await (0, import_execa.default)("yarn", ["workspace", "web", "add", "humanize-string@2.1.0"]);
  (0, import_rollback.addFunctionToRollback)(async () => {
    await (0, import_execa.default)("yarn", ["workspace", "web", "remove", "humanize-string"]);
  });
};
const addSetImport = (task) => {
  const routesPath = (0, import_lib.getPaths)().web.routes;
  const routesContent = (0, import_lib.readFile)(routesPath).toString();
  const [redwoodRouterImport, importStart, spacing, importContent, importEnd] = routesContent.match(
    /(import {)(\s*)([^]*)(} from ['"]@redwoodjs\/router['"])/
  ) || [];
  if (!redwoodRouterImport) {
    task.skip(
      "Couldn't add Set import from @redwoodjs/router to Routes.{jsx,tsx}"
    );
    return void 0;
  }
  const routerImports = importContent.replace(/\s/g, "").split(",");
  if (routerImports.includes(PACKAGE_SET)) {
    return "Skipping Set import";
  }
  const newRoutesContent = routesContent.replace(
    redwoodRouterImport,
    importStart + spacing + PACKAGE_SET + `,` + spacing + importContent + importEnd
  );
  (0, import_lib.writeFile)(routesPath, newRoutesContent, { overwriteExisting: true });
  return "Added Set import to Routes.{jsx,tsx}";
};
const addScaffoldSetToRouter = async (model, path2) => {
  const templateNames = getTemplateStrings(model, path2);
  const nameVars = (0, import_lib.nameVariants)(model);
  const title = nameVars.pluralPascalName;
  const titleTo = templateNames.pluralRouteName;
  const buttonLabel = `New ${nameVars.singularPascalName}`;
  const buttonTo = templateNames.newRouteName;
  return (0, import_lib.addRoutesToRouterTask)(
    await routes({ model, path: path2 }),
    "ScaffoldLayout",
    { title, titleTo, buttonLabel, buttonTo }
  );
};
const command = "scaffold <model>";
const description = "Generate Pages, SDL, and Services files based on a given DB schema Model. Also accepts <path/model>";
const builder = (yargs) => {
  yargs.positional("model", {
    description: "Model to scaffold. You can also use <path/model> to nest files by type at the given path directory (or directories). For example, 'rw g scaffold admin/post'"
  }).option("docs", {
    description: "Generate SDL and GraphQL comments to use in documentation",
    type: "boolean",
    default: false
  }).option("tests", {
    description: "Generate test files",
    type: "boolean"
  }).option("tailwind", {
    description: "Generate TailwindCSS version of scaffold.css (automatically set to `true` if TailwindCSS config exists)",
    type: "boolean"
  }).option("rollback", {
    description: "Revert all generator actions if an error occurs",
    type: "boolean",
    default: true
  }).epilogue(
    `Also see the ${(0, import_terminal_link.default)(
      "Redwood CLI Reference",
      "https://redwoodjs.com/docs/cli-commands#generate-scaffold"
    )}`
  );
  Object.entries(import_helpers.yargsDefaults).forEach(([option, config]) => {
    yargs.option(option, config);
  });
};
const tasks = ({
  docs,
  model,
  path: path2,
  force,
  tests,
  typescript,
  javascript,
  tailwind
}) => {
  return new import_listr2.Listr(
    [
      {
        title: "Generating scaffold files...",
        task: async () => {
          const f = await files({
            docs,
            model,
            path: path2,
            tests,
            typescript,
            javascript,
            tailwind,
            force
          });
          return (0, import_lib.writeFilesTask)(f, { overwriteExisting: force });
        }
      },
      {
        title: "Install helper packages",
        task: (_, task) => addHelperPackages(task)
      },
      {
        title: "Adding layout import...",
        task: async () => addLayoutImport()
      },
      {
        title: "Adding set import...",
        task: async (_, task) => addSetImport(task)
      },
      {
        title: "Adding scaffold routes...",
        task: async () => addScaffoldSetToRouter(model, path2)
      },
      {
        title: "Adding scaffold asset imports...",
        task: () => (0, import_lib.addScaffoldImport)()
      },
      {
        title: `Generating types ...`,
        task: async () => {
          const { errors } = await (0, import_generate.generate)();
          for (const { message, error } of errors) {
            console.error(message);
            console.log();
            console.error(error);
            console.log();
          }
          (0, import_rollback.addFunctionToRollback)(import_generate.generate, true);
        }
      }
    ],
    { rendererOptions: { collapseSubtasks: false }, exitOnError: true }
  );
};
const handler = async ({
  model: modelArg,
  force,
  tests,
  typescript,
  tailwind,
  docs = false,
  rollback
}) => {
  if (tests === void 0) {
    tests = (0, import_project_config.getConfig)().generate.tests;
  }
  (0, import_cli_helpers.recordTelemetryAttributes)({
    command: "generate scaffold",
    force,
    tests,
    typescript,
    tailwind,
    docs,
    rollback
  });
  const { model, path: path2 } = splitPathAndModel(modelArg);
  tailwind = shouldUseTailwindCSS(tailwind);
  try {
    const { name } = await (0, import_schemaHelpers.verifyModelName)({ name: model });
    const t = tasks({
      docs,
      model: name,
      path: path2,
      force,
      tests,
      typescript,
      tailwind
    });
    if (rollback && !force) {
      (0, import_rollback.prepareForRollback)(t);
    }
    await t.run();
  } catch (e) {
    console.log(import_colors.default.error(e.message));
    process.exit(e?.existCode || 1);
  }
};
const splitPathAndModel = (pathSlashModel) => {
  const path2 = pathSlashModel.split("/").slice(0, -1).join("/");
  const model = pathSlashModel.split("/").pop();
  return { model, path: path2 };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  builder,
  command,
  description,
  files,
  handler,
  routes,
  shouldUseTailwindCSS,
  splitPathAndModel,
  tasks
});
