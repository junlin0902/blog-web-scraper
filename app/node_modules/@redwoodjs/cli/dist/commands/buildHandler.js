"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var buildHandler_exports = {};
__export(buildHandler_exports, {
  handler: () => handler
});
module.exports = __toCommonJS(buildHandler_exports);
var import_path = __toESM(require("path"));
var import_execa = __toESM(require("execa"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_listr2 = require("listr2");
var import_terminal_link = __toESM(require("terminal-link"));
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_api = require("@redwoodjs/internal/dist/build/api");
var import_generate = require("@redwoodjs/internal/dist/generate/generate");
var import_validateSchema = require("@redwoodjs/internal/dist/validateSchema");
var import_detection = require("@redwoodjs/prerender/detection");
var import_telemetry = require("@redwoodjs/telemetry");
var import_lib = require("../lib");
var import_generatePrismaClient = require("../lib/generatePrismaClient");
const handler = async ({
  side = ["api", "web"],
  verbose = false,
  prisma = true,
  prerender
}) => {
  (0, import_cli_helpers.recordTelemetryAttributes)({
    command: "build",
    side: JSON.stringify(side),
    verbose,
    prisma,
    prerender
  });
  const rwjsPaths = (0, import_lib.getPaths)();
  const rwjsConfig = (0, import_lib.getConfig)();
  const useFragments = rwjsConfig.graphql?.fragments;
  const useTrustedDocuments = rwjsConfig.graphql?.trustedDocuments;
  const prismaSchemaExists = import_fs_extra.default.existsSync(rwjsPaths.api.dbSchema);
  const prerenderRoutes = prerender && side.includes("web") ? (0, import_detection.detectPrerenderRoutes)() : [];
  const shouldGeneratePrismaClient = prisma && prismaSchemaExists && (side.includes("api") || prerenderRoutes.length > 0);
  const tasks = [
    shouldGeneratePrismaClient && {
      title: "Generating Prisma Client...",
      task: () => {
        const { cmd, args } = (0, import_generatePrismaClient.generatePrismaCommand)(rwjsPaths.api.dbSchema);
        return (0, import_execa.default)(cmd, args, {
          stdio: verbose ? "inherit" : "pipe",
          shell: true,
          cwd: rwjsPaths.api.base
        });
      }
    },
    // If using GraphQL Fragments or Trusted Documents, then we need to use
    // codegen to generate the types needed for possible types and the
    // trusted document store hashes
    (useFragments || useTrustedDocuments) && {
      title: `Generating types needed for ${[
        useFragments && "GraphQL Fragments",
        useTrustedDocuments && "Trusted Documents"
      ].filter(Boolean).join(" and ")} support...`,
      task: async () => {
        await (0, import_generate.generate)();
      }
    },
    side.includes("api") && {
      title: "Verifying graphql schema...",
      task: import_validateSchema.loadAndValidateSdls
    },
    side.includes("api") && {
      title: "Building API...",
      task: async () => {
        await (0, import_api.cleanApiBuild)();
        const { errors, warnings } = await (0, import_api.buildApi)();
        if (errors.length) {
          console.error(errors);
        }
        if (warnings.length) {
          console.warn(warnings);
        }
      }
    },
    side.includes("web") && {
      title: "Building Web...",
      task: async () => {
        process.env.VITE_CJS_IGNORE_WARNING = "true";
        await (0, import_execa.default)(
          `node ${require.resolve("@redwoodjs/vite/bins/rw-vite-build.mjs")} --webDir="${rwjsPaths.web.base}" --verbose=${verbose}`,
          {
            stdio: verbose ? "inherit" : "pipe",
            shell: true,
            // `cwd` is needed for yarn to find the rw-vite-build binary
            // It won't change process.cwd for anything else here, in this
            // process
            cwd: rwjsPaths.web.base
          }
        );
        if (!(0, import_lib.getConfig)().experimental?.streamingSsr?.enabled) {
          console.log("Creating 200.html...");
          const indexHtmlPath = import_path.default.join((0, import_lib.getPaths)().web.dist, "index.html");
          import_fs_extra.default.copyFileSync(
            indexHtmlPath,
            import_path.default.join((0, import_lib.getPaths)().web.dist, "200.html")
          );
        }
      }
    }
  ].filter(Boolean);
  const triggerPrerender = async () => {
    console.log("Starting prerendering...");
    if (prerenderRoutes.length === 0) {
      console.log(
        `You have not marked any routes to "prerender" in your ${(0, import_terminal_link.default)(
          "Routes",
          "file://" + rwjsPaths.web.routes
        )}.`
      );
      return;
    }
    await (0, import_execa.default)("yarn rw prerender", {
      stdio: "inherit",
      shell: true,
      cwd: rwjsPaths.web.base
    });
  };
  const jobs = new import_listr2.Listr(tasks, {
    renderer: verbose && "verbose"
  });
  await (0, import_telemetry.timedTelemetry)(process.argv, { type: "build" }, async () => {
    await jobs.run();
    if (side.includes("web") && prerender && prismaSchemaExists) {
      await triggerPrerender();
    }
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
