"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var upgrade_exports = {};
__export(upgrade_exports, {
  builder: () => builder,
  command: () => command,
  description: () => description,
  getCmdMajorVersion: () => getCmdMajorVersion,
  handler: () => handler,
  validateTag: () => validateTag
});
module.exports = __toCommonJS(upgrade_exports);
var import_path = __toESM(require("path"));
var import_execa = __toESM(require("execa"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_latest_version = __toESM(require("latest-version"));
var import_listr2 = require("listr2");
var import_terminal_link = __toESM(require("terminal-link"));
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_project_config = require("@redwoodjs/project-config");
var import_lib = require("../lib");
var import_colors = __toESM(require("../lib/colors"));
var import_generatePrismaClient = require("../lib/generatePrismaClient");
var import_plugin = require("../lib/plugin");
const command = "upgrade";
const description = "Upgrade all @redwoodjs packages via interactive CLI";
const builder = (yargs) => {
  yargs.example(
    "rw upgrade -t 0.20.1-canary.5",
    "Specify a version. URL for Version History:\nhttps://www.npmjs.com/package/@redwoodjs/core"
  ).option("dry-run", {
    alias: "d",
    description: "Check for outdated packages without upgrading",
    type: "boolean"
  }).option("tag", {
    alias: "t",
    description: '[choices: "latest", "rc", "next", "canary", "experimental", or a specific-version (see example below)] WARNING: "canary", "rc" and "experimental" are unstable releases! And "canary" releases include breaking changes often requiring codemods if upgrading a project.',
    requiresArg: true,
    type: "string",
    coerce: validateTag
  }).option("verbose", {
    alias: "v",
    description: "Print verbose logs",
    type: "boolean",
    default: false
  }).option("dedupe", {
    description: "Skip dedupe check with --no-dedupe",
    type: "boolean",
    default: true
  }).epilogue(
    `Also see the ${(0, import_terminal_link.default)(
      "Redwood CLI Reference for the upgrade command",
      "https://redwoodjs.com/docs/cli-commands#upgrade"
    )}.
And the ${(0, import_terminal_link.default)(
      "GitHub releases page",
      "https://github.com/redwoodjs/redwood/releases"
    )} for more information on the current release.`
  );
};
const SEMVER_REGEX = /(?<=^v?|\sv?)(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)(?:-(?:0|[1-9]\d*|[\da-z-]*[a-z-][\da-z-]*)(?:\.(?:0|[1-9]\d*|[\da-z-]*[a-z-][\da-z-]*))*)?(?:\+[\da-z-]+(?:\.[\da-z-]+)*)?(?=$|\s)/i;
const isValidSemver = (string) => {
  return SEMVER_REGEX.test(string);
};
const isValidRedwoodJSTag = (tag) => {
  return ["rc", "canary", "latest", "next", "experimental"].includes(tag);
};
const validateTag = (tag) => {
  const isTagValid = isValidSemver(tag) || isValidRedwoodJSTag(tag);
  if (!isTagValid) {
    throw new Error(
      import_colors.default.error(
        "Invalid tag supplied. Supported values: 'rc', 'canary', 'latest', 'next', 'experimental', or a valid semver version\n"
      )
    );
  }
  return tag;
};
const handler = async ({ dryRun, tag, verbose, dedupe }) => {
  (0, import_cli_helpers.recordTelemetryAttributes)({
    command: "upgrade",
    dryRun,
    tag,
    verbose,
    dedupe
  });
  const tasks = new import_listr2.Listr(
    [
      {
        title: "Checking latest version",
        task: async (ctx) => setLatestVersionToContext(ctx, tag)
      },
      {
        title: "Updating your Redwood version",
        task: (ctx) => updateRedwoodDepsForAllSides(ctx, { dryRun, verbose }),
        enabled: (ctx) => !!ctx.versionToUpgradeTo
      },
      {
        title: "Updating other packages in your package.json(s)",
        task: (ctx) => updatePackageVersionsFromTemplate(ctx, { dryRun, verbose }),
        enabled: (ctx) => ctx.versionToUpgradeTo?.includes("canary")
      },
      {
        title: "Downloading yarn patches",
        task: (ctx) => downloadYarnPatches(ctx, { dryRun, verbose }),
        enabled: (ctx) => ctx.versionToUpgradeTo?.includes("canary")
      },
      {
        title: "Removing CLI cache",
        task: (ctx) => removeCliCache(ctx, { dryRun, verbose })
      },
      {
        title: "Running yarn install",
        task: (ctx) => yarnInstall(ctx, { dryRun, verbose }),
        skip: () => dryRun
      },
      {
        title: "Refreshing the Prisma client",
        task: (_ctx, task) => refreshPrismaClient(task, { verbose }),
        skip: () => dryRun
      },
      {
        title: "De-duplicating dependencies",
        skip: () => dryRun || !dedupe,
        task: (_ctx, task) => dedupeDeps(task, { verbose })
      },
      {
        title: "One more thing..",
        task: (ctx, task) => {
          const version = ctx.versionToUpgradeTo;
          const messageSections = [
            `One more thing...

   ${import_colors.default.warning(
              `\u{1F389} Your project has been upgraded to RedwoodJS ${version}!`
            )} 

`
          ];
          if ([void 0, "latest", "rc"].includes(tag)) {
            messageSections.push(
              `   Please review the release notes for any manual steps: 
   \u2756 ${(0, import_terminal_link.default)(
                `Redwood community discussion`,
                `https://community.redwoodjs.com/c/announcements/releases-and-upgrade-guides/`
              )}
   \u2756 ${(0, import_terminal_link.default)(
                `GitHub Release notes`,
                `https://github.com/redwoodjs/redwood/releases`
                // intentionally not linking to specific version
              )} 

`
            );
          }
          if (tag) {
            const additionalMessages = [];
            if (!(0, import_project_config.getConfig)().notifications.versionUpdates.includes(tag) && isValidRedwoodJSTag(tag)) {
              additionalMessages.push(
                `   \u2756 You may want to update your redwood.toml config so that \`notifications.versionUpdates\` includes "${tag}"
`
              );
            }
            if (additionalMessages.length > 0) {
              messageSections.push(
                `   \u{1F4E2} ${import_colors.default.warning(`We'd also like to remind you that:`)} 
`,
                ...additionalMessages
              );
            }
          }
          task.title = messageSections.join("").trimEnd();
        }
      }
    ],
    {
      renderer: verbose && "verbose",
      rendererOptions: { collapseSubtasks: false }
    }
  );
  await tasks.run();
};
async function yarnInstall({ verbose }) {
  const yarnVersion = await getCmdMajorVersion("yarn");
  try {
    await (0, import_execa.default)(
      "yarn install",
      yarnVersion > 1 ? [] : ["--force", "--non-interactive"],
      {
        shell: true,
        stdio: verbose ? "inherit" : "pipe",
        cwd: (0, import_lib.getPaths)().base
      }
    );
  } catch (e) {
    throw new Error(
      "Could not finish installation. Please run `yarn install` and then `yarn dedupe`, before continuing"
    );
  }
}
async function removeCliCache(ctx, { dryRun, verbose }) {
  const cliCacheDir = import_path.default.join(
    (0, import_lib.getPaths)().generated.base,
    import_plugin.PLUGIN_CACHE_FILENAME
  );
  if (verbose) {
    console.log("Removing CLI cache at: ", cliCacheDir);
  }
  if (!dryRun) {
    import_fs_extra.default.removeSync(cliCacheDir);
  }
}
async function setLatestVersionToContext(ctx, tag) {
  try {
    const foundVersion = await (0, import_latest_version.default)(
      "@redwoodjs/core",
      tag ? { version: tag } : {}
    );
    ctx.versionToUpgradeTo = foundVersion;
    return foundVersion;
  } catch (e) {
    throw new Error("Could not find the latest version");
  }
}
function updatePackageJsonVersion(pkgPath, version, { dryRun, verbose }) {
  const pkg = JSON.parse(
    import_fs_extra.default.readFileSync(import_path.default.join(pkgPath, "package.json"), "utf-8")
  );
  if (pkg.dependencies) {
    for (const depName of Object.keys(pkg.dependencies).filter(
      (x) => x.startsWith("@redwoodjs/") && x !== "@redwoodjs/studio"
    )) {
      if (verbose || dryRun) {
        console.log(` - ${depName}: ${pkg.dependencies[depName]} => ${version}`);
      }
      pkg.dependencies[depName] = `${version}`;
    }
  }
  if (pkg.devDependencies) {
    for (const depName of Object.keys(pkg.devDependencies).filter(
      (x) => x.startsWith("@redwoodjs/") && x !== "@redwoodjs/studio"
    )) {
      if (verbose || dryRun) {
        console.log(
          ` - ${depName}: ${pkg.devDependencies[depName]} => ${version}`
        );
      }
      pkg.devDependencies[depName] = `${version}`;
    }
  }
  if (!dryRun) {
    import_fs_extra.default.writeFileSync(
      import_path.default.join(pkgPath, "package.json"),
      JSON.stringify(pkg, void 0, 2)
    );
  }
}
function updateRedwoodDepsForAllSides(ctx, options) {
  if (!ctx.versionToUpgradeTo) {
    throw new Error("Failed to upgrade");
  }
  const updatePaths = [
    (0, import_lib.getPaths)().base,
    (0, import_lib.getPaths)().api.base,
    (0, import_lib.getPaths)().web.base
  ];
  return new import_listr2.Listr(
    updatePaths.map((basePath) => {
      const pkgJsonPath = import_path.default.join(basePath, "package.json");
      return {
        title: `Updating ${pkgJsonPath}`,
        task: () => updatePackageJsonVersion(basePath, ctx.versionToUpgradeTo, options),
        skip: () => !import_fs_extra.default.existsSync(pkgJsonPath)
      };
    })
  );
}
async function updatePackageVersionsFromTemplate(ctx, { dryRun, verbose }) {
  if (!ctx.versionToUpgradeTo) {
    throw new Error("Failed to upgrade");
  }
  const packageJsons = [
    {
      basePath: (0, import_lib.getPaths)().base,
      url: "https://raw.githubusercontent.com/redwoodjs/redwood/main/packages/create-redwood-app/templates/ts/package.json"
    },
    {
      basePath: (0, import_lib.getPaths)().api.base,
      url: "https://raw.githubusercontent.com/redwoodjs/redwood/main/packages/create-redwood-app/templates/ts/api/package.json"
    },
    {
      basePath: (0, import_lib.getPaths)().web.base,
      url: "https://raw.githubusercontent.com/redwoodjs/redwood/main/packages/create-redwood-app/templates/ts/web/package.json"
    }
  ];
  return new import_listr2.Listr(
    packageJsons.map(({ basePath, url }) => {
      const pkgJsonPath = import_path.default.join(basePath, "package.json");
      return {
        title: `Updating ${pkgJsonPath}`,
        task: async () => {
          const res = await fetch(url);
          const text = await res.text();
          const templatePackageJson = JSON.parse(text);
          const localPackageJsonText = import_fs_extra.default.readFileSync(pkgJsonPath, "utf-8");
          const localPackageJson = JSON.parse(localPackageJsonText);
          Object.entries(templatePackageJson.dependencies || {}).forEach(
            ([depName, depVersion]) => {
              if (!depName.startsWith("@redwoodjs/")) {
                if (verbose || dryRun) {
                  console.log(
                    ` - ${depName}: ${localPackageJson.dependencies[depName]} => ${depVersion}`
                  );
                }
                localPackageJson.dependencies[depName] = depVersion;
              }
            }
          );
          Object.entries(templatePackageJson.devDependencies || {}).forEach(
            ([depName, depVersion]) => {
              if (!depName.startsWith("@redwoodjs/")) {
                if (verbose || dryRun) {
                  console.log(
                    ` - ${depName}: ${localPackageJson.devDependencies[depName]} => ${depVersion}`
                  );
                }
                localPackageJson.devDependencies[depName] = depVersion;
              }
            }
          );
          if (!dryRun) {
            import_fs_extra.default.writeFileSync(
              pkgJsonPath,
              JSON.stringify(localPackageJson, null, 2)
            );
          }
        },
        skip: () => !import_fs_extra.default.existsSync(pkgJsonPath)
      };
    })
  );
}
async function downloadYarnPatches(ctx, { dryRun, verbose }) {
  if (!ctx.versionToUpgradeTo) {
    throw new Error("Failed to upgrade");
  }
  const githubToken = process.env.GH_TOKEN || process.env.GITHUB_TOKEN || process.env.REDWOOD_GITHUB_TOKEN;
  const res = await fetch(
    "https://api.github.com/repos/redwoodjs/redwood/git/trees/main?recursive=1",
    {
      headers: {
        Authorization: githubToken ? `Bearer ${githubToken}` : void 0,
        ["X-GitHub-Api-Version"]: "2022-11-28",
        Accept: "application/vnd.github+json"
      }
    }
  );
  const json = await res.json();
  const patches = json.tree?.filter(
    (patchInfo) => patchInfo.path.startsWith(
      "packages/create-redwood-app/templates/ts/.yarn/patches/"
    )
  );
  const patchDir = import_path.default.join((0, import_lib.getPaths)().base, ".yarn", "patches");
  if (verbose) {
    console.log("Creating patch directory", patchDir);
  }
  if (!dryRun) {
    import_fs_extra.default.mkdirSync(patchDir, { recursive: true });
  }
  return new import_listr2.Listr(
    (patches || []).map((patch) => {
      return {
        title: `Downloading ${patch.path}`,
        task: async () => {
          const res2 = await fetch(patch.url);
          const patchMeta = await res2.json();
          const patchPath = import_path.default.join(
            (0, import_lib.getPaths)().base,
            ".yarn",
            "patches",
            import_path.default.basename(patch.path)
          );
          if (verbose) {
            console.log("Writing patch", patchPath);
          }
          if (!dryRun) {
            await import_fs_extra.default.writeFile(patchPath, patchMeta.content, "base64");
          }
        }
      };
    })
  );
}
async function refreshPrismaClient(task, { verbose }) {
  try {
    await (0, import_generatePrismaClient.generatePrismaClient)({
      verbose,
      force: false,
      schema: (0, import_lib.getPaths)().api.dbSchema
    });
  } catch (e) {
    task.skip("Refreshing the Prisma client caused an Error.");
    console.log(
      "You may need to update your prisma client manually: $ yarn rw prisma generate"
    );
    console.log(import_colors.default.error(e.message));
  }
}
const getCmdMajorVersion = async (command2) => {
  const { stdout } = await (0, import_execa.default)(command2, ["--version"], {
    cwd: (0, import_lib.getPaths)().base
  });
  if (!SEMVER_REGEX.test(stdout)) {
    throw new Error(`Unable to verify ${command2} version.`);
  }
  const version = stdout.match(SEMVER_REGEX)[0];
  return parseInt(version.split(".")[0]);
};
const dedupeDeps = async (task, { verbose }) => {
  try {
    const yarnVersion = await getCmdMajorVersion("yarn");
    const baseExecaArgsForDedupe = {
      shell: true,
      stdio: verbose ? "inherit" : "pipe",
      cwd: (0, import_lib.getPaths)().base
    };
    if (yarnVersion > 1) {
      await (0, import_execa.default)("yarn", ["dedupe"], baseExecaArgsForDedupe);
    } else {
      task.skip(
        "Yarn 1.x doesn't support dedupe directly. Please upgrade yarn or use npx with `npx yarn-deduplicate` manually."
      );
    }
  } catch (e) {
    console.log(import_colors.default.error(e.message));
    throw new Error(
      "Could not finish de-duplication. For yarn 1.x, please run `npx yarn-deduplicate`, or for yarn 3 run `yarn dedupe` before continuing"
    );
  }
  await yarnInstall({ verbose });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  builder,
  command,
  description,
  getCmdMajorVersion,
  handler,
  validateTag
});
