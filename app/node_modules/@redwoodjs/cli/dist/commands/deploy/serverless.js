"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var serverless_exports = {};
__export(serverless_exports, {
  aliases: () => aliases,
  buildCommands: () => buildCommands,
  builder: () => builder,
  command: () => command,
  deployCommands: () => deployCommands,
  description: () => description,
  handler: () => handler,
  preRequisites: () => preRequisites
});
module.exports = __toCommonJS(serverless_exports);
var import_path = __toESM(require("path"));
var import_boxen = __toESM(require("boxen"));
var import_chalk = __toESM(require("chalk"));
var import_dotenv_defaults = require("dotenv-defaults");
var import_execa = __toESM(require("execa"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_listr2 = require("listr2");
var import_prompts = __toESM(require("prompts"));
var import_terminal_link = __toESM(require("terminal-link"));
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_lib = require("../../lib");
var import_colors = __toESM(require("../../lib/colors"));
const command = "serverless";
const aliases = ["aws serverless", "sls"];
const description = "Deploy to AWS via the serverless framework";
const builder = (yargs) => {
  yargs.option("stage", {
    describe: "serverless stage pass through param: https://www.serverless.com/blog/stages-and-environments",
    default: "production",
    type: "string"
  });
  yargs.option("sides", {
    describe: "which Side(s) to deploy",
    choices: ["api", "web"],
    default: ["api", "web"],
    alias: "side",
    type: "array"
  });
  yargs.option("verbose", {
    describe: "verbosity of logs",
    default: true,
    type: "boolean"
  });
  yargs.option("pack-only", {
    describe: "Only build and pack, and dont push code up using serverless",
    default: false,
    type: "boolean"
  });
  yargs.option("first-run", {
    describe: "Set this flag the first time you deploy, to configure your API URL on the webside",
    default: false,
    type: "boolean"
  });
  yargs.epilogue(
    `Also see the ${(0, import_terminal_link.default)(
      "Redwood CLI Reference",
      "https://redwoodjs.com/docs/cli-commands#deploy"
    )}
`
  );
};
const preRequisites = () => [
  {
    title: "Checking if Serverless framework is installed...",
    command: ["yarn serverless", ["--version"]],
    errorMessage: [
      "Looks like Serverless is not installed.",
      "Please run yarn add -W --dev serverless."
    ]
  }
];
const buildCommands = ({ sides }) => {
  return [
    {
      title: `Building ${sides.join(" & ")}...`,
      command: ["yarn", ["rw", "build", ...sides]]
    },
    {
      title: "Packing Functions...",
      enabled: () => sides.includes("api"),
      task: async () => {
        const { nftPack } = await import("./packing/nft.js");
        await nftPack();
      }
    }
  ];
};
const deployCommands = ({ stage, sides, firstRun, packOnly }) => {
  const slsStage = stage ? ["--stage", stage] : [];
  return sides.map((side) => {
    return {
      title: `Deploying ${side}....`,
      task: async () => {
        await (0, import_execa.default)("yarn", ["serverless", "deploy", ...slsStage], {
          cwd: import_path.default.join((0, import_lib.getPaths)().base, side),
          shell: true,
          stdio: "inherit",
          cleanup: true
        });
      },
      skip: () => {
        if (firstRun && side === "web") {
          return "Skipping web deploy, until environment configured";
        }
        if (packOnly) {
          return "Finishing early due to --pack-only flag. Your Redwood project is packaged and ready to deploy";
        }
      }
    };
  });
};
const loadDotEnvForStage = (dotEnvPath) => {
  (0, import_dotenv_defaults.config)({
    path: dotEnvPath,
    defaults: import_path.default.join((0, import_lib.getPaths)().base, ".env.defaults"),
    encoding: "utf8"
  });
};
const handler = async (yargs) => {
  (0, import_cli_helpers.recordTelemetryAttributes)({
    command: "deploy serverless",
    sides: JSON.stringify(yargs.sides),
    verbose: yargs.verbose,
    packOnly: yargs.packOnly,
    firstRun: yargs.firstRun
  });
  const rwjsPaths = (0, import_lib.getPaths)();
  const dotEnvPath = import_path.default.join(rwjsPaths.base, `.env.${yargs.stage}`);
  loadDotEnvForStage(dotEnvPath);
  const tasks = new import_listr2.Listr(
    [
      ...preRequisites(yargs).map(mapCommandsToListr),
      ...buildCommands(yargs).map(mapCommandsToListr),
      ...deployCommands(yargs).map(mapCommandsToListr)
    ],
    {
      exitOnError: true,
      renderer: yargs.verbose && "verbose"
    }
  );
  try {
    await tasks.run();
    if (yargs.firstRun) {
      const SETUP_MARKER = import_chalk.default.bgBlue(import_chalk.default.black("First Setup "));
      console.log();
      console.log(SETUP_MARKER, import_colors.default.success("Starting first setup wizard..."));
      const { stdout: slsInfo } = await (0, import_execa.default)(
        `yarn serverless info --verbose --stage=${yargs.stage}`,
        {
          shell: true,
          cwd: (0, import_lib.getPaths)().api.base
        }
      );
      const deployedApiUrl = slsInfo.match(/HttpApiUrl: (https:\/\/.*)/)[1];
      console.log();
      console.log(SETUP_MARKER, `Found ${import_colors.default.success(deployedApiUrl)}`);
      console.log();
      const { addDotEnv } = await (0, import_prompts.default)({
        type: "confirm",
        name: "addDotEnv",
        message: `Add API_URL to your .env.${yargs.stage}? This will be used if you deploy the web side from your machine`
      });
      if (addDotEnv) {
        import_fs_extra.default.writeFileSync(dotEnvPath, `API_URL=${deployedApiUrl}`);
        loadDotEnvForStage(dotEnvPath);
      }
      if (yargs.sides.includes("web")) {
        console.log();
        console.log(SETUP_MARKER, "Deploying web side with updated API_URL");
        console.log(
          SETUP_MARKER,
          "First deploys can take a good few minutes..."
        );
        console.log();
        const webDeployTasks = new import_listr2.Listr(
          [
            // Rebuild web with the new API_URL
            ...buildCommands({ ...yargs, sides: ["web"], firstRun: false }).map(
              mapCommandsToListr
            ),
            ...deployCommands({
              ...yargs,
              sides: ["web"],
              firstRun: false
            }).map(mapCommandsToListr)
          ],
          {
            exitOnError: true,
            renderer: yargs.verbose && "verbose"
          }
        );
        await webDeployTasks.run();
        const { stdout: slsInfo2 } = await (0, import_execa.default)(
          `yarn serverless info --verbose --stage=${yargs.stage}`,
          {
            shell: true,
            cwd: (0, import_lib.getPaths)().web.base
          }
        );
        const deployedWebUrl = slsInfo2.match(/url: (https:\/\/.*)/)[1];
        const message = [
          import_colors.default.bold("Successful first deploy!"),
          "",
          `View your deployed site at: ${import_colors.default.success(deployedWebUrl)}`,
          "",
          "You can use serverless.com CI/CD by connecting/creating an app",
          "To do this run `yarn serverless` on each of the sides, and connect your account",
          "",
          "Find more information in our docs:",
          import_colors.default.underline("https://redwoodjs.com/docs/deploy#serverless")
        ];
        console.log(
          (0, import_boxen.default)(message.join("\n"), {
            padding: { top: 0, bottom: 0, right: 1, left: 1 },
            margin: 1,
            borderColor: "gray"
          })
        );
      }
    }
  } catch (e) {
    console.error(import_colors.default.error(e.message));
    process.exit(e?.exitCode || 1);
  }
};
const mapCommandsToListr = ({
  title,
  command: command2,
  task,
  cwd,
  errorMessage,
  skip,
  enabled
}) => {
  return {
    title,
    task: task ? task : async () => {
      try {
        const executingCommand = (0, import_execa.default)(...command2, {
          cwd: cwd || (0, import_lib.getPaths)().base,
          shell: true
        });
        executingCommand.stdout.pipe(process.stdout);
        await executingCommand;
      } catch (error) {
        if (errorMessage) {
          error.message = error.message + "\n" + errorMessage.join(" ");
        }
        throw error;
      }
    },
    skip,
    enabled
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  aliases,
  buildCommands,
  builder,
  command,
  deployCommands,
  description,
  handler,
  preRequisites
});
