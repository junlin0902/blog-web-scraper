"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var baremetal_exports = {};
__export(baremetal_exports, {
  DEFAULT_SERVER_CONFIG: () => DEFAULT_SERVER_CONFIG,
  builder: () => builder,
  command: () => command,
  commandWithLifecycleEvents: () => commandWithLifecycleEvents,
  commands: () => commands,
  deployTasks: () => deployTasks,
  description: () => description,
  execaOptions: () => execaOptions,
  handler: () => handler,
  lifecycleTask: () => lifecycleTask,
  maintenanceTasks: () => maintenanceTasks,
  parseConfig: () => parseConfig,
  rollbackTasks: () => rollbackTasks,
  serverConfigWithDefaults: () => serverConfigWithDefaults,
  throwMissingConfig: () => throwMissingConfig,
  verifyConfig: () => verifyConfig,
  verifyServerConfig: () => verifyServerConfig
});
module.exports = __toCommonJS(baremetal_exports);
var import_path = __toESM(require("path"));
var import_boxen = __toESM(require("boxen"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_listr2 = require("listr2");
var toml = __toESM(require("smol-toml"));
var import_string_env_interpolation = require("string-env-interpolation");
var import_terminal_link = __toESM(require("terminal-link"));
var import_title_case = require("title-case");
var import_cli_helpers = require("@redwoodjs/cli-helpers");
var import_lib = require("../../lib");
var import_colors = __toESM(require("../../lib/colors"));
var import_SshExecutor = require("./baremetal/SshExecutor");
const CONFIG_FILENAME = "deploy.toml";
const SYMLINK_FLAGS = "-nsf";
const CURRENT_RELEASE_SYMLINK_NAME = "current";
const LIFECYCLE_HOOKS = ["before", "after"];
const DEFAULT_SERVER_CONFIG = {
  port: 22,
  branch: "main",
  packageManagerCommand: "yarn",
  monitorCommand: "pm2",
  sides: ["api", "web"],
  keepReleases: 5
};
const command = "baremetal [environment]";
const description = "Deploy to baremetal server(s)";
const pathJoin = import_path.default.posix.join;
const execaOptions = {
  cwd: pathJoin((0, import_lib.getPaths)().base),
  stdio: "inherit",
  shell: true,
  cleanup: true
};
const builder = (yargs) => {
  yargs.positional("environment", {
    describe: "The environment to deploy to",
    type: "string"
  });
  yargs.option("first-run", {
    describe: "Set this flag the first time you deploy: starts server processes from scratch",
    default: false,
    type: "boolean"
  });
  yargs.option("df", {
    describe: "Check available disk space",
    default: true,
    type: "boolean"
  });
  yargs.option("update", {
    describe: "Update code to latest revision",
    default: true,
    type: "boolean"
  });
  yargs.option("install", {
    describe: "Run `yarn install`",
    default: true,
    type: "boolean"
  });
  yargs.option("migrate", {
    describe: "Run database migration tasks",
    default: true,
    type: "boolean"
  });
  yargs.option("build", {
    describe: "Run build process for the deployed `sides`",
    default: true,
    type: "boolean"
  });
  yargs.option("restart", {
    describe: "Restart server processes",
    default: true,
    type: "boolean"
  });
  yargs.option("cleanup", {
    describe: "Remove old deploy directories",
    default: true,
    type: "boolean"
  });
  yargs.option("releaseDir", {
    describe: "Directory to create for the latest release, defaults to timestamp",
    default: (/* @__PURE__ */ new Date()).toISOString().replace(/[:\-TZ]/g, "").replace(/\.\d+$/, ""),
    type: "string"
  });
  yargs.option("branch", {
    describe: "The branch to deploy",
    type: "string"
  });
  yargs.option("maintenance", {
    describe: "Add/remove the maintenance page",
    choices: ["up", "down"],
    help: "Put up a maintenance page by replacing the content of web/dist/index.html with the content of web/src/maintenance.html"
  });
  yargs.option("rollback", {
    describe: "Add/remove the maintenance page",
    help: "Rollback [count] number of releases"
  });
  yargs.option("verbose", {
    describe: "Verbose mode, for debugging purposes",
    default: false,
    type: "boolean"
  });
  yargs.epilogue(
    `Also see the ${(0, import_terminal_link.default)(
      "Redwood Baremetal Deploy Reference",
      "https://redwoodjs.com/docs/cli-commands#deploy"
    )}
`
  );
};
const throwMissingConfig = (name) => {
  throw new Error(
    `"${name}" config option not set. See https://redwoodjs.com/docs/deployment/baremetal#deploytoml`
  );
};
const verifyConfig = (config, yargs) => {
  if (!yargs.environment) {
    throw new Error(
      "Must specify an environment to deploy to, ex: `yarn rw deploy baremetal production`"
    );
  }
  if (!config[yargs.environment]) {
    throw new Error(`No servers found for environment "${yargs.environment}"`);
  }
  return true;
};
const verifyServerConfig = (config) => {
  if (!config.host) {
    throwMissingConfig("host");
  }
  if (!config.path) {
    throwMissingConfig("path");
  }
  if (!config.repo) {
    throwMissingConfig("repo");
  }
  if (config.freeSpaceRequired && !/^\d+$/.test(config.freeSpaceRequired)) {
    throw new Error('"freeSpaceRequired" must be an integer >= 0');
  }
  return true;
};
const symlinkCurrentCommand = async (dir, ssh, path2) => {
  return await ssh.exec(path2, "ln", [
    SYMLINK_FLAGS,
    dir,
    CURRENT_RELEASE_SYMLINK_NAME
  ]);
};
const restartProcessCommand = async (processName, ssh, serverConfig, path2) => {
  return await ssh.exec(path2, serverConfig.monitorCommand, [
    "restart",
    processName
  ]);
};
const serverConfigWithDefaults = (serverConfig, yargs) => {
  return {
    ...DEFAULT_SERVER_CONFIG,
    ...serverConfig,
    branch: yargs.branch || serverConfig.branch || DEFAULT_SERVER_CONFIG.branch
  };
};
const maintenanceTasks = (status, ssh, serverConfig) => {
  const deployPath = pathJoin(serverConfig.path, CURRENT_RELEASE_SYMLINK_NAME);
  const tasks = [];
  if (status === "up") {
    tasks.push({
      title: `Enabling maintenance page...`,
      task: async () => {
        await ssh.exec(deployPath, "cp", [
          pathJoin("web", "dist", "200.html"),
          pathJoin("web", "dist", "200.html.orig")
        ]);
        await ssh.exec(deployPath, "ln", [
          SYMLINK_FLAGS,
          pathJoin("..", "src", "maintenance.html"),
          pathJoin("web", "dist", "200.html")
        ]);
      }
    });
    if (serverConfig.processNames) {
      tasks.push({
        title: `Stopping ${serverConfig.processNames.join(", ")} processes...`,
        task: async () => {
          await ssh.exec(serverConfig.path, serverConfig.monitorCommand, [
            "stop",
            serverConfig.processNames.join(" ")
          ]);
        }
      });
    }
  } else if (status === "down") {
    tasks.push({
      title: `Starting ${serverConfig.processNames.join(", ")} processes...`,
      task: async () => {
        await ssh.exec(serverConfig.path, serverConfig.monitorCommand, [
          "start",
          serverConfig.processNames.join(" ")
        ]);
      }
    });
    if (serverConfig.processNames) {
      tasks.push({
        title: `Disabling maintenance page...`,
        task: async () => {
          await ssh.exec(deployPath, "rm", [
            pathJoin("web", "dist", "200.html")
          ]);
          await ssh.exec(deployPath, "cp", [
            pathJoin("web", "dist", "200.html.orig"),
            pathJoin("web", "dist", "200.html")
          ]);
        }
      });
    }
  }
  return tasks;
};
const rollbackTasks = (count, ssh, serverConfig) => {
  let rollbackCount = 1;
  if (parseInt(count) === count) {
    rollbackCount = count;
  }
  const tasks = [
    {
      title: `Rolling back ${rollbackCount} release(s)...`,
      task: async () => {
        const currentLink = (await ssh.exec(serverConfig.path, "readlink", ["-f", "current"])).stdout.split("/").pop();
        const dirs = (await ssh.exec(serverConfig.path, "ls", ["-t"])).stdout.split("\n").filter((dirs2) => !dirs2.match(/current/));
        const deployedIndex = dirs.indexOf(currentLink);
        const rollbackIndex = deployedIndex + rollbackCount;
        if (dirs[rollbackIndex]) {
          console.info("Setting symlink");
          await symlinkCurrentCommand(
            dirs[rollbackIndex],
            ssh,
            serverConfig.path
          );
        } else {
          throw new Error(
            `Cannot rollback ${rollbackCount} release(s): ${dirs.length - dirs.indexOf(currentLink) - 1} previous release(s) available`
          );
        }
      }
    }
  ];
  if (serverConfig.processNames) {
    for (const processName of serverConfig.processNames) {
      tasks.push({
        title: `Restarting ${processName} process...`,
        task: async () => {
          await restartProcessCommand(
            processName,
            ssh,
            serverConfig,
            serverConfig.path
          );
        }
      });
    }
  }
  return tasks;
};
const lifecycleTask = (lifecycle, task, skip, { serverLifecycle, ssh, cmdPath }) => {
  if (serverLifecycle[lifecycle]?.[task]) {
    const tasks = [];
    for (const command2 of serverLifecycle[lifecycle][task]) {
      tasks.push({
        title: `${(0, import_title_case.titleCase)(lifecycle)} ${task}: \`${command2}\``,
        task: async () => {
          await ssh.exec(cmdPath, command2);
        },
        skip: () => skip
      });
    }
    return tasks;
  }
};
const commandWithLifecycleEvents = ({ name, config, skip, command: command2 }) => {
  const tasks = [];
  tasks.push(lifecycleTask("before", name, skip, config));
  tasks.push({ ...command2, skip: () => skip });
  tasks.push(lifecycleTask("after", name, skip, config));
  return tasks.flat().filter((t) => t);
};
const deployTasks = (yargs, ssh, serverConfig, serverLifecycle) => {
  const cmdPath = pathJoin(serverConfig.path, yargs.releaseDir);
  const config = { yargs, ssh, serverConfig, serverLifecycle, cmdPath };
  const tasks = [];
  tasks.push(
    commandWithLifecycleEvents({
      name: "df",
      config: { ...config, cmdPath: serverConfig.path },
      skip: !yargs.df || serverConfig.freeSpaceRequired === 0 || serverConfig.freeSpaceRequired === "0",
      command: {
        title: `Checking available disk space...`,
        task: async (_ctx, task) => {
          const { stdout } = await ssh.exec(serverConfig.path, "df", [
            serverConfig.path,
            "|",
            "awk",
            `'NR == 2 {print "df:"$4}'`
          ]);
          const df = stdout.split("\n").find((line) => line.startsWith("df:"));
          if (!df || !df.startsWith("df:") || df === "df:") {
            return task.skip(
              import_colors.default.warning("Warning: Could not get disk space information")
            );
          }
          const dfMb = parseInt(df.replace("df:", ""), 10) / 1024;
          if (isNaN(dfMb)) {
            return task.skip(
              import_colors.default.warning("Warning: Could not parse disk space information")
            );
          }
          task.output = `Available disk space: ${dfMb}MB`;
          const freeSpaceRequired = parseInt(
            serverConfig.freeSpaceRequired ?? 2048,
            10
          );
          if (dfMb < freeSpaceRequired) {
            if (typeof serverConfig.freeSpaceRequired === "undefined") {
              return task.skip(
                import_colors.default.warning(
                  `Warning: Your server is running low on disk space. (${Math.round(dfMb)}MB available)`
                )
              );
            }
            throw new Error(
              `Not enough disk space. You need at least ${freeSpaceRequired}MB free space to continue.`
            );
          }
        }
      }
    })
  );
  tasks.push(
    commandWithLifecycleEvents({
      name: "update",
      config: { ...config, cmdPath: serverConfig.path },
      skip: !yargs.update,
      command: {
        title: `Cloning \`${serverConfig.branch}\` branch...`,
        task: async () => {
          await ssh.exec(serverConfig.path, "git", [
            "clone",
            `--branch=${serverConfig.branch}`,
            `--depth=1`,
            serverConfig.repo,
            yargs.releaseDir
          ]);
        }
      }
    })
  );
  tasks.push(
    commandWithLifecycleEvents({
      name: "symlinkEnv",
      config,
      skip: !yargs.update,
      command: {
        title: `Symlink .env...`,
        task: async () => {
          await ssh.exec(cmdPath, "ln", [SYMLINK_FLAGS, "../.env", ".env"]);
        }
      }
    })
  );
  tasks.push(
    commandWithLifecycleEvents({
      name: "install",
      config,
      skip: !yargs.install,
      command: {
        title: `Installing dependencies...`,
        task: async () => {
          await ssh.exec(cmdPath, serverConfig.packageManagerCommand, [
            "install"
          ]);
        }
      }
    })
  );
  tasks.push(
    commandWithLifecycleEvents({
      name: "migrate",
      config,
      skip: !yargs.migrate || serverConfig?.migrate === false,
      command: {
        title: `DB Migrations...`,
        task: async () => {
          await ssh.exec(cmdPath, serverConfig.packageManagerCommand, [
            "rw",
            "prisma",
            "migrate",
            "deploy"
          ]);
          await ssh.exec(cmdPath, serverConfig.packageManagerCommand, [
            "rw",
            "prisma",
            "generate"
          ]);
          await ssh.exec(cmdPath, serverConfig.packageManagerCommand, [
            "rw",
            "dataMigrate",
            "up"
          ]);
        }
      }
    })
  );
  for (const side of serverConfig.sides) {
    tasks.push(
      commandWithLifecycleEvents({
        name: "build",
        config,
        skip: !yargs.build,
        command: {
          title: `Building ${side}...`,
          task: async () => {
            await ssh.exec(cmdPath, serverConfig.packageManagerCommand, [
              "rw",
              "build",
              side
            ]);
          }
        }
      })
    );
  }
  tasks.push(
    commandWithLifecycleEvents({
      name: "symlinkCurrent",
      config,
      skip: !yargs.update,
      command: {
        title: `Symlinking current release...`,
        task: async () => {
          await symlinkCurrentCommand(yargs.releaseDir, ssh, serverConfig.path);
        },
        skip: () => !yargs.update
      }
    })
  );
  if (serverConfig.processNames) {
    for (const processName of serverConfig.processNames) {
      if (yargs.firstRun) {
        tasks.push(
          commandWithLifecycleEvents({
            name: "restart",
            config,
            skip: !yargs.restart,
            command: {
              title: `Starting ${processName} process for the first time...`,
              task: async () => {
                await ssh.exec(serverConfig.path, serverConfig.monitorCommand, [
                  "start",
                  pathJoin(CURRENT_RELEASE_SYMLINK_NAME, "ecosystem.config.js"),
                  "--only",
                  processName
                ]);
              }
            }
          })
        );
        tasks.push({
          title: `Saving ${processName} state for future startup...`,
          task: async () => {
            await ssh.exec(serverConfig.path, serverConfig.monitorCommand, [
              "save"
            ]);
          },
          skip: () => !yargs.restart
        });
      } else {
        tasks.push(
          commandWithLifecycleEvents({
            name: "restart",
            config,
            skip: !yargs.restart,
            command: {
              title: `Restarting ${processName} process...`,
              task: async () => {
                await restartProcessCommand(
                  processName,
                  ssh,
                  serverConfig,
                  serverConfig.path
                );
              }
            }
          })
        );
      }
    }
  }
  tasks.push(
    commandWithLifecycleEvents({
      name: "cleanup",
      config: { ...config, cmdPath: serverConfig.path },
      skip: !yargs.cleanup,
      command: {
        title: `Cleaning up old deploys...`,
        task: async () => {
          const fileStartIndex = serverConfig.keepReleases + 2;
          await ssh.exec(
            serverConfig.path,
            `ls -t | tail -n +${fileStartIndex} | xargs rm -rf`
          );
        }
      }
    })
  );
  return tasks.flat().filter((e) => e);
};
const mergeLifecycleEvents = (lifecycle, other) => {
  let lifecycleCopy = JSON.parse(JSON.stringify(lifecycle));
  for (const hook of LIFECYCLE_HOOKS) {
    for (const key in other[hook]) {
      lifecycleCopy[hook][key] = (lifecycleCopy[hook][key] || []).concat(
        other[hook][key]
      );
    }
  }
  return lifecycleCopy;
};
const parseConfig = (yargs, rawConfigToml) => {
  const configToml = (0, import_string_env_interpolation.env)(rawConfigToml);
  const config = toml.parse(configToml);
  let envConfig;
  const emptyLifecycle = {};
  verifyConfig(config, yargs);
  for (const hook of LIFECYCLE_HOOKS) {
    emptyLifecycle[hook] = {};
  }
  let envLifecycle = mergeLifecycleEvents(emptyLifecycle, config);
  envConfig = config[yargs.environment];
  envLifecycle = mergeLifecycleEvents(envLifecycle, envConfig);
  return { envConfig, envLifecycle };
};
const commands = (yargs, ssh) => {
  const deployConfig = import_fs_extra.default.readFileSync(pathJoin((0, import_lib.getPaths)().base, CONFIG_FILENAME)).toString();
  let { envConfig, envLifecycle } = parseConfig(yargs, deployConfig);
  let servers = [];
  let tasks = [];
  for (const config of envConfig.servers) {
    const serverConfig = serverConfigWithDefaults(config, yargs);
    verifyServerConfig(serverConfig);
    const serverLifecycle = mergeLifecycleEvents(envLifecycle, serverConfig);
    tasks.push({
      title: "Connecting...",
      task: () => ssh.connect({
        host: serverConfig.host,
        port: serverConfig.port,
        username: serverConfig.username,
        password: serverConfig.password,
        privateKey: serverConfig.privateKey,
        privateKeyPath: serverConfig.privateKeyPath,
        passphrase: serverConfig.passphrase,
        agent: serverConfig.agentForward && process.env.SSH_AUTH_SOCK,
        agentForward: serverConfig.agentForward
      })
    });
    if (yargs.maintenance) {
      tasks = tasks.concat(
        maintenanceTasks(yargs.maintenance, ssh, serverConfig)
      );
    } else if (yargs.rollback) {
      tasks = tasks.concat(rollbackTasks(yargs.rollback, ssh, serverConfig));
    } else {
      tasks = tasks.concat(
        deployTasks(yargs, ssh, serverConfig, serverLifecycle)
      );
    }
    tasks.push({
      title: "Disconnecting...",
      task: () => ssh.dispose()
    });
    servers.push({
      title: serverConfig.host,
      task: () => {
        return new import_listr2.Listr(tasks);
      }
    });
  }
  return servers;
};
const handler = async (yargs) => {
  (0, import_cli_helpers.recordTelemetryAttributes)({
    command: "deploy baremetal",
    firstRun: yargs.firstRun,
    df: yargs.df,
    update: yargs.update,
    install: yargs.install,
    migrate: yargs.migrate,
    build: yargs.build,
    restart: yargs.restart,
    cleanup: yargs.cleanup,
    maintenance: yargs.maintenance,
    rollback: yargs.rollback,
    verbose: yargs.verbose
  });
  const tomlPath = import_path.default.join((0, import_lib.getPaths)().base, "deploy.toml");
  const ecosystemPath = import_path.default.join((0, import_lib.getPaths)().base, "ecosystem.config.js");
  if (!import_fs_extra.default.existsSync(tomlPath) || !import_fs_extra.default.existsSync(ecosystemPath)) {
    console.error(
      import_colors.default.error("\nError: Baremetal deploy has not been properly setup.\n") + "Please run `yarn rw setup deploy baremetal` before deploying"
    );
    process.exit(1);
  }
  const ssh = new import_SshExecutor.SshExecutor(yargs.verbose);
  try {
    const tasks = new import_listr2.Listr(commands(yargs, ssh), {
      concurrent: true,
      exitOnError: true,
      renderer: yargs.verbose && "verbose"
    });
    await tasks.run();
  } catch (e) {
    console.error(import_colors.default.error("\nDeploy failed:"));
    console.error(
      (0, import_boxen.default)(e.stderr || e.message, {
        padding: { top: 0, bottom: 0, right: 1, left: 1 },
        margin: 0,
        borderColor: "red"
      })
    );
    process.exit(e?.exitCode || 1);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_SERVER_CONFIG,
  builder,
  command,
  commandWithLifecycleEvents,
  commands,
  deployTasks,
  description,
  execaOptions,
  handler,
  lifecycleTask,
  maintenanceTasks,
  parseConfig,
  rollbackTasks,
  serverConfigWithDefaults,
  throwMissingConfig,
  verifyConfig,
  verifyServerConfig
});
