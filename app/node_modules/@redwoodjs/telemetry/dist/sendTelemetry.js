"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var sendTelemetry_exports = {};
__export(sendTelemetry_exports, {
  sanitizeArgv: () => sanitizeArgv,
  sendTelemetry: () => sendTelemetry
});
module.exports = __toCommonJS(sendTelemetry_exports);
var import_fs = __toESM(require("fs"));
var import_os = __toESM(require("os"));
var import_path = __toESM(require("path"));
var import_fetch = require("@whatwg-node/fetch");
var import_ci_info = __toESM(require("ci-info"));
var import_envinfo = __toESM(require("envinfo"));
var import_systeminformation = __toESM(require("systeminformation"));
var import_uuid = require("uuid");
var import_project_config = require("@redwoodjs/project-config");
const { DefaultHost } = require("@redwoodjs/structure/dist/hosts");
const { RWProject } = require("@redwoodjs/structure/dist/model/RWProject");
const SENSITIVE_ARG_POSITIONS = {
  exec: {
    positions: [1],
    redactWith: ["[script]"],
    allowOnly: ["exec"]
  },
  g: {
    positions: [2, 3],
    redactWith: ["[name]", "[path]"]
  },
  generate: {
    positions: [2, 3],
    redactWith: ["[name]", "[path]"]
  },
  prisma: {
    options: ["--name"],
    redactWith: ["[name]"]
  },
  lint: {
    allowOnly: ["lint", "--fix"],
    redactWith: ["[path]"]
  }
};
const getInfo = async (presets = {}) => {
  const info = JSON.parse(
    await import_envinfo.default.run(
      {
        System: ["OS", "Shell"],
        Binaries: ["Node", "Yarn", "npm"],
        npmPackages: "@redwoodjs/*",
        IDEs: ["VSCode"]
      },
      { json: true }
    )
  );
  const shell = info.System?.Shell;
  if (shell?.path?.match("/")) {
    info.System.Shell.name = info.System.Shell.path.split("/").pop();
  } else if (shell?.path.match("\\")) {
    info.System.Shell.name = info.System.Shell.path.split("\\").pop();
  }
  const cpu = await import_systeminformation.default.cpu();
  const mem = await import_systeminformation.default.mem();
  const experiments = Object.keys((0, import_project_config.getRawConfig)()["experimental"] || {});
  return {
    os: info.System?.OS?.split(" ")[0],
    osVersion: info.System?.OS?.split(" ")[1],
    shell: info.System?.Shell?.name,
    nodeVersion: info.Binaries?.Node?.version,
    yarnVersion: info.Binaries?.Yarn?.version,
    npmVersion: info.Binaries?.npm?.version,
    vsCodeVersion: info.IDEs?.VSCode?.version,
    redwoodVersion: presets.redwoodVersion || info.npmPackages["@redwoodjs/core"]?.installed,
    system: `${cpu.physicalCores}.${Math.round(mem.total / 1073741824)}`,
    webBundler: "vite",
    // Hardcoded as this is now the only supported bundler
    experiments
  };
};
const sanitizeArgv = (argv) => {
  const name = argv[2];
  const sensitiveCommand = SENSITIVE_ARG_POSITIONS[name];
  const args = argv.slice(2);
  if (sensitiveCommand) {
    if (sensitiveCommand.positions) {
      sensitiveCommand.positions.forEach((pos, index) => {
        if (args[pos] && !args[pos].includes("--")) {
          args[pos] = sensitiveCommand.redactWith[index];
        }
      });
    }
    if (sensitiveCommand.options) {
      sensitiveCommand.options.forEach((option, index) => {
        const argIndex = args.indexOf(option);
        if (argIndex !== -1) {
          args[argIndex + 1] = sensitiveCommand.redactWith[index];
        }
      });
    }
    if (sensitiveCommand.allowOnly) {
      args.forEach((arg, index) => {
        if (!sensitiveCommand.allowOnly?.includes(arg) && !sensitiveCommand.redactWith.includes(arg)) {
          args[index] = sensitiveCommand.redactWith[0];
        }
      });
    }
  }
  return args.join(" ");
};
const buildPayload = async () => {
  let payload = {};
  let project;
  const processArgv = [...process.argv];
  if (import_os.default.type() === "Windows_NT") {
    const argvIndex = processArgv.findIndex((arg) => arg === "--argv") + 1;
    let argvFormatted = argvIndex !== 0 ? processArgv[argvIndex] : null;
    if (argvFormatted) {
      argvFormatted = "[" + argvFormatted.substring(1, argvFormatted.length - 1).split(",").map((arg) => {
        return arg.startsWith('"') || arg.startsWith("'") ? arg : `"${arg}"`;
      }).join(",") + "]";
      processArgv[argvIndex] = argvFormatted;
    }
  }
  const argv = require("yargs/yargs")(processArgv.slice(2)).parse();
  const rootDir = argv.root;
  const command = argv.argv ? sanitizeArgv(JSON.parse(argv.argv)) : "";
  payload = {
    type: argv.type || "command",
    command,
    duration: argv.duration ? parseInt(argv.duration) : null,
    uid: uniqueId(rootDir) || null,
    ci: import_ci_info.default.isCI,
    redwoodCi: !!process.env.REDWOOD_CI,
    NODE_ENV: process.env.NODE_ENV || null,
    ...await getInfo({ redwoodVersion: argv.rwVersion, command })
  };
  if (argv.error) {
    payload.type = "error";
    payload.error = argv.error.split("\n")[0].replace(/(\/[@\-\.\w]+)/g, "[path]");
  }
  if (rootDir) {
    project = new RWProject({
      projectRoot: rootDir,
      host: new DefaultHost()
    });
  }
  const routes = project.getRouter().routes;
  const prerenderedRoutes = routes.filter((route) => route.hasPrerender);
  payload = {
    ...payload,
    complexity: `${routes.length}.${prerenderedRoutes.length}.${project.services.length}.${project.cells.length}.${project.pages.length}`,
    sides: project.sides.join(",")
  };
  return payload;
};
const uniqueId = (rootDir) => {
  const telemetryCachePath = import_path.default.join(
    rootDir || "/tmp",
    ".redwood",
    "telemetry.txt"
  );
  const now = Date.now();
  const expires = now - 24 * 60 * 60 * 1e3;
  let uuid;
  if (!import_fs.default.existsSync(telemetryCachePath) || import_fs.default.statSync(telemetryCachePath).mtimeMs < expires) {
    uuid = (0, import_uuid.v4)();
    try {
      if (!import_fs.default.existsSync(import_path.default.dirname(telemetryCachePath))) {
        import_fs.default.mkdirSync(import_path.default.dirname(telemetryCachePath), { recursive: true });
      }
      import_fs.default.writeFileSync(telemetryCachePath, uuid);
    } catch {
      console.error("\nCould not create telemetry.txt file\n");
    }
  } else {
    uuid = import_fs.default.readFileSync(telemetryCachePath).toString();
  }
  return uuid;
};
const sendTelemetry = async () => {
  const telemetryUrl = process.env.REDWOOD_REDIRECT_TELEMETRY || "https://telemetry.redwoodjs.com/api/v1/telemetry";
  try {
    const payload = await buildPayload();
    if (process.env.REDWOOD_VERBOSE_TELEMETRY) {
      console.info("Redwood Telemetry Payload", payload);
    }
    const response = await (0, import_fetch.fetch)(telemetryUrl, {
      method: "post",
      body: JSON.stringify(payload),
      headers: { "Content-Type": "application/json" }
    });
    if (process.env.REDWOOD_VERBOSE_TELEMETRY) {
      console.info("Redwood Telemetry Response:", response);
    }
    if (process.env.REDWOOD_VERBOSE_TELEMETRY && response.status !== 200) {
      console.error("Error from telemetry insert:", await response.text());
    }
  } catch (e) {
    if (process.env.REDWOOD_VERBOSE_TELEMETRY) {
      console.error("Uncaught error in telemetry:", e);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  sanitizeArgv,
  sendTelemetry
});
