"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useRedwoodDirective_exports = {};
__export(useRedwoodDirective_exports, {
  DirectiveType: () => DirectiveType,
  getDirectiveByName: () => getDirectiveByName,
  hasDirective: () => hasDirective,
  isPromise: () => isPromise,
  useRedwoodDirective: () => useRedwoodDirective
});
module.exports = __toCommonJS(useRedwoodDirective_exports);
var import_utils = require("@graphql-tools/utils");
var import_graphql = require("graphql");
var DirectiveType = /* @__PURE__ */ ((DirectiveType2) => {
  DirectiveType2["VALIDATOR"] = "VALIDATOR_DIRECTIVE";
  DirectiveType2["TRANSFORMER"] = "TRANSFORMER_DIRECTIVE";
  return DirectiveType2;
})(DirectiveType || {});
function hasDirective(info) {
  try {
    const { parentType, fieldName, schema } = info;
    const schemaType = schema.getType(parentType.name);
    const field = schemaType.getFields()[fieldName];
    const astNode = field.astNode;
    return !!astNode?.directives?.length;
  } catch (error) {
    console.error(error);
    return false;
  }
}
function getDirectiveByName(fieldConfig, directiveName) {
  const associatedDirective = fieldConfig.astNode?.directives?.find(
    (directive) => directive.name.value === directiveName
  );
  return associatedDirective ?? null;
}
function isPromise(value) {
  return typeof value?.then === "function";
}
function wrapAffectedResolvers(schema, options) {
  return (0, import_utils.mapSchema)(schema, {
    [import_utils.MapperKind.OBJECT_FIELD](fieldConfig, _, __, schema2) {
      const directiveNode = getDirectiveByName(fieldConfig, options.name);
      const directive = directiveNode ? schema2.getDirective(directiveNode.name.value) : null;
      if (directiveNode && directive) {
        const directiveArgs = (0, import_graphql.getDirectiveValues)(directive, { directives: [directiveNode] }) || {};
        const originalResolve = fieldConfig.resolve ?? import_graphql.defaultFieldResolver;
        const originalSubscribe = fieldConfig.subscribe ?? import_graphql.defaultFieldResolver;
        if (_isValidator(options)) {
          return {
            ...fieldConfig,
            resolve: function useRedwoodDirectiveValidatorResolver(root, args, context, info) {
              const result = options.onResolvedValue({
                root,
                args,
                context,
                info,
                directiveNode,
                directiveArgs
              });
              if (isPromise(result)) {
                return result.then(
                  () => originalResolve(root, args, context, info)
                );
              }
              return originalResolve(root, args, context, info);
            },
            subscribe: function useRedwoodDirectiveValidatorResolver(root, args, context, info) {
              const result = options.onResolvedValue({
                root,
                args,
                context,
                info,
                directiveNode,
                directiveArgs
              });
              if (isPromise(result)) {
                return result.then(
                  () => originalSubscribe(root, args, context, info)
                );
              }
              return originalSubscribe(root, args, context, info);
            }
          };
        }
        if (_isTransformer(options)) {
          return {
            ...fieldConfig,
            resolve: function useRedwoodDirectiveTransformerResolver(root, args, context, info) {
              const resolvedValue = originalResolve(root, args, context, info);
              if (isPromise(resolvedValue)) {
                return resolvedValue.then(
                  (resolvedValue2) => options.onResolvedValue({
                    root,
                    args,
                    context,
                    info,
                    directiveNode,
                    directiveArgs,
                    resolvedValue: resolvedValue2
                  })
                );
              }
              return options.onResolvedValue({
                root,
                args,
                context,
                info,
                directiveNode,
                directiveArgs,
                resolvedValue
              });
            }
          };
        }
      }
      return fieldConfig;
    }
  });
}
const useRedwoodDirective = (options) => {
  const wasDirectiveApplied = Symbol.for(`useRedwoodDirective.${options.name}}`);
  return {
    onSchemaChange({ schema, replaceSchema }) {
      if (schema.extensions?.[wasDirectiveApplied] === true) {
        return;
      }
      const transformedSchema = wrapAffectedResolvers(schema, options);
      transformedSchema.extensions = {
        ...schema.extensions,
        [wasDirectiveApplied]: true
      };
      replaceSchema(transformedSchema);
    }
  };
};
const _isValidator = (options) => {
  return options.type === "VALIDATOR_DIRECTIVE" /* VALIDATOR */;
};
const _isTransformer = (options) => {
  return options.type === "TRANSFORMER_DIRECTIVE" /* TRANSFORMER */;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DirectiveType,
  getDirectiveByName,
  hasDirective,
  isPromise,
  useRedwoodDirective
});
