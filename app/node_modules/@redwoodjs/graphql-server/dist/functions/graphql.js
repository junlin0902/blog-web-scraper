"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var graphql_exports = {};
__export(graphql_exports, {
  createGraphQLHandler: () => createGraphQLHandler
});
module.exports = __toCommonJS(graphql_exports);
var import_store = require("@redwoodjs/context/dist/store");
var import_createGraphQLYoga = require("../createGraphQLYoga");
const createGraphQLHandler = ({
  healthCheckId,
  loggerConfig,
  context,
  getCurrentUser,
  onException,
  generateGraphiQLHeader,
  extraPlugins,
  authDecoder,
  cors,
  services,
  sdls,
  directives = [],
  armorConfig,
  allowedOperations,
  allowIntrospection,
  allowGraphiQL,
  defaultError = "Something went wrong.",
  graphiQLEndpoint = "/graphql",
  schemaOptions,
  openTelemetryOptions,
  trustedDocuments
}) => {
  const { yoga, logger } = (0, import_createGraphQLYoga.createGraphQLYoga)({
    healthCheckId,
    loggerConfig,
    context,
    getCurrentUser,
    onException,
    generateGraphiQLHeader,
    extraPlugins,
    authDecoder,
    cors,
    services,
    sdls,
    directives,
    armorConfig,
    allowedOperations,
    allowIntrospection,
    allowGraphiQL,
    defaultError,
    graphiQLEndpoint,
    schemaOptions,
    openTelemetryOptions,
    trustedDocuments
  });
  const handlerFn = async (event, requestContext) => {
    requestContext.callbackWaitsForEmptyEventLoop = false;
    let lambdaResponse;
    try {
      const [, rest = ""] = event.path.split(graphiQLEndpoint);
      const url = new URL(graphiQLEndpoint + rest, "http://localhost");
      if (event.queryStringParameters != null) {
        for (const queryName in event.queryStringParameters) {
          const queryValue = event.queryStringParameters[queryName];
          if (queryValue != null) {
            url.searchParams.set(queryName, queryValue);
          }
        }
      }
      const response = await yoga.fetch(
        url,
        {
          method: event.httpMethod,
          headers: event.headers,
          body: event.body ? Buffer.from(event.body, event.isBase64Encoded ? "base64" : "utf8") : void 0
        },
        {
          event,
          requestContext
        }
      );
      const responseHeaders = {};
      response.headers.forEach((value, name) => {
        responseHeaders[name] = value;
      });
      lambdaResponse = {
        body: await response.text(),
        statusCode: response.status,
        headers: responseHeaders,
        isBase64Encoded: false
      };
    } catch (e) {
      logger.error(e);
      if (onException) {
        onException();
      }
      lambdaResponse = {
        body: JSON.stringify({ error: "GraphQL execution failed" }),
        statusCode: 200
        // should be 500
      };
    }
    if (!lambdaResponse.headers) {
      lambdaResponse.headers = {};
    }
    return lambdaResponse;
  };
  return (event, context2) => {
    const execFn = async () => {
      try {
        return await handlerFn(event, context2);
      } catch (e) {
        if (onException) {
          onException();
        }
        throw e;
      }
    };
    return (0, import_store.getAsyncStoreInstance)().run(/* @__PURE__ */ new Map(), execFn);
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createGraphQLHandler
});
