"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var makeMergedSchema_exports = {};
__export(makeMergedSchema_exports, {
  makeMergedSchema: () => makeMergedSchema
});
module.exports = __toCommonJS(makeMergedSchema_exports);
var import_merge = require("@graphql-tools/merge");
var import_schema = require("@graphql-tools/schema");
var opentelemetry = __toESM(require("@opentelemetry/api"));
var import_lodash = require("lodash");
var rootGqlSchema = __toESM(require("./rootSchema"));
const wrapWithOpenTelemetry = async (func, args, root, context, info, name) => {
  const tracer = opentelemetry.trace.getTracer("redwoodjs");
  const parentSpan = context !== null && context["OPEN_TELEMETRY_GRAPHQL"];
  const parentContext = parentSpan ? opentelemetry.trace.setSpan(opentelemetry.context.active(), parentSpan) : opentelemetry.context.active();
  return await tracer.startActiveSpan(
    `redwoodjs:graphql:resolver:${name}`,
    {},
    parentContext,
    async (span) => {
      span.setAttribute(
        "graphql.execute.operationName",
        `${args.operationName || "Anonymous Operation"}`
      );
      try {
        const result = await func(args, {
          root,
          context,
          info
        });
        span.end();
        return result;
      } catch (ex) {
        span.recordException(ex);
        span.setStatus({ code: opentelemetry.SpanStatusCode.ERROR });
        span.end();
        throw ex;
      }
    }
  );
};
const mapFieldsToService = ({
  fields = {},
  resolvers: unmappedResolvers,
  services
}) => Object.keys(fields).reduce((resolvers, name) => {
  if (resolvers?.[name]) {
    return resolvers;
  }
  if (services?.[name]) {
    return {
      ...resolvers,
      // Map the arguments from GraphQL to an ordinary function a service would
      // expect.
      [name]: async (root, args, context, info) => {
        const captureResolvers = (
          // @ts-expect-error context is unknown
          context && context["OPEN_TELEMETRY_GRAPHQL"] !== void 0
        );
        if (captureResolvers) {
          return wrapWithOpenTelemetry(
            services[name],
            args,
            root,
            context,
            info,
            name
          );
        }
        return services[name](args, { root, context, info });
      }
    };
  }
  return resolvers;
}, unmappedResolvers);
const resolveUnionType = (types) => ({
  __resolveType(obj) {
    if (Object.hasOwn(obj, "__typename")) {
      for (const type of types) {
        if (type.name === obj["__typename"]) {
          return type.name;
        }
      }
    }
    const fieldIntersections = new Array(types.length).fill(0);
    let maxIntersectionFields = 0;
    let maxIntersectionType;
    let maxIntersectionIdx = 0;
    for (let i = 0; i < types.length; i++) {
      const type = types[i];
      const fieldIntersection = Object.keys(type.getFields()).filter(
        (field) => field in obj
      );
      fieldIntersections[i] = fieldIntersection.length;
      if (fieldIntersection.length > maxIntersectionFields) {
        maxIntersectionFields = fieldIntersection.length;
        maxIntersectionType = type;
        maxIntersectionIdx = i;
      }
    }
    if (fieldIntersections.includes(maxIntersectionFields, maxIntersectionIdx + 1)) {
      throw Error(
        "Unable to resolve correct type for union. Try adding unique fields to each type or __typename to each resolver"
      );
    }
    return maxIntersectionType?.name ?? null;
  }
});
const mergeResolversWithServices = ({
  schema,
  resolvers,
  services
}) => {
  const mergedServices = (0, import_lodash.merge)(
    {},
    ...Object.keys(services).map((name) => services[name])
  );
  const typesWithFields = Object.keys(schema.getTypeMap()).filter((name) => !name.startsWith("_")).filter(
    (name) => typeof schema.getType(name).getFields !== "undefined"
  ).map((name) => {
    return schema.getType(name);
  }).filter(
    (type) => type !== void 0 && type !== null
  );
  const unionTypes = Object.keys(schema.getTypeMap()).filter(
    (name) => typeof schema.getType(name).getTypes !== "undefined"
  ).map((name) => {
    return schema.getType(name);
  }).filter(
    (type) => type !== void 0 && type !== null
  );
  const mappedResolvers = typesWithFields.reduce((acc, type) => {
    let servicesForType = mergedServices;
    if (!["Query", "Mutation", "Subscription"].includes(type.name)) {
      servicesForType = mergedServices?.[type.name];
    }
    return {
      ...acc,
      [type.name]: mapFieldsToService({
        fields: type.getFields(),
        resolvers: resolvers?.[type.name],
        services: servicesForType
      })
    };
  }, {});
  const mappedUnionResolvers = unionTypes.reduce((acc, type) => {
    return {
      ...acc,
      [type.name]: resolveUnionType(type.getTypes())
    };
  }, {});
  return (0, import_lodash.omitBy)(
    {
      ...resolvers,
      ...mappedResolvers,
      ...mappedUnionResolvers
    },
    (v) => typeof v === "undefined"
  );
};
const mergeResolvers = (schemas) => (0, import_lodash.omitBy)(
  (0, import_lodash.merge)(
    {},
    ...[
      rootGqlSchema.resolvers,
      ...Object.values(schemas).map(({ resolvers }) => resolvers)
    ]
  ),
  (v) => typeof v === "undefined"
);
const mergeTypes = (types, options) => {
  const schemaDefinition = options && typeof options.schemaDefinition === "boolean" ? options.schemaDefinition : true;
  return (0, import_merge.mergeTypeDefs)(types, {
    useSchemaDefinition: schemaDefinition,
    forceSchemaDefinition: schemaDefinition,
    throwOnConflict: true,
    commentDescriptions: true,
    reverseDirectives: true,
    ...options
  });
};
const mergeResolversWithSubscriptions = ({
  schema,
  subscriptions,
  resolverValidationOptions,
  inheritResolversFromInterfaces
}) => {
  if (subscriptions && subscriptions.length > 0) {
    const subscriptionResolvers = { Subscription: {} };
    subscriptions?.forEach((subscription) => {
      subscriptionResolvers["Subscription"] = {
        ...subscriptionResolvers["Subscription"],
        ...subscription.resolvers
      };
    });
    return (0, import_schema.addResolversToSchema)({
      schema,
      resolvers: subscriptionResolvers,
      resolverValidationOptions,
      inheritResolversFromInterfaces
    });
  }
  return schema;
};
const makeMergedSchema = ({
  sdls,
  services,
  schemaOptions = {},
  directives,
  subscriptions = [],
  includeScalars
}) => {
  const sdlSchemas = Object.values(sdls).map(({ schema: schema2 }) => schema2);
  const rootEntries = [rootGqlSchema.schema];
  if (includeScalars?.File !== false) {
    rootEntries.push(rootGqlSchema.scalarSchemas.File);
  }
  const typeDefs = mergeTypes(
    [
      ...rootEntries,
      ...directives.map((directive) => directive.schema),
      // pick out schemas from directives
      ...subscriptions.map((subscription) => subscription.schema),
      // pick out schemas from subscriptions
      ...sdlSchemas
      // pick out the schemas from sdls
    ],
    { all: true }
  );
  const { typeDefs: schemaOptionsTypeDefs = [], ...otherSchemaOptions } = schemaOptions;
  const schema = (0, import_schema.makeExecutableSchema)({
    typeDefs: [typeDefs, schemaOptionsTypeDefs],
    ...otherSchemaOptions
  });
  const resolvers = mergeResolversWithServices({
    schema,
    resolvers: mergeResolvers(sdls),
    services
  });
  const schemaWithSubscriptions = mergeResolversWithSubscriptions({
    schema,
    subscriptions
  });
  const { resolverValidationOptions, inheritResolversFromInterfaces } = schemaOptions || {};
  return (0, import_schema.addResolversToSchema)({
    schema: schemaWithSubscriptions,
    resolvers,
    resolverValidationOptions,
    inheritResolversFromInterfaces
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  makeMergedSchema
});
