"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var babel_plugin_redwood_graphql_options_extract_exports = {};
__export(babel_plugin_redwood_graphql_options_extract_exports, {
  default: () => babel_plugin_redwood_graphql_options_extract_default
});
module.exports = __toCommonJS(babel_plugin_redwood_graphql_options_extract_exports);
const exportVariableName = "__rw_graphqlOptions";
function optionsConstNode(t, value, state) {
  if (t.isIdentifier(value) || t.isObjectExpression(value) || t.isCallExpression(value) || t.isConditionalExpression(value)) {
    return t.exportNamedDeclaration(
      t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier(exportVariableName), value)
      ])
    );
  } else {
    throw new Error(
      `Unable to parse graphql function options in '${state.file.opts.filename}'`
    );
  }
}
function babel_plugin_redwood_graphql_options_extract_default({ types: t }) {
  return {
    name: "babel-plugin-redwood-graphql-options-extract",
    visitor: {
      Program(path, state) {
        const importNames = /* @__PURE__ */ new Set();
        path.traverse({
          ImportDeclaration(p) {
            if (t.isStringLiteral(p.node.source, {
              value: "@redwoodjs/graphql-server"
            })) {
              for (const specifier of p.node.specifiers) {
                if (t.isImportSpecifier(specifier) && t.isIdentifier(specifier.imported) && specifier.imported.name === "createGraphQLHandler") {
                  importNames.add(specifier.local.name);
                }
              }
            }
          }
        });
        const callExpressionPaths = [];
        path.traverse({
          CallExpression(p) {
            if (t.isIdentifier(p.node.callee) && importNames.has(p.node.callee.name)) {
              callExpressionPaths.push(p);
            }
          }
        });
        if (callExpressionPaths.length > 1) {
          console.log(
            `There are ${callExpressionPaths.length} calls to 'createGraphQLHandler' in '${state.file.opts.filename}'. The automatic extraction of graphql options will fallback to the first usage.`
          );
          return;
        }
        const callExpressionPath = callExpressionPaths[0];
        if (!callExpressionPath) {
          return;
        }
        const options = callExpressionPath.node.arguments[0];
        const optionsConst = optionsConstNode(t, options, state);
        const statementParent = callExpressionPath.getStatementParent();
        if (!statementParent) {
          throw new Error(
            `Unable to find statement parent for graphql function in '${state.file.opts.filename}'`
          );
        }
        statementParent.insertBefore(optionsConst);
        callExpressionPath.node.arguments[0] = t.identifier(exportVariableName);
      }
    }
  };
}
