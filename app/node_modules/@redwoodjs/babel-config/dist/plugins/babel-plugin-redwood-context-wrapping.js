"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var babel_plugin_redwood_context_wrapping_exports = {};
__export(babel_plugin_redwood_context_wrapping_exports, {
  default: () => babel_plugin_redwood_context_wrapping_default
});
module.exports = __toCommonJS(babel_plugin_redwood_context_wrapping_exports);
function generateWrappedHandler(t, isAsync) {
  const contextStoreVariableDeclaration = t.variableDeclaration("const", [
    t.variableDeclarator(
      t.identifier("__rw_contextStore"),
      t.callExpression(
        t.memberExpression(
          t.callExpression(t.identifier("__rw_getAsyncStoreInstance"), []),
          t.identifier("getStore")
        ),
        []
      )
    )
  ]);
  t.addComment(
    contextStoreVariableDeclaration,
    "leading",
    " The store will be undefined if no context isolation has been performed yet",
    true
  );
  return t.arrowFunctionExpression(
    [t.identifier("__rw_event"), t.identifier("__rw__context")],
    t.blockStatement([
      contextStoreVariableDeclaration,
      t.ifStatement(
        t.binaryExpression(
          "===",
          t.identifier("__rw_contextStore"),
          t.identifier("undefined")
        ),
        t.blockStatement([
          t.returnStatement(
            t.callExpression(
              t.memberExpression(
                t.callExpression(
                  t.identifier("__rw_getAsyncStoreInstance"),
                  []
                ),
                t.identifier("run")
              ),
              [
                t.newExpression(t.identifier("Map"), []),
                t.identifier("__rw_handler"),
                t.identifier("__rw_event"),
                t.identifier("__rw__context")
              ]
            )
          )
        ])
      ),
      t.returnStatement(
        t.callExpression(t.identifier("__rw_handler"), [
          t.identifier("__rw_event"),
          t.identifier("__rw__context")
        ])
      )
    ]),
    isAsync
  );
}
function babel_plugin_redwood_context_wrapping_default({ types: t }, { projectIsEsm = false } = {}) {
  return {
    name: "babel-plugin-redwood-context-wrapping",
    visitor: {
      ExportNamedDeclaration(path, _state) {
        const declaration = path.node.declaration;
        if (!t.isVariableDeclaration(declaration)) {
          return;
        }
        const identifier = declaration.declarations[0].id;
        if (!t.isIdentifier(identifier)) {
          return;
        }
        if (identifier.name !== "handler") {
          return;
        }
        const parentNode = path.parentPath.node;
        if (!t.isProgram(parentNode)) {
          return;
        }
        path.insertBefore(
          // import { getAsyncStoreInstance as __rw_getAsyncStoreInstance } from '@redwoodjs/context/dist/store'
          t.importDeclaration(
            [
              t.importSpecifier(
                t.identifier("__rw_getAsyncStoreInstance"),
                t.identifier("getAsyncStoreInstance")
              )
            ],
            t.stringLiteral(
              projectIsEsm ? "@redwoodjs/context/dist/store.js" : "@redwoodjs/context/dist/store"
            )
          )
        );
        path.insertBefore(
          t.variableDeclaration("const", [
            t.variableDeclarator(
              t.identifier("__rw_handler"),
              declaration.declarations[0].init
            )
          ])
        );
        let isAsync = false;
        const originalInit = declaration.declarations[0].init;
        if (t.isFunction(originalInit)) {
          isAsync = originalInit.async;
        }
        declaration.declarations[0].init = generateWrappedHandler(t, isAsync);
      }
    }
  };
}
