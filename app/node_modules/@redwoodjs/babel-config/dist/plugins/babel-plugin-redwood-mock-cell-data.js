"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var babel_plugin_redwood_mock_cell_data_exports = {};
__export(babel_plugin_redwood_mock_cell_data_exports, {
  default: () => babel_plugin_redwood_mock_cell_data_default,
  getCellMetadata: () => getCellMetadata
});
module.exports = __toCommonJS(babel_plugin_redwood_mock_cell_data_exports);
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_parser = require("@babel/parser");
var import_traverse = __toESM(require("@babel/traverse"));
var import_fast_glob = __toESM(require("fast-glob"));
var import_graphql = require("graphql");
function babel_plugin_redwood_mock_cell_data_default({ types: t }) {
  let nodesToRemove = [];
  let nodesToInsert = [];
  const createExportStandard = (ex) => t.exportNamedDeclaration(
    t.variableDeclaration("const", [
      t.variableDeclarator(t.identifier("standard"), ex)
    ])
  );
  return {
    name: "babel-plugin-redwood-mock-cell-data",
    visitor: {
      Program: {
        enter() {
          nodesToRemove = [];
          nodesToInsert = [];
        },
        exit(p) {
          for (const n of nodesToRemove) {
            n.remove();
          }
          p.node.body.unshift(...nodesToInsert);
        }
      },
      ExportNamedDeclaration(p, state) {
        const d = p.node.declaration;
        let mockFunction;
        switch (d?.type) {
          case "VariableDeclaration":
            {
              const standardMockExport = d.declarations[0];
              const id = standardMockExport.id;
              const exportName = id?.name;
              if (exportName !== "standard") {
                return;
              }
              const mockFunctionMaybe = standardMockExport?.init;
              if (!mockFunctionMaybe) {
                return;
              }
              if (mockFunctionMaybe.type !== "ArrowFunctionExpression" && mockFunctionMaybe.type !== "FunctionExpression") {
                throw new Error(
                  `
 
 Mock Error: You must export your standard mock as a function 
 
`
                );
              }
              mockFunction = mockFunctionMaybe;
            }
            break;
          case "FunctionDeclaration":
            {
              const exportName = d.id?.name;
              if (exportName !== "standard") {
                return;
              }
              mockFunction = t.arrowFunctionExpression(d.params, d.body);
            }
            break;
          default:
            return;
        }
        const dirname = import_path.default.dirname(state.file.opts.filename);
        const cellName = import_path.default.basename(dirname);
        const [cellPath] = import_fast_glob.default.sync(`${cellName}.{js,jsx,ts,tsx}`, {
          cwd: dirname,
          absolute: true,
          ignore: ["node_modules"]
        });
        if (!cellPath) {
          return;
        }
        const cellMetadata = getCellMetadata(cellPath);
        if (cellMetadata.hasDefaultExport || !cellMetadata.hasQueryExport) {
          return;
        }
        const mockGraphQLCall = t.callExpression(
          t.identifier("mockGraphQLQuery"),
          [t.stringLiteral(cellMetadata.operationName), mockFunction]
        );
        nodesToRemove = [...nodesToRemove, p];
        if (cellMetadata.hasAfterQueryExport) {
          const importAfterQuery = t.importDeclaration(
            [
              t.importSpecifier(
                t.identifier("afterQuery"),
                t.identifier("afterQuery")
              )
            ],
            t.stringLiteral(`./${import_path.default.basename(cellPath)}`)
          );
          nodesToInsert = [
            ...nodesToInsert,
            importAfterQuery,
            createExportStandard(
              t.arrowFunctionExpression(
                [],
                t.callExpression(t.identifier("afterQuery"), [
                  t.callExpression(mockGraphQLCall, [])
                ])
              )
            )
          ];
        } else {
          nodesToInsert = [
            ...nodesToInsert,
            createExportStandard(mockGraphQLCall)
          ];
        }
      }
    }
  };
}
const getCellMetadata = (p) => {
  const ast = getCellAst(p);
  let hasDefaultExport = false;
  const namedExports = [];
  let operation;
  (0, import_traverse.default)(ast, {
    ExportDefaultDeclaration() {
      hasDefaultExport = true;
      return;
    },
    ExportNamedDeclaration(path2) {
      const specifiers = path2.node?.specifiers;
      if (specifiers.length) {
        for (const s of specifiers) {
          const id = s.exported;
          namedExports.push({
            name: id.name,
            type: "re-export"
          });
        }
        return;
      }
      const declaration = path2.node.declaration;
      if (!declaration) {
        return;
      }
      if (declaration.type === "VariableDeclaration") {
        const id = declaration.declarations[0].id;
        namedExports.push({
          name: id.name,
          type: "variable"
        });
      } else if (declaration.type === "FunctionDeclaration") {
        namedExports.push({
          name: declaration?.id?.name,
          type: "function"
        });
      } else if (declaration.type === "ClassDeclaration") {
        namedExports.push({
          name: declaration?.id?.name,
          type: "class"
        });
      }
    },
    TaggedTemplateExpression(path2) {
      if (path2.parent?.id?.name !== "QUERY") {
        return;
      }
      operation = path2.node.quasi.quasis[0].value.raw;
    }
  });
  const hasQueryExport = namedExports.find(({ name }) => name === "QUERY");
  const hasAfterQueryExport = namedExports.find(
    ({ name }) => name === "afterQuery"
  );
  let operationName = "";
  if (operation) {
    const document = (0, import_graphql.parse)(operation);
    for (const definition of document.definitions) {
      if (definition.kind === import_graphql.Kind.OPERATION_DEFINITION && definition.name?.value) {
        operationName = definition.name.value;
      }
    }
  }
  return {
    hasDefaultExport,
    namedExports,
    hasQueryExport,
    hasAfterQueryExport,
    operationName
  };
};
function getCellAst(filePath) {
  const code = import_fs.default.readFileSync(filePath, "utf-8");
  const plugins = ["typescript", "jsx"].filter(Boolean);
  try {
    return (0, import_parser.parse)(code, {
      sourceType: "module",
      plugins
    });
  } catch (e) {
    console.error(`Error parsing: ${filePath}`);
    console.error(e);
    throw new Error(e?.message);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getCellMetadata
});
