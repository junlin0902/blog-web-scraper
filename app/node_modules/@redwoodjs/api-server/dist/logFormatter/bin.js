#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/logFormatter/bin.ts
var import_split2 = __toESM(require("split2"));

// src/logFormatter/index.ts
var import_fast_json_parse = __toESM(require("fast-json-parse"));

// src/logFormatter/formatters.ts
var import_chalk = __toESM(require("chalk"));
var import_pretty_bytes = __toESM(require("pretty-bytes"));
var import_pretty_ms = __toESM(require("pretty-ms"));
var NEWLINE = "\n";
var emojiLog = {
  warn: "\u{1F6A6}",
  info: "\u{1F332}",
  error: "\u{1F6A8}",
  debug: "\u{1F41B}",
  fatal: "\u{1F480}",
  trace: "\u{1F9F5}"
};
var ignoredCustomData = [
  "time",
  "pid",
  "hostname",
  "msg",
  "res",
  "req",
  "reqId",
  "responseTime"
];
var isObject = (object) => {
  return object && Object.prototype.toString.apply(object) === "[object Object]";
};
var isEmptyObject = (object) => {
  return object && !Object.keys(object).length;
};
var isPinoLog = (log) => {
  return log && Object.prototype.hasOwnProperty.call(log, "level");
};
var isWideEmoji = (character) => {
  return character !== "\u{1F6A6}";
};
var formatBundleSize = (bundle) => {
  const bytes = parseInt(bundle, 10);
  const size = (0, import_pretty_bytes.default)(bytes).replace(/ /, "");
  return import_chalk.default.gray(size);
};
var formatCustom = (query) => {
  if (!query) {
    return;
  }
  ignoredCustomData.forEach((key) => {
    delete query[key];
  });
  if (!isEmptyObject(query)) {
    return import_chalk.default.white(
      NEWLINE + "\u{1F5D2} Custom" + NEWLINE + JSON.stringify(query, null, 2)
    );
  }
  return;
};
var formatData = (data) => {
  if (!isEmptyObject(data)) {
    return import_chalk.default.white(
      NEWLINE + "\u{1F4E6} Result Data" + NEWLINE + JSON.stringify(data, null, 2)
    );
  }
  return;
};
var formatDate = (instant) => {
  const date = new Date(instant);
  const hours = date.getHours().toString().padStart(2, "0");
  const minutes = date.getMinutes().toString().padStart(2, "0");
  const seconds = date.getSeconds().toString().padStart(2, "0");
  const prettyDate = hours + ":" + minutes + ":" + seconds;
  return import_chalk.default.gray(prettyDate);
};
var formatErrorProp = (errorPropValue) => {
  const errorType = errorPropValue["type"] || "Error";
  delete errorPropValue["message"];
  delete errorPropValue["stack"];
  delete errorPropValue["type"];
  return import_chalk.default.redBright(
    NEWLINE + NEWLINE + `\u{1F6A8} ${errorType} Info` + NEWLINE + NEWLINE + JSON.stringify(errorPropValue, null, 2) + NEWLINE
  );
};
var formatLevel = (level) => {
  const emoji = emojiLog[level];
  const padding = isWideEmoji(emoji) ? "" : " ";
  return emoji + padding;
};
var formatLoadTime = (elapsedTime) => {
  const elapsed = parseInt(elapsedTime, 10);
  const time = (0, import_pretty_ms.default)(elapsed);
  return import_chalk.default.gray(time);
};
var formatMessage = (logData) => {
  const { level, message } = logData;
  const msg = formatMessageName(message);
  let pretty;
  if (level === "error") {
    pretty = import_chalk.default.red(msg);
  }
  if (level === "trace") {
    pretty = import_chalk.default.white(msg);
  }
  if (level === "warn") {
    const orange = "#ffa500";
    pretty = import_chalk.default.hex(orange)(msg);
  }
  if (level === "debug") {
    pretty = import_chalk.default.yellow(msg);
  }
  if (level === "info" || level === "customlevel") {
    pretty = import_chalk.default.green(msg);
  }
  if (level === "fatal") {
    pretty = import_chalk.default.white.bgRed(msg);
  }
  return pretty;
};
var formatMethod = (method) => {
  return method && import_chalk.default.white(method);
};
var formatRequestId = (requestId) => {
  return requestId && import_chalk.default.cyan(requestId);
};
var formatNs = (ns) => {
  return ns && import_chalk.default.cyan(ns);
};
var formatName = (name) => {
  return name && import_chalk.default.blue(name);
};
var formatMessageName = (message) => {
  if (message === void 0) {
    return "";
  }
  if (message === "request") {
    return "<--";
  }
  if (message === "response") {
    return "-->";
  }
  return message;
};
var formatOperationName = (operationName) => {
  return import_chalk.default.white(NEWLINE + "\u{1F3F7}  " + operationName);
};
var formatQuery = (query) => {
  if (!isEmptyObject(query)) {
    return import_chalk.default.white(
      NEWLINE + "\u{1F52D} Query" + NEWLINE + JSON.stringify(query, null, 2)
    );
  }
  return;
};
var formatResponseCache = (responseCache) => {
  if (!isEmptyObject(responseCache)) {
    return import_chalk.default.white(
      NEWLINE + "\u{1F4BE} Response Cache" + NEWLINE + JSON.stringify(responseCache, null, 2)
    );
  }
  return;
};
var formatStatusCode = (statusCode) => {
  statusCode = statusCode || "xxx";
  return import_chalk.default.white(statusCode);
};
var formatStack = (stack) => {
  return import_chalk.default.redBright(
    stack ? NEWLINE + "\u{1F95E} Error Stack" + NEWLINE + NEWLINE + stack + NEWLINE : ""
  );
};
var formatTracing = (data) => {
  if (!isEmptyObject(data)) {
    return import_chalk.default.white(
      NEWLINE + "\u23F0 Timing" + NEWLINE + JSON.stringify(data, null, 2)
    );
  }
  return;
};
var formatUrl = (url) => {
  return import_chalk.default.white(url);
};
var formatUserAgent = (userAgent) => {
  return import_chalk.default.grey(NEWLINE + "\u{1F575}\uFE0F\u200D\u2640\uFE0F " + userAgent);
};
var noEmpty = (value) => {
  return !!value;
};

// src/logFormatter/index.ts
var LogFormatter = () => {
  const parse = (inputData) => {
    let logData;
    if (typeof inputData === "string") {
      const parsedData = (0, import_fast_json_parse.default)(inputData);
      if (!parsedData.value || parsedData.err || !isPinoLog(parsedData.value)) {
        return inputData + NEWLINE;
      }
      logData = parsedData.value;
    } else if (isObject(inputData) && isPinoLog(inputData)) {
      logData = inputData;
    } else {
      return inputData + NEWLINE;
    }
    if (!logData.level) {
      return inputData + NEWLINE;
    }
    if (!logData.message) {
      logData.message = logData.msg;
    }
    if (typeof logData.level === "number") {
      convertLogNumber(logData);
    }
    return output2(logData) + NEWLINE;
  };
  const convertLogNumber = (logData) => {
    if (logData.level === 10) {
      logData.level = "trace";
    }
    if (logData.level === 20) {
      logData.level = "debug";
    }
    if (logData.level === 30) {
      logData.level = "info";
    }
    if (logData.level === 40) {
      logData.level = "warn";
    }
    if (logData.level === 50) {
      logData.level = "error";
    }
    if (logData.level === 60) {
      logData.level = "fatal";
    }
  };
  const output2 = (logData) => {
    const output3 = [];
    output3.push(formatDate(logData.time || Date.now()));
    output3.push(formatLevel(logData.level));
    output3.push(formatNs(logData.ns));
    output3.push(formatName(logData.name));
    output3.push(formatRequestId(logData.requestId));
    output3.push(formatMessage(logData));
    const req = logData.req;
    const res = logData.res;
    const { statusCode: responseStatusCode } = res || {};
    const { method: requestMethod, url: requestUrl } = req || {};
    const {
      level,
      message,
      name,
      ns,
      err: logDataErr,
      stack: logDataStack,
      statusCode: logDataStatusCode,
      elapsed,
      responseTime: logDataResponseTime,
      method: logDataMethod,
      custom,
      contentLength,
      operationName,
      query,
      data: graphQLData,
      responseCache,
      tracing,
      url: logDataUrl,
      userAgent,
      ...rest
    } = logData;
    const statusCode = responseStatusCode || logDataStatusCode;
    const responseTime = logDataResponseTime || elapsed;
    const method = requestMethod || logDataMethod;
    const url = requestUrl || logDataUrl;
    const logDataErrStack = logDataErr && logDataErr.stack;
    const stack = level === "fatal" || level === "error" ? logDataStack || logDataErr && logDataErrStack : null;
    const err = (level === "fatal" || level === "error") && logDataErr && Object.keys(logDataErr).find((key) => key !== "stack") ? logDataErr : null;
    if (!message) {
      logData.message = "";
    }
    if (!level) {
      logData.level = "customlevel";
    }
    if (!name) {
      logData.name = "";
    }
    if (!ns) {
      logData.ns = "";
    }
    if (method != null) {
      output3.push(formatMethod(method));
      output3.push(formatStatusCode(statusCode));
    }
    if (url != null) {
      output3.push(formatUrl(url));
    }
    if (contentLength != null) {
      output3.push(formatBundleSize(contentLength));
    }
    if (custom) {
      output3.push(formatCustom(custom));
    }
    if (responseTime != null) {
      output3.push(formatLoadTime(responseTime));
    }
    if (userAgent != null) {
      output3.push(formatUserAgent(userAgent));
    }
    if (operationName != null) {
      output3.push(formatOperationName(operationName));
    }
    if (query != null) {
      output3.push(formatQuery(query));
    }
    if (graphQLData != null) {
      output3.push(formatData(graphQLData));
    }
    if (responseCache != null) {
      output3.push(formatResponseCache(responseCache));
    }
    if (tracing != null) {
      output3.push(formatTracing(tracing));
    }
    if (err != null) {
      output3.push(formatErrorProp(err));
    }
    if (stack != null) {
      output3.push(formatStack(stack));
    }
    if (rest) {
      output3.push(formatCustom(rest));
    }
    return output3.filter(noEmpty).join(" ");
  };
  return parse;
};

// src/logFormatter/bin.ts
var input = process.stdin;
var output = process.stdout;
input.pipe((0, import_split2.default)(LogFormatter())).pipe(output);
process.on("SIGINT", () => {
  process.exit(0);
});
