"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useOnResolve = void 0;
const graphql_1 = require("graphql");
const core_1 = require("@envelop/core");
/**
 * Wraps the provided schema by hooking into the resolvers of every field.
 *
 * Use the `onResolve` argument to manipulate the resolver and its results/errors.
 */
function useOnResolve(onResolve, opts = { skipIntrospection: true }) {
    const hasWrappedResolveSymbol = Symbol('hasWrappedResolve');
    return {
        onSchemaChange({ schema: _schema }) {
            const schema = _schema;
            if (!schema)
                return; // nothing to do if schema is missing
            for (const type of Object.values(schema.getTypeMap())) {
                if ((!opts.skipIntrospection || !(0, graphql_1.isIntrospectionType)(type)) && (0, graphql_1.isObjectType)(type)) {
                    for (const field of Object.values(type.getFields())) {
                        if (field[hasWrappedResolveSymbol])
                            continue;
                        let resolver = (field.resolve || graphql_1.defaultFieldResolver);
                        field.resolve = (root, args, context, info) => (0, core_1.mapMaybePromise)(onResolve({
                            root,
                            args,
                            context,
                            info,
                            resolver,
                            replaceResolver: newResolver => {
                                resolver = newResolver;
                            },
                        }), afterResolve => {
                            if (typeof afterResolve === 'function') {
                                try {
                                    return (0, core_1.mapMaybePromise)(resolver(root, args, context, info), result => (0, core_1.mapMaybePromise)(afterResolve({
                                        result,
                                        setResult: newResult => {
                                            result = newResult;
                                        },
                                    }), () => result), errorResult => (0, core_1.mapMaybePromise)(afterResolve({
                                        result: errorResult,
                                        setResult: newResult => {
                                            errorResult = newResult;
                                        },
                                    }), () => {
                                        throw errorResult;
                                    }));
                                }
                                catch (err) {
                                    let errorResult = err;
                                    return (0, core_1.mapMaybePromise)(afterResolve({
                                        result: errorResult,
                                        setResult: newResult => {
                                            errorResult = newResult;
                                        },
                                    }), () => errorResult);
                                }
                            }
                            return resolver(root, args, context, info);
                        });
                        field[hasWrappedResolveSymbol] = true;
                    }
                }
            }
        },
    };
}
exports.useOnResolve = useOnResolve;
