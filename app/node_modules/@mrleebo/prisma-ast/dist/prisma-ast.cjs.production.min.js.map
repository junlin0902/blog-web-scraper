{"version":3,"file":"prisma-ast.cjs.production.min.js","sources":["../src/lexer.ts","../src/schemaUtils.ts","../src/getConfig.ts","../src/parser.ts","../src/visitor.ts","../src/getSchema.ts","../src/schemaSorter.ts","../src/printSchema.ts","../src/finder.ts","../src/PrismaSchemaBuilder.ts","../src/produceSchema.ts"],"sourcesContent":["import { createToken, Lexer, IMultiModeLexerDefinition } from 'chevrotain';\n\nexport const Identifier = createToken({\n  name: 'Identifier',\n  pattern: /[a-zA-Z][\\w-]*/,\n});\nexport const Datasource = createToken({\n  name: 'Datasource',\n  pattern: /datasource/,\n  push_mode: 'block',\n});\nexport const Generator = createToken({\n  name: 'Generator',\n  pattern: /generator/,\n  push_mode: 'block',\n});\nexport const Model = createToken({\n  name: 'Model',\n  pattern: /model/,\n  push_mode: 'block',\n});\nexport const View = createToken({\n  name: 'View',\n  pattern: /view/,\n  push_mode: 'block',\n});\nexport const Enum = createToken({\n  name: 'Enum',\n  pattern: /enum/,\n  push_mode: 'block',\n});\nexport const Type = createToken({\n  name: 'Type',\n  pattern: /type/,\n  push_mode: 'block',\n});\nexport const True = createToken({\n  name: 'True',\n  pattern: /true/,\n  longer_alt: Identifier,\n});\nexport const False = createToken({\n  name: 'False',\n  pattern: /false/,\n  longer_alt: Identifier,\n});\nexport const Null = createToken({\n  name: 'Null',\n  pattern: /null/,\n  longer_alt: Identifier,\n});\nexport const Comment = createToken({\n  name: 'Comment',\n  pattern: Lexer.NA,\n});\n\nexport const DocComment = createToken({\n  name: 'DocComment',\n  pattern: /\\/\\/\\/[ \\t]*(.*)/,\n  categories: [Comment],\n});\nexport const LineComment = createToken({\n  name: 'LineComment',\n  pattern: /\\/\\/[ \\t]*(.*)/,\n  categories: [Comment],\n});\nexport const Attribute = createToken({\n  name: 'Attribute',\n  pattern: Lexer.NA,\n});\nexport const BlockAttribute = createToken({\n  name: 'BlockAttribute',\n  pattern: /@@/,\n  label: \"'@@'\",\n  categories: [Attribute],\n});\nexport const FieldAttribute = createToken({\n  name: 'FieldAttribute',\n  pattern: /@/,\n  label: \"'@'\",\n  categories: [Attribute],\n});\nexport const Dot = createToken({\n  name: 'Dot',\n  pattern: /\\./,\n  label: \"'.'\",\n});\nexport const QuestionMark = createToken({\n  name: 'QuestionMark',\n  pattern: /\\?/,\n  label: \"'?'\",\n});\nexport const LCurly = createToken({\n  name: 'LCurly',\n  pattern: /{/,\n  label: \"'{'\",\n});\nexport const RCurly = createToken({\n  name: 'RCurly',\n  pattern: /}/,\n  label: \"'}'\",\n  pop_mode: true,\n});\nexport const LRound = createToken({\n  name: 'LRound',\n  pattern: /\\(/,\n  label: \"'('\",\n});\nexport const RRound = createToken({\n  name: 'RRound',\n  pattern: /\\)/,\n  label: \"')'\",\n});\nexport const LSquare = createToken({\n  name: 'LSquare',\n  pattern: /\\[/,\n  label: \"'['\",\n});\nexport const RSquare = createToken({\n  name: 'RSquare',\n  pattern: /\\]/,\n  label: \"']'\",\n});\nexport const Comma = createToken({\n  name: 'Comma',\n  pattern: /,/,\n  label: \"','\",\n});\nexport const Colon = createToken({\n  name: 'Colon',\n  pattern: /:/,\n  label: \"':'\",\n});\nexport const Equals = createToken({\n  name: 'Equals',\n  pattern: /=/,\n  label: \"'='\",\n});\nexport const StringLiteral = createToken({\n  name: 'StringLiteral',\n  pattern: /\"(:?[^\\\\\"\\n\\r]|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/,\n});\nexport const NumberLiteral = createToken({\n  name: 'NumberLiteral',\n  pattern: /-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?/,\n});\nexport const WhiteSpace = createToken({\n  name: 'WhiteSpace',\n  pattern: /\\s+/,\n  group: Lexer.SKIPPED,\n});\nexport const LineBreak = createToken({\n  name: 'LineBreak',\n  pattern: /\\n|\\r\\n/,\n  line_breaks: true,\n  label: 'LineBreak',\n});\n\nconst naTokens = [Comment, DocComment, LineComment, LineBreak, WhiteSpace];\n\nexport const multiModeTokens: IMultiModeLexerDefinition = {\n  modes: {\n    global: [...naTokens, Datasource, Generator, Model, View, Enum, Type],\n    block: [\n      ...naTokens,\n      Attribute,\n      BlockAttribute,\n      FieldAttribute,\n      Dot,\n      QuestionMark,\n      LCurly,\n      RCurly,\n      LSquare,\n      RSquare,\n      LRound,\n      RRound,\n      Comma,\n      Colon,\n      Equals,\n      True,\n      False,\n      Null,\n      StringLiteral,\n      NumberLiteral,\n      Identifier,\n    ],\n  },\n  defaultMode: 'global',\n};\n\nexport const PrismaLexer = new Lexer(multiModeTokens);\n","import type { CstNode, IToken } from 'chevrotain';\nimport * as schema from './getSchema';\n\nconst schemaObjects = ['model', 'view', 'type'] as const;\n\nexport function isOneOfSchemaObjects<T extends string>(\n  obj: schema.Object,\n  schemas: readonly T[]\n): obj is Extract<schema.Object, { type: T }> {\n  return obj != null && 'type' in obj && schemas.includes(obj.type as T);\n}\n\n/** Returns true if the value is an Object, such as a model or view or composite type. */\nexport function isSchemaObject(\n  obj: schema.Object\n): obj is Extract<schema.Object, { type: (typeof schemaObjects)[number] }> {\n  return isOneOfSchemaObjects(obj, schemaObjects);\n}\n\nconst fieldObjects = ['field', 'enumerator'] as const;\n/** Returns true if the value is a Field or Enumerator. */\nexport function isSchemaField(\n  field: schema.Field | schema.Enumerator\n): field is Extract<schema.Field, { type: (typeof fieldObjects)[number] }> {\n  return field != null && 'type' in field && fieldObjects.includes(field.type);\n}\n\n/** Returns true if the value of the CstNode is a Token. */\nexport function isToken(node: [IToken] | [CstNode]): node is [IToken] {\n  return 'image' in node[0];\n}\n\n/**\n * If parser.nodeLocationTracking is set, then read the location statistics\n * from the available tokens. If tracking is 'none' then just return the\n * existing data structure.\n * */\nexport function appendLocationData<T extends Record<string, unknown>>(\n  data: T,\n  ...tokens: IToken[]\n): T {\n  const location = tokens.reduce((memo, token) => {\n    if (!token) return memo;\n\n    const {\n      endColumn = -Infinity,\n      endLine = -Infinity,\n      endOffset = -Infinity,\n      startColumn = Infinity,\n      startLine = Infinity,\n      startOffset = Infinity,\n    } = memo;\n\n    if (token.startLine != null && token.startLine < startLine)\n      memo.startLine = token.startLine;\n    if (token.startColumn != null && token.startColumn < startColumn)\n      memo.startColumn = token.startColumn;\n    if (token.startOffset != null && token.startOffset < startOffset)\n      memo.startOffset = token.startOffset;\n\n    if (token.endLine != null && token.endLine > endLine)\n      memo.endLine = token.endLine;\n    if (token.endColumn != null && token.endColumn > endColumn)\n      memo.endColumn = token.endColumn;\n    if (token.endOffset != null && token.endOffset > endOffset)\n      memo.endOffset = token.endOffset;\n\n    return memo;\n  }, {} as IToken);\n\n  return Object.assign(data, { location });\n}\n","import type { IParserConfig } from 'chevrotain';\nimport {\n  lilconfigSync as configSync,\n  type LilconfigResult as ConfigResultRaw,\n} from 'lilconfig';\n\nexport type PrismaAstParserConfig = Pick<IParserConfig, 'nodeLocationTracking'>;\nexport interface PrismaAstConfig {\n  parser: PrismaAstParserConfig;\n}\n\ntype ConfigResult<T> = Omit<ConfigResultRaw, 'config'> & {\n  config: T;\n};\n\nconst defaultConfig: PrismaAstConfig = {\n  parser: { nodeLocationTracking: 'none' },\n};\n\nlet config: PrismaAstConfig;\nexport default function getConfig(): PrismaAstConfig {\n  if (config != null) return config;\n\n  const result: ConfigResult<PrismaAstConfig> | null =\n    configSync('prisma-ast').search();\n  return (config = Object.assign(defaultConfig, result?.config));\n}\n","import { CstParser } from 'chevrotain';\nimport getConfig, { PrismaAstParserConfig } from './getConfig';\nimport * as lexer from './lexer';\n\ntype ComponentType =\n  | 'datasource'\n  | 'generator'\n  | 'model'\n  | 'view'\n  | 'enum'\n  | 'type';\nexport class PrismaParser extends CstParser {\n  readonly config: PrismaAstParserConfig;\n\n  constructor(config: PrismaAstParserConfig) {\n    super(lexer.multiModeTokens, config);\n    this.performSelfAnalysis();\n    this.config = config;\n  }\n\n  private break = this.RULE('break', () => {\n    this.CONSUME1(lexer.LineBreak);\n    this.CONSUME2(lexer.LineBreak);\n  });\n\n  private keyedArg = this.RULE('keyedArg', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'keyName' });\n    this.CONSUME(lexer.Colon);\n    this.SUBRULE(this.value);\n  });\n\n  private array = this.RULE('array', () => {\n    this.CONSUME(lexer.LSquare);\n    this.MANY_SEP({\n      SEP: lexer.Comma,\n      DEF: () => {\n        this.SUBRULE(this.value);\n      },\n    });\n    this.CONSUME(lexer.RSquare);\n  });\n\n  private func = this.RULE('func', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'funcName' });\n    this.CONSUME(lexer.LRound);\n    this.MANY_SEP({\n      SEP: lexer.Comma,\n      DEF: () => {\n        this.OR([\n          { ALT: () => this.SUBRULE(this.keyedArg) },\n          { ALT: () => this.SUBRULE(this.value) },\n        ]);\n      },\n    });\n    this.CONSUME(lexer.RRound);\n  });\n\n  private value = this.RULE('value', () => {\n    this.OR([\n      { ALT: () => this.CONSUME(lexer.StringLiteral, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.NumberLiteral, { LABEL: 'value' }) },\n      { ALT: () => this.SUBRULE(this.array, { LABEL: 'value' }) },\n      { ALT: () => this.SUBRULE(this.func, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.True, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.False, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.Null, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'value' }) },\n    ]);\n  });\n\n  private property = this.RULE('property', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'propertyName' });\n    this.CONSUME(lexer.Equals);\n    this.SUBRULE(this.value, { LABEL: 'propertyValue' });\n  });\n\n  private assignment = this.RULE('assignment', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'assignmentName' });\n    this.CONSUME(lexer.Equals);\n    this.SUBRULE(this.value, { LABEL: 'assignmentValue' });\n  });\n\n  private field = this.RULE('field', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'fieldName' });\n    this.SUBRULE(this.value, { LABEL: 'fieldType' });\n    this.OPTION1(() => {\n      this.OR([\n        {\n          ALT: () => {\n            this.CONSUME(lexer.LSquare, { LABEL: 'array' });\n            this.CONSUME(lexer.RSquare, { LABEL: 'array' });\n          },\n        },\n        { ALT: () => this.CONSUME(lexer.QuestionMark, { LABEL: 'optional' }) },\n      ]);\n    });\n    this.MANY(() => {\n      this.SUBRULE(this.fieldAttribute, { LABEL: 'attributeList' });\n    });\n    this.OPTION2(() => {\n      this.CONSUME(lexer.Comment, { LABEL: 'comment' });\n    });\n  });\n\n  private block = this.RULE(\n    'block',\n    (\n      options: {\n        componentType?: ComponentType;\n      } = {}\n    ) => {\n      const { componentType } = options;\n      const isEnum = componentType === 'enum';\n      const isObject =\n        componentType === 'model' ||\n        componentType === 'view' ||\n        componentType === 'type';\n\n      this.CONSUME(lexer.LCurly);\n      this.CONSUME1(lexer.LineBreak);\n      this.MANY(() => {\n        this.OR([\n          { ALT: () => this.SUBRULE(this.comment, { LABEL: 'list' }) },\n          {\n            GATE: () => isObject,\n            ALT: () => this.SUBRULE(this.property, { LABEL: 'list' }),\n          },\n          { ALT: () => this.SUBRULE(this.blockAttribute, { LABEL: 'list' }) },\n          {\n            GATE: () => isObject,\n            ALT: () => this.SUBRULE(this.field, { LABEL: 'list' }),\n          },\n          {\n            GATE: () => isEnum,\n            ALT: () => this.SUBRULE(this.enum, { LABEL: 'list' }),\n          },\n          {\n            GATE: () => !isObject,\n            ALT: () => this.SUBRULE(this.assignment, { LABEL: 'list' }),\n          },\n          { ALT: () => this.SUBRULE(this.break, { LABEL: 'list' }) },\n          { ALT: () => this.CONSUME2(lexer.LineBreak) },\n        ]);\n      });\n      this.CONSUME(lexer.RCurly);\n    }\n  );\n\n  private enum = this.RULE('enum', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'enumName' });\n    this.MANY(() => {\n      this.SUBRULE(this.fieldAttribute, { LABEL: 'attributeList' });\n    });\n    this.OPTION(() => {\n      this.CONSUME(lexer.Comment, { LABEL: 'comment' });\n    });\n  });\n\n  private fieldAttribute = this.RULE('fieldAttribute', () => {\n    this.CONSUME(lexer.FieldAttribute, { LABEL: 'fieldAttribute' });\n    this.OR([\n      {\n        ALT: () => {\n          this.CONSUME1(lexer.Identifier, { LABEL: 'groupName' });\n          this.CONSUME(lexer.Dot);\n          this.CONSUME2(lexer.Identifier, { LABEL: 'attributeName' });\n        },\n      },\n      {\n        ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'attributeName' }),\n      },\n    ]);\n\n    this.OPTION(() => {\n      this.CONSUME(lexer.LRound);\n      this.MANY_SEP({\n        SEP: lexer.Comma,\n        DEF: () => {\n          this.SUBRULE(this.attributeArg);\n        },\n      });\n      this.CONSUME(lexer.RRound);\n    });\n  });\n\n  private blockAttribute = this.RULE('blockAttribute', () => {\n    this.CONSUME(lexer.BlockAttribute, { LABEL: 'blockAttribute' }),\n      this.OR([\n        {\n          ALT: () => {\n            this.CONSUME1(lexer.Identifier, { LABEL: 'groupName' });\n            this.CONSUME(lexer.Dot);\n            this.CONSUME2(lexer.Identifier, { LABEL: 'attributeName' });\n          },\n        },\n        {\n          ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'attributeName' }),\n        },\n      ]);\n\n    this.OPTION(() => {\n      this.CONSUME(lexer.LRound);\n      this.MANY_SEP({\n        SEP: lexer.Comma,\n        DEF: () => {\n          this.SUBRULE(this.attributeArg);\n        },\n      });\n      this.CONSUME(lexer.RRound);\n    });\n  });\n\n  private attributeArg = this.RULE('attributeArg', () => {\n    this.OR([\n      {\n        ALT: () => this.SUBRULE(this.keyedArg, { LABEL: 'value' }),\n      },\n      {\n        ALT: () => this.SUBRULE(this.value, { LABEL: 'value' }),\n      },\n    ]);\n  });\n\n  private component = this.RULE('component', () => {\n    const type = this.OR1([\n      { ALT: () => this.CONSUME(lexer.Datasource, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Generator, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Model, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.View, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Enum, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Type, { LABEL: 'type' }) },\n    ]);\n    this.OR2([\n      {\n        ALT: () => {\n          this.CONSUME1(lexer.Identifier, { LABEL: 'groupName' });\n          this.CONSUME(lexer.Dot);\n          this.CONSUME2(lexer.Identifier, { LABEL: 'componentName' });\n        },\n      },\n      {\n        ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'componentName' }),\n      },\n    ]);\n\n    this.SUBRULE(this.block, {\n      ARGS: [{ componentType: type.image as ComponentType }],\n    });\n  });\n\n  private comment = this.RULE('comment', () => {\n    this.CONSUME(lexer.Comment, { LABEL: 'text' });\n  });\n\n  public schema = this.RULE('schema', () => {\n    this.MANY(() => {\n      this.OR([\n        { ALT: () => this.SUBRULE(this.comment, { LABEL: 'list' }) },\n        { ALT: () => this.SUBRULE(this.component, { LABEL: 'list' }) },\n        { ALT: () => this.SUBRULE(this.break, { LABEL: 'list' }) },\n        { ALT: () => this.CONSUME(lexer.LineBreak) },\n      ]);\n    });\n  });\n}\n\nexport const defaultParser = new PrismaParser(getConfig().parser);\n","import { CstNode, IToken } from '@chevrotain/types';\nimport * as Types from './getSchema';\n\nimport { appendLocationData, isToken } from './schemaUtils';\nimport { PrismaParser, defaultParser } from './parser';\nimport { ICstVisitor } from 'chevrotain';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype Class<T> = new (...args: any[]) => T;\nexport type PrismaVisitor = ICstVisitor<any, any>;\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport const VisitorClassFactory = (\n  parser: PrismaParser\n): Class<PrismaVisitor> => {\n  const BasePrismaVisitor = parser.getBaseCstVisitorConstructorWithDefaults();\n  return class PrismaVisitor extends BasePrismaVisitor {\n    constructor() {\n      super();\n      this.validateVisitor();\n    }\n\n    schema(ctx: CstNode & { list: CstNode[] }): Types.Schema {\n      const list = ctx.list?.map((item) => this.visit([item])) || [];\n      return { type: 'schema', list };\n    }\n\n    component(\n      ctx: CstNode & {\n        type: [IToken];\n        componentName: [IToken];\n        block: [CstNode];\n      }\n    ): Types.Block {\n      const [type] = ctx.type;\n      const [name] = ctx.componentName;\n      const list = this.visit(ctx.block);\n\n      const data = (() => {\n        switch (type.image) {\n          case 'datasource':\n            return {\n              type: 'datasource',\n              name: name.image,\n              assignments: list,\n            } as const satisfies Types.Datasource;\n          case 'generator':\n            return {\n              type: 'generator',\n              name: name.image,\n              assignments: list,\n            } as const satisfies Types.Generator;\n          case 'model':\n            return {\n              type: 'model',\n              name: name.image,\n              properties: list,\n            } as const satisfies Types.Model;\n          case 'view':\n            return {\n              type: 'view',\n              name: name.image,\n              properties: list,\n            } as const satisfies Types.View;\n          case 'enum':\n            return {\n              type: 'enum',\n              name: name.image,\n              enumerators: list,\n            } as const satisfies Types.Enum;\n          case 'type':\n            return {\n              type: 'type',\n              name: name.image,\n              properties: list,\n            } as const satisfies Types.Type;\n          default:\n            throw new Error(`Unexpected block type: ${type}`);\n        }\n      })();\n\n      return this.maybeAppendLocationData(data, type, name);\n    }\n\n    break(): Types.Break {\n      return { type: 'break' };\n    }\n\n    comment(ctx: CstNode & { text: [IToken] }): Types.Comment {\n      const [comment] = ctx.text;\n      const data = {\n        type: 'comment',\n        text: comment.image,\n      } as const satisfies Types.Comment;\n      return this.maybeAppendLocationData(data, comment);\n    }\n\n    block(ctx: CstNode & { list: CstNode[] }): BlockList {\n      return ctx.list?.map((item) => this.visit([item]));\n    }\n\n    assignment(\n      ctx: CstNode & { assignmentName: [IToken]; assignmentValue: [CstNode] }\n    ): Types.Assignment {\n      const value = this.visit(ctx.assignmentValue);\n      const [key] = ctx.assignmentName;\n      const data = {\n        type: 'assignment',\n        key: key.image,\n        value,\n      } as const satisfies Types.Assignment;\n      return this.maybeAppendLocationData(data, key);\n    }\n\n    field(\n      ctx: CstNode & {\n        fieldName: [IToken];\n        fieldType: [CstNode];\n        array: [IToken];\n        optional: [IToken];\n        attributeList: CstNode[];\n        comment: [IToken];\n      }\n    ): Types.Field {\n      const fieldType = this.visit(ctx.fieldType);\n      const [name] = ctx.fieldName;\n      const attributes = ctx.attributeList?.map((item) => this.visit([item]));\n      const comment = ctx.comment?.[0]?.image;\n      const data = {\n        type: 'field',\n        name: name.image,\n        fieldType,\n        array: ctx.array != null,\n        optional: ctx.optional != null,\n        attributes,\n        comment,\n      } as const satisfies Types.Field;\n\n      return this.maybeAppendLocationData(\n        data,\n        name,\n        ctx.optional?.[0],\n        ctx.array?.[0]\n      );\n    }\n\n    fieldAttribute(\n      ctx: CstNode & {\n        fieldAttribute: [IToken];\n        groupName: [IToken];\n        attributeName: [IToken];\n        attributeArg: CstNode[];\n      }\n    ): Types.Attr {\n      const [name] = ctx.attributeName;\n      const [group] = ctx.groupName || [{}];\n      const args = ctx.attributeArg?.map((attr) => this.visit(attr));\n      const data = {\n        type: 'attribute',\n        name: name.image,\n        kind: 'field',\n        group: group.image,\n        args,\n      } as const satisfies Types.Attr;\n      return this.maybeAppendLocationData(\n        data,\n        name,\n        ...ctx.fieldAttribute,\n        group\n      );\n    }\n\n    blockAttribute(\n      ctx: CstNode & {\n        blockAttribute: [IToken];\n        groupName: [IToken];\n        attributeName: [IToken];\n        attributeArg: CstNode[];\n      }\n    ): Types.Attr | null {\n      const [name] = ctx.attributeName;\n      const [group] = ctx.groupName || [{}];\n      const args = ctx.attributeArg?.map((attr) => this.visit(attr));\n      const data = {\n        type: 'attribute',\n        name: name.image,\n        kind: 'object',\n        group: group.image,\n        args,\n      } as const satisfies Types.Attr;\n\n      return this.maybeAppendLocationData(\n        data,\n        name,\n        ...ctx.blockAttribute,\n        group\n      );\n    }\n\n    attributeArg(ctx: CstNode & { value: [CstNode] }): Types.AttributeArgument {\n      const value = this.visit(ctx.value);\n      return { type: 'attributeArgument', value };\n    }\n\n    func(\n      ctx: CstNode & {\n        funcName: [IToken];\n        value: CstNode[];\n        keyedArg: CstNode[];\n      }\n    ): Types.Func {\n      const [name] = ctx.funcName;\n      const params = ctx.value?.map((item) => this.visit([item]));\n      const keyedParams = ctx.keyedArg?.map((item) => this.visit([item]));\n      const pars = (params || keyedParams) && [\n        ...(params ?? []),\n        ...(keyedParams ?? []),\n      ];\n      const data = {\n        type: 'function',\n        name: name.image,\n        params: pars,\n      } as const satisfies Types.Func;\n      return this.maybeAppendLocationData(data, name);\n    }\n\n    array(ctx: CstNode & { value: CstNode[] }): Types.RelationArray {\n      const args = ctx.value?.map((item) => this.visit([item]));\n      return { type: 'array', args };\n    }\n\n    keyedArg(\n      ctx: CstNode & { keyName: [IToken]; value: [CstNode] }\n    ): Types.KeyValue {\n      const [key] = ctx.keyName;\n      const value = this.visit(ctx.value);\n      const data = {\n        type: 'keyValue',\n        key: key.image,\n        value,\n      } as const satisfies Types.KeyValue;\n      return this.maybeAppendLocationData(data, key);\n    }\n\n    value(ctx: CstNode & { value: [IToken] | [CstNode] }): Types.Value {\n      if (isToken(ctx.value)) {\n        const [{ image }] = ctx.value;\n        return image;\n      }\n      return this.visit(ctx.value);\n    }\n\n    enum(\n      ctx: CstNode & {\n        enumName: [IToken];\n        attributeList: CstNode[];\n        comment: [IToken];\n      }\n    ): Types.Enumerator {\n      const [name] = ctx.enumName;\n      const attributes = ctx.attributeList?.map((item) => this.visit([item]));\n      const comment = ctx.comment?.[0]?.image;\n      const data = {\n        type: 'enumerator',\n        name: name.image,\n        attributes,\n        comment,\n      } as const satisfies Types.Enumerator;\n      return this.maybeAppendLocationData(data, name);\n    }\n\n    maybeAppendLocationData<T extends Record<string, unknown>>(\n      data: T,\n      ...tokens: IToken[]\n    ): T {\n      if (parser.config.nodeLocationTracking === 'none') return data;\n      return appendLocationData(data, ...tokens);\n    }\n  };\n};\n\ntype BlockList = Array<\n  | Types.Comment\n  | Types.Property\n  | Types.Attribute\n  | Types.Field\n  | Types.Enum\n  | Types.Assignment\n  | Types.Break\n>;\nexport const DefaultVisitorClass = VisitorClassFactory(defaultParser);\nexport const defaultVisitor = new DefaultVisitorClass();\n","import { PrismaLexer } from './lexer';\nimport { PrismaVisitor, defaultVisitor } from './visitor';\nimport type { CstNodeLocation } from 'chevrotain';\nimport { PrismaParser, defaultParser } from './parser';\n\n/**\n * Parses a string containing a prisma schema's source code and returns an\n * object that represents the parsed data structure. You can make direct\n * modifications to the objects and arrays nested within, and then produce\n * a new prisma schema using printSchema().\n *\n * @example\n * const schema = getSchema(source)\n * // ... make changes to schema object ...\n * const changedSource = printSchema(schema)\n * */\nexport function getSchema(\n  source: string,\n  options?: {\n    parser: PrismaParser;\n    visitor: PrismaVisitor;\n  }\n): Schema {\n  const lexingResult = PrismaLexer.tokenize(source);\n\n  const parser = options?.parser ?? defaultParser;\n  parser.input = lexingResult.tokens;\n  const cstNode = parser.schema();\n  if (parser.errors.length > 0) throw parser.errors[0];\n\n  const visitor = options?.visitor ?? defaultVisitor;\n  return visitor.visit(cstNode);\n}\n\nexport interface Schema {\n  type: 'schema';\n  list: Block[];\n}\n\nexport type Block =\n  | Model\n  | View\n  | Datasource\n  | Generator\n  | Enum\n  | Comment\n  | Break\n  | Type;\n\nexport interface Object {\n  type: 'model' | 'view' | 'type';\n  name: string;\n  properties: Array<Property | Comment | Break>;\n}\n\nexport interface Model extends Object {\n  type: 'model';\n  location?: CstNodeLocation;\n}\n\nexport interface View extends Object {\n  type: 'view';\n  location?: CstNodeLocation;\n}\n\nexport interface Type extends Object {\n  type: 'type';\n  location?: CstNodeLocation;\n}\n\nexport interface Datasource {\n  type: 'datasource';\n  name: string;\n  assignments: Array<Assignment | Comment | Break>;\n  location?: CstNodeLocation;\n}\n\nexport interface Generator {\n  type: 'generator';\n  name: string;\n  assignments: Array<Assignment | Comment | Break>;\n  location?: CstNodeLocation;\n}\n\nexport interface Enum {\n  type: 'enum';\n  name: string;\n  enumerators: Array<\n    Enumerator | Comment | Break | BlockAttribute | GroupedAttribute\n  >;\n  location?: CstNodeLocation;\n}\n\nexport interface Comment {\n  type: 'comment';\n  text: string;\n}\n\nexport interface Break {\n  type: 'break';\n}\n\nexport type Property = GroupedBlockAttribute | BlockAttribute | Field;\n\nexport interface Assignment {\n  type: 'assignment';\n  key: string;\n  value: Value;\n}\n\nexport interface Enumerator {\n  type: 'enumerator';\n  name: string;\n  value?: Value;\n  attributes?: Attribute[];\n  comment?: string;\n}\n\nexport interface BlockAttribute {\n  type: 'attribute';\n  kind: 'object' | 'view' | 'type';\n  group?: string;\n  name: string;\n  args: AttributeArgument[];\n  location?: CstNodeLocation;\n}\n\nexport type GroupedBlockAttribute = BlockAttribute & { group: string };\n\nexport interface Field {\n  type: 'field';\n  name: string;\n  fieldType: string | Func;\n  array?: boolean;\n  optional?: boolean;\n  attributes?: Attribute[];\n  comment?: string;\n  location?: CstNodeLocation;\n}\n\nexport type Attr =\n  | Attribute\n  | GroupedAttribute\n  | BlockAttribute\n  | GroupedBlockAttribute;\n\nexport interface Attribute {\n  type: 'attribute';\n  kind: 'field';\n  group?: string;\n  name: string;\n  args?: AttributeArgument[];\n  location?: CstNodeLocation;\n}\n\nexport type GroupedAttribute = Attribute & { group: string };\n\nexport interface AttributeArgument {\n  type: 'attributeArgument';\n  value: KeyValue | Value | Func;\n}\n\nexport interface KeyValue {\n  type: 'keyValue';\n  key: string;\n  value: Value;\n}\n\nexport interface Func {\n  type: 'function';\n  name: string;\n  params: Value[];\n}\n\nexport interface RelationArray {\n  type: 'array';\n  args: string[];\n}\n\nexport type Value =\n  | string\n  | number\n  | boolean\n  | Func\n  | RelationArray\n  | Array<Value>;\n","import { Block, Schema } from './getSchema';\n\nconst unsorted = ['break', 'comment'];\nconst defaultSortOrder = [\n  'generator',\n  'datasource',\n  'model',\n  'view',\n  'enum',\n  'break',\n  'comment',\n];\n\n/** Sorts the schema parts, in the given order, and alphabetically for parts of the same type. */\nexport const schemaSorter =\n  (\n    schema: Schema,\n    locales?: string | string[],\n    sortOrder: string[] = defaultSortOrder\n  ) =>\n  (a: Block, b: Block): number => {\n    // Preserve the position of comments and line breaks relative to their\n    // position in the file, since when a re-sort happens it wouldn't be\n    // clear whether a comment should affix to the object above or below it.\n    const aUnsorted = unsorted.indexOf(a.type) !== -1;\n    const bUnsorted = unsorted.indexOf(b.type) !== -1;\n\n    if (aUnsorted !== bUnsorted) {\n      return schema.list.indexOf(a) - schema.list.indexOf(b);\n    }\n\n    if (sortOrder !== defaultSortOrder)\n      sortOrder = sortOrder.concat(defaultSortOrder);\n    const typeIndex = sortOrder.indexOf(a.type) - sortOrder.indexOf(b.type);\n    if (typeIndex !== 0) return typeIndex;\n\n    // Resolve ties using the name of object's name.\n    if ('name' in a && 'name' in b)\n      return a.name.localeCompare(b.name, locales);\n\n    // If all else fails, leave objects in their original position.\n    return 0;\n  };\n","import * as Types from './getSchema';\nimport { EOL } from 'os';\nimport { schemaSorter } from './schemaSorter';\n\ntype Block = 'generator' | 'datasource' | 'model' | 'view' | 'enum' | 'type';\n\nexport interface PrintOptions {\n  sort?: boolean;\n  locales?: string | string[];\n  sortOrder?: Block[];\n}\n\n/**\n * Converts the given schema object into a string representing the prisma\n * schema's source code. Optionally can take options to change the sort order\n * of the schema parts.\n * */\nexport function printSchema(\n  schema: Types.Schema,\n  options: PrintOptions = {}\n): string {\n  const { sort = false, locales = undefined, sortOrder = undefined } = options;\n  let blocks = schema.list;\n  if (sort) {\n    // no point in preserving line breaks when re-sorting\n    blocks = schema.list = blocks.filter((block) => block.type !== 'break');\n    const sorter = schemaSorter(schema, locales, sortOrder);\n    blocks.sort(sorter);\n  }\n\n  return (\n    blocks\n      .map(printBlock)\n      .filter(Boolean)\n      .join(EOL)\n      .replace(/(\\r?\\n\\s*){3,}/g, EOL + EOL) + EOL\n  );\n}\n\nfunction printBlock(block: Types.Block): string {\n  switch (block.type) {\n    case 'comment':\n      return printComment(block);\n    case 'datasource':\n      return printDatasource(block);\n    case 'enum':\n      return printEnum(block);\n    case 'generator':\n      return printGenerator(block);\n    case 'model':\n    case 'view':\n    case 'type':\n      return printObject(block);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unrecognized block type`);\n  }\n}\n\nfunction printComment(comment: Types.Comment) {\n  return comment.text;\n}\n\nfunction printBreak() {\n  return EOL;\n}\n\nfunction printDatasource(db: Types.Datasource) {\n  const children = computeAssignmentFormatting(db.assignments);\n\n  return `\ndatasource ${db.name} {\n  ${children}\n}`;\n}\n\nfunction printEnum(enumerator: Types.Enum) {\n  const list: Array<\n    | Types.Comment\n    | Types.Break\n    | Types.Enumerator\n    | Types.BlockAttribute\n    | Types.GroupedBlockAttribute\n    | Types.GroupedAttribute\n  > = enumerator.enumerators;\n  const children = list\n    .filter(Boolean)\n    .map(printEnumerator)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n\n  return `\nenum ${enumerator.name} {\n  ${children}\n}`;\n}\n\nfunction printEnumerator(\n  enumerator:\n    | Types.Enumerator\n    | Types.Attribute\n    | Types.Comment\n    | Types.Break\n    | Types.BlockAttribute\n    | Types.GroupedBlockAttribute\n    | Types.GroupedAttribute\n) {\n  switch (enumerator.type) {\n    case 'enumerator': {\n      const attrs = enumerator.attributes\n        ? enumerator.attributes.map(printAttribute)\n        : [];\n      return [enumerator.name, ...attrs, enumerator.comment]\n        .filter(Boolean)\n        .join(' ');\n    }\n    case 'attribute':\n      return printAttribute(enumerator);\n    case 'comment':\n      return printComment(enumerator);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unexpected enumerator type`);\n  }\n}\n\nfunction printGenerator(generator: Types.Generator) {\n  const children = computeAssignmentFormatting(generator.assignments);\n\n  return `\ngenerator ${generator.name} {\n  ${children}\n}`;\n}\n\nfunction printObject(object: Types.Object) {\n  const props = [...object.properties];\n\n  // If block attributes are declared in the middle of the block, move them to\n  // the bottom of the list.\n  let blockAttributeMoved = false;\n  props.sort((a, b) => {\n    if (\n      a.type === 'attribute' &&\n      a.kind === 'object' &&\n      (b.type !== 'attribute' ||\n        (b.type === 'attribute' && b.kind !== 'object'))\n    ) {\n      blockAttributeMoved = true;\n      return 1;\n    }\n\n    if (\n      b.type === 'attribute' &&\n      b.kind === 'object' &&\n      (a.type !== 'attribute' ||\n        (a.type === 'attribute' && a.kind !== 'object'))\n    ) {\n      blockAttributeMoved = true;\n      return -1;\n    }\n\n    return 0;\n  });\n\n  // Insert a break between the block attributes and the file if the block\n  // attributes are too close to the model's fields\n  const attrIndex = props.findIndex(\n    (item) => item.type === 'attribute' && item.kind === 'object'\n  );\n\n  const needsSpace = !['break', 'comment'].includes(props[attrIndex - 1]?.type);\n  if (blockAttributeMoved && needsSpace) {\n    props.splice(attrIndex, 0, { type: 'break' });\n  }\n\n  const children = computePropertyFormatting(props);\n\n  return `\n${object.type} ${object.name} {\n  ${children}\n}`;\n}\n\nfunction printAssignment(\n  node: Types.Assignment | Types.Comment | Types.Break,\n  keyLength = 0\n) {\n  switch (node.type) {\n    case 'comment':\n      return printComment(node);\n    case 'break':\n      return printBreak();\n    case 'assignment':\n      return `${node.key.padEnd(keyLength)} = ${printValue(node.value)}`;\n    default:\n      throw new Error(`Unexpected assignment type`);\n  }\n}\n\nfunction printProperty(\n  node: Types.Property | Types.Comment | Types.Break,\n  nameLength = 0,\n  typeLength = 0\n) {\n  switch (node.type) {\n    case 'attribute':\n      return printAttribute(node);\n    case 'field':\n      return printField(node, nameLength, typeLength);\n    case 'comment':\n      return printComment(node);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unrecognized property type`);\n  }\n}\n\nfunction printAttribute(attribute: Types.Attribute | Types.BlockAttribute) {\n  const args =\n    attribute.args && attribute.args.length > 0\n      ? `(${attribute.args.map(printAttributeArg).filter(Boolean).join(', ')})`\n      : '';\n\n  const name = [attribute.name];\n  if (attribute.group) name.unshift(attribute.group);\n\n  return `${attribute.kind === 'field' ? '@' : '@@'}${name.join('.')}${args}`;\n}\n\nfunction printAttributeArg(arg: Types.AttributeArgument) {\n  return printValue(arg.value);\n}\n\nfunction printField(field: Types.Field, nameLength = 0, typeLength = 0) {\n  const name = field.name.padEnd(nameLength);\n  const fieldType = printFieldType(field).padEnd(typeLength);\n  const attrs = field.attributes ? field.attributes.map(printAttribute) : [];\n  const comment = field.comment;\n  return (\n    [name, fieldType, ...attrs]\n      .filter(Boolean)\n      .join(' ')\n      // comments ignore indents\n      .trim() + (comment ? ` ${comment}` : '')\n  );\n}\n\nfunction printFieldType(field: Types.Field) {\n  const suffix = field.array ? '[]' : field.optional ? '?' : '';\n\n  if (typeof field.fieldType === 'object') {\n    switch (field.fieldType.type) {\n      case 'function': {\n        return `${printFunction(field.fieldType)}${suffix}`;\n      }\n      default:\n        throw new Error(`Unexpected field type`);\n    }\n  }\n\n  return `${field.fieldType}${suffix}`;\n}\n\nfunction printFunction(func: Types.Func) {\n  const params = func.params ? func.params.map(printValue) : '';\n  return `${func.name}(${params})`;\n}\n\nfunction printValue(value: Types.KeyValue | Types.Value): string {\n  switch (typeof value) {\n    case 'object': {\n      if ('type' in value) {\n        switch (value.type) {\n          case 'keyValue':\n            return `${value.key}: ${printValue(value.value)}`;\n          case 'function':\n            return printFunction(value);\n          case 'array':\n            return `[${\n              value.args != null ? value.args.map(printValue).join(', ') : ''\n            }]`;\n          default:\n            throw new Error(`Unexpected value type`);\n        }\n      }\n\n      throw new Error(`Unexpected object value`);\n    }\n    default:\n      return String(value);\n  }\n}\n\nfunction computeAssignmentFormatting(\n  list: Array<Types.Comment | Types.Break | Types.Assignment>\n) {\n  let pos = 0;\n  const listBlocks = list.reduce<Array<typeof list>>(\n    (memo, current, index, arr) => {\n      if (current.type === 'break') return memo;\n      if (index > 0 && arr[index - 1].type === 'break') memo[++pos] = [];\n      memo[pos].push(current);\n      return memo;\n    },\n    [[]]\n  );\n\n  const keyLengths = listBlocks.map((lists) =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'assignment' ? current.key.length : 0\n        ),\n      0\n    )\n  );\n\n  return list\n    .map((item, index, arr) => {\n      if (index > 0 && item.type !== 'break' && arr[index - 1].type === 'break')\n        keyLengths.shift();\n      return printAssignment(item, keyLengths[0]);\n    })\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n}\n\nfunction computePropertyFormatting(\n  list: Array<Types.Break | Types.Comment | Types.Property>\n) {\n  let pos = 0;\n  const listBlocks = list.reduce<Array<typeof list>>(\n    (memo, current, index, arr) => {\n      if (current.type === 'break') return memo;\n      if (index > 0 && arr[index - 1].type === 'break') memo[++pos] = [];\n      memo[pos].push(current);\n      return memo;\n    },\n    [[]]\n  );\n\n  const nameLengths = listBlocks.map((lists) =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'field' ? current.name.length : 0\n        ),\n      0\n    )\n  );\n\n  const typeLengths = listBlocks.map((lists) =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'field' ? printFieldType(current).length : 0\n        ),\n      0\n    )\n  );\n\n  return list\n    .map((prop, index, arr) => {\n      if (\n        index > 0 &&\n        prop.type !== 'break' &&\n        arr[index - 1].type === 'break'\n      ) {\n        nameLengths.shift();\n        typeLengths.shift();\n      }\n\n      return printProperty(prop, nameLengths[0], typeLengths[0]);\n    })\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n}\n","import type * as schema from './getSchema';\n\nexport type ByTypeSourceObject =\n  | schema.Block\n  | schema.Enumerator\n  | schema.Field\n  | schema.Property\n  | schema.Attribute\n  | schema.Assignment;\n\nexport type ByTypeMatchObject = Exclude<\n  ByTypeSourceObject,\n  schema.Comment | schema.Break\n>;\nexport type ByTypeMatch = ByTypeMatchObject['type'];\nexport type ByTypeOptions = { name?: string | RegExp };\nexport type FindByBlock<Match> = Extract<ByTypeMatchObject, { type: Match }>;\n\nexport const findByType = <const Match extends ByTypeMatch>(\n  list: ByTypeSourceObject[],\n  typeToMatch: Match,\n  options: ByTypeOptions = {}\n): FindByBlock<Match> | null => {\n  const [match, unexpected] = list.filter(findBy(typeToMatch, options));\n\n  if (!match) return null;\n\n  if (unexpected)\n    throw new Error(`Found multiple blocks with [type=${typeToMatch}]`);\n\n  return match;\n};\n\nexport const findAllByType = <const Match extends ByTypeMatch>(\n  list: ByTypeSourceObject[],\n  typeToMatch: Match,\n  options: ByTypeOptions = {}\n): Array<FindByBlock<Match>> => {\n  return list.filter(findBy(typeToMatch, options));\n};\n\ntype NameOf<Match extends ByTypeMatch> = Extract<\n  Match,\n  Match extends 'assignment' ? 'key' : 'name'\n>;\n\nconst findBy =\n  <Match extends ByTypeMatch, MatchName extends NameOf<Match>>(\n    typeToMatch: Match,\n    { name }: ByTypeOptions = {}\n  ) =>\n  (block: ByTypeSourceObject): block is FindByBlock<Match> => {\n    if (name != null) {\n      const nameAttribute = (\n        typeToMatch === 'assignment' ? 'key' : 'name'\n      ) as MatchName;\n      if (!(nameAttribute in block)) return false;\n      const nameMatches =\n        typeof name === 'string'\n          ? block[nameAttribute] === name\n          : name.test(block[nameAttribute]);\n      if (!nameMatches) return false;\n    }\n\n    return block.type === typeToMatch;\n  };\n","import * as schema from './getSchema';\nimport {\n  isOneOfSchemaObjects,\n  isSchemaField,\n  isSchemaObject,\n} from './schemaUtils';\nimport { PrintOptions, printSchema } from './printSchema';\nimport * as finder from './finder';\n\n/** Returns the function type Original with its return type changed to NewReturn. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ReplaceReturnType<Original extends (...args: any) => any, NewReturn> = (\n  ...a: Parameters<Original>\n) => NewReturn;\n\n/**\n * Methods with return values that do not propagate the builder should not have\n * their return value modified by the type replacement system below\n * */\ntype ExtractKeys = 'getSchema' | 'getSubject' | 'getParent' | 'print';\n\n/** These keys preserve the return value context that they were given */\ntype NeutralKeys =\n  | 'break'\n  | 'comment'\n  | 'attribute'\n  | 'enumerator'\n  | 'then'\n  | 'findByType'\n  | 'findAllByType';\n\n/** Keys allowed when you call .datasource() or .generator() */\ntype DatasourceOrGeneratorKeys = 'assignment';\n\n/** Keys allowed when you call .enum(\"name\") */\ntype EnumKeys = 'enumerator';\n\n/** Keys allowed when you call .field(\"name\") */\ntype FieldKeys = 'attribute' | 'removeAttribute';\n\n/** Keys allowed when you call .model(\"name\") */\ntype BlockKeys = 'blockAttribute' | 'field' | 'removeField';\n\ntype PrismaSchemaFinderOptions = finder.ByTypeOptions & {\n  within?: finder.ByTypeSourceObject[];\n};\n\n/**\n * Utility type for making the PrismaSchemaBuilder below readable:\n * Removes methods from the builder that are prohibited based on the context\n * the builder is in. For example, you can add fields to a model, but you can't\n * add fields to an enum or a datasource.\n */\ntype PrismaSchemaSubset<\n  Universe extends keyof ConcretePrismaSchemaBuilder,\n  Method\n> = ReplaceReturnType<\n  ConcretePrismaSchemaBuilder[Universe],\n  PrismaSchemaBuilder<Exclude<keyof ConcretePrismaSchemaBuilder, Method>>\n>;\n\n/**\n * The brain of this whole operation: depending on the key of the method name\n * we receive, filter the available list of method calls the user can make to\n * prevent them from making invalid calls, such as builder.datasource().field()\n * */\ntype PrismaSchemaBuilder<K extends keyof ConcretePrismaSchemaBuilder> = {\n  [U in K]: U extends ExtractKeys\n    ? ConcretePrismaSchemaBuilder[U]\n    : U extends NeutralKeys\n    ? ConcretePrismaSchemaBuilder[U] //ReplaceReturnType<ConcretePrismaSchemaBuilder[U], PrismaSchemaBuilder<K>>\n    : U extends 'datasource'\n    ? PrismaSchemaSubset<U, 'datasource' | EnumKeys | FieldKeys | BlockKeys>\n    : U extends 'generator'\n    ? PrismaSchemaSubset<U, EnumKeys | FieldKeys | BlockKeys>\n    : U extends 'model'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys | FieldKeys>\n    : U extends 'view'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys | FieldKeys>\n    : U extends 'type'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys | FieldKeys>\n    : U extends 'field'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys>\n    : U extends 'removeField'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys | FieldKeys>\n    : U extends 'enum'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | BlockKeys | FieldKeys>\n    : U extends 'removeAttribute'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys>\n    : PrismaSchemaSubset<\n        U,\n        DatasourceOrGeneratorKeys | EnumKeys | FieldKeys | BlockKeys | 'comment'\n      >;\n};\n\ntype Arg =\n  | string\n  | {\n      name: string;\n      function?: Arg[];\n    };\ntype Parent = schema.Block | undefined;\ntype Subject = schema.Block | schema.Field | schema.Enumerator | undefined;\n\nexport class ConcretePrismaSchemaBuilder {\n  private schema: schema.Schema;\n  private _subject: Subject;\n  private _parent: Parent;\n\n  constructor(source = '') {\n    this.schema = schema.getSchema(source);\n  }\n\n  /** Prints the schema out as a source string */\n  print(options: PrintOptions = {}): string {\n    return printSchema(this.schema, options);\n  }\n\n  /** Returns the underlying schema object for more advanced use cases. */\n  getSchema(): schema.Schema {\n    return this.schema;\n  }\n\n  /** Mutation Methods */\n\n  /** Adds or updates a generator block based on the name. */\n  generator(name: string, provider = 'prisma-client-js'): this {\n    const generator: schema.Generator =\n      this.schema.list.reduce<schema.Generator>(\n        (memo, block) =>\n          block.type === 'generator' && block.name === name ? block : memo,\n        {\n          type: 'generator',\n          name,\n          assignments: [\n            { type: 'assignment', key: 'provider', value: `\"${provider}\"` },\n          ],\n        }\n      );\n\n    if (!this.schema.list.includes(generator)) this.schema.list.push(generator);\n    this._subject = generator;\n    return this;\n  }\n\n  /** Removes something from the schema with the given name. */\n  drop(name: string): this {\n    const index = this.schema.list.findIndex(\n      (block) => 'name' in block && block.name === name\n    );\n    if (index !== -1) this.schema.list.splice(index, 1);\n    return this;\n  }\n\n  /** Sets the datasource for the schema. */\n  datasource(provider: string, url: string | { env: string }): this {\n    const datasource: schema.Datasource = {\n      type: 'datasource',\n      name: 'db',\n      assignments: [\n        {\n          type: 'assignment',\n          key: 'url',\n          value:\n            typeof url === 'string'\n              ? `\"${url}\"`\n              : { type: 'function', name: 'env', params: [`\"${url.env}\"`] },\n        },\n        { type: 'assignment', key: 'provider', value: provider },\n      ],\n    };\n    const existingIndex = this.schema.list.findIndex(\n      (block) => block.type === 'datasource'\n    );\n    this.schema.list.splice(\n      existingIndex,\n      existingIndex !== -1 ? 1 : 0,\n      datasource\n    );\n    this._subject = datasource;\n    return this;\n  }\n\n  /** Adds or updates a model based on the name. Can be chained with .field() or .blockAttribute() to add to it. */\n  model(name: string): this {\n    const model = this.schema.list.reduce<schema.Model>(\n      (memo, block) =>\n        block.type === 'model' && block.name === name ? block : memo,\n      { type: 'model', name, properties: [] }\n    );\n    if (!this.schema.list.includes(model)) this.schema.list.push(model);\n    this._subject = model;\n    return this;\n  }\n\n  /** Adds or updates a view based on the name. Can be chained with .field() or .blockAttribute() to add to it. */\n  view(name: string): this {\n    const view = this.schema.list.reduce<schema.View>(\n      (memo, block) =>\n        block.type === 'view' && block.name === name ? block : memo,\n      { type: 'view', name, properties: [] }\n    );\n    if (!this.schema.list.includes(view)) this.schema.list.push(view);\n    this._subject = view;\n    return this;\n  }\n\n  /** Adds or updates a type based on the name. Can be chained with .field() or .blockAttribute() to add to it. */\n  type(name: string): this {\n    const type = this.schema.list.reduce<schema.Type>(\n      (memo, block) =>\n        block.type === 'type' && block.name === name ? block : memo,\n      { type: 'type', name, properties: [] }\n    );\n    if (!this.schema.list.includes(type)) this.schema.list.push(type);\n    this._subject = type;\n    return this;\n  }\n\n  /** Adds or updates an enum based on the name. Can be chained with .enumerator() to add a value to it. */\n  enum(name: string, enumeratorNames: string[] = []): this {\n    const e = this.schema.list.reduce<schema.Enum>(\n      (memo, block) =>\n        block.type === 'enum' && block.name === name ? block : memo,\n      {\n        type: 'enum',\n        name,\n        enumerators: enumeratorNames.map((name) => ({\n          type: 'enumerator',\n          name,\n        })),\n      } satisfies schema.Enum\n    );\n    if (!this.schema.list.includes(e)) this.schema.list.push(e);\n    this._subject = e;\n    return this;\n  }\n\n  /** Add an enum value to the current enum. */\n  enumerator(value: string): this {\n    const subject = this.getSubject<schema.Enum>();\n    if (!subject || !('type' in subject) || subject.type !== 'enum') {\n      throw new Error('Subject must be a prisma enum!');\n    }\n\n    const enumerator = {\n      type: 'enumerator',\n      name: value,\n    } satisfies schema.Enumerator;\n    subject.enumerators.push(enumerator);\n    this._parent = this._subject as Exclude<\n      Subject,\n      { type: 'field' | 'enumerator' }\n    >;\n    this._subject = enumerator;\n    return this;\n  }\n\n  /**\n   * Returns the current subject, such as a model, field, or enum.\n   * @example\n   * builder.getModel('User').field('firstName').getSubject() // the firstName field\n   * */\n  private getSubject<S extends Subject>(): S {\n    return this._subject as S;\n  }\n\n  /** Returns the parent of the current subject when in a nested context. The parent of a field is its model or view. */\n  private getParent<S extends Parent = schema.Object>(): S {\n    return this._parent as S;\n  }\n\n  /**\n   * Adds a block-level attribute to the current model.\n   * @example\n   * builder.model('Project')\n   *   .blockAttribute(\"map\", \"projects\")\n   *   .blockAttribute(\"unique\", [\"firstName\", \"lastName\"]) // @@unique([firstName, lastName])\n   * */\n  blockAttribute(\n    name: string,\n    args?: string | string[] | Record<string, schema.Value>\n  ): this {\n    let subject = this.getSubject<schema.Object | schema.Enum>();\n    if (subject.type !== 'enum' && !isSchemaObject(subject)) {\n      const parent = this.getParent<schema.Object>();\n      if (!isOneOfSchemaObjects(parent, ['model', 'view', 'type', 'enum']))\n        throw new Error('Subject must be a prisma model, view, or type!');\n\n      subject = this._subject = parent;\n    }\n\n    const attributeArgs = ((): schema.AttributeArgument[] => {\n      if (!args) return [] as schema.AttributeArgument[];\n      if (typeof args === 'string')\n        return [{ type: 'attributeArgument', value: `\"${args}\"` }];\n      if (Array.isArray(args))\n        return [{ type: 'attributeArgument', value: { type: 'array', args } }];\n      return Object.entries(args).map(([key, value]) => ({\n        type: 'attributeArgument',\n        value: { type: 'keyValue', key, value },\n      }));\n    })();\n\n    const property: schema.BlockAttribute = {\n      type: 'attribute',\n      kind: 'object',\n      name,\n      args: attributeArgs,\n    };\n\n    if (subject.type === 'enum') {\n      subject.enumerators.push(property);\n    } else {\n      subject.properties.push(property);\n    }\n    return this;\n  }\n\n  /** Adds an attribute to the current field. */\n  attribute<T extends schema.Field>(\n    name: string,\n    args?: Arg[] | Record<string, string[]>\n  ): this {\n    const parent = this.getParent();\n    const subject = this.getSubject<T>();\n    if (!isOneOfSchemaObjects(parent, ['model', 'view', 'type', 'enum'])) {\n      throw new Error('Parent must be a prisma model or view!');\n    }\n\n    if (!isSchemaField(subject)) {\n      throw new Error('Subject must be a prisma field or enumerator!');\n    }\n\n    if (!subject.attributes) subject.attributes = [];\n    const attribute = subject.attributes.reduce<schema.Attribute>(\n      (memo, attr) =>\n        attr.type === 'attribute' &&\n        `${attr.group ? `${attr.group}.` : ''}${attr.name}` === name\n          ? attr\n          : memo,\n      {\n        type: 'attribute',\n        kind: 'field',\n        name,\n      }\n    );\n\n    if (Array.isArray(args)) {\n      const mapArg = (arg: Arg): schema.Value | schema.Func => {\n        return typeof arg === 'string'\n          ? arg\n          : {\n              type: 'function',\n              name: arg.name,\n              params: arg.function?.map(mapArg) ?? [],\n            };\n      };\n\n      if (args.length > 0)\n        attribute.args = args.map((arg) => ({\n          type: 'attributeArgument',\n          value: mapArg(arg),\n        }));\n    } else if (typeof args === 'object') {\n      attribute.args = Object.entries(args).map(([key, value]) => ({\n        type: 'attributeArgument',\n        value: { type: 'keyValue', key, value: { type: 'array', args: value } },\n      }));\n    }\n\n    if (!subject.attributes.includes(attribute))\n      subject.attributes.push(attribute);\n\n    return this;\n  }\n\n  /** Remove an attribute from the current field */\n  removeAttribute<T extends schema.Field>(name: string): this {\n    const parent = this.getParent();\n    const subject = this.getSubject<T>();\n    if (!isSchemaObject(parent)) {\n      throw new Error('Parent must be a prisma model or view!');\n    }\n\n    if (!isSchemaField(subject)) {\n      throw new Error('Subject must be a prisma field!');\n    }\n\n    if (!subject.attributes) subject.attributes = [];\n    subject.attributes = subject.attributes.filter(\n      (attr) => !(attr.type === 'attribute' && attr.name === name)\n    );\n\n    return this;\n  }\n\n  /** Add an assignment to a generator or datasource */\n  assignment<T extends schema.Generator | schema.Datasource>(\n    key: string,\n    value: string\n  ): this {\n    const subject = this.getSubject<T>();\n    if (\n      !subject ||\n      !('type' in subject) ||\n      !['generator', 'datasource'].includes(subject.type)\n    )\n      throw new Error('Subject must be a prisma generator or datasource!');\n\n    function tap<T>(subject: T, callback: (s: T) => void) {\n      callback(subject);\n      return subject;\n    }\n\n    const assignment = subject.assignments.reduce<schema.Assignment>(\n      (memo, assignment) =>\n        assignment.type === 'assignment' && assignment.key === key\n          ? tap(assignment, (a) => {\n              a.value = `\"${value}\"`;\n            })\n          : memo,\n      {\n        type: 'assignment',\n        key,\n        value: `\"${value}\"`,\n      }\n    );\n\n    if (!subject.assignments.includes(assignment))\n      subject.assignments.push(assignment);\n\n    return this;\n  }\n\n  /** Finder Methods */\n\n  /**\n   * Queries the block list for the given block type. Returns `null` if none\n   * match. Throws an error if more than one match is found.\n   * */\n  findByType<const Match extends finder.ByTypeMatch>(\n    typeToMatch: Match,\n    { within = this.schema.list, ...options }: PrismaSchemaFinderOptions\n  ): finder.FindByBlock<Match> | null {\n    return finder.findByType(within, typeToMatch, options);\n  }\n\n  /**\n   * Queries the block list for the given block type. Returns an array of all\n   * matching objects, and an empty array (`[]`) if none match.\n   * */\n  findAllByType<const Match extends finder.ByTypeMatch>(\n    typeToMatch: Match,\n    { within = this.schema.list, ...options }: PrismaSchemaFinderOptions\n  ): Array<finder.FindByBlock<Match> | null> {\n    return finder.findAllByType(within, typeToMatch, options);\n  }\n\n  /** Internal Utilities */\n\n  private blockInsert(statement: schema.Break | schema.Comment): this {\n    let subject = this.getSubject<schema.Block>();\n    const allowed = [\n      'datasource',\n      'enum',\n      'generator',\n      'model',\n      'view',\n      'type',\n    ];\n    if (!subject || !('type' in subject) || !allowed.includes(subject.type)) {\n      const parent = this.getParent<schema.Block>();\n      if (!parent || !('type' in parent) || !allowed.includes(parent.type)) {\n        throw new Error('Subject must be a prisma block!');\n      }\n\n      subject = this._subject = parent;\n    }\n\n    switch (subject.type) {\n      case 'datasource': {\n        subject.assignments.push(statement);\n        break;\n      }\n      case 'enum': {\n        subject.enumerators.push(statement);\n        break;\n      }\n      case 'generator': {\n        subject.assignments.push(statement);\n        break;\n      }\n      case 'model': {\n        subject.properties.push(statement);\n        break;\n      }\n    }\n    return this;\n  }\n\n  /** Add a line break */\n  break(): this {\n    const lineBreak: schema.Break = { type: 'break' };\n    return this.blockInsert(lineBreak);\n  }\n\n  /**\n   * Add a comment. Regular comments start with // and do not appear in the\n   * prisma AST. Node comments start with /// and will appear in the AST,\n   * affixed to the node that follows the comment.\n   * */\n  comment(text: string, node = false): this {\n    const comment: schema.Comment = {\n      type: 'comment',\n      text: `//${node ? '/' : ''} ${text}`,\n    };\n    return this.blockInsert(comment);\n  }\n\n  /**\n   * Add a comment to the schema. Regular comments start with // and do not appear in the\n   * prisma AST. Node comments start with /// and will appear in the AST,\n   * affixed to the node that follows the comment.\n   * */\n  schemaComment(text: string, node = false): this {\n    const comment: schema.Comment = {\n      type: 'comment',\n      text: `//${node ? '/' : ''} ${text}`,\n    };\n    this.schema.list.push(comment);\n    return this;\n  }\n\n  /**\n   * Adds or updates a field in the current model. The field can be customized\n   * further with one or more .attribute() calls.\n   * */\n  field(name: string, fieldType: string | schema.Func = 'String'): this {\n    let subject = this.getSubject<schema.Object>();\n    if (!isSchemaObject(subject)) {\n      const parent = this.getParent<schema.Object>();\n      if (!isSchemaObject(parent))\n        throw new Error(\n          'Subject must be a prisma model or view or composite type!'\n        );\n\n      subject = this._subject = parent;\n    }\n\n    const field = subject.properties.reduce<schema.Field>(\n      (memo, block) =>\n        block.type === 'field' && block.name === name ? block : memo,\n      {\n        type: 'field',\n        name,\n        fieldType,\n      }\n    );\n\n    if (!subject.properties.includes(field)) subject.properties.push(field);\n    this._parent = subject;\n    this._subject = field;\n    return this;\n  }\n\n  /** Drop a field from the current model or view or composite type. */\n  removeField(name: string): this {\n    let subject = this.getSubject<schema.Object>();\n    if (!isSchemaObject(subject)) {\n      const parent = this.getParent<schema.Object>();\n      if (!isSchemaObject(parent))\n        throw new Error(\n          'Subject must be a prisma model or view or composite type!'\n        );\n\n      subject = this._subject = parent;\n    }\n\n    subject.properties = subject.properties.filter(\n      (field) => !(field.type === 'field' && field.name === name)\n    );\n    return this;\n  }\n\n  /**\n   * Returns the current subject, allowing for more advanced ways of\n   * manipulating the schema.\n   * */\n  then<R extends NonNullable<Subject>>(\n    callback: (subject: R) => unknown\n  ): this {\n    callback(this._subject as R);\n    return this;\n  }\n}\n\nexport function createPrismaSchemaBuilder(\n  source?: string\n): PrismaSchemaBuilder<\n  Exclude<\n    keyof ConcretePrismaSchemaBuilder,\n    DatasourceOrGeneratorKeys | EnumKeys | FieldKeys | BlockKeys\n  >\n> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return new ConcretePrismaSchemaBuilder(source) as any;\n}\n","import { PrintOptions } from './printSchema';\nimport { createPrismaSchemaBuilder } from './PrismaSchemaBuilder';\n\ntype Options = PrintOptions;\n\n/**\n * Receives a prisma schema in the form of a string containing source code, and\n * a callback builder function. Use the builder to modify your schema as\n * desired. Returns the schema as a string with the modifications applied.\n * */\nexport function produceSchema(\n  source: string,\n  producer: (builder: ReturnType<typeof createPrismaSchemaBuilder>) => void,\n  options: Options = {}\n): string {\n  const builder = createPrismaSchemaBuilder(source);\n  producer(builder);\n  return builder.print(options);\n}\n"],"names":["Identifier","createToken","name","pattern","Datasource","push_mode","Generator","Model","View","Enum","Type","True","longer_alt","False","Null","Comment","Lexer","NA","DocComment","categories","LineComment","Attribute","BlockAttribute","label","FieldAttribute","Dot","QuestionMark","LCurly","RCurly","pop_mode","LRound","RRound","LSquare","RSquare","Comma","Colon","Equals","StringLiteral","NumberLiteral","WhiteSpace","group","SKIPPED","LineBreak","line_breaks","naTokens","multiModeTokens","modes","global","concat","block","defaultMode","PrismaLexer","schemaObjects","isOneOfSchemaObjects","obj","schemas","includes","type","isSchemaObject","fieldObjects","isSchemaField","field","appendLocationData","data","_len","arguments","length","tokens","Array","_key","location","reduce","memo","token","_memo$endColumn","endColumn","Infinity","_memo$endLine","endLine","_memo$endOffset","endOffset","_memo$startColumn","startColumn","_memo$startLine","startLine","_memo$startOffset","startOffset","Object","assign","config","defaultConfig","parser","nodeLocationTracking","PrismaParser","_CstParser","_this","call","this","lexer","RULE","CONSUME1","CONSUME2","keyedArg","CONSUME","LABEL","SUBRULE","value","array","MANY_SEP","SEP","DEF","func","OR","ALT","property","assignment","OPTION1","MANY","fieldAttribute","OPTION2","options","componentType","isEnum","isObject","comment","GATE","blockAttribute","OPTION","attributeArg","component","OR1","OR2","ARGS","image","schema","performSelfAnalysis","_inheritsLoose","CstParser","defaultParser","result","configSync","lilconfigSync","search","getConfig","VisitorClassFactory","_BasePrismaVisitor","PrismaVisitor","validateVisitor","_proto","prototype","ctx","_ctx$list","_this2","list","map","item","visit","componentName","assignments","properties","enumerators","Error","maybeAppendLocationData","text","_ctx$list2","_this3","assignmentValue","key","assignmentName","_ctx$attributeList","_ctx$comment","_ctx$optional","_ctx$array","_this4","fieldType","fieldName","attributes","attributeList","optional","_ctx$attributeArg","_this5","attributeName","groupName","args","attr","apply","kind","_ctx$attributeArg2","_this6","_ctx$value","_ctx$keyedArg","_this7","funcName","params","keyedParams","pars","_ctx$value2","_this8","keyName","_ctx$attributeList2","_ctx$comment2","_this9","enumName","getBaseCstVisitorConstructorWithDefaults","defaultVisitor","getSchema","source","_options$parser","_options$visitor","lexingResult","tokenize","input","cstNode","errors","visitor","unsorted","defaultSortOrder","printSchema","_options$sort","sort","_options$locales","locales","undefined","_options$sortOrder","sortOrder","blocks","filter","sorter","a","b","indexOf","typeIndex","localeCompare","schemaSorter","printBlock","Boolean","join","EOL","replace","printComment","children","computeAssignmentFormatting","db","enumerator","printEnumerator","printEnum","generator","printGenerator","object","_props","props","blockAttributeMoved","attrIndex","findIndex","needsSpace","splice","pos","listBlocks","nameLengths","typeLengths","current","index","arr","push","lists","max","Math","printFieldType","prop","shift","node","nameLength","typeLength","printAttribute","padEnd","attrs","trim","printField","printBreak","printProperty","printObject","attribute","printAttributeArg","unshift","arg","printValue","suffix","printFunction","String","keyLengths","keyLength","printAssignment","findBy","typeToMatch","_temp","nameAttribute","test","ConcretePrismaSchemaBuilder","_subject","_parent","print","provider","drop","datasource","url","env","existingIndex","model","view","enumeratorNames","e","subject","getSubject","getParent","parent","isArray","entries","_ref","mapArg","_arg$function$map","_arg$function","_ref2","removeAttribute","callback","tap","findByType","_ref3","_ref3$within","within","_list$filter","match","finder","_objectWithoutPropertiesLoose","_excluded","findAllByType","_ref4","_ref4$within","_excluded2","blockInsert","statement","allowed","schemaComment","removeField","then","createPrismaSchemaBuilder","producer","builder"],"mappings":"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"}