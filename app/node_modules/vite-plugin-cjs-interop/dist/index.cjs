"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  cjsInterop: () => cjsInterop
});
module.exports = __toCommonJS(src_exports);
var import_acorn = require("acorn");
var import_acorn_import_assertions = require("acorn-import-assertions");
var import_magic_string = __toESM(require("magic-string"), 1);
var import_minimatch = require("minimatch");
var walker = import("estree-walker");
var CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
function cjsInterop(options) {
  const virtualModuleId = "virtual:cjs-dyn-import";
  const dependencies = Array.from(new Set(options.dependencies));
  const { client = false, apply = "both" } = options;
  let sourcemaps = false;
  const matchesDependencies = (value) => {
    return dependencies.some((dependency) => (0, import_minimatch.minimatch)(value, dependency));
  };
  return {
    name: "cjs-interop",
    enforce: "post",
    apply: apply === "both" ? void 0 : apply,
    configResolved(config) {
      sourcemaps = !!config.build.sourcemap;
    },
    async transform(code, id, options2) {
      if (!client && !options2?.ssr) return;
      if (CSS_LANGS_RE.test(id)) return;
      const ast = import_acorn.Parser.extend(import_acorn_import_assertions.importAssertions).parse(code, {
        sourceType: "module",
        ecmaVersion: "latest",
        locations: true,
        allowHashBang: true
      });
      const toBeFixed = [];
      const dynamicImportsToBeFixed = [];
      const preambles = [];
      const { walk } = await walker;
      walk(ast, {
        enter(node) {
          if (node.type === "ImportDeclaration") {
            if (matchesDependencies(node.source.value)) {
              toBeFixed.push(node);
            }
          } else if (node.type === "ImportExpression") {
            if (node.source.type === "Literal" && matchesDependencies(node.source.value)) {
              dynamicImportsToBeFixed.push(node);
            }
          }
        }
      });
      if (toBeFixed.length === 0 && dynamicImportsToBeFixed.length === 0) {
        return;
      }
      const bottomUpToBeFixed = toBeFixed.reverse();
      const ms = sourcemaps ? new import_magic_string.default(code) : null;
      let counter = 1;
      let isNamespaceImport = false;
      for (const node of dynamicImportsToBeFixed.reverse()) {
        const insertion = ".then(__cjs_dyn_import__)";
        if (sourcemaps) {
          ms.appendRight(node.end, insertion);
        } else {
          code = code.slice(0, node.end) + insertion + code.slice(node.end);
        }
      }
      for (const node of bottomUpToBeFixed) {
        const destructurings = [];
        const name = `__cjsInterop${counter++}__`;
        let changed = false;
        for (const specifier of node.specifiers) {
          if (specifier.type === "ImportDefaultSpecifier") {
            changed = true;
            destructurings.push(
              `default: ${specifier.local.name} = ${name}`
            );
          } else if (specifier.type === "ImportSpecifier") {
            changed = true;
            if (specifier.imported.name === specifier.local.name) {
              destructurings.push(specifier.local.name);
            } else {
              destructurings.push(
                `${specifier.imported.name}: ${specifier.local.name}`
              );
            }
          } else if (specifier.type === "ImportNamespaceSpecifier") {
            changed = true;
            isNamespaceImport = true;
            destructurings.push(specifier.local.name);
          }
        }
        if (!changed) {
          continue;
        }
        if (!isNamespaceImport)
          preambles.push(
            `const { ${destructurings.join(
              ", "
            )} } = ${name}?.default?.__esModule ? ${name}.default : ${name};`
          );
        else
          preambles.push(
            `const ${destructurings[0]} = ${name}?.default?.__esModule ? ${name}.default : ${name};`
          );
        const replacement = `import ${name} from ${JSON.stringify(
          node.source.value
        )};`;
        if (sourcemaps) {
          ms.overwrite(node.start, node.end, replacement);
        } else {
          code = code.slice(0, node.start) + replacement + code.slice(node.end);
        }
      }
      if (dynamicImportsToBeFixed.length) {
        const importCompat = `import { __cjs_dyn_import__ } from "${virtualModuleId}";
`;
        if (sourcemaps) {
          ms.prepend(importCompat);
        } else {
          code = importCompat + code;
        }
      }
      const preamble = preambles.reverse().join("\n") + "\n";
      if (sourcemaps) {
        ms.prepend(preamble);
        return {
          code: ms.toString(),
          map: ms.generateMap({ hires: true })
        };
      } else {
        code = preamble + code;
        return {
          code
        };
      }
    },
    resolveId(id) {
      if (id === virtualModuleId) {
        return id;
      }
    },
    load(id) {
      if (id === virtualModuleId) {
        return `
// This file is generated by vite-plugin-cjs-interop
// The cache allows the same object to be returned for the same dynamic import
// however static imports are not affected and will therefore return a different
// object
const modCache = new WeakMap();

export function __cjs_dyn_import__(rawImport) {
  if (rawImport?.default?.__esModule) {
    return rawImport.default;
  }
  if (modCache.has(rawImport)) {
    return modCache.get(rawImport);
  }
  const source = rawImport?.default;
  if (source) {
    const mod = Object.create(rawImport);
    modCache.set(rawImport, mod);
    Object.keys(source)
      .filter(key => !Object.hasOwn(rawImport, key))
      .forEach(key => {
        Object.defineProperty(mod, key, { enumerable: true, get: () => source[key] })
      });
    return mod;
  }
  return rawImport;
}`;
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  cjsInterop
});
