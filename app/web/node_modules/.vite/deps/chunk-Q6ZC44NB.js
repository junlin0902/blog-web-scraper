import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  useNoAuth
} from "./chunk-RINCEELR.js";
import {
  BREAK,
  Kind,
  __assign,
  __awaiter,
  __extends,
  __generator,
  __rest,
  __spreadArray,
  graphql_exports,
  init_graphql,
  init_lib,
  init_tslib_es6,
  isSelectionNode,
  lib_exports,
  print,
  tslib_es6_exports,
  visit
} from "./chunk-G6BOFV44.js";
import {
  require_react
} from "./chunk-ZILOSMTM.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-USKKUMLC.js";

// ../node_modules/ts-invariant/lib/invariant.js
var invariant_exports = {};
__export(invariant_exports, {
  InvariantError: () => InvariantError,
  default: () => invariant_default,
  invariant: () => invariant,
  setVerbosity: () => setVerbosity
});
function invariant(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
function wrapConsoleMethod(name) {
  return function() {
    if (verbosityLevels.indexOf(name) >= verbosityLevel) {
      var method = console[name] || console.log;
      return method.apply(console, arguments);
    }
  };
}
function setVerbosity(level) {
  var old = verbosityLevels[verbosityLevel];
  verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
  return old;
}
var import_dist7, import_dist8, import_dist9, genericMessage, _a, setPrototypeOf, InvariantError, verbosityLevels, verbosityLevel, invariant_default;
var init_invariant = __esm({
  "../node_modules/ts-invariant/lib/invariant.js"() {
    import_dist7 = __toESM(require_dist());
    import_dist8 = __toESM(require_dist2());
    import_dist9 = __toESM(require_dist3());
    init_tslib_es6();
    genericMessage = "Invariant Violation";
    _a = Object.setPrototypeOf;
    setPrototypeOf = _a === void 0 ? function(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    } : _a;
    InvariantError = /** @class */
    function(_super) {
      __extends(InvariantError2, _super);
      function InvariantError2(message) {
        if (message === void 0) {
          message = genericMessage;
        }
        var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError2.prototype);
        return _this;
      }
      return InvariantError2;
    }(Error);
    verbosityLevels = ["debug", "log", "warn", "error", "silent"];
    verbosityLevel = verbosityLevels.indexOf("log");
    (function(invariant4) {
      invariant4.debug = wrapConsoleMethod("debug");
      invariant4.log = wrapConsoleMethod("log");
      invariant4.warn = wrapConsoleMethod("warn");
      invariant4.error = wrapConsoleMethod("error");
    })(invariant || (invariant = {}));
    invariant_default = invariant;
  }
});

// ../node_modules/@wry/trie/lib/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  Trie: () => Trie
});
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
var import_dist34, import_dist35, import_dist36, defaultMakeData, forEach, slice, hasOwnProperty, Trie;
var init_lib2 = __esm({
  "../node_modules/@wry/trie/lib/index.js"() {
    import_dist34 = __toESM(require_dist());
    import_dist35 = __toESM(require_dist2());
    import_dist36 = __toESM(require_dist3());
    defaultMakeData = () => /* @__PURE__ */ Object.create(null);
    ({ forEach, slice } = Array.prototype);
    ({ hasOwnProperty } = Object.prototype);
    Trie = class _Trie {
      constructor(weakness = true, makeData = defaultMakeData) {
        this.weakness = weakness;
        this.makeData = makeData;
      }
      lookup() {
        return this.lookupArray(arguments);
      }
      lookupArray(array) {
        let node = this;
        forEach.call(array, (key) => node = node.getChildTrie(key));
        return hasOwnProperty.call(node, "data") ? node.data : node.data = this.makeData(slice.call(array));
      }
      peek() {
        return this.peekArray(arguments);
      }
      peekArray(array) {
        let node = this;
        for (let i = 0, len = array.length; node && i < len; ++i) {
          const map = node.mapFor(array[i], false);
          node = map && map.get(array[i]);
        }
        return node && node.data;
      }
      remove() {
        return this.removeArray(arguments);
      }
      removeArray(array) {
        let data;
        if (array.length) {
          const head = array[0];
          const map = this.mapFor(head, false);
          const child = map && map.get(head);
          if (child) {
            data = child.removeArray(slice.call(array, 1));
            if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
              map.delete(head);
            }
          }
        } else {
          data = this.data;
          delete this.data;
        }
        return data;
      }
      getChildTrie(key) {
        const map = this.mapFor(key, true);
        let child = map.get(key);
        if (!child)
          map.set(key, child = new _Trie(this.weakness, this.makeData));
        return child;
      }
      mapFor(key, create) {
        return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (create ? this.strong = /* @__PURE__ */ new Map() : void 0);
      }
    };
  }
});

// ../node_modules/@wry/caches/lib/strong.js
function defaultDispose() {
}
var import_dist46, import_dist47, import_dist48, StrongCache;
var init_strong = __esm({
  "../node_modules/@wry/caches/lib/strong.js"() {
    import_dist46 = __toESM(require_dist(), 1);
    import_dist47 = __toESM(require_dist2(), 1);
    import_dist48 = __toESM(require_dist3(), 1);
    StrongCache = class {
      constructor(max = Infinity, dispose = defaultDispose) {
        this.max = max;
        this.dispose = dispose;
        this.map = /* @__PURE__ */ new Map();
        this.newest = null;
        this.oldest = null;
      }
      has(key) {
        return this.map.has(key);
      }
      get(key) {
        const node = this.getNode(key);
        return node && node.value;
      }
      get size() {
        return this.map.size;
      }
      getNode(key) {
        const node = this.map.get(key);
        if (node && node !== this.newest) {
          const { older, newer } = node;
          if (newer) {
            newer.older = older;
          }
          if (older) {
            older.newer = newer;
          }
          node.older = this.newest;
          node.older.newer = node;
          node.newer = null;
          this.newest = node;
          if (node === this.oldest) {
            this.oldest = newer;
          }
        }
        return node;
      }
      set(key, value) {
        let node = this.getNode(key);
        if (node) {
          return node.value = value;
        }
        node = {
          key,
          value,
          newer: null,
          older: this.newest
        };
        if (this.newest) {
          this.newest.newer = node;
        }
        this.newest = node;
        this.oldest = this.oldest || node;
        this.map.set(key, node);
        return node.value;
      }
      clean() {
        while (this.oldest && this.map.size > this.max) {
          this.delete(this.oldest.key);
        }
      }
      delete(key) {
        const node = this.map.get(key);
        if (node) {
          if (node === this.newest) {
            this.newest = node.older;
          }
          if (node === this.oldest) {
            this.oldest = node.newer;
          }
          if (node.newer) {
            node.newer.older = node.older;
          }
          if (node.older) {
            node.older.newer = node.newer;
          }
          this.map.delete(key);
          this.dispose(node.value, key);
          return true;
        }
        return false;
      }
    };
  }
});

// ../node_modules/@wry/caches/lib/weak.js
function noop() {
}
var import_dist49, import_dist50, import_dist51, defaultDispose2, _WeakRef, _WeakMap, _FinalizationRegistry, finalizationBatchSize, WeakCache;
var init_weak = __esm({
  "../node_modules/@wry/caches/lib/weak.js"() {
    import_dist49 = __toESM(require_dist(), 1);
    import_dist50 = __toESM(require_dist2(), 1);
    import_dist51 = __toESM(require_dist3(), 1);
    defaultDispose2 = noop;
    _WeakRef = typeof WeakRef !== "undefined" ? WeakRef : function(value) {
      return { deref: () => value };
    };
    _WeakMap = typeof WeakMap !== "undefined" ? WeakMap : Map;
    _FinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : function() {
      return {
        register: noop,
        unregister: noop
      };
    };
    finalizationBatchSize = 10024;
    WeakCache = class {
      constructor(max = Infinity, dispose = defaultDispose2) {
        this.max = max;
        this.dispose = dispose;
        this.map = new _WeakMap();
        this.newest = null;
        this.oldest = null;
        this.unfinalizedNodes = /* @__PURE__ */ new Set();
        this.finalizationScheduled = false;
        this.size = 0;
        this.finalize = () => {
          const iterator = this.unfinalizedNodes.values();
          for (let i = 0; i < finalizationBatchSize; i++) {
            const node = iterator.next().value;
            if (!node)
              break;
            this.unfinalizedNodes.delete(node);
            const key = node.key;
            delete node.key;
            node.keyRef = new _WeakRef(key);
            this.registry.register(key, node, node);
          }
          if (this.unfinalizedNodes.size > 0) {
            queueMicrotask(this.finalize);
          } else {
            this.finalizationScheduled = false;
          }
        };
        this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));
      }
      has(key) {
        return this.map.has(key);
      }
      get(key) {
        const node = this.getNode(key);
        return node && node.value;
      }
      getNode(key) {
        const node = this.map.get(key);
        if (node && node !== this.newest) {
          const { older, newer } = node;
          if (newer) {
            newer.older = older;
          }
          if (older) {
            older.newer = newer;
          }
          node.older = this.newest;
          node.older.newer = node;
          node.newer = null;
          this.newest = node;
          if (node === this.oldest) {
            this.oldest = newer;
          }
        }
        return node;
      }
      set(key, value) {
        let node = this.getNode(key);
        if (node) {
          return node.value = value;
        }
        node = {
          key,
          value,
          newer: null,
          older: this.newest
        };
        if (this.newest) {
          this.newest.newer = node;
        }
        this.newest = node;
        this.oldest = this.oldest || node;
        this.scheduleFinalization(node);
        this.map.set(key, node);
        this.size++;
        return node.value;
      }
      clean() {
        while (this.oldest && this.size > this.max) {
          this.deleteNode(this.oldest);
        }
      }
      deleteNode(node) {
        if (node === this.newest) {
          this.newest = node.older;
        }
        if (node === this.oldest) {
          this.oldest = node.newer;
        }
        if (node.newer) {
          node.newer.older = node.older;
        }
        if (node.older) {
          node.older.newer = node.newer;
        }
        this.size--;
        const key = node.key || node.keyRef && node.keyRef.deref();
        this.dispose(node.value, key);
        if (!node.keyRef) {
          this.unfinalizedNodes.delete(node);
        } else {
          this.registry.unregister(node);
        }
        if (key)
          this.map.delete(key);
      }
      delete(key) {
        const node = this.map.get(key);
        if (node) {
          this.deleteNode(node);
          return true;
        }
        return false;
      }
      scheduleFinalization(node) {
        this.unfinalizedNodes.add(node);
        if (!this.finalizationScheduled) {
          this.finalizationScheduled = true;
          queueMicrotask(this.finalize);
        }
      }
    };
  }
});

// ../node_modules/@wry/caches/lib/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  StrongCache: () => StrongCache,
  WeakCache: () => WeakCache
});
var import_dist52, import_dist53, import_dist54;
var init_lib3 = __esm({
  "../node_modules/@wry/caches/lib/index.js"() {
    import_dist52 = __toESM(require_dist());
    import_dist53 = __toESM(require_dist2());
    import_dist54 = __toESM(require_dist3());
    init_strong();
    init_weak();
  }
});

// ../node_modules/optimism/node_modules/@wry/trie/lib/index.js
function isObjRef2(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
var import_dist76, import_dist77, import_dist78, defaultMakeData2, forEach2, slice2, hasOwnProperty2, Trie2;
var init_lib4 = __esm({
  "../node_modules/optimism/node_modules/@wry/trie/lib/index.js"() {
    import_dist76 = __toESM(require_dist());
    import_dist77 = __toESM(require_dist2());
    import_dist78 = __toESM(require_dist3());
    defaultMakeData2 = () => /* @__PURE__ */ Object.create(null);
    ({ forEach: forEach2, slice: slice2 } = Array.prototype);
    ({ hasOwnProperty: hasOwnProperty2 } = Object.prototype);
    Trie2 = class _Trie {
      constructor(weakness = true, makeData = defaultMakeData2) {
        this.weakness = weakness;
        this.makeData = makeData;
      }
      lookup(...array) {
        return this.lookupArray(array);
      }
      lookupArray(array) {
        let node = this;
        forEach2.call(array, (key) => node = node.getChildTrie(key));
        return hasOwnProperty2.call(node, "data") ? node.data : node.data = this.makeData(slice2.call(array));
      }
      peek(...array) {
        return this.peekArray(array);
      }
      peekArray(array) {
        let node = this;
        for (let i = 0, len = array.length; node && i < len; ++i) {
          const map = this.weakness && isObjRef2(array[i]) ? node.weak : node.strong;
          node = map && map.get(array[i]);
        }
        return node && node.data;
      }
      getChildTrie(key) {
        const map = this.weakness && isObjRef2(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
        let child = map.get(key);
        if (!child)
          map.set(key, child = new _Trie(this.weakness, this.makeData));
        return child;
      }
    };
  }
});

// ../node_modules/@wry/context/lib/slot.js
function maybe2(fn) {
  try {
    return fn();
  } catch (ignored) {
  }
}
var import_dist79, import_dist80, import_dist81, currentContext, MISSING_VALUE, idCounter, makeSlotClass, globalKey, host, globalHost, Slot;
var init_slot = __esm({
  "../node_modules/@wry/context/lib/slot.js"() {
    import_dist79 = __toESM(require_dist(), 1);
    import_dist80 = __toESM(require_dist2(), 1);
    import_dist81 = __toESM(require_dist3(), 1);
    currentContext = null;
    MISSING_VALUE = {};
    idCounter = 1;
    makeSlotClass = () => class Slot {
      constructor() {
        this.id = [
          "slot",
          idCounter++,
          Date.now(),
          Math.random().toString(36).slice(2)
        ].join(":");
      }
      hasValue() {
        for (let context = currentContext; context; context = context.parent) {
          if (this.id in context.slots) {
            const value = context.slots[this.id];
            if (value === MISSING_VALUE)
              break;
            if (context !== currentContext) {
              currentContext.slots[this.id] = value;
            }
            return true;
          }
        }
        if (currentContext) {
          currentContext.slots[this.id] = MISSING_VALUE;
        }
        return false;
      }
      getValue() {
        if (this.hasValue()) {
          return currentContext.slots[this.id];
        }
      }
      withValue(value, callback, args, thisArg) {
        const slots = {
          __proto__: null,
          [this.id]: value
        };
        const parent = currentContext;
        currentContext = { parent, slots };
        try {
          return callback.apply(thisArg, args);
        } finally {
          currentContext = parent;
        }
      }
      // Capture the current context and wrap a callback function so that it
      // reestablishes the captured context when called.
      static bind(callback) {
        const context = currentContext;
        return function() {
          const saved = currentContext;
          try {
            currentContext = context;
            return callback.apply(this, arguments);
          } finally {
            currentContext = saved;
          }
        };
      }
      // Immediately run a callback function without any captured context.
      static noContext(callback, args, thisArg) {
        if (currentContext) {
          const saved = currentContext;
          try {
            currentContext = null;
            return callback.apply(thisArg, args);
          } finally {
            currentContext = saved;
          }
        } else {
          return callback.apply(thisArg, args);
        }
      }
    };
    globalKey = "@wry/context:Slot";
    host = // Prefer globalThis when available.
    // https://github.com/benjamn/wryware/issues/347
    maybe2(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
    // bundlers to the appropriate identifier (window, self, ...) depending on the
    // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
    maybe2(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
    // back to using the Array constructor as a namespace, but that was flagged in
    // https://github.com/benjamn/wryware/issues/347, and can be avoided.
    /* @__PURE__ */ Object.create(null);
    globalHost = host;
    Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
    // constructor, so we check there as well, to prevent Slot class duplication.
    Array[globalKey] || function(Slot2) {
      try {
        Object.defineProperty(globalHost, globalKey, {
          value: Slot2,
          enumerable: false,
          writable: false,
          // When it was possible for globalHost to be the Array constructor (a
          // legacy Slot dedup strategy), it was important for the property to be
          // configurable:true so it could be deleted. That does not seem to be as
          // important when globalHost is the global object, but I don't want to
          // cause similar problems again, and configurable:true seems safest.
          // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
          configurable: true
        });
      } finally {
        return Slot2;
      }
    }(makeSlotClass());
  }
});

// ../node_modules/@wry/context/lib/index.js
function setTimeoutWithContext(callback, delay) {
  return setTimeout(bind(callback), delay);
}
function asyncFromGen(genFn) {
  return function() {
    const gen = genFn.apply(this, arguments);
    const boundNext = bind(gen.next);
    const boundThrow = bind(gen.throw);
    return new Promise((resolve, reject) => {
      function invoke(method, argument) {
        try {
          var result2 = method.call(gen, argument);
        } catch (error) {
          return reject(error);
        }
        const next = result2.done ? resolve : invokeNext;
        if (isPromiseLike(result2.value)) {
          result2.value.then(next, result2.done ? reject : invokeThrow);
        } else {
          next(result2.value);
        }
      }
      const invokeNext = (value) => invoke(boundNext, value);
      const invokeThrow = (error) => invoke(boundThrow, error);
      invokeNext();
    });
  };
}
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var import_dist82, import_dist83, import_dist84, bind, noContext;
var init_lib5 = __esm({
  "../node_modules/@wry/context/lib/index.js"() {
    import_dist82 = __toESM(require_dist());
    import_dist83 = __toESM(require_dist2());
    import_dist84 = __toESM(require_dist3());
    init_slot();
    ({ bind, noContext } = Slot);
  }
});

// ../node_modules/optimism/lib/context.js
function nonReactive(fn) {
  return parentEntrySlot.withValue(void 0, fn);
}
var import_dist85, import_dist86, import_dist87, parentEntrySlot;
var init_context = __esm({
  "../node_modules/optimism/lib/context.js"() {
    import_dist85 = __toESM(require_dist(), 1);
    import_dist86 = __toESM(require_dist2(), 1);
    import_dist87 = __toESM(require_dist3(), 1);
    init_lib5();
    init_lib5();
    parentEntrySlot = new Slot();
  }
});

// ../node_modules/optimism/lib/helpers.js
function maybeUnsubscribe(entryOrDep) {
  const { unsubscribe } = entryOrDep;
  if (typeof unsubscribe === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe();
  }
}
var import_dist88, import_dist89, import_dist90, hasOwnProperty3, arrayFromSet;
var init_helpers = __esm({
  "../node_modules/optimism/lib/helpers.js"() {
    import_dist88 = __toESM(require_dist(), 1);
    import_dist89 = __toESM(require_dist2(), 1);
    import_dist90 = __toESM(require_dist3(), 1);
    ({ hasOwnProperty: hasOwnProperty3 } = Object.prototype);
    arrayFromSet = Array.from || function(set) {
      const array = [];
      set.forEach((item) => array.push(item));
      return array;
    };
  }
});

// ../node_modules/optimism/lib/entry.js
function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a, b) {
  const len = a.length;
  return (
    // Unknown values are not equal to each other.
    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    len === b.length && // The underlying value or exception must be the same.
    a[len - 1] === b[len - 1]
  );
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
function rememberParent(child) {
  const parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  const { normalizeResult } = entry;
  let oldValueCopy;
  if (normalizeResult && entry.value.length === 1) {
    oldValueCopy = valueCopy(entry.value);
  }
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
    if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
      try {
        entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
      } catch (_a2) {
      }
    }
  } catch (e) {
    entry.value[1] = e;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  eachParent(child, reportDirtyChild);
}
function reportClean(child) {
  eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
  const parentCount = child.parents.size;
  if (parentCount) {
    const parents = arrayFromSet(child.parents);
    for (let i = 0; i < parentCount; ++i) {
      callback(parents[i], child);
    }
  }
}
function reportDirtyChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(mightBeDirty(child));
  const parentWasClean = !mightBeDirty(parent);
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  if (parentWasClean) {
    reportDirty(parent);
  }
}
function reportCleanChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(!mightBeDirty(child));
  const childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  const dc = parent.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      parent.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent) {
  if (parent.childValues.size > 0) {
    parent.childValues.forEach((_value, child) => {
      forgetChild(parent, child);
    });
  }
  parent.forgetDeps();
  assert(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
var import_dist91, import_dist92, import_dist93, emptySetPool, POOL_TARGET_SIZE, Entry;
var init_entry = __esm({
  "../node_modules/optimism/lib/entry.js"() {
    import_dist91 = __toESM(require_dist(), 1);
    import_dist92 = __toESM(require_dist2(), 1);
    import_dist93 = __toESM(require_dist3(), 1);
    init_context();
    init_helpers();
    emptySetPool = [];
    POOL_TARGET_SIZE = 100;
    Entry = class _Entry {
      constructor(fn) {
        this.fn = fn;
        this.parents = /* @__PURE__ */ new Set();
        this.childValues = /* @__PURE__ */ new Map();
        this.dirtyChildren = null;
        this.dirty = true;
        this.recomputing = false;
        this.value = [];
        this.deps = null;
        ++_Entry.count;
      }
      peek() {
        if (this.value.length === 1 && !mightBeDirty(this)) {
          rememberParent(this);
          return this.value[0];
        }
      }
      // This is the most important method of the Entry API, because it
      // determines whether the cached this.value can be returned immediately,
      // or must be recomputed. The overall performance of the caching system
      // depends on the truth of the following observations: (1) this.dirty is
      // usually false, (2) this.dirtyChildren is usually null/empty, and thus
      // (3) valueGet(this.value) is usually returned without recomputation.
      recompute(args) {
        assert(!this.recomputing, "already recomputing");
        rememberParent(this);
        return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
      }
      setDirty() {
        if (this.dirty)
          return;
        this.dirty = true;
        reportDirty(this);
        maybeUnsubscribe(this);
      }
      dispose() {
        this.setDirty();
        forgetChildren(this);
        eachParent(this, (parent, child) => {
          parent.setDirty();
          forgetChild(parent, this);
        });
      }
      forget() {
        this.dispose();
      }
      dependOn(dep2) {
        dep2.add(this);
        if (!this.deps) {
          this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
        }
        this.deps.add(dep2);
      }
      forgetDeps() {
        if (this.deps) {
          arrayFromSet(this.deps).forEach((dep2) => dep2.delete(this));
          this.deps.clear();
          emptySetPool.push(this.deps);
          this.deps = null;
        }
      }
    };
    Entry.count = 0;
  }
});

// ../node_modules/optimism/lib/dep.js
function dep(options) {
  const depsByKey = /* @__PURE__ */ new Map();
  const subscribe = options && options.subscribe;
  function depend(key) {
    const parent = parentEntrySlot.getValue();
    if (parent) {
      let dep2 = depsByKey.get(key);
      if (!dep2) {
        depsByKey.set(key, dep2 = /* @__PURE__ */ new Set());
      }
      parent.dependOn(dep2);
      if (typeof subscribe === "function") {
        maybeUnsubscribe(dep2);
        dep2.unsubscribe = subscribe(key);
      }
    }
  }
  depend.dirty = function dirty(key, entryMethodName) {
    const dep2 = depsByKey.get(key);
    if (dep2) {
      const m = entryMethodName && hasOwnProperty3.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
      arrayFromSet(dep2).forEach((entry) => entry[m]());
      depsByKey.delete(key);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}
var import_dist94, import_dist95, import_dist96, EntryMethods;
var init_dep = __esm({
  "../node_modules/optimism/lib/dep.js"() {
    import_dist94 = __toESM(require_dist(), 1);
    import_dist95 = __toESM(require_dist2(), 1);
    import_dist96 = __toESM(require_dist3(), 1);
    init_context();
    init_helpers();
    EntryMethods = {
      setDirty: true,
      dispose: true,
      forget: true
      // Fully remove parent Entry from LRU cache and computation graph
    };
  }
});

// ../node_modules/optimism/lib/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  KeyTrie: () => Trie2,
  Slot: () => Slot,
  asyncFromGen: () => asyncFromGen,
  bindContext: () => bind,
  defaultMakeCacheKey: () => defaultMakeCacheKey,
  dep: () => dep,
  noContext: () => noContext,
  nonReactive: () => nonReactive,
  setTimeout: () => setTimeoutWithContext,
  wrap: () => wrap2
});
function defaultMakeCacheKey(...args) {
  const trie = defaultKeyTrie || (defaultKeyTrie = new Trie2(typeof WeakMap === "function"));
  return trie.lookupArray(args);
}
function wrap2(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = StrongCache } = /* @__PURE__ */ Object.create(null)) {
  const cache2 = typeof cacheOption === "function" ? new cacheOption(max, (entry) => entry.dispose()) : cacheOption;
  const optimistic = function() {
    const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    let entry = cache2.get(key);
    if (!entry) {
      cache2.set(key, entry = new Entry(originalFunction));
      entry.normalizeResult = normalizeResult;
      entry.subscribe = subscribe;
      entry.forget = () => cache2.delete(key);
    }
    const value = entry.recompute(Array.prototype.slice.call(arguments));
    cache2.set(key, entry);
    caches.add(cache2);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach((cache3) => cache3.clean());
      caches.clear();
    }
    return value;
  };
  Object.defineProperty(optimistic, "size", {
    get: () => cache2.size,
    configurable: false,
    enumerable: false
  });
  Object.freeze(optimistic.options = {
    max,
    keyArgs,
    makeCacheKey,
    normalizeResult,
    subscribe,
    cache: cache2
  });
  function dirtyKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      entry.setDirty();
    }
  }
  optimistic.dirtyKey = dirtyKey;
  optimistic.dirty = function dirty() {
    dirtyKey(makeCacheKey.apply(null, arguments));
  };
  function peekKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      return entry.peek();
    }
  }
  optimistic.peekKey = peekKey;
  optimistic.peek = function peek() {
    return peekKey(makeCacheKey.apply(null, arguments));
  };
  function forgetKey(key) {
    return key ? cache2.delete(key) : false;
  }
  optimistic.forgetKey = forgetKey;
  optimistic.forget = function forget() {
    return forgetKey(makeCacheKey.apply(null, arguments));
  };
  optimistic.makeCacheKey = makeCacheKey;
  optimistic.getKey = keyArgs ? function getKey() {
    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
  } : makeCacheKey;
  return Object.freeze(optimistic);
}
var import_dist97, import_dist98, import_dist99, defaultKeyTrie, caches;
var init_lib6 = __esm({
  "../node_modules/optimism/lib/index.js"() {
    import_dist97 = __toESM(require_dist());
    import_dist98 = __toESM(require_dist2());
    import_dist99 = __toESM(require_dist3());
    init_lib4();
    init_lib3();
    init_entry();
    init_context();
    init_context();
    init_dep();
    caches = /* @__PURE__ */ new Set();
  }
});

// ../node_modules/zen-observable-ts/module.js
var module_exports = {};
__export(module_exports, {
  Observable: () => Observable
});
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function getMethod(obj, key) {
  var value = obj[key];
  if (value == null) return void 0;
  if (typeof value !== "function") throw new TypeError(value + " is not a function");
  return value;
}
function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x) {
  return x instanceof Observable;
}
function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function() {
      throw e;
    });
  }
}
function enqueue(fn) {
  Promise.resolve().then(function() {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}
function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === void 0) return;
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, "unsubscribe");
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === "closed") break;
  }
}
function notifySubscription(subscription, type, value) {
  subscription._state = "running";
  var observer = subscription._observer;
  try {
    var m = getMethod(observer, type);
    switch (type) {
      case "next":
        if (m) m.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m) m.call(observer, value);
        else throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }
  if (subscription._state === "closed") cleanupSubscription(subscription);
  else if (subscription._state === "running") subscription._state = "ready";
}
function onNotify(subscription, type, value) {
  if (subscription._state === "closed") return;
  if (subscription._state === "buffering") {
    subscription._queue.push({
      type,
      value
    });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{
      type,
      value
    }];
    enqueue(function() {
      return flushSubscription(subscription);
    });
    return;
  }
  notifySubscription(subscription, type, value);
}
var import_dist121, import_dist122, import_dist123, hasSymbols, hasSymbol, getSymbol, SymbolIterator, SymbolObservable, SymbolSpecies, Subscription, SubscriptionObserver, Observable;
var init_module = __esm({
  "../node_modules/zen-observable-ts/module.js"() {
    import_dist121 = __toESM(require_dist());
    import_dist122 = __toESM(require_dist2());
    import_dist123 = __toESM(require_dist3());
    hasSymbols = function() {
      return typeof Symbol === "function";
    };
    hasSymbol = function(name) {
      return hasSymbols() && Boolean(Symbol[name]);
    };
    getSymbol = function(name) {
      return hasSymbol(name) ? Symbol[name] : "@@" + name;
    };
    if (hasSymbols() && !hasSymbol("observable")) {
      Symbol.observable = Symbol("observable");
    }
    SymbolIterator = getSymbol("iterator");
    SymbolObservable = getSymbol("observable");
    SymbolSpecies = getSymbol("species");
    Subscription = function() {
      function Subscription2(observer, subscriber) {
        this._cleanup = void 0;
        this._observer = observer;
        this._queue = void 0;
        this._state = "initializing";
        var subscriptionObserver = new SubscriptionObserver(this);
        try {
          this._cleanup = subscriber.call(void 0, subscriptionObserver);
        } catch (e) {
          subscriptionObserver.error(e);
        }
        if (this._state === "initializing") this._state = "ready";
      }
      var _proto = Subscription2.prototype;
      _proto.unsubscribe = function unsubscribe() {
        if (this._state !== "closed") {
          closeSubscription(this);
          cleanupSubscription(this);
        }
      };
      _createClass(Subscription2, [{
        key: "closed",
        get: function() {
          return this._state === "closed";
        }
      }]);
      return Subscription2;
    }();
    SubscriptionObserver = function() {
      function SubscriptionObserver2(subscription) {
        this._subscription = subscription;
      }
      var _proto2 = SubscriptionObserver2.prototype;
      _proto2.next = function next(value) {
        onNotify(this._subscription, "next", value);
      };
      _proto2.error = function error(value) {
        onNotify(this._subscription, "error", value);
      };
      _proto2.complete = function complete() {
        onNotify(this._subscription, "complete");
      };
      _createClass(SubscriptionObserver2, [{
        key: "closed",
        get: function() {
          return this._subscription._state === "closed";
        }
      }]);
      return SubscriptionObserver2;
    }();
    Observable = function() {
      function Observable2(subscriber) {
        if (!(this instanceof Observable2)) throw new TypeError("Observable cannot be called as a function");
        if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");
        this._subscriber = subscriber;
      }
      var _proto3 = Observable2.prototype;
      _proto3.subscribe = function subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          observer = {
            next: observer,
            error: arguments[1],
            complete: arguments[2]
          };
        }
        return new Subscription(observer, this._subscriber);
      };
      _proto3.forEach = function forEach3(fn) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          if (typeof fn !== "function") {
            reject(new TypeError(fn + " is not a function"));
            return;
          }
          function done() {
            subscription.unsubscribe();
            resolve();
          }
          var subscription = _this.subscribe({
            next: function(value) {
              try {
                fn(value, done);
              } catch (e) {
                reject(e);
                subscription.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
        });
      };
      _proto3.map = function map(fn) {
        var _this2 = this;
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        var C = getSpecies(this);
        return new C(function(observer) {
          return _this2.subscribe({
            next: function(value) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
              observer.next(value);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              observer.complete();
            }
          });
        });
      };
      _proto3.filter = function filter(fn) {
        var _this3 = this;
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        var C = getSpecies(this);
        return new C(function(observer) {
          return _this3.subscribe({
            next: function(value) {
              try {
                if (!fn(value)) return;
              } catch (e) {
                return observer.error(e);
              }
              observer.next(value);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              observer.complete();
            }
          });
        });
      };
      _proto3.reduce = function reduce(fn) {
        var _this4 = this;
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        var C = getSpecies(this);
        var hasSeed = arguments.length > 1;
        var hasValue = false;
        var seed = arguments[1];
        var acc = seed;
        return new C(function(observer) {
          return _this4.subscribe({
            next: function(value) {
              var first = !hasValue;
              hasValue = true;
              if (!first || hasSeed) {
                try {
                  acc = fn(acc, value);
                } catch (e) {
                  return observer.error(e);
                }
              } else {
                acc = value;
              }
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              if (!hasValue && !hasSeed) return observer.error(new TypeError("Cannot reduce an empty sequence"));
              observer.next(acc);
              observer.complete();
            }
          });
        });
      };
      _proto3.concat = function concat2() {
        var _this5 = this;
        for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
          sources[_key] = arguments[_key];
        }
        var C = getSpecies(this);
        return new C(function(observer) {
          var subscription;
          var index = 0;
          function startNext(next) {
            subscription = next.subscribe({
              next: function(v) {
                observer.next(v);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                if (index === sources.length) {
                  subscription = void 0;
                  observer.complete();
                } else {
                  startNext(C.from(sources[index++]));
                }
              }
            });
          }
          startNext(_this5);
          return function() {
            if (subscription) {
              subscription.unsubscribe();
              subscription = void 0;
            }
          };
        });
      };
      _proto3.flatMap = function flatMap(fn) {
        var _this6 = this;
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        var C = getSpecies(this);
        return new C(function(observer) {
          var subscriptions = [];
          var outer = _this6.subscribe({
            next: function(value) {
              if (fn) {
                try {
                  value = fn(value);
                } catch (e) {
                  return observer.error(e);
                }
              }
              var inner = C.from(value).subscribe({
                next: function(value2) {
                  observer.next(value2);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  var i = subscriptions.indexOf(inner);
                  if (i >= 0) subscriptions.splice(i, 1);
                  completeIfDone();
                }
              });
              subscriptions.push(inner);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              completeIfDone();
            }
          });
          function completeIfDone() {
            if (outer.closed && subscriptions.length === 0) observer.complete();
          }
          return function() {
            subscriptions.forEach(function(s) {
              return s.unsubscribe();
            });
            outer.unsubscribe();
          };
        });
      };
      _proto3[SymbolObservable] = function() {
        return this;
      };
      Observable2.from = function from2(x) {
        var C = typeof this === "function" ? this : Observable2;
        if (x == null) throw new TypeError(x + " is not an object");
        var method = getMethod(x, SymbolObservable);
        if (method) {
          var observable = method.call(x);
          if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
          if (isObservable(observable) && observable.constructor === C) return observable;
          return new C(function(observer) {
            return observable.subscribe(observer);
          });
        }
        if (hasSymbol("iterator")) {
          method = getMethod(x, SymbolIterator);
          if (method) {
            return new C(function(observer) {
              enqueue(function() {
                if (observer.closed) return;
                for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done; ) {
                  var item = _step.value;
                  observer.next(item);
                  if (observer.closed) return;
                }
                observer.complete();
              });
            });
          }
        }
        if (Array.isArray(x)) {
          return new C(function(observer) {
            enqueue(function() {
              if (observer.closed) return;
              for (var i = 0; i < x.length; ++i) {
                observer.next(x[i]);
                if (observer.closed) return;
              }
              observer.complete();
            });
          });
        }
        throw new TypeError(x + " is not observable");
      };
      Observable2.of = function of() {
        for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          items[_key2] = arguments[_key2];
        }
        var C = typeof this === "function" ? this : Observable2;
        return new C(function(observer) {
          enqueue(function() {
            if (observer.closed) return;
            for (var i = 0; i < items.length; ++i) {
              observer.next(items[i]);
              if (observer.closed) return;
            }
            observer.complete();
          });
        });
      };
      _createClass(Observable2, null, [{
        key: SymbolSpecies,
        get: function() {
          return this;
        }
      }]);
      return Observable2;
    }();
    if (hasSymbols()) {
      Object.defineProperty(Observable, Symbol("extensions"), {
        value: {
          symbol: SymbolObservable,
          hostReportError
        },
        configurable: true
      });
    }
  }
});

// ../node_modules/symbol-observable/es/ponyfill.js
function symbolObservablePonyfill(root2) {
  var result2;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result2 = Symbol2.observable;
    } else {
      if (typeof Symbol2.for === "function") {
        result2 = Symbol2.for("https://github.com/benlesh/symbol-observable");
      } else {
        result2 = Symbol2("https://github.com/benlesh/symbol-observable");
      }
      try {
        Symbol2.observable = result2;
      } catch (err) {
      }
    }
  } else {
    result2 = "@@observable";
  }
  return result2;
}
var import_dist124, import_dist125, import_dist126;
var init_ponyfill = __esm({
  "../node_modules/symbol-observable/es/ponyfill.js"() {
    import_dist124 = __toESM(require_dist());
    import_dist125 = __toESM(require_dist2());
    import_dist126 = __toESM(require_dist3());
  }
});

// ../node_modules/symbol-observable/es/index.js
var es_exports = {};
__export(es_exports, {
  default: () => es_default
});
var import_dist127, import_dist128, import_dist129, root, result, es_default;
var init_es = __esm({
  "../node_modules/symbol-observable/es/index.js"() {
    import_dist127 = __toESM(require_dist());
    import_dist128 = __toESM(require_dist2());
    import_dist129 = __toESM(require_dist3());
    init_ponyfill();
    if (typeof self !== "undefined") {
      root = self;
    } else if (typeof window !== "undefined") {
      root = window;
    } else if (typeof global !== "undefined") {
      root = global;
    } else if (typeof module !== "undefined") {
      root = module;
    } else {
      root = Function("return this")();
    }
    result = symbolObservablePonyfill(root);
    es_default = result;
  }
});

// ../node_modules/@wry/equality/lib/index.js
var lib_exports5 = {};
__export(lib_exports5, {
  default: () => lib_default,
  equal: () => equal
});
function equal(a, b) {
  try {
    return check(a, b);
  } finally {
    previousComparisons.clear();
  }
}
function check(a, b) {
  if (a === b) {
    return true;
  }
  const aTag = toString2.call(a);
  const bTag = toString2.call(b);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a.length !== b.length)
        return false;
    case "[object Object]": {
      if (previouslyCompared(a, b))
        return true;
      const aKeys = definedKeys(a);
      const bKeys = definedKeys(b);
      const keyCount = aKeys.length;
      if (keyCount !== bKeys.length)
        return false;
      for (let k = 0; k < keyCount; ++k) {
        if (!hasOwnProperty5.call(b, aKeys[k])) {
          return false;
        }
      }
      for (let k = 0; k < keyCount; ++k) {
        const key = aKeys[k];
        if (!check(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a.name === b.name && a.message === b.message;
    case "[object Number]":
      if (a !== a)
        return b !== b;
    case "[object Boolean]":
    case "[object Date]":
      return +a === +b;
    case "[object RegExp]":
    case "[object String]":
      return a == `${b}`;
    case "[object Map]":
    case "[object Set]": {
      if (a.size !== b.size)
        return false;
      if (previouslyCompared(a, b))
        return true;
      const aIterator = a.entries();
      const isMap = aTag === "[object Map]";
      while (true) {
        const info = aIterator.next();
        if (info.done)
          break;
        const [aKey, aValue] = info.value;
        if (!b.has(aKey)) {
          return false;
        }
        if (isMap && !check(aValue, b.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case "[object DataView]": {
      let len = a.byteLength;
      if (len === b.byteLength) {
        while (len-- && a[len] === b[len]) {
        }
      }
      return len === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const aCode = fnToStr.call(a);
      if (aCode !== fnToStr.call(b)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
  return this[key] !== void 0;
}
function endsWith(full, suffix) {
  const fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a, b) {
  let bSet = previousComparisons.get(a);
  if (bSet) {
    if (bSet.has(b))
      return true;
  } else {
    previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
  }
  bSet.add(b);
  return false;
}
var import_dist232, import_dist233, import_dist234, toString2, hasOwnProperty5, fnToStr, previousComparisons, lib_default, nativeCodeSuffix;
var init_lib7 = __esm({
  "../node_modules/@wry/equality/lib/index.js"() {
    import_dist232 = __toESM(require_dist());
    import_dist233 = __toESM(require_dist2());
    import_dist234 = __toESM(require_dist3());
    ({ toString: toString2, hasOwnProperty: hasOwnProperty5 } = Object.prototype);
    fnToStr = Function.prototype.toString;
    previousComparisons = /* @__PURE__ */ new Map();
    lib_default = equal;
    nativeCodeSuffix = "{ [native code] }";
  }
});

// ../node_modules/rehackt/index.js
var require_rehackt = __commonJS({
  "../node_modules/rehackt/index.js"(exports, module2) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    if (0) {
      module2.exports = null;
    }
    module2.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = void 0;
    module2.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
    module2.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
    Object.assign(module2.exports, require_react());
  }
});

// ../node_modules/@apollo/client/utilities/globals/globals.cjs
var require_globals = __commonJS({
  "../node_modules/@apollo/client/utilities/globals/globals.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tsInvariant = (init_invariant(), __toCommonJS(invariant_exports));
    var version2 = "3.11.1";
    function maybe3(thunk) {
      try {
        return thunk();
      } catch (_a2) {
      }
    }
    var global$1 = maybe3(function() {
      return globalThis;
    }) || maybe3(function() {
      return window;
    }) || maybe3(function() {
      return self;
    }) || maybe3(function() {
      return global;
    }) || maybe3(function() {
      return maybe3.constructor("return this")();
    });
    var prefixCounts2 = /* @__PURE__ */ new Map();
    function makeUniqueId2(prefix) {
      var count = prefixCounts2.get(prefix) || 1;
      prefixCounts2.set(prefix, count + 1);
      return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
    }
    function stringifyForDisplay2(value, space) {
      if (space === void 0) {
        space = 0;
      }
      var undefId = makeUniqueId2("stringifyForDisplay");
      return JSON.stringify(value, function(key, value2) {
        return value2 === void 0 ? undefId : value2;
      }, space).split(JSON.stringify(undefId)).join("<undefined>");
    }
    function wrap3(fn) {
      return function(message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (typeof message === "number") {
          var arg0 = message;
          message = getHandledErrorMsg2(arg0);
          if (!message) {
            message = getFallbackErrorMsg2(arg0, args);
            args = [];
          }
        }
        fn.apply(void 0, [message].concat(args));
      };
    }
    var invariant4 = Object.assign(function invariant5(condition, message) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (!condition) {
        tsInvariant.invariant(condition, getHandledErrorMsg2(message, args) || getFallbackErrorMsg2(message, args));
      }
    }, {
      debug: wrap3(tsInvariant.invariant.debug),
      log: wrap3(tsInvariant.invariant.log),
      warn: wrap3(tsInvariant.invariant.warn),
      error: wrap3(tsInvariant.invariant.error)
    });
    function newInvariantError2(message) {
      var optionalParams = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
      }
      return new tsInvariant.InvariantError(getHandledErrorMsg2(message, optionalParams) || getFallbackErrorMsg2(message, optionalParams));
    }
    var ApolloErrorMessageHandler2 = Symbol.for("ApolloErrorMessageHandler_" + version2);
    function stringify2(arg) {
      if (typeof arg == "string") {
        return arg;
      }
      try {
        return stringifyForDisplay2(arg, 2).slice(0, 1e3);
      } catch (_a2) {
        return "<non-serializable>";
      }
    }
    function getHandledErrorMsg2(message, messageArgs) {
      if (messageArgs === void 0) {
        messageArgs = [];
      }
      if (!message)
        return;
      return global$1[ApolloErrorMessageHandler2] && global$1[ApolloErrorMessageHandler2](message, messageArgs.map(stringify2));
    }
    function getFallbackErrorMsg2(message, messageArgs) {
      if (messageArgs === void 0) {
        messageArgs = [];
      }
      if (!message)
        return;
      return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
        version: version2,
        message,
        args: messageArgs.map(stringify2)
      })));
    }
    var DEV2 = globalThis.__DEV__ !== false;
    exports.InvariantError = tsInvariant.InvariantError;
    exports.DEV = DEV2;
    exports.__DEV__ = DEV2;
    exports.global = global$1;
    exports.invariant = invariant4;
    exports.maybe = maybe3;
    exports.newInvariantError = newInvariantError2;
  }
});

// ../node_modules/@apollo/client/utilities/utilities.cjs
var require_utilities = __commonJS({
  "../node_modules/@apollo/client/utilities/utilities.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var graphql = (init_graphql(), __toCommonJS(graphql_exports));
    var trie = (init_lib2(), __toCommonJS(lib_exports2));
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var caches2 = (init_lib3(), __toCommonJS(lib_exports3));
    var optimism = (init_lib6(), __toCommonJS(lib_exports4));
    var zenObservableTs = (init_module(), __toCommonJS(module_exports));
    init_es();
    function shouldInclude2(_a2, variables) {
      var directives = _a2.directives;
      if (!directives || !directives.length) {
        return true;
      }
      return getInclusionDirectives2(directives).every(function(_a3) {
        var directive = _a3.directive, ifArgument = _a3.ifArgument;
        var evaledValue = false;
        if (ifArgument.value.kind === "Variable") {
          evaledValue = variables && variables[ifArgument.value.name.value];
          globals.invariant(evaledValue !== void 0, 69, directive.name.value);
        } else {
          evaledValue = ifArgument.value.value;
        }
        return directive.name.value === "skip" ? !evaledValue : evaledValue;
      });
    }
    function getDirectiveNames2(root2) {
      var names = [];
      graphql.visit(root2, {
        Directive: function(node) {
          names.push(node.name.value);
        }
      });
      return names;
    }
    var hasAnyDirectives2 = function(names, root2) {
      return hasDirectives2(names, root2, false);
    };
    var hasAllDirectives2 = function(names, root2) {
      return hasDirectives2(names, root2, true);
    };
    function hasDirectives2(names, root2, all) {
      var nameSet = new Set(names);
      var uniqueCount = nameSet.size;
      graphql.visit(root2, {
        Directive: function(node) {
          if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
            return graphql.BREAK;
          }
        }
      });
      return all ? !nameSet.size : nameSet.size < uniqueCount;
    }
    function hasClientExports2(document) {
      return document && hasDirectives2(["client", "export"], document, true);
    }
    function isInclusionDirective2(_a2) {
      var value = _a2.name.value;
      return value === "skip" || value === "include";
    }
    function getInclusionDirectives2(directives) {
      var result2 = [];
      if (directives && directives.length) {
        directives.forEach(function(directive) {
          if (!isInclusionDirective2(directive))
            return;
          var directiveArguments = directive.arguments;
          var directiveName = directive.name.value;
          globals.invariant(directiveArguments && directiveArguments.length === 1, 70, directiveName);
          var ifArgument = directiveArguments[0];
          globals.invariant(ifArgument.name && ifArgument.name.value === "if", 71, directiveName);
          var ifValue = ifArgument.value;
          globals.invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 72, directiveName);
          result2.push({ directive, ifArgument });
        });
      }
      return result2;
    }
    var isReactNative2 = globals.maybe(function() {
      return navigator.product;
    }) == "ReactNative";
    var canUseWeakMap2 = typeof WeakMap === "function" && !(isReactNative2 && !global.HermesInternal);
    var canUseWeakSet2 = typeof WeakSet === "function";
    var canUseSymbol2 = typeof Symbol === "function" && typeof Symbol.for === "function";
    var canUseAsyncIteratorSymbol2 = canUseSymbol2 && Symbol.asyncIterator;
    var canUseDOM2 = typeof globals.maybe(function() {
      return window.document.createElement;
    }) === "function";
    var usingJSDOM2 = globals.maybe(function() {
      return navigator.userAgent.indexOf("jsdom") >= 0;
    }) || false;
    var canUseLayoutEffect2 = (canUseDOM2 || isReactNative2) && !usingJSDOM2;
    function isNonNullObject2(obj) {
      return obj !== null && typeof obj === "object";
    }
    function isPlainObject2(obj) {
      return obj !== null && typeof obj === "object" && (Object.getPrototypeOf(obj) === Object.prototype || Object.getPrototypeOf(obj) === null);
    }
    function getFragmentQueryDocument2(document, fragmentName) {
      var actualFragmentName = fragmentName;
      var fragments = [];
      document.definitions.forEach(function(definition) {
        if (definition.kind === "OperationDefinition") {
          throw globals.newInvariantError(
            73,
            definition.operation,
            definition.name ? " named '".concat(definition.name.value, "'") : ""
          );
        }
        if (definition.kind === "FragmentDefinition") {
          fragments.push(definition);
        }
      });
      if (typeof actualFragmentName === "undefined") {
        globals.invariant(fragments.length === 1, 74, fragments.length);
        actualFragmentName = fragments[0].name.value;
      }
      var query = tslib.__assign(tslib.__assign({}, document), { definitions: tslib.__spreadArray([
        {
          kind: "OperationDefinition",
          operation: "query",
          selectionSet: {
            kind: "SelectionSet",
            selections: [
              {
                kind: "FragmentSpread",
                name: {
                  kind: "Name",
                  value: actualFragmentName
                }
              }
            ]
          }
        }
      ], document.definitions, true) });
      return query;
    }
    function createFragmentMap2(fragments) {
      if (fragments === void 0) {
        fragments = [];
      }
      var symTable = {};
      fragments.forEach(function(fragment) {
        symTable[fragment.name.value] = fragment;
      });
      return symTable;
    }
    function getFragmentFromSelection2(selection, fragmentMap) {
      switch (selection.kind) {
        case "InlineFragment":
          return selection;
        case "FragmentSpread": {
          var fragmentName = selection.name.value;
          if (typeof fragmentMap === "function") {
            return fragmentMap(fragmentName);
          }
          var fragment = fragmentMap && fragmentMap[fragmentName];
          globals.invariant(fragment, 75, fragmentName);
          return fragment || null;
        }
        default:
          return null;
      }
    }
    var scheduledCleanup2 = /* @__PURE__ */ new WeakSet();
    function schedule2(cache2) {
      if (cache2.size <= (cache2.max || -1)) {
        return;
      }
      if (!scheduledCleanup2.has(cache2)) {
        scheduledCleanup2.add(cache2);
        setTimeout(function() {
          cache2.clean();
          scheduledCleanup2.delete(cache2);
        }, 100);
      }
    }
    var AutoCleanedWeakCache2 = function(max, dispose) {
      var cache2 = new caches2.WeakCache(max, dispose);
      cache2.set = function(key, value) {
        var ret = caches2.WeakCache.prototype.set.call(this, key, value);
        schedule2(this);
        return ret;
      };
      return cache2;
    };
    var AutoCleanedStrongCache2 = function(max, dispose) {
      var cache2 = new caches2.StrongCache(max, dispose);
      cache2.set = function(key, value) {
        var ret = caches2.StrongCache.prototype.set.call(this, key, value);
        schedule2(this);
        return ret;
      };
      return cache2;
    };
    var cacheSizeSymbol2 = Symbol.for("apollo.cacheSize");
    var cacheSizes2 = tslib.__assign({}, globals.global[cacheSizeSymbol2]);
    var globalCaches2 = {};
    function registerGlobalCache2(name, getSize) {
      globalCaches2[name] = getSize;
    }
    var canonicalStringify3 = Object.assign(function canonicalStringify4(value) {
      return JSON.stringify(value, stableObjectReplacer2);
    }, {
      reset: function() {
        sortingMap2 = new AutoCleanedStrongCache2(cacheSizes2.canonicalStringify || 1e3);
      }
    });
    if (globalThis.__DEV__ !== false) {
      registerGlobalCache2("canonicalStringify", function() {
        return sortingMap2.size;
      });
    }
    var sortingMap2;
    canonicalStringify3.reset();
    function stableObjectReplacer2(key, value) {
      if (value && typeof value === "object") {
        var proto = Object.getPrototypeOf(value);
        if (proto === Object.prototype || proto === null) {
          var keys = Object.keys(value);
          if (keys.every(everyKeyInOrder2))
            return value;
          var unsortedKey = JSON.stringify(keys);
          var sortedKeys = sortingMap2.get(unsortedKey);
          if (!sortedKeys) {
            keys.sort();
            var sortedKey = JSON.stringify(keys);
            sortedKeys = sortingMap2.get(sortedKey) || keys;
            sortingMap2.set(unsortedKey, sortedKeys);
            sortingMap2.set(sortedKey, sortedKeys);
          }
          var sortedObject_1 = Object.create(proto);
          sortedKeys.forEach(function(key2) {
            sortedObject_1[key2] = value[key2];
          });
          return sortedObject_1;
        }
      }
      return value;
    }
    function everyKeyInOrder2(key, i, keys) {
      return i === 0 || keys[i - 1] <= key;
    }
    function makeReference2(id) {
      return { __ref: String(id) };
    }
    function isReference2(obj) {
      return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
    }
    function isDocumentNode2(value) {
      return isNonNullObject2(value) && value.kind === "Document" && Array.isArray(value.definitions);
    }
    function isStringValue2(value) {
      return value.kind === "StringValue";
    }
    function isBooleanValue2(value) {
      return value.kind === "BooleanValue";
    }
    function isIntValue2(value) {
      return value.kind === "IntValue";
    }
    function isFloatValue2(value) {
      return value.kind === "FloatValue";
    }
    function isVariable2(value) {
      return value.kind === "Variable";
    }
    function isObjectValue2(value) {
      return value.kind === "ObjectValue";
    }
    function isListValue2(value) {
      return value.kind === "ListValue";
    }
    function isEnumValue2(value) {
      return value.kind === "EnumValue";
    }
    function isNullValue2(value) {
      return value.kind === "NullValue";
    }
    function valueToObjectRepresentation2(argObj, name, value, variables) {
      if (isIntValue2(value) || isFloatValue2(value)) {
        argObj[name.value] = Number(value.value);
      } else if (isBooleanValue2(value) || isStringValue2(value)) {
        argObj[name.value] = value.value;
      } else if (isObjectValue2(value)) {
        var nestedArgObj_1 = {};
        value.fields.map(function(obj) {
          return valueToObjectRepresentation2(nestedArgObj_1, obj.name, obj.value, variables);
        });
        argObj[name.value] = nestedArgObj_1;
      } else if (isVariable2(value)) {
        var variableValue = (variables || {})[value.name.value];
        argObj[name.value] = variableValue;
      } else if (isListValue2(value)) {
        argObj[name.value] = value.values.map(function(listValue) {
          var nestedArgArrayObj = {};
          valueToObjectRepresentation2(nestedArgArrayObj, name, listValue, variables);
          return nestedArgArrayObj[name.value];
        });
      } else if (isEnumValue2(value)) {
        argObj[name.value] = value.value;
      } else if (isNullValue2(value)) {
        argObj[name.value] = null;
      } else {
        throw globals.newInvariantError(84, name.value, value.kind);
      }
    }
    function storeKeyNameFromField2(field, variables) {
      var directivesObj = null;
      if (field.directives) {
        directivesObj = {};
        field.directives.forEach(function(directive) {
          directivesObj[directive.name.value] = {};
          if (directive.arguments) {
            directive.arguments.forEach(function(_a2) {
              var name = _a2.name, value = _a2.value;
              return valueToObjectRepresentation2(directivesObj[directive.name.value], name, value, variables);
            });
          }
        });
      }
      var argObj = null;
      if (field.arguments && field.arguments.length) {
        argObj = {};
        field.arguments.forEach(function(_a2) {
          var name = _a2.name, value = _a2.value;
          return valueToObjectRepresentation2(argObj, name, value, variables);
        });
      }
      return getStoreKeyName2(field.name.value, argObj, directivesObj);
    }
    var KNOWN_DIRECTIVES2 = [
      "connection",
      "include",
      "skip",
      "client",
      "rest",
      "export",
      "nonreactive"
    ];
    var storeKeyNameStringify2 = canonicalStringify3;
    var getStoreKeyName2 = Object.assign(function(fieldName, args, directives) {
      if (args && directives && directives["connection"] && directives["connection"]["key"]) {
        if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
          var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
          filterKeys.sort();
          var filteredArgs_1 = {};
          filterKeys.forEach(function(key) {
            filteredArgs_1[key] = args[key];
          });
          return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify2(filteredArgs_1), ")");
        } else {
          return directives["connection"]["key"];
        }
      }
      var completeFieldName = fieldName;
      if (args) {
        var stringifiedArgs = storeKeyNameStringify2(args);
        completeFieldName += "(".concat(stringifiedArgs, ")");
      }
      if (directives) {
        Object.keys(directives).forEach(function(key) {
          if (KNOWN_DIRECTIVES2.indexOf(key) !== -1)
            return;
          if (directives[key] && Object.keys(directives[key]).length) {
            completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify2(directives[key]), ")");
          } else {
            completeFieldName += "@".concat(key);
          }
        });
      }
      return completeFieldName;
    }, {
      setStringify: function(s) {
        var previous = storeKeyNameStringify2;
        storeKeyNameStringify2 = s;
        return previous;
      }
    });
    function argumentsObjectFromField2(field, variables) {
      if (field.arguments && field.arguments.length) {
        var argObj_1 = {};
        field.arguments.forEach(function(_a2) {
          var name = _a2.name, value = _a2.value;
          return valueToObjectRepresentation2(argObj_1, name, value, variables);
        });
        return argObj_1;
      }
      return null;
    }
    function resultKeyNameFromField2(field) {
      return field.alias ? field.alias.value : field.name.value;
    }
    function getTypenameFromResult2(result2, selectionSet, fragmentMap) {
      var fragments;
      for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
        var selection = _a2[_i];
        if (isField2(selection)) {
          if (selection.name.value === "__typename") {
            return result2[resultKeyNameFromField2(selection)];
          }
        } else if (fragments) {
          fragments.push(selection);
        } else {
          fragments = [selection];
        }
      }
      if (typeof result2.__typename === "string") {
        return result2.__typename;
      }
      if (fragments) {
        for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
          var selection = fragments_1[_b];
          var typename = getTypenameFromResult2(result2, getFragmentFromSelection2(selection, fragmentMap).selectionSet, fragmentMap);
          if (typeof typename === "string") {
            return typename;
          }
        }
      }
    }
    function isField2(selection) {
      return selection.kind === "Field";
    }
    function isInlineFragment2(selection) {
      return selection.kind === "InlineFragment";
    }
    function checkDocument2(doc) {
      globals.invariant(doc && doc.kind === "Document", 76);
      var operations = doc.definitions.filter(function(d) {
        return d.kind !== "FragmentDefinition";
      }).map(function(definition) {
        if (definition.kind !== "OperationDefinition") {
          throw globals.newInvariantError(77, definition.kind);
        }
        return definition;
      });
      globals.invariant(operations.length <= 1, 78, operations.length);
      return doc;
    }
    function getOperationDefinition2(doc) {
      checkDocument2(doc);
      return doc.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition";
      })[0];
    }
    function getOperationName2(doc) {
      return doc.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition" && !!definition.name;
      }).map(function(x) {
        return x.name.value;
      })[0] || null;
    }
    function getFragmentDefinitions3(doc) {
      return doc.definitions.filter(function(definition) {
        return definition.kind === "FragmentDefinition";
      });
    }
    function getQueryDefinition2(doc) {
      var queryDef = getOperationDefinition2(doc);
      globals.invariant(queryDef && queryDef.operation === "query", 79);
      return queryDef;
    }
    function getFragmentDefinition2(doc) {
      globals.invariant(doc.kind === "Document", 80);
      globals.invariant(doc.definitions.length <= 1, 81);
      var fragmentDef = doc.definitions[0];
      globals.invariant(fragmentDef.kind === "FragmentDefinition", 82);
      return fragmentDef;
    }
    function getMainDefinition2(queryDoc) {
      checkDocument2(queryDoc);
      var fragmentDefinition;
      for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
        var definition = _a2[_i];
        if (definition.kind === "OperationDefinition") {
          var operation = definition.operation;
          if (operation === "query" || operation === "mutation" || operation === "subscription") {
            return definition;
          }
        }
        if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
          fragmentDefinition = definition;
        }
      }
      if (fragmentDefinition) {
        return fragmentDefinition;
      }
      throw globals.newInvariantError(83);
    }
    function getDefaultValues2(definition) {
      var defaultValues = /* @__PURE__ */ Object.create(null);
      var defs = definition && definition.variableDefinitions;
      if (defs && defs.length) {
        defs.forEach(function(def) {
          if (def.defaultValue) {
            valueToObjectRepresentation2(defaultValues, def.variable.name, def.defaultValue);
          }
        });
      }
      return defaultValues;
    }
    function identity2(document) {
      return document;
    }
    var DocumentTransform2 = function() {
      function DocumentTransform3(transform, options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        this.resultCache = canUseWeakSet2 ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
        this.transform = transform;
        if (options.getCacheKey) {
          this.getCacheKey = options.getCacheKey;
        }
        this.cached = options.cache !== false;
        this.resetCache();
      }
      DocumentTransform3.prototype.getCacheKey = function(document) {
        return [document];
      };
      DocumentTransform3.identity = function() {
        return new DocumentTransform3(identity2, { cache: false });
      };
      DocumentTransform3.split = function(predicate, left, right) {
        if (right === void 0) {
          right = DocumentTransform3.identity();
        }
        return Object.assign(new DocumentTransform3(
          function(document) {
            var documentTransform = predicate(document) ? left : right;
            return documentTransform.transformDocument(document);
          },
          { cache: false }
        ), { left, right });
      };
      DocumentTransform3.prototype.resetCache = function() {
        var _this = this;
        if (this.cached) {
          var stableCacheKeys_1 = new trie.Trie(canUseWeakMap2);
          this.performWork = optimism.wrap(DocumentTransform3.prototype.performWork.bind(this), {
            makeCacheKey: function(document) {
              var cacheKeys = _this.getCacheKey(document);
              if (cacheKeys) {
                globals.invariant(Array.isArray(cacheKeys), 68);
                return stableCacheKeys_1.lookupArray(cacheKeys);
              }
            },
            max: cacheSizes2["documentTransform.cache"],
            cache: caches2.WeakCache
          });
        }
      };
      DocumentTransform3.prototype.performWork = function(document) {
        checkDocument2(document);
        return this.transform(document);
      };
      DocumentTransform3.prototype.transformDocument = function(document) {
        if (this.resultCache.has(document)) {
          return document;
        }
        var transformedDocument = this.performWork(document);
        this.resultCache.add(transformedDocument);
        return transformedDocument;
      };
      DocumentTransform3.prototype.concat = function(otherTransform) {
        var _this = this;
        return Object.assign(new DocumentTransform3(
          function(document) {
            return otherTransform.transformDocument(_this.transformDocument(document));
          },
          { cache: false }
        ), {
          left: this,
          right: otherTransform
        });
      };
      return DocumentTransform3;
    }();
    var printCache2;
    var print3 = Object.assign(function(ast) {
      var result2 = printCache2.get(ast);
      if (!result2) {
        result2 = graphql.print(ast);
        printCache2.set(ast, result2);
      }
      return result2;
    }, {
      reset: function() {
        printCache2 = new AutoCleanedWeakCache2(cacheSizes2.print || 2e3);
      }
    });
    print3.reset();
    if (globalThis.__DEV__ !== false) {
      registerGlobalCache2("print", function() {
        return printCache2 ? printCache2.size : 0;
      });
    }
    var isArray2 = Array.isArray;
    function isNonEmptyArray2(value) {
      return Array.isArray(value) && value.length > 0;
    }
    var TYPENAME_FIELD2 = {
      kind: graphql.Kind.FIELD,
      name: {
        kind: graphql.Kind.NAME,
        value: "__typename"
      }
    };
    function isEmpty2(op, fragmentMap) {
      return !op || op.selectionSet.selections.every(function(selection) {
        return selection.kind === graphql.Kind.FRAGMENT_SPREAD && isEmpty2(fragmentMap[selection.name.value], fragmentMap);
      });
    }
    function nullIfDocIsEmpty2(doc) {
      return isEmpty2(getOperationDefinition2(doc) || getFragmentDefinition2(doc), createFragmentMap2(getFragmentDefinitions3(doc))) ? null : doc;
    }
    function getDirectiveMatcher2(configs) {
      var names = /* @__PURE__ */ new Map();
      var tests = /* @__PURE__ */ new Map();
      configs.forEach(function(directive) {
        if (directive) {
          if (directive.name) {
            names.set(directive.name, directive);
          } else if (directive.test) {
            tests.set(directive.test, directive);
          }
        }
      });
      return function(directive) {
        var config = names.get(directive.name.value);
        if (!config && tests.size) {
          tests.forEach(function(testConfig, test) {
            if (test(directive)) {
              config = testConfig;
            }
          });
        }
        return config;
      };
    }
    function makeInUseGetterFunction2(defaultKey) {
      var map = /* @__PURE__ */ new Map();
      return function inUseGetterFunction(key) {
        if (key === void 0) {
          key = defaultKey;
        }
        var inUse = map.get(key);
        if (!inUse) {
          map.set(key, inUse = {
            variables: /* @__PURE__ */ new Set(),
            fragmentSpreads: /* @__PURE__ */ new Set()
          });
        }
        return inUse;
      };
    }
    function removeDirectivesFromDocument2(directives, doc) {
      checkDocument2(doc);
      var getInUseByOperationName = makeInUseGetterFunction2("");
      var getInUseByFragmentName = makeInUseGetterFunction2("");
      var getInUse = function(ancestors) {
        for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
          if (isArray2(ancestor))
            continue;
          if (ancestor.kind === graphql.Kind.OPERATION_DEFINITION) {
            return getInUseByOperationName(ancestor.name && ancestor.name.value);
          }
          if (ancestor.kind === graphql.Kind.FRAGMENT_DEFINITION) {
            return getInUseByFragmentName(ancestor.name.value);
          }
        }
        globalThis.__DEV__ !== false && globals.invariant.error(85);
        return null;
      };
      var operationCount = 0;
      for (var i = doc.definitions.length - 1; i >= 0; --i) {
        if (doc.definitions[i].kind === graphql.Kind.OPERATION_DEFINITION) {
          ++operationCount;
        }
      }
      var directiveMatcher = getDirectiveMatcher2(directives);
      var shouldRemoveField = function(nodeDirectives) {
        return isNonEmptyArray2(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
          return config && config.remove;
        });
      };
      var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
      var firstVisitMadeChanges = false;
      var fieldOrInlineFragmentVisitor = {
        enter: function(node) {
          if (shouldRemoveField(node.directives)) {
            firstVisitMadeChanges = true;
            return null;
          }
        }
      };
      var docWithoutDirectiveSubtrees = graphql.visit(doc, {
        Field: fieldOrInlineFragmentVisitor,
        InlineFragment: fieldOrInlineFragmentVisitor,
        VariableDefinition: {
          enter: function() {
            return false;
          }
        },
        Variable: {
          enter: function(node, _key, _parent, _path, ancestors) {
            var inUse = getInUse(ancestors);
            if (inUse) {
              inUse.variables.add(node.name.value);
            }
          }
        },
        FragmentSpread: {
          enter: function(node, _key, _parent, _path, ancestors) {
            if (shouldRemoveField(node.directives)) {
              firstVisitMadeChanges = true;
              return null;
            }
            var inUse = getInUse(ancestors);
            if (inUse) {
              inUse.fragmentSpreads.add(node.name.value);
            }
          }
        },
        FragmentDefinition: {
          enter: function(node, _key, _parent, path) {
            originalFragmentDefsByPath.set(JSON.stringify(path), node);
          },
          leave: function(node, _key, _parent, path) {
            var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
            if (node === originalNode) {
              return node;
            }
            if (operationCount > 0 && node.selectionSet.selections.every(function(selection) {
              return selection.kind === graphql.Kind.FIELD && selection.name.value === "__typename";
            })) {
              getInUseByFragmentName(node.name.value).removed = true;
              firstVisitMadeChanges = true;
              return null;
            }
          }
        },
        Directive: {
          leave: function(node) {
            if (directiveMatcher(node)) {
              firstVisitMadeChanges = true;
              return null;
            }
          }
        }
      });
      if (!firstVisitMadeChanges) {
        return doc;
      }
      var populateTransitiveVars = function(inUse) {
        if (!inUse.transitiveVars) {
          inUse.transitiveVars = new Set(inUse.variables);
          if (!inUse.removed) {
            inUse.fragmentSpreads.forEach(function(childFragmentName) {
              populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
                inUse.transitiveVars.add(varName);
              });
            });
          }
        }
        return inUse;
      };
      var allFragmentNamesUsed = /* @__PURE__ */ new Set();
      docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
        if (def.kind === graphql.Kind.OPERATION_DEFINITION) {
          populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
            allFragmentNamesUsed.add(childFragmentName);
          });
        } else if (def.kind === graphql.Kind.FRAGMENT_DEFINITION && operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
          allFragmentNamesUsed.add(def.name.value);
        }
      });
      allFragmentNamesUsed.forEach(function(fragmentName) {
        populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
          allFragmentNamesUsed.add(childFragmentName);
        });
      });
      var fragmentWillBeRemoved = function(fragmentName) {
        return !!(!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
      };
      var enterVisitor = {
        enter: function(node) {
          if (fragmentWillBeRemoved(node.name.value)) {
            return null;
          }
        }
      };
      return nullIfDocIsEmpty2(graphql.visit(docWithoutDirectiveSubtrees, {
        FragmentSpread: enterVisitor,
        FragmentDefinition: enterVisitor,
        OperationDefinition: {
          leave: function(node) {
            if (node.variableDefinitions) {
              var usedVariableNames_1 = populateTransitiveVars(
                getInUseByOperationName(node.name && node.name.value)
              ).transitiveVars;
              if (usedVariableNames_1.size < node.variableDefinitions.length) {
                return tslib.__assign(tslib.__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
                  return usedVariableNames_1.has(varDef.variable.name.value);
                }) });
              }
            }
          }
        }
      }));
    }
    var addTypenameToDocument2 = Object.assign(function(doc) {
      return graphql.visit(doc, {
        SelectionSet: {
          enter: function(node, _key, parent) {
            if (parent && parent.kind === graphql.Kind.OPERATION_DEFINITION) {
              return;
            }
            var selections = node.selections;
            if (!selections) {
              return;
            }
            var skip = selections.some(function(selection) {
              return isField2(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
            });
            if (skip) {
              return;
            }
            var field = parent;
            if (isField2(field) && field.directives && field.directives.some(function(d) {
              return d.name.value === "export";
            })) {
              return;
            }
            return tslib.__assign(tslib.__assign({}, node), { selections: tslib.__spreadArray(tslib.__spreadArray([], selections, true), [TYPENAME_FIELD2], false) });
          }
        }
      });
    }, {
      added: function(field) {
        return field === TYPENAME_FIELD2;
      }
    });
    var connectionRemoveConfig = {
      test: function(directive) {
        var willRemove = directive.name.value === "connection";
        if (willRemove) {
          if (!directive.arguments || !directive.arguments.some(function(arg) {
            return arg.name.value === "key";
          })) {
            globalThis.__DEV__ !== false && globals.invariant.warn(86);
          }
        }
        return willRemove;
      }
    };
    function removeConnectionDirectiveFromDocument2(doc) {
      return removeDirectivesFromDocument2([connectionRemoveConfig], checkDocument2(doc));
    }
    function getArgumentMatcher(config) {
      return function argumentMatcher(argument) {
        return config.some(function(aConfig) {
          return argument.value && argument.value.kind === graphql.Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
        });
      };
    }
    function removeArgumentsFromDocument2(config, doc) {
      var argMatcher = getArgumentMatcher(config);
      return nullIfDocIsEmpty2(graphql.visit(doc, {
        OperationDefinition: {
          enter: function(node) {
            return tslib.__assign(tslib.__assign({}, node), {
              variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
                return !config.some(function(arg) {
                  return arg.name === varDef.variable.name.value;
                });
              }) : []
            });
          }
        },
        Field: {
          enter: function(node) {
            var shouldRemoveField = config.some(function(argConfig) {
              return argConfig.remove;
            });
            if (shouldRemoveField) {
              var argMatchCount_1 = 0;
              if (node.arguments) {
                node.arguments.forEach(function(arg) {
                  if (argMatcher(arg)) {
                    argMatchCount_1 += 1;
                  }
                });
              }
              if (argMatchCount_1 === 1) {
                return null;
              }
            }
          }
        },
        Argument: {
          enter: function(node) {
            if (argMatcher(node)) {
              return null;
            }
          }
        }
      }));
    }
    function removeFragmentSpreadFromDocument2(config, doc) {
      function enter(node) {
        if (config.some(function(def) {
          return def.name === node.name.value;
        })) {
          return null;
        }
      }
      return nullIfDocIsEmpty2(graphql.visit(doc, {
        FragmentSpread: { enter },
        FragmentDefinition: { enter }
      }));
    }
    function buildQueryFromSelectionSet2(document) {
      var definition = getMainDefinition2(document);
      var definitionOperation = definition.operation;
      if (definitionOperation === "query") {
        return document;
      }
      var modifiedDoc = graphql.visit(document, {
        OperationDefinition: {
          enter: function(node) {
            return tslib.__assign(tslib.__assign({}, node), { operation: "query" });
          }
        }
      });
      return modifiedDoc;
    }
    function removeClientSetsFromDocument2(document) {
      checkDocument2(document);
      var modifiedDoc = removeDirectivesFromDocument2([
        {
          test: function(directive) {
            return directive.name.value === "client";
          },
          remove: true
        }
      ], document);
      return modifiedDoc;
    }
    function isOperation(document, operation) {
      var _a2;
      return ((_a2 = getOperationDefinition2(document)) === null || _a2 === void 0 ? void 0 : _a2.operation) === operation;
    }
    function isMutationOperation2(document) {
      return isOperation(document, "mutation");
    }
    function isQueryOperation2(document) {
      return isOperation(document, "query");
    }
    function isSubscriptionOperation2(document) {
      return isOperation(document, "subscription");
    }
    var hasOwnProperty9 = Object.prototype.hasOwnProperty;
    function mergeDeep2() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return mergeDeepArray2(sources);
    }
    function mergeDeepArray2(sources) {
      var target = sources[0] || {};
      var count = sources.length;
      if (count > 1) {
        var merger = new DeepMerger2();
        for (var i = 1; i < count; ++i) {
          target = merger.merge(target, sources[i]);
        }
      }
      return target;
    }
    var defaultReconciler2 = function(target, source, property) {
      return this.merge(target[property], source[property]);
    };
    var DeepMerger2 = function() {
      function DeepMerger3(reconciler) {
        if (reconciler === void 0) {
          reconciler = defaultReconciler2;
        }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject2;
        this.pastCopies = /* @__PURE__ */ new Set();
      }
      DeepMerger3.prototype.merge = function(target, source) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject2(source) && isNonNullObject2(target)) {
          Object.keys(source).forEach(function(sourceKey) {
            if (hasOwnProperty9.call(target, sourceKey)) {
              var targetValue = target[sourceKey];
              if (source[sourceKey] !== targetValue) {
                var result2 = _this.reconciler.apply(_this, tslib.__spreadArray([
                  target,
                  source,
                  sourceKey
                ], context, false));
                if (result2 !== targetValue) {
                  target = _this.shallowCopyForMerge(target);
                  target[sourceKey] = result2;
                }
              }
            } else {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = source[sourceKey];
            }
          });
          return target;
        }
        return source;
      };
      DeepMerger3.prototype.shallowCopyForMerge = function(value) {
        if (isNonNullObject2(value)) {
          if (!this.pastCopies.has(value)) {
            if (Array.isArray(value)) {
              value = value.slice(0);
            } else {
              value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
            }
            this.pastCopies.add(value);
          }
        }
        return value;
      };
      return DeepMerger3;
    }();
    function concatPagination2(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        merge: function(existing, incoming) {
          return existing ? tslib.__spreadArray(tslib.__spreadArray([], existing, true), incoming, true) : incoming;
        }
      };
    }
    function offsetLimitPagination2(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        merge: function(existing, incoming, _a2) {
          var args = _a2.args;
          var merged = existing ? existing.slice(0) : [];
          if (incoming) {
            if (args) {
              var _b = args.offset, offset = _b === void 0 ? 0 : _b;
              for (var i = 0; i < incoming.length; ++i) {
                merged[offset + i] = incoming[i];
              }
            } else {
              merged.push.apply(merged, incoming);
            }
          }
          return merged;
        }
      };
    }
    function relayStylePagination2(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        read: function(existing, _a2) {
          var canRead = _a2.canRead, readField = _a2.readField;
          if (!existing)
            return existing;
          var edges = [];
          var firstEdgeCursor = "";
          var lastEdgeCursor = "";
          existing.edges.forEach(function(edge) {
            if (canRead(readField("node", edge))) {
              edges.push(edge);
              if (edge.cursor) {
                firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
                lastEdgeCursor = edge.cursor || lastEdgeCursor;
              }
            }
          });
          if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {
            firstEdgeCursor = "";
          }
          var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;
          return tslib.__assign(tslib.__assign({}, getExtras(existing)), { edges, pageInfo: tslib.__assign(tslib.__assign({}, existing.pageInfo), {
            startCursor: startCursor || firstEdgeCursor,
            endCursor: endCursor || lastEdgeCursor
          }) });
        },
        merge: function(existing, incoming, _a2) {
          var args = _a2.args, isReference3 = _a2.isReference, readField = _a2.readField;
          if (!existing) {
            existing = makeEmptyData();
          }
          if (!incoming) {
            return existing;
          }
          var incomingEdges = incoming.edges ? incoming.edges.map(function(edge) {
            if (isReference3(edge = tslib.__assign({}, edge))) {
              edge.cursor = readField("cursor", edge);
            }
            return edge;
          }) : [];
          if (incoming.pageInfo) {
            var pageInfo_1 = incoming.pageInfo;
            var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
            var firstEdge = incomingEdges[0];
            var lastEdge = incomingEdges[incomingEdges.length - 1];
            if (firstEdge && startCursor) {
              firstEdge.cursor = startCursor;
            }
            if (lastEdge && endCursor) {
              lastEdge.cursor = endCursor;
            }
            var firstCursor = firstEdge && firstEdge.cursor;
            if (firstCursor && !startCursor) {
              incoming = mergeDeep2(incoming, {
                pageInfo: {
                  startCursor: firstCursor
                }
              });
            }
            var lastCursor = lastEdge && lastEdge.cursor;
            if (lastCursor && !endCursor) {
              incoming = mergeDeep2(incoming, {
                pageInfo: {
                  endCursor: lastCursor
                }
              });
            }
          }
          var prefix = existing.edges;
          var suffix = [];
          if (args && args.after) {
            var index = prefix.findIndex(function(edge) {
              return edge.cursor === args.after;
            });
            if (index >= 0) {
              prefix = prefix.slice(0, index + 1);
            }
          } else if (args && args.before) {
            var index = prefix.findIndex(function(edge) {
              return edge.cursor === args.before;
            });
            suffix = index < 0 ? prefix : prefix.slice(index);
            prefix = [];
          } else if (incoming.edges) {
            prefix = [];
          }
          var edges = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], prefix, true), incomingEdges, true), suffix, true);
          var pageInfo = tslib.__assign(tslib.__assign({}, incoming.pageInfo), existing.pageInfo);
          if (incoming.pageInfo) {
            var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = tslib.__rest(_b, ["hasPreviousPage", "hasNextPage", "startCursor", "endCursor"]);
            Object.assign(pageInfo, extras);
            if (!prefix.length) {
              if (void 0 !== hasPreviousPage)
                pageInfo.hasPreviousPage = hasPreviousPage;
              if (void 0 !== startCursor)
                pageInfo.startCursor = startCursor;
            }
            if (!suffix.length) {
              if (void 0 !== hasNextPage)
                pageInfo.hasNextPage = hasNextPage;
              if (void 0 !== endCursor)
                pageInfo.endCursor = endCursor;
            }
          }
          return tslib.__assign(tslib.__assign(tslib.__assign({}, getExtras(existing)), getExtras(incoming)), { edges, pageInfo });
        }
      };
    }
    var getExtras = function(obj) {
      return tslib.__rest(obj, notExtras);
    };
    var notExtras = ["edges", "pageInfo"];
    function makeEmptyData() {
      return {
        edges: [],
        pageInfo: {
          hasPreviousPage: false,
          hasNextPage: true,
          startCursor: "",
          endCursor: ""
        }
      };
    }
    function createFulfilledPromise2(value) {
      var promise = Promise.resolve(value);
      promise.status = "fulfilled";
      promise.value = value;
      return promise;
    }
    function createRejectedPromise2(reason) {
      var promise = Promise.reject(reason);
      promise.catch(function() {
      });
      promise.status = "rejected";
      promise.reason = reason;
      return promise;
    }
    function isStatefulPromise2(promise) {
      return "status" in promise;
    }
    function wrapPromiseWithState2(promise) {
      if (isStatefulPromise2(promise)) {
        return promise;
      }
      var pendingPromise = promise;
      pendingPromise.status = "pending";
      pendingPromise.then(function(value) {
        if (pendingPromise.status === "pending") {
          var fulfilledPromise = pendingPromise;
          fulfilledPromise.status = "fulfilled";
          fulfilledPromise.value = value;
        }
      }, function(reason) {
        if (pendingPromise.status === "pending") {
          var rejectedPromise = pendingPromise;
          rejectedPromise.status = "rejected";
          rejectedPromise.reason = reason;
        }
      });
      return promise;
    }
    var toString3 = Object.prototype.toString;
    function cloneDeep2(value) {
      return cloneDeepHelper2(value);
    }
    function cloneDeepHelper2(val, seen) {
      switch (toString3.call(val)) {
        case "[object Array]": {
          seen = seen || /* @__PURE__ */ new Map();
          if (seen.has(val))
            return seen.get(val);
          var copy_1 = val.slice(0);
          seen.set(val, copy_1);
          copy_1.forEach(function(child, i) {
            copy_1[i] = cloneDeepHelper2(child, seen);
          });
          return copy_1;
        }
        case "[object Object]": {
          seen = seen || /* @__PURE__ */ new Map();
          if (seen.has(val))
            return seen.get(val);
          var copy_2 = Object.create(Object.getPrototypeOf(val));
          seen.set(val, copy_2);
          Object.keys(val).forEach(function(key) {
            copy_2[key] = cloneDeepHelper2(val[key], seen);
          });
          return copy_2;
        }
        default:
          return val;
      }
    }
    function deepFreeze2(value) {
      var workSet = /* @__PURE__ */ new Set([value]);
      workSet.forEach(function(obj) {
        if (isNonNullObject2(obj) && shallowFreeze2(obj) === obj) {
          Object.getOwnPropertyNames(obj).forEach(function(name) {
            if (isNonNullObject2(obj[name]))
              workSet.add(obj[name]);
          });
        }
      });
      return value;
    }
    function shallowFreeze2(obj) {
      if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
        try {
          Object.freeze(obj);
        } catch (e) {
          if (e instanceof TypeError)
            return null;
          throw e;
        }
      }
      return obj;
    }
    function maybeDeepFreeze2(obj) {
      if (globalThis.__DEV__ !== false) {
        deepFreeze2(obj);
      }
      return obj;
    }
    function iterateObserversSafely2(observers, method, argument) {
      var observersWithMethod = [];
      observers.forEach(function(obs) {
        return obs[method] && observersWithMethod.push(obs);
      });
      observersWithMethod.forEach(function(obs) {
        return obs[method](argument);
      });
    }
    function asyncMap2(observable, mapFn, catchFn) {
      return new zenObservableTs.Observable(function(observer) {
        var promiseQueue = {
          then: function(callback) {
            return new Promise(function(resolve) {
              return resolve(callback());
            });
          }
        };
        function makeCallback(examiner, key) {
          return function(arg) {
            if (examiner) {
              var both = function() {
                return observer.closed ? 0 : examiner(arg);
              };
              promiseQueue = promiseQueue.then(both, both).then(function(result2) {
                return observer.next(result2);
              }, function(error) {
                return observer.error(error);
              });
            } else {
              observer[key](arg);
            }
          };
        }
        var handler = {
          next: makeCallback(mapFn, "next"),
          error: makeCallback(catchFn, "error"),
          complete: function() {
            promiseQueue.then(function() {
              return observer.complete();
            });
          }
        };
        var sub = observable.subscribe(handler);
        return function() {
          return sub.unsubscribe();
        };
      });
    }
    function fixObservableSubclass2(subclass) {
      function set(key) {
        Object.defineProperty(subclass, key, { value: zenObservableTs.Observable });
      }
      if (canUseSymbol2 && Symbol.species) {
        set(Symbol.species);
      }
      set("@@species");
      return subclass;
    }
    function isPromiseLike3(value) {
      return value && typeof value.then === "function";
    }
    var Concast2 = function(_super) {
      tslib.__extends(Concast3, _super);
      function Concast3(sources) {
        var _this = _super.call(this, function(observer) {
          _this.addObserver(observer);
          return function() {
            return _this.removeObserver(observer);
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.promise = new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        });
        _this.handlers = {
          next: function(result2) {
            if (_this.sub !== null) {
              _this.latest = ["next", result2];
              _this.notify("next", result2);
              iterateObserversSafely2(_this.observers, "next", result2);
            }
          },
          error: function(error) {
            var sub = _this.sub;
            if (sub !== null) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              _this.latest = ["error", error];
              _this.reject(error);
              _this.notify("error", error);
              iterateObserversSafely2(_this.observers, "error", error);
            }
          },
          complete: function() {
            var _a2 = _this, sub = _a2.sub, _b = _a2.sources, sources2 = _b === void 0 ? [] : _b;
            if (sub !== null) {
              var value = sources2.shift();
              if (!value) {
                if (sub)
                  setTimeout(function() {
                    return sub.unsubscribe();
                  });
                _this.sub = null;
                if (_this.latest && _this.latest[0] === "next") {
                  _this.resolve(_this.latest[1]);
                } else {
                  _this.resolve();
                }
                _this.notify("complete");
                iterateObserversSafely2(_this.observers, "complete");
              } else if (isPromiseLike3(value)) {
                value.then(function(obs) {
                  return _this.sub = obs.subscribe(_this.handlers);
                }, _this.handlers.error);
              } else {
                _this.sub = value.subscribe(_this.handlers);
              }
            }
          }
        };
        _this.nextResultListeners = /* @__PURE__ */ new Set();
        _this.cancel = function(reason) {
          _this.reject(reason);
          _this.sources = [];
          _this.handlers.complete();
        };
        _this.promise.catch(function(_) {
        });
        if (typeof sources === "function") {
          sources = [new zenObservableTs.Observable(sources)];
        }
        if (isPromiseLike3(sources)) {
          sources.then(function(iterable) {
            return _this.start(iterable);
          }, _this.handlers.error);
        } else {
          _this.start(sources);
        }
        return _this;
      }
      Concast3.prototype.start = function(sources) {
        if (this.sub !== void 0)
          return;
        this.sources = Array.from(sources);
        this.handlers.complete();
      };
      Concast3.prototype.deliverLastMessage = function(observer) {
        if (this.latest) {
          var nextOrError = this.latest[0];
          var method = observer[nextOrError];
          if (method) {
            method.call(observer, this.latest[1]);
          }
          if (this.sub === null && nextOrError === "next" && observer.complete) {
            observer.complete();
          }
        }
      };
      Concast3.prototype.addObserver = function(observer) {
        if (!this.observers.has(observer)) {
          this.deliverLastMessage(observer);
          this.observers.add(observer);
        }
      };
      Concast3.prototype.removeObserver = function(observer) {
        if (this.observers.delete(observer) && this.observers.size < 1) {
          this.handlers.complete();
        }
      };
      Concast3.prototype.notify = function(method, arg) {
        var nextResultListeners = this.nextResultListeners;
        if (nextResultListeners.size) {
          this.nextResultListeners = /* @__PURE__ */ new Set();
          nextResultListeners.forEach(function(listener) {
            return listener(method, arg);
          });
        }
      };
      Concast3.prototype.beforeNext = function(callback) {
        var called = false;
        this.nextResultListeners.add(function(method, arg) {
          if (!called) {
            called = true;
            callback(method, arg);
          }
        });
      };
      return Concast3;
    }(zenObservableTs.Observable);
    fixObservableSubclass2(Concast2);
    function isExecutionPatchIncrementalResult2(value) {
      return "incremental" in value;
    }
    function isExecutionPatchInitialResult2(value) {
      return "hasNext" in value && "data" in value;
    }
    function isExecutionPatchResult2(value) {
      return isExecutionPatchIncrementalResult2(value) || isExecutionPatchInitialResult2(value);
    }
    function isApolloPayloadResult2(value) {
      return isNonNullObject2(value) && "payload" in value;
    }
    function mergeIncrementalData2(prevResult, result2) {
      var mergedData = prevResult;
      var merger = new DeepMerger2();
      if (isExecutionPatchIncrementalResult2(result2) && isNonEmptyArray2(result2.incremental)) {
        result2.incremental.forEach(function(_a2) {
          var data = _a2.data, path = _a2.path;
          for (var i = path.length - 1; i >= 0; --i) {
            var key = path[i];
            var isNumericKey = !isNaN(+key);
            var parent_1 = isNumericKey ? [] : {};
            parent_1[key] = data;
            data = parent_1;
          }
          mergedData = merger.merge(mergedData, data);
        });
      }
      return mergedData;
    }
    function graphQLResultHasError2(result2) {
      var errors = getGraphQLErrorsFromResult2(result2);
      return isNonEmptyArray2(errors);
    }
    function getGraphQLErrorsFromResult2(result2) {
      var graphQLErrors = isNonEmptyArray2(result2.errors) ? result2.errors.slice(0) : [];
      if (isExecutionPatchIncrementalResult2(result2) && isNonEmptyArray2(result2.incremental)) {
        result2.incremental.forEach(function(incrementalResult) {
          if (incrementalResult.errors) {
            graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
          }
        });
      }
      return graphQLErrors;
    }
    function compact2() {
      var objects = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
      }
      var result2 = /* @__PURE__ */ Object.create(null);
      objects.forEach(function(obj) {
        if (!obj)
          return;
        Object.keys(obj).forEach(function(key) {
          var value = obj[key];
          if (value !== void 0) {
            result2[key] = value;
          }
        });
      });
      return result2;
    }
    var prefixCounts2 = /* @__PURE__ */ new Map();
    function makeUniqueId2(prefix) {
      var count = prefixCounts2.get(prefix) || 1;
      prefixCounts2.set(prefix, count + 1);
      return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
    }
    function stringifyForDisplay2(value, space) {
      if (space === void 0) {
        space = 0;
      }
      var undefId = makeUniqueId2("stringifyForDisplay");
      return JSON.stringify(value, function(key, value2) {
        return value2 === void 0 ? undefId : value2;
      }, space).split(JSON.stringify(undefId)).join("<undefined>");
    }
    function mergeOptions2(defaults, options) {
      return compact2(defaults, options, options.variables && {
        variables: compact2(tslib.__assign(tslib.__assign({}, defaults && defaults.variables), options.variables))
      });
    }
    function omitDeep2(value, key) {
      return __omitDeep(value, key);
    }
    function __omitDeep(value, key, known) {
      if (known === void 0) {
        known = /* @__PURE__ */ new Map();
      }
      if (known.has(value)) {
        return known.get(value);
      }
      var modified = false;
      if (Array.isArray(value)) {
        var array_1 = [];
        known.set(value, array_1);
        value.forEach(function(value2, index) {
          var result2 = __omitDeep(value2, key, known);
          modified || (modified = result2 !== value2);
          array_1[index] = result2;
        });
        if (modified) {
          return array_1;
        }
      } else if (isPlainObject2(value)) {
        var obj_1 = Object.create(Object.getPrototypeOf(value));
        known.set(value, obj_1);
        Object.keys(value).forEach(function(k) {
          if (k === key) {
            modified = true;
            return;
          }
          var result2 = __omitDeep(value[k], key, known);
          modified || (modified = result2 !== value[k]);
          obj_1[k] = result2;
        });
        if (modified) {
          return obj_1;
        }
      }
      return value;
    }
    function stripTypename2(value) {
      return omitDeep2(value, "__typename");
    }
    exports.DEV = globals.DEV;
    exports.maybe = globals.maybe;
    exports.Observable = zenObservableTs.Observable;
    exports.AutoCleanedStrongCache = AutoCleanedStrongCache2;
    exports.AutoCleanedWeakCache = AutoCleanedWeakCache2;
    exports.Concast = Concast2;
    exports.DeepMerger = DeepMerger2;
    exports.DocumentTransform = DocumentTransform2;
    exports.addTypenameToDocument = addTypenameToDocument2;
    exports.argumentsObjectFromField = argumentsObjectFromField2;
    exports.asyncMap = asyncMap2;
    exports.buildQueryFromSelectionSet = buildQueryFromSelectionSet2;
    exports.cacheSizes = cacheSizes2;
    exports.canUseAsyncIteratorSymbol = canUseAsyncIteratorSymbol2;
    exports.canUseDOM = canUseDOM2;
    exports.canUseLayoutEffect = canUseLayoutEffect2;
    exports.canUseSymbol = canUseSymbol2;
    exports.canUseWeakMap = canUseWeakMap2;
    exports.canUseWeakSet = canUseWeakSet2;
    exports.canonicalStringify = canonicalStringify3;
    exports.checkDocument = checkDocument2;
    exports.cloneDeep = cloneDeep2;
    exports.compact = compact2;
    exports.concatPagination = concatPagination2;
    exports.createFragmentMap = createFragmentMap2;
    exports.createFulfilledPromise = createFulfilledPromise2;
    exports.createRejectedPromise = createRejectedPromise2;
    exports.fixObservableSubclass = fixObservableSubclass2;
    exports.getDefaultValues = getDefaultValues2;
    exports.getDirectiveNames = getDirectiveNames2;
    exports.getFragmentDefinition = getFragmentDefinition2;
    exports.getFragmentDefinitions = getFragmentDefinitions3;
    exports.getFragmentFromSelection = getFragmentFromSelection2;
    exports.getFragmentQueryDocument = getFragmentQueryDocument2;
    exports.getGraphQLErrorsFromResult = getGraphQLErrorsFromResult2;
    exports.getInclusionDirectives = getInclusionDirectives2;
    exports.getMainDefinition = getMainDefinition2;
    exports.getOperationDefinition = getOperationDefinition2;
    exports.getOperationName = getOperationName2;
    exports.getQueryDefinition = getQueryDefinition2;
    exports.getStoreKeyName = getStoreKeyName2;
    exports.getTypenameFromResult = getTypenameFromResult2;
    exports.graphQLResultHasError = graphQLResultHasError2;
    exports.hasAllDirectives = hasAllDirectives2;
    exports.hasAnyDirectives = hasAnyDirectives2;
    exports.hasClientExports = hasClientExports2;
    exports.hasDirectives = hasDirectives2;
    exports.isApolloPayloadResult = isApolloPayloadResult2;
    exports.isArray = isArray2;
    exports.isDocumentNode = isDocumentNode2;
    exports.isExecutionPatchIncrementalResult = isExecutionPatchIncrementalResult2;
    exports.isExecutionPatchInitialResult = isExecutionPatchInitialResult2;
    exports.isExecutionPatchResult = isExecutionPatchResult2;
    exports.isField = isField2;
    exports.isInlineFragment = isInlineFragment2;
    exports.isMutationOperation = isMutationOperation2;
    exports.isNonEmptyArray = isNonEmptyArray2;
    exports.isNonNullObject = isNonNullObject2;
    exports.isPlainObject = isPlainObject2;
    exports.isQueryOperation = isQueryOperation2;
    exports.isReference = isReference2;
    exports.isStatefulPromise = isStatefulPromise2;
    exports.isSubscriptionOperation = isSubscriptionOperation2;
    exports.iterateObserversSafely = iterateObserversSafely2;
    exports.makeReference = makeReference2;
    exports.makeUniqueId = makeUniqueId2;
    exports.maybeDeepFreeze = maybeDeepFreeze2;
    exports.mergeDeep = mergeDeep2;
    exports.mergeDeepArray = mergeDeepArray2;
    exports.mergeIncrementalData = mergeIncrementalData2;
    exports.mergeOptions = mergeOptions2;
    exports.offsetLimitPagination = offsetLimitPagination2;
    exports.omitDeep = omitDeep2;
    exports.print = print3;
    exports.relayStylePagination = relayStylePagination2;
    exports.removeArgumentsFromDocument = removeArgumentsFromDocument2;
    exports.removeClientSetsFromDocument = removeClientSetsFromDocument2;
    exports.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument2;
    exports.removeDirectivesFromDocument = removeDirectivesFromDocument2;
    exports.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument2;
    exports.resultKeyNameFromField = resultKeyNameFromField2;
    exports.shouldInclude = shouldInclude2;
    exports.storeKeyNameFromField = storeKeyNameFromField2;
    exports.stringifyForDisplay = stringifyForDisplay2;
    exports.stripTypename = stripTypename2;
    exports.valueToObjectRepresentation = valueToObjectRepresentation2;
    exports.wrapPromiseWithState = wrapPromiseWithState2;
  }
});

// ../node_modules/@apollo/client/cache/cache.cjs
var require_cache = __commonJS({
  "../node_modules/@apollo/client/cache/cache.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var optimism = (init_lib6(), __toCommonJS(lib_exports4));
    var utilities = require_utilities();
    var caches2 = (init_lib3(), __toCommonJS(lib_exports3));
    var equal2 = (init_lib7(), __toCommonJS(lib_exports5));
    var trie = (init_lib2(), __toCommonJS(lib_exports2));
    var graphql = (init_graphql(), __toCommonJS(graphql_exports));
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e["default"] : e;
    }
    var equal__default = _interopDefaultLegacy(equal2);
    var getInMemoryCacheMemoryInternals2 = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals2 : void 0;
    var getApolloCacheMemoryInternals2 = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals2 : void 0;
    function _getApolloCacheMemoryInternals2() {
      return {
        cache: {
          fragmentQueryDocuments: getWrapperInformation2(this["getFragmentDoc"])
        }
      };
    }
    function _getInMemoryCacheMemoryInternals2() {
      var fragments = this.config.fragments;
      return tslib.__assign(tslib.__assign({}, _getApolloCacheMemoryInternals2.apply(this)), { addTypenameDocumentTransform: transformInfo2(this["addTypenameTransform"]), inMemoryCache: {
        executeSelectionSet: getWrapperInformation2(this["storeReader"]["executeSelectionSet"]),
        executeSubSelectedArray: getWrapperInformation2(this["storeReader"]["executeSubSelectedArray"]),
        maybeBroadcastWatch: getWrapperInformation2(this["maybeBroadcastWatch"])
      }, fragmentRegistry: {
        findFragmentSpreads: getWrapperInformation2(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
        lookup: getWrapperInformation2(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
        transform: getWrapperInformation2(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
      } });
    }
    function isWrapper2(f) {
      return !!f && "dirtyKey" in f;
    }
    function getWrapperInformation2(f) {
      return isWrapper2(f) ? f.size : void 0;
    }
    function isDefined2(value) {
      return value != null;
    }
    function transformInfo2(transform) {
      return recurseTransformInfo2(transform).map(function(cache2) {
        return { cache: cache2 };
      });
    }
    function recurseTransformInfo2(transform) {
      return transform ? tslib.__spreadArray(tslib.__spreadArray([
        getWrapperInformation2(transform === null || transform === void 0 ? void 0 : transform["performWork"])
      ], recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined2) : [];
    }
    function equalByQuery2(query, _a2, _b, variables) {
      var aData = _a2.data, aRest = tslib.__rest(_a2, ["data"]);
      var bData = _b.data, bRest = tslib.__rest(_b, ["data"]);
      return equal__default(aRest, bRest) && equalBySelectionSet2(utilities.getMainDefinition(query).selectionSet, aData, bData, {
        fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
        variables
      });
    }
    function equalBySelectionSet2(selectionSet, aResult, bResult, context) {
      if (aResult === bResult) {
        return true;
      }
      var seenSelections = /* @__PURE__ */ new Set();
      return selectionSet.selections.every(function(selection) {
        if (seenSelections.has(selection))
          return true;
        seenSelections.add(selection);
        if (!utilities.shouldInclude(selection, context.variables))
          return true;
        if (selectionHasNonreactiveDirective2(selection))
          return true;
        if (utilities.isField(selection)) {
          var resultKey = utilities.resultKeyNameFromField(selection);
          var aResultChild = aResult && aResult[resultKey];
          var bResultChild = bResult && bResult[resultKey];
          var childSelectionSet = selection.selectionSet;
          if (!childSelectionSet) {
            return equal__default(aResultChild, bResultChild);
          }
          var aChildIsArray = Array.isArray(aResultChild);
          var bChildIsArray = Array.isArray(bResultChild);
          if (aChildIsArray !== bChildIsArray)
            return false;
          if (aChildIsArray && bChildIsArray) {
            var length_1 = aResultChild.length;
            if (bResultChild.length !== length_1) {
              return false;
            }
            for (var i = 0; i < length_1; ++i) {
              if (!equalBySelectionSet2(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
                return false;
              }
            }
            return true;
          }
          return equalBySelectionSet2(childSelectionSet, aResultChild, bResultChild, context);
        } else {
          var fragment = utilities.getFragmentFromSelection(selection, context.fragmentMap);
          if (fragment) {
            if (selectionHasNonreactiveDirective2(fragment))
              return true;
            return equalBySelectionSet2(
              fragment.selectionSet,
              aResult,
              bResult,
              context
            );
          }
        }
      });
    }
    function selectionHasNonreactiveDirective2(selection) {
      return !!selection.directives && selection.directives.some(directiveIsNonreactive2);
    }
    function directiveIsNonreactive2(dir) {
      return dir.name.value === "nonreactive";
    }
    var ApolloCache2 = function() {
      function ApolloCache3() {
        this.assumeImmutableResults = false;
        this.getFragmentDoc = optimism.wrap(utilities.getFragmentQueryDocument, {
          max: utilities.cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
          cache: caches2.WeakCache
        });
      }
      ApolloCache3.prototype.batch = function(options) {
        var _this = this;
        var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
        var updateResult;
        this.performTransaction(function() {
          return updateResult = options.update(_this);
        }, optimisticId);
        return updateResult;
      };
      ApolloCache3.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
        this.performTransaction(transaction, optimisticId);
      };
      ApolloCache3.prototype.transformDocument = function(document) {
        return document;
      };
      ApolloCache3.prototype.transformForLink = function(document) {
        return document;
      };
      ApolloCache3.prototype.identify = function(object) {
        return;
      };
      ApolloCache3.prototype.gc = function() {
        return [];
      };
      ApolloCache3.prototype.modify = function(options) {
        return false;
      };
      ApolloCache3.prototype.readQuery = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options.optimistic;
        }
        return this.read(tslib.__assign(tslib.__assign({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
      };
      ApolloCache3.prototype.watchFragment = function(options) {
        var _this = this;
        var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, otherOptions = tslib.__rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
        var query = this.getFragmentDoc(fragment, fragmentName);
        var diffOptions = tslib.__assign(tslib.__assign({}, otherOptions), { returnPartialData: true, id: typeof from2 === "string" ? from2 : this.identify(from2), query, optimistic });
        var latestDiff;
        return new utilities.Observable(function(observer) {
          return _this.watch(tslib.__assign(tslib.__assign({}, diffOptions), { immediate: true, callback: function(diff) {
            if (latestDiff && equalByQuery2(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data: diff.result })) {
              return;
            }
            var result2 = {
              data: diff.result,
              complete: !!diff.complete
            };
            if (diff.missing) {
              result2.missing = utilities.mergeDeepArray(diff.missing.map(function(error) {
                return error.missing;
              }));
            }
            latestDiff = diff;
            observer.next(result2);
          } }));
        });
      };
      ApolloCache3.prototype.readFragment = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options.optimistic;
        }
        return this.read(tslib.__assign(tslib.__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
      };
      ApolloCache3.prototype.writeQuery = function(_a2) {
        var id = _a2.id, data = _a2.data, options = tslib.__rest(_a2, ["id", "data"]);
        return this.write(Object.assign(options, {
          dataId: id || "ROOT_QUERY",
          result: data
        }));
      };
      ApolloCache3.prototype.writeFragment = function(_a2) {
        var id = _a2.id, data = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = tslib.__rest(_a2, ["id", "data", "fragment", "fragmentName"]);
        return this.write(Object.assign(options, {
          query: this.getFragmentDoc(fragment, fragmentName),
          dataId: id,
          result: data
        }));
      };
      ApolloCache3.prototype.updateQuery = function(options, update) {
        return this.batch({
          update: function(cache2) {
            var value = cache2.readQuery(options);
            var data = update(value);
            if (data === void 0 || data === null)
              return value;
            cache2.writeQuery(tslib.__assign(tslib.__assign({}, options), { data }));
            return data;
          }
        });
      };
      ApolloCache3.prototype.updateFragment = function(options, update) {
        return this.batch({
          update: function(cache2) {
            var value = cache2.readFragment(options);
            var data = update(value);
            if (data === void 0 || data === null)
              return value;
            cache2.writeFragment(tslib.__assign(tslib.__assign({}, options), { data }));
            return data;
          }
        });
      };
      return ApolloCache3;
    }();
    if (globalThis.__DEV__ !== false) {
      ApolloCache2.prototype.getMemoryInternals = getApolloCacheMemoryInternals2;
    }
    exports.Cache = void 0;
    /* @__PURE__ */ (function(Cache2) {
    })(exports.Cache || (exports.Cache = {}));
    var MissingFieldError2 = function(_super) {
      tslib.__extends(MissingFieldError3, _super);
      function MissingFieldError3(message, path, query, variables) {
        var _a2;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.path = path;
        _this.query = query;
        _this.variables = variables;
        if (Array.isArray(_this.path)) {
          _this.missing = _this.message;
          for (var i = _this.path.length - 1; i >= 0; --i) {
            _this.missing = (_a2 = {}, _a2[_this.path[i]] = _this.missing, _a2);
          }
        } else {
          _this.missing = _this.path;
        }
        _this.__proto__ = MissingFieldError3.prototype;
        return _this;
      }
      return MissingFieldError3;
    }(Error);
    var hasOwn2 = Object.prototype.hasOwnProperty;
    function isNullish2(value) {
      return value === null || value === void 0;
    }
    function defaultDataIdFromObject2(_a2, context) {
      var __typename = _a2.__typename, id = _a2.id, _id = _a2._id;
      if (typeof __typename === "string") {
        if (context) {
          context.keyObject = !isNullish2(id) ? { id } : !isNullish2(_id) ? { _id } : void 0;
        }
        if (isNullish2(id) && !isNullish2(_id)) {
          id = _id;
        }
        if (!isNullish2(id)) {
          return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
        }
      }
    }
    var defaultConfig2 = {
      dataIdFromObject: defaultDataIdFromObject2,
      addTypename: true,
      resultCaching: true,
      canonizeResults: false
    };
    function normalizeConfig2(config) {
      return utilities.compact(defaultConfig2, config);
    }
    function shouldCanonizeResults2(config) {
      var value = config.canonizeResults;
      return value === void 0 ? defaultConfig2.canonizeResults : value;
    }
    function getTypenameFromStoreObject2(store, objectOrReference) {
      return utilities.isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
    }
    var TypeOrFieldNameRegExp2 = /^[_a-z][_0-9a-z]*/i;
    function fieldNameFromStoreName2(storeFieldName) {
      var match = storeFieldName.match(TypeOrFieldNameRegExp2);
      return match ? match[0] : storeFieldName;
    }
    function selectionSetMatchesResult2(selectionSet, result2, variables) {
      if (utilities.isNonNullObject(result2)) {
        return utilities.isArray(result2) ? result2.every(function(item) {
          return selectionSetMatchesResult2(selectionSet, item, variables);
        }) : selectionSet.selections.every(function(field) {
          if (utilities.isField(field) && utilities.shouldInclude(field, variables)) {
            var key = utilities.resultKeyNameFromField(field);
            return hasOwn2.call(result2, key) && (!field.selectionSet || selectionSetMatchesResult2(field.selectionSet, result2[key], variables));
          }
          return true;
        });
      }
      return false;
    }
    function storeValueIsStoreObject2(value) {
      return utilities.isNonNullObject(value) && !utilities.isReference(value) && !utilities.isArray(value);
    }
    function makeProcessedFieldsMerger2() {
      return new utilities.DeepMerger();
    }
    function extractFragmentContext2(document, fragments) {
      var fragmentMap = utilities.createFragmentMap(utilities.getFragmentDefinitions(document));
      return {
        fragmentMap,
        lookupFragment: function(name) {
          var def = fragmentMap[name];
          if (!def && fragments) {
            def = fragments.lookup(name);
          }
          return def || null;
        }
      };
    }
    var DELETE2 = /* @__PURE__ */ Object.create(null);
    var delModifier2 = function() {
      return DELETE2;
    };
    var INVALIDATE2 = /* @__PURE__ */ Object.create(null);
    exports.EntityStore = function() {
      function EntityStore2(policies, group) {
        var _this = this;
        this.policies = policies;
        this.group = group;
        this.data = /* @__PURE__ */ Object.create(null);
        this.rootIds = /* @__PURE__ */ Object.create(null);
        this.refs = /* @__PURE__ */ Object.create(null);
        this.getFieldValue = function(objectOrReference, storeFieldName) {
          return utilities.maybeDeepFreeze(utilities.isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
        };
        this.canRead = function(objOrRef) {
          return utilities.isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
        };
        this.toReference = function(objOrIdOrRef, mergeIntoStore) {
          if (typeof objOrIdOrRef === "string") {
            return utilities.makeReference(objOrIdOrRef);
          }
          if (utilities.isReference(objOrIdOrRef)) {
            return objOrIdOrRef;
          }
          var id = _this.policies.identify(objOrIdOrRef)[0];
          if (id) {
            var ref = utilities.makeReference(id);
            if (mergeIntoStore) {
              _this.merge(id, objOrIdOrRef);
            }
            return ref;
          }
        };
      }
      EntityStore2.prototype.toObject = function() {
        return tslib.__assign({}, this.data);
      };
      EntityStore2.prototype.has = function(dataId) {
        return this.lookup(dataId, true) !== void 0;
      };
      EntityStore2.prototype.get = function(dataId, fieldName) {
        this.group.depend(dataId, fieldName);
        if (hasOwn2.call(this.data, dataId)) {
          var storeObject = this.data[dataId];
          if (storeObject && hasOwn2.call(storeObject, fieldName)) {
            return storeObject[fieldName];
          }
        }
        if (fieldName === "__typename" && hasOwn2.call(this.policies.rootTypenamesById, dataId)) {
          return this.policies.rootTypenamesById[dataId];
        }
        if (this instanceof Layer2) {
          return this.parent.get(dataId, fieldName);
        }
      };
      EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
        if (dependOnExistence)
          this.group.depend(dataId, "__exists");
        if (hasOwn2.call(this.data, dataId)) {
          return this.data[dataId];
        }
        if (this instanceof Layer2) {
          return this.parent.lookup(dataId, dependOnExistence);
        }
        if (this.policies.rootTypenamesById[dataId]) {
          return /* @__PURE__ */ Object.create(null);
        }
      };
      EntityStore2.prototype.merge = function(older, newer) {
        var _this = this;
        var dataId;
        if (utilities.isReference(older))
          older = older.__ref;
        if (utilities.isReference(newer))
          newer = newer.__ref;
        var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
        var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
        if (!incoming)
          return;
        globals.invariant(typeof dataId === "string", 1);
        var merged = new utilities.DeepMerger(storeObjectReconciler2).merge(existing, incoming);
        this.data[dataId] = merged;
        if (merged !== existing) {
          delete this.refs[dataId];
          if (this.group.caching) {
            var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
            if (!existing)
              fieldsToDirty_1.__exists = 1;
            Object.keys(incoming).forEach(function(storeFieldName) {
              if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                fieldsToDirty_1[storeFieldName] = 1;
                var fieldName = fieldNameFromStoreName2(storeFieldName);
                if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                  fieldsToDirty_1[fieldName] = 1;
                }
                if (merged[storeFieldName] === void 0 && !(_this instanceof Layer2)) {
                  delete merged[storeFieldName];
                }
              }
            });
            if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
              delete fieldsToDirty_1.__typename;
            }
            Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
              return _this.group.dirty(dataId, fieldName);
            });
          }
        }
      };
      EntityStore2.prototype.modify = function(dataId, fields) {
        var _this = this;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var changedFields_1 = /* @__PURE__ */ Object.create(null);
          var needToMerge_1 = false;
          var allDeleted_1 = true;
          var sharedDetails_1 = {
            DELETE: DELETE2,
            INVALIDATE: INVALIDATE2,
            isReference: utilities.isReference,
            toReference: this.toReference,
            canRead: this.canRead,
            readField: function(fieldNameOrOptions, from2) {
              return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                fieldName: fieldNameOrOptions,
                from: from2 || utilities.makeReference(dataId)
              } : fieldNameOrOptions, { store: _this });
            }
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            var fieldName = fieldNameFromStoreName2(storeFieldName);
            var fieldValue = storeObject[storeFieldName];
            if (fieldValue === void 0)
              return;
            var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
            if (modify) {
              var newValue = modify === delModifier2 ? DELETE2 : modify(utilities.maybeDeepFreeze(fieldValue), tslib.__assign(tslib.__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
              if (newValue === INVALIDATE2) {
                _this.group.dirty(dataId, storeFieldName);
              } else {
                if (newValue === DELETE2)
                  newValue = void 0;
                if (newValue !== fieldValue) {
                  changedFields_1[storeFieldName] = newValue;
                  needToMerge_1 = true;
                  fieldValue = newValue;
                  if (globalThis.__DEV__ !== false) {
                    var checkReference = function(ref) {
                      if (_this.lookup(ref.__ref) === void 0) {
                        globalThis.__DEV__ !== false && globals.invariant.warn(2, ref);
                        return true;
                      }
                    };
                    if (utilities.isReference(newValue)) {
                      checkReference(newValue);
                    } else if (Array.isArray(newValue)) {
                      var seenReference = false;
                      var someNonReference = void 0;
                      for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {
                        var value = newValue_1[_i];
                        if (utilities.isReference(value)) {
                          seenReference = true;
                          if (checkReference(value))
                            break;
                        } else {
                          if (typeof value === "object" && !!value) {
                            var id = _this.policies.identify(value)[0];
                            if (id) {
                              someNonReference = value;
                            }
                          }
                        }
                        if (seenReference && someNonReference !== void 0) {
                          globalThis.__DEV__ !== false && globals.invariant.warn(3, someNonReference);
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (fieldValue !== void 0) {
              allDeleted_1 = false;
            }
          });
          if (needToMerge_1) {
            this.merge(dataId, changedFields_1);
            if (allDeleted_1) {
              if (this instanceof Layer2) {
                this.data[dataId] = void 0;
              } else {
                delete this.data[dataId];
              }
              this.group.dirty(dataId, "__exists");
            }
            return true;
          }
        }
        return false;
      };
      EntityStore2.prototype.delete = function(dataId, fieldName, args) {
        var _a2;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var typename = this.getFieldValue(storeObject, "__typename");
          var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
          return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier2, _a2) : delModifier2);
        }
        return false;
      };
      EntityStore2.prototype.evict = function(options, limit) {
        var evicted = false;
        if (options.id) {
          if (hasOwn2.call(this.data, options.id)) {
            evicted = this.delete(options.id, options.fieldName, options.args);
          }
          if (this instanceof Layer2 && this !== limit) {
            evicted = this.parent.evict(options, limit) || evicted;
          }
          if (options.fieldName || evicted) {
            this.group.dirty(options.id, options.fieldName || "__exists");
          }
        }
        return evicted;
      };
      EntityStore2.prototype.clear = function() {
        this.replace(null);
      };
      EntityStore2.prototype.extract = function() {
        var _this = this;
        var obj = this.toObject();
        var extraRootIds = [];
        this.getRootIdSet().forEach(function(id) {
          if (!hasOwn2.call(_this.policies.rootTypenamesById, id)) {
            extraRootIds.push(id);
          }
        });
        if (extraRootIds.length) {
          obj.__META = { extraRootIds: extraRootIds.sort() };
        }
        return obj;
      };
      EntityStore2.prototype.replace = function(newData) {
        var _this = this;
        Object.keys(this.data).forEach(function(dataId) {
          if (!(newData && hasOwn2.call(newData, dataId))) {
            _this.delete(dataId);
          }
        });
        if (newData) {
          var __META = newData.__META, rest_1 = tslib.__rest(newData, ["__META"]);
          Object.keys(rest_1).forEach(function(dataId) {
            _this.merge(dataId, rest_1[dataId]);
          });
          if (__META) {
            __META.extraRootIds.forEach(this.retain, this);
          }
        }
      };
      EntityStore2.prototype.retain = function(rootId) {
        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
      };
      EntityStore2.prototype.release = function(rootId) {
        if (this.rootIds[rootId] > 0) {
          var count = --this.rootIds[rootId];
          if (!count)
            delete this.rootIds[rootId];
          return count;
        }
        return 0;
      };
      EntityStore2.prototype.getRootIdSet = function(ids) {
        if (ids === void 0) {
          ids = /* @__PURE__ */ new Set();
        }
        Object.keys(this.rootIds).forEach(ids.add, ids);
        if (this instanceof Layer2) {
          this.parent.getRootIdSet(ids);
        } else {
          Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
        }
        return ids;
      };
      EntityStore2.prototype.gc = function() {
        var _this = this;
        var ids = this.getRootIdSet();
        var snapshot = this.toObject();
        ids.forEach(function(id) {
          if (hasOwn2.call(snapshot, id)) {
            Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
            delete snapshot[id];
          }
        });
        var idsToRemove = Object.keys(snapshot);
        if (idsToRemove.length) {
          var root_1 = this;
          while (root_1 instanceof Layer2)
            root_1 = root_1.parent;
          idsToRemove.forEach(function(id) {
            return root_1.delete(id);
          });
        }
        return idsToRemove;
      };
      EntityStore2.prototype.findChildRefIds = function(dataId) {
        if (!hasOwn2.call(this.refs, dataId)) {
          var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
          var root2 = this.data[dataId];
          if (!root2)
            return found_1;
          var workSet_1 = /* @__PURE__ */ new Set([root2]);
          workSet_1.forEach(function(obj) {
            if (utilities.isReference(obj)) {
              found_1[obj.__ref] = true;
            }
            if (utilities.isNonNullObject(obj)) {
              Object.keys(obj).forEach(function(key) {
                var child = obj[key];
                if (utilities.isNonNullObject(child)) {
                  workSet_1.add(child);
                }
              });
            }
          });
        }
        return this.refs[dataId];
      };
      EntityStore2.prototype.makeCacheKey = function() {
        return this.group.keyMaker.lookupArray(arguments);
      };
      return EntityStore2;
    }();
    var CacheGroup2 = function() {
      function CacheGroup3(caching, parent) {
        if (parent === void 0) {
          parent = null;
        }
        this.caching = caching;
        this.parent = parent;
        this.d = null;
        this.resetCaching();
      }
      CacheGroup3.prototype.resetCaching = function() {
        this.d = this.caching ? optimism.dep() : null;
        this.keyMaker = new trie.Trie(utilities.canUseWeakMap);
      };
      CacheGroup3.prototype.depend = function(dataId, storeFieldName) {
        if (this.d) {
          this.d(makeDepKey2(dataId, storeFieldName));
          var fieldName = fieldNameFromStoreName2(storeFieldName);
          if (fieldName !== storeFieldName) {
            this.d(makeDepKey2(dataId, fieldName));
          }
          if (this.parent) {
            this.parent.depend(dataId, storeFieldName);
          }
        }
      };
      CacheGroup3.prototype.dirty = function(dataId, storeFieldName) {
        if (this.d) {
          this.d.dirty(
            makeDepKey2(dataId, storeFieldName),
            storeFieldName === "__exists" ? "forget" : "setDirty"
          );
        }
      };
      return CacheGroup3;
    }();
    function makeDepKey2(dataId, storeFieldName) {
      return storeFieldName + "#" + dataId;
    }
    function maybeDependOnExistenceOfEntity2(store, entityId) {
      if (supportsResultCaching2(store)) {
        store.group.depend(entityId, "__exists");
      }
    }
    (function(EntityStore2) {
      var Root = function(_super) {
        tslib.__extends(Root2, _super);
        function Root2(_a2) {
          var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
          var _this = _super.call(this, policies, new CacheGroup2(resultCaching)) || this;
          _this.stump = new Stump2(_this);
          _this.storageTrie = new trie.Trie(utilities.canUseWeakMap);
          if (seed)
            _this.replace(seed);
          return _this;
        }
        Root2.prototype.addLayer = function(layerId, replay) {
          return this.stump.addLayer(layerId, replay);
        };
        Root2.prototype.removeLayer = function() {
          return this;
        };
        Root2.prototype.getStorage = function() {
          return this.storageTrie.lookupArray(arguments);
        };
        return Root2;
      }(EntityStore2);
      EntityStore2.Root = Root;
    })(exports.EntityStore || (exports.EntityStore = {}));
    var Layer2 = function(_super) {
      tslib.__extends(Layer3, _super);
      function Layer3(id, parent, replay, group) {
        var _this = _super.call(this, parent.policies, group) || this;
        _this.id = id;
        _this.parent = parent;
        _this.replay = replay;
        _this.group = group;
        replay(_this);
        return _this;
      }
      Layer3.prototype.addLayer = function(layerId, replay) {
        return new Layer3(layerId, this, replay, this.group);
      };
      Layer3.prototype.removeLayer = function(layerId) {
        var _this = this;
        var parent = this.parent.removeLayer(layerId);
        if (layerId === this.id) {
          if (this.group.caching) {
            Object.keys(this.data).forEach(function(dataId) {
              var ownStoreObject = _this.data[dataId];
              var parentStoreObject = parent["lookup"](dataId);
              if (!parentStoreObject) {
                _this.delete(dataId);
              } else if (!ownStoreObject) {
                _this.group.dirty(dataId, "__exists");
                Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                  _this.group.dirty(dataId, storeFieldName);
                });
              } else if (ownStoreObject !== parentStoreObject) {
                Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                  if (!equal2.equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                    _this.group.dirty(dataId, storeFieldName);
                  }
                });
              }
            });
          }
          return parent;
        }
        if (parent === this.parent)
          return this;
        return parent.addLayer(this.id, this.replay);
      };
      Layer3.prototype.toObject = function() {
        return tslib.__assign(tslib.__assign({}, this.parent.toObject()), this.data);
      };
      Layer3.prototype.findChildRefIds = function(dataId) {
        var fromParent = this.parent.findChildRefIds(dataId);
        return hasOwn2.call(this.data, dataId) ? tslib.__assign(tslib.__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
      };
      Layer3.prototype.getStorage = function() {
        var p = this.parent;
        while (p.parent)
          p = p.parent;
        return p.getStorage.apply(
          p,
          arguments
        );
      };
      return Layer3;
    }(exports.EntityStore);
    var Stump2 = function(_super) {
      tslib.__extends(Stump3, _super);
      function Stump3(root2) {
        return _super.call(this, "EntityStore.Stump", root2, function() {
        }, new CacheGroup2(root2.group.caching, root2.group)) || this;
      }
      Stump3.prototype.removeLayer = function() {
        return this;
      };
      Stump3.prototype.merge = function(older, newer) {
        return this.parent.merge(older, newer);
      };
      return Stump3;
    }(Layer2);
    function storeObjectReconciler2(existingObject, incomingObject, property) {
      var existingValue = existingObject[property];
      var incomingValue = incomingObject[property];
      return equal2.equal(existingValue, incomingValue) ? existingValue : incomingValue;
    }
    function supportsResultCaching2(store) {
      return !!(store instanceof exports.EntityStore && store.group.caching);
    }
    function shallowCopy2(value) {
      if (utilities.isNonNullObject(value)) {
        return utilities.isArray(value) ? value.slice(0) : tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
      }
      return value;
    }
    var ObjectCanon2 = function() {
      function ObjectCanon3() {
        this.known = new (utilities.canUseWeakSet ? WeakSet : Set)();
        this.pool = new trie.Trie(utilities.canUseWeakMap);
        this.passes = /* @__PURE__ */ new WeakMap();
        this.keysByJSON = /* @__PURE__ */ new Map();
        this.empty = this.admit({});
      }
      ObjectCanon3.prototype.isKnown = function(value) {
        return utilities.isNonNullObject(value) && this.known.has(value);
      };
      ObjectCanon3.prototype.pass = function(value) {
        if (utilities.isNonNullObject(value)) {
          var copy = shallowCopy2(value);
          this.passes.set(copy, value);
          return copy;
        }
        return value;
      };
      ObjectCanon3.prototype.admit = function(value) {
        var _this = this;
        if (utilities.isNonNullObject(value)) {
          var original = this.passes.get(value);
          if (original)
            return original;
          var proto = Object.getPrototypeOf(value);
          switch (proto) {
            case Array.prototype: {
              if (this.known.has(value))
                return value;
              var array = value.map(this.admit, this);
              var node = this.pool.lookupArray(array);
              if (!node.array) {
                this.known.add(node.array = array);
                if (globalThis.__DEV__ !== false) {
                  Object.freeze(array);
                }
              }
              return node.array;
            }
            case null:
            case Object.prototype: {
              if (this.known.has(value))
                return value;
              var proto_1 = Object.getPrototypeOf(value);
              var array_1 = [proto_1];
              var keys = this.sortedKeys(value);
              array_1.push(keys.json);
              var firstValueIndex_1 = array_1.length;
              keys.sorted.forEach(function(key) {
                array_1.push(_this.admit(value[key]));
              });
              var node = this.pool.lookupArray(array_1);
              if (!node.object) {
                var obj_1 = node.object = Object.create(proto_1);
                this.known.add(obj_1);
                keys.sorted.forEach(function(key, i) {
                  obj_1[key] = array_1[firstValueIndex_1 + i];
                });
                if (globalThis.__DEV__ !== false) {
                  Object.freeze(obj_1);
                }
              }
              return node.object;
            }
          }
        }
        return value;
      };
      ObjectCanon3.prototype.sortedKeys = function(obj) {
        var keys = Object.keys(obj);
        var node = this.pool.lookupArray(keys);
        if (!node.keys) {
          keys.sort();
          var json = JSON.stringify(keys);
          if (!(node.keys = this.keysByJSON.get(json))) {
            this.keysByJSON.set(json, node.keys = { sorted: keys, json });
          }
        }
        return node.keys;
      };
      return ObjectCanon3;
    }();
    function execSelectionSetKeyArgs2(options) {
      return [
        options.selectionSet,
        options.objectOrReference,
        options.context,
        options.context.canonizeResults
      ];
    }
    var StoreReader2 = function() {
      function StoreReader3(config) {
        var _this = this;
        this.knownResults = new (utilities.canUseWeakMap ? WeakMap : Map)();
        this.config = utilities.compact(config, {
          addTypename: config.addTypename !== false,
          canonizeResults: shouldCanonizeResults2(config)
        });
        this.canon = config.canon || new ObjectCanon2();
        this.executeSelectionSet = optimism.wrap(function(options) {
          var _a2;
          var canonizeResults = options.context.canonizeResults;
          var peekArgs = execSelectionSetKeyArgs2(options);
          peekArgs[3] = !canonizeResults;
          var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
          if (other) {
            if (canonizeResults) {
              return tslib.__assign(tslib.__assign({}, other), {
                result: _this.canon.admit(other.result)
              });
            }
            return other;
          }
          maybeDependOnExistenceOfEntity2(options.context.store, options.enclosingRef.__ref);
          return _this.execSelectionSetImpl(options);
        }, {
          max: this.config.resultCacheMaxSize || utilities.cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
          keyArgs: execSelectionSetKeyArgs2,
          makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
            if (supportsResultCaching2(context.store)) {
              return context.store.makeCacheKey(selectionSet, utilities.isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
            }
          }
        });
        this.executeSubSelectedArray = optimism.wrap(function(options) {
          maybeDependOnExistenceOfEntity2(options.context.store, options.enclosingRef.__ref);
          return _this.execSubSelectedArrayImpl(options);
        }, {
          max: this.config.resultCacheMaxSize || utilities.cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
          makeCacheKey: function(_a2) {
            var field = _a2.field, array = _a2.array, context = _a2.context;
            if (supportsResultCaching2(context.store)) {
              return context.store.makeCacheKey(field, array, context.varString);
            }
          }
        });
      }
      StoreReader3.prototype.resetCanon = function() {
        this.canon = new ObjectCanon2();
      };
      StoreReader3.prototype.diffQueryAgainstStore = function(_a2) {
        var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
        var policies = this.config.cache.policies;
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(utilities.getQueryDefinition(query))), variables);
        var rootRef = utilities.makeReference(rootId);
        var execResult = this.executeSelectionSet({
          selectionSet: utilities.getMainDefinition(query).selectionSet,
          objectOrReference: rootRef,
          enclosingRef: rootRef,
          context: tslib.__assign({ store, query, policies, variables, varString: utilities.canonicalStringify(variables), canonizeResults }, extractFragmentContext2(query, this.config.fragments))
        });
        var missing;
        if (execResult.missing) {
          missing = [
            new MissingFieldError2(firstMissing2(execResult.missing), execResult.missing, query, variables)
          ];
          if (!returnPartialData) {
            throw missing[0];
          }
        }
        return {
          result: execResult.result,
          complete: !missing,
          missing
        };
      };
      StoreReader3.prototype.isFresh = function(result2, parent, selectionSet, context) {
        if (supportsResultCaching2(context.store) && this.knownResults.get(result2) === selectionSet) {
          var latest = this.executeSelectionSet.peek(
            selectionSet,
            parent,
            context,
            this.canon.isKnown(result2)
          );
          if (latest && result2 === latest.result) {
            return true;
          }
        }
        return false;
      };
      StoreReader3.prototype.execSelectionSetImpl = function(_a2) {
        var _this = this;
        var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context = _a2.context;
        if (utilities.isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
          return {
            result: this.canon.empty,
            missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
          };
        }
        var variables = context.variables, policies = context.policies, store = context.store;
        var typename = store.getFieldValue(objectOrReference, "__typename");
        var objectsToMerge = [];
        var missing;
        var missingMerger = new utilities.DeepMerger();
        if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
          objectsToMerge.push({ __typename: typename });
        }
        function handleMissing(result3, resultName) {
          var _a3;
          if (result3.missing) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result3.missing, _a3));
          }
          return result3.result;
        }
        var workSet = new Set(selectionSet.selections);
        workSet.forEach(function(selection) {
          var _a3, _b;
          if (!utilities.shouldInclude(selection, variables))
            return;
          if (utilities.isField(selection)) {
            var fieldValue = policies.readField({
              fieldName: selection.name.value,
              field: selection,
              variables: context.variables,
              from: objectOrReference
            }, context);
            var resultName = utilities.resultKeyNameFromField(selection);
            if (fieldValue === void 0) {
              if (!utilities.addTypenameToDocument.added(selection)) {
                missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(utilities.isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
              }
            } else if (utilities.isArray(fieldValue)) {
              if (fieldValue.length > 0) {
                fieldValue = handleMissing(_this.executeSubSelectedArray({
                  field: selection,
                  array: fieldValue,
                  enclosingRef,
                  context
                }), resultName);
              }
            } else if (!selection.selectionSet) {
              if (context.canonizeResults) {
                fieldValue = _this.canon.pass(fieldValue);
              }
            } else if (fieldValue != null) {
              fieldValue = handleMissing(_this.executeSelectionSet({
                selectionSet: selection.selectionSet,
                objectOrReference: fieldValue,
                enclosingRef: utilities.isReference(fieldValue) ? fieldValue : enclosingRef,
                context
              }), resultName);
            }
            if (fieldValue !== void 0) {
              objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
            }
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, context.lookupFragment);
            if (!fragment && selection.kind === graphql.Kind.FRAGMENT_SPREAD) {
              throw globals.newInvariantError(9, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename)) {
              fragment.selectionSet.selections.forEach(workSet.add, workSet);
            }
          }
        });
        var result2 = utilities.mergeDeepArray(objectsToMerge);
        var finalResult = { result: result2, missing };
        var frozen = context.canonizeResults ? this.canon.admit(finalResult) : utilities.maybeDeepFreeze(finalResult);
        if (frozen.result) {
          this.knownResults.set(frozen.result, selectionSet);
        }
        return frozen;
      };
      StoreReader3.prototype.execSubSelectedArrayImpl = function(_a2) {
        var _this = this;
        var field = _a2.field, array = _a2.array, enclosingRef = _a2.enclosingRef, context = _a2.context;
        var missing;
        var missingMerger = new utilities.DeepMerger();
        function handleMissing(childResult, i) {
          var _a3;
          if (childResult.missing) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[i] = childResult.missing, _a3));
          }
          return childResult.result;
        }
        if (field.selectionSet) {
          array = array.filter(context.store.canRead);
        }
        array = array.map(function(item, i) {
          if (item === null) {
            return null;
          }
          if (utilities.isArray(item)) {
            return handleMissing(_this.executeSubSelectedArray({
              field,
              array: item,
              enclosingRef,
              context
            }), i);
          }
          if (field.selectionSet) {
            return handleMissing(_this.executeSelectionSet({
              selectionSet: field.selectionSet,
              objectOrReference: item,
              enclosingRef: utilities.isReference(item) ? item : enclosingRef,
              context
            }), i);
          }
          if (globalThis.__DEV__ !== false) {
            assertSelectionSetForIdValue2(context.store, field, item);
          }
          return item;
        });
        return {
          result: context.canonizeResults ? this.canon.admit(array) : array,
          missing
        };
      };
      return StoreReader3;
    }();
    function firstMissing2(tree) {
      try {
        JSON.stringify(tree, function(_, value) {
          if (typeof value === "string")
            throw value;
          return value;
        });
      } catch (result2) {
        return result2;
      }
    }
    function assertSelectionSetForIdValue2(store, field, fieldValue) {
      if (!field.selectionSet) {
        var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
        workSet_1.forEach(function(value) {
          if (utilities.isNonNullObject(value)) {
            globals.invariant(
              !utilities.isReference(value),
              10,
              getTypenameFromStoreObject2(store, value),
              field.name.value
            );
            Object.values(value).forEach(workSet_1.add, workSet_1);
          }
        });
      }
    }
    var cacheSlot2 = new optimism.Slot();
    var cacheInfoMap2 = /* @__PURE__ */ new WeakMap();
    function getCacheInfo2(cache2) {
      var info = cacheInfoMap2.get(cache2);
      if (!info) {
        cacheInfoMap2.set(cache2, info = {
          vars: /* @__PURE__ */ new Set(),
          dep: optimism.dep()
        });
      }
      return info;
    }
    function forgetCache2(cache2) {
      getCacheInfo2(cache2).vars.forEach(function(rv) {
        return rv.forgetCache(cache2);
      });
    }
    function recallCache2(cache2) {
      getCacheInfo2(cache2).vars.forEach(function(rv) {
        return rv.attachCache(cache2);
      });
    }
    function makeVar2(value) {
      var caches3 = /* @__PURE__ */ new Set();
      var listeners = /* @__PURE__ */ new Set();
      var rv = function(newValue) {
        if (arguments.length > 0) {
          if (value !== newValue) {
            value = newValue;
            caches3.forEach(function(cache3) {
              getCacheInfo2(cache3).dep.dirty(rv);
              broadcast2(cache3);
            });
            var oldListeners = Array.from(listeners);
            listeners.clear();
            oldListeners.forEach(function(listener) {
              return listener(value);
            });
          }
        } else {
          var cache2 = cacheSlot2.getValue();
          if (cache2) {
            attach(cache2);
            getCacheInfo2(cache2).dep(rv);
          }
        }
        return value;
      };
      rv.onNextChange = function(listener) {
        listeners.add(listener);
        return function() {
          listeners.delete(listener);
        };
      };
      var attach = rv.attachCache = function(cache2) {
        caches3.add(cache2);
        getCacheInfo2(cache2).vars.add(rv);
        return rv;
      };
      rv.forgetCache = function(cache2) {
        return caches3.delete(cache2);
      };
      return rv;
    }
    function broadcast2(cache2) {
      if (cache2.broadcastWatches) {
        cache2.broadcastWatches();
      }
    }
    var specifierInfoCache2 = /* @__PURE__ */ Object.create(null);
    function lookupSpecifierInfo2(spec) {
      var cacheKey = JSON.stringify(spec);
      return specifierInfoCache2[cacheKey] || (specifierInfoCache2[cacheKey] = /* @__PURE__ */ Object.create(null));
    }
    function keyFieldsFnFromSpecifier2(specifier) {
      var info = lookupSpecifierInfo2(specifier);
      return info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {
        var extract = function(from2, key) {
          return context.readField(key, from2);
        };
        var keyObject = context.keyObject = collectSpecifierPaths2(specifier, function(schemaKeyPath) {
          var extracted = extractKeyPath2(
            context.storeObject,
            schemaKeyPath,
            extract
          );
          if (extracted === void 0 && object !== context.storeObject && hasOwn2.call(object, schemaKeyPath[0])) {
            extracted = extractKeyPath2(object, schemaKeyPath, extractKey2);
          }
          globals.invariant(extracted !== void 0, 4, schemaKeyPath.join("."), object);
          return extracted;
        });
        return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
      });
    }
    function keyArgsFnFromSpecifier2(specifier) {
      var info = lookupSpecifierInfo2(specifier);
      return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
        var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
        var collected = collectSpecifierPaths2(specifier, function(keyPath) {
          var firstKey = keyPath[0];
          var firstChar = firstKey.charAt(0);
          if (firstChar === "@") {
            if (field && utilities.isNonEmptyArray(field.directives)) {
              var directiveName_1 = firstKey.slice(1);
              var d = field.directives.find(function(d2) {
                return d2.name.value === directiveName_1;
              });
              var directiveArgs = d && utilities.argumentsObjectFromField(d, variables);
              return directiveArgs && extractKeyPath2(
                directiveArgs,
                keyPath.slice(1)
              );
            }
            return;
          }
          if (firstChar === "$") {
            var variableName = firstKey.slice(1);
            if (variables && hasOwn2.call(variables, variableName)) {
              var varKeyPath = keyPath.slice(0);
              varKeyPath[0] = variableName;
              return extractKeyPath2(variables, varKeyPath);
            }
            return;
          }
          if (args) {
            return extractKeyPath2(args, keyPath);
          }
        });
        var suffix = JSON.stringify(collected);
        if (args || suffix !== "{}") {
          fieldName += ":" + suffix;
        }
        return fieldName;
      });
    }
    function collectSpecifierPaths2(specifier, extractor) {
      var merger = new utilities.DeepMerger();
      return getSpecifierPaths2(specifier).reduce(function(collected, path) {
        var _a2;
        var toMerge = extractor(path);
        if (toMerge !== void 0) {
          for (var i = path.length - 1; i >= 0; --i) {
            toMerge = (_a2 = {}, _a2[path[i]] = toMerge, _a2);
          }
          collected = merger.merge(collected, toMerge);
        }
        return collected;
      }, /* @__PURE__ */ Object.create(null));
    }
    function getSpecifierPaths2(spec) {
      var info = lookupSpecifierInfo2(spec);
      if (!info.paths) {
        var paths_1 = info.paths = [];
        var currentPath_1 = [];
        spec.forEach(function(s, i) {
          if (utilities.isArray(s)) {
            getSpecifierPaths2(s).forEach(function(p) {
              return paths_1.push(currentPath_1.concat(p));
            });
            currentPath_1.length = 0;
          } else {
            currentPath_1.push(s);
            if (!utilities.isArray(spec[i + 1])) {
              paths_1.push(currentPath_1.slice(0));
              currentPath_1.length = 0;
            }
          }
        });
      }
      return info.paths;
    }
    function extractKey2(object, key) {
      return object[key];
    }
    function extractKeyPath2(object, path, extract) {
      extract = extract || extractKey2;
      return normalize2(path.reduce(function reducer(obj, key) {
        return utilities.isArray(obj) ? obj.map(function(child) {
          return reducer(child, key);
        }) : obj && extract(obj, key);
      }, object));
    }
    function normalize2(value) {
      if (utilities.isNonNullObject(value)) {
        if (utilities.isArray(value)) {
          return value.map(normalize2);
        }
        return collectSpecifierPaths2(Object.keys(value).sort(), function(path) {
          return extractKeyPath2(value, path);
        });
      }
      return value;
    }
    function argsFromFieldSpecifier2(spec) {
      return spec.args !== void 0 ? spec.args : spec.field ? utilities.argumentsObjectFromField(spec.field, spec.variables) : null;
    }
    var nullKeyFieldsFn2 = function() {
      return void 0;
    };
    var simpleKeyArgsFn2 = function(_args, context) {
      return context.fieldName;
    };
    var mergeTrueFn2 = function(existing, incoming, _a2) {
      var mergeObjects = _a2.mergeObjects;
      return mergeObjects(existing, incoming);
    };
    var mergeFalseFn2 = function(_, incoming) {
      return incoming;
    };
    var Policies2 = function() {
      function Policies3(config) {
        this.config = config;
        this.typePolicies = /* @__PURE__ */ Object.create(null);
        this.toBeAdded = /* @__PURE__ */ Object.create(null);
        this.supertypeMap = /* @__PURE__ */ new Map();
        this.fuzzySubtypes = /* @__PURE__ */ new Map();
        this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
        this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
        this.usingPossibleTypes = false;
        this.config = tslib.__assign({ dataIdFromObject: defaultDataIdFromObject2 }, config);
        this.cache = this.config.cache;
        this.setRootTypename("Query");
        this.setRootTypename("Mutation");
        this.setRootTypename("Subscription");
        if (config.possibleTypes) {
          this.addPossibleTypes(config.possibleTypes);
        }
        if (config.typePolicies) {
          this.addTypePolicies(config.typePolicies);
        }
      }
      Policies3.prototype.identify = function(object, partialContext) {
        var _a2;
        var policies = this;
        var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object.__typename;
        if (typename === this.rootTypenamesById.ROOT_QUERY) {
          return ["ROOT_QUERY"];
        }
        var storeObject = partialContext && partialContext.storeObject || object;
        var context = tslib.__assign(tslib.__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
          var options = normalizeReadFieldOptions2(arguments, storeObject);
          return policies.readField(options, {
            store: policies.cache["data"],
            variables: options.variables
          });
        } });
        var id;
        var policy = typename && this.getTypePolicy(typename);
        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
        while (keyFn) {
          var specifierOrId = keyFn(tslib.__assign(tslib.__assign({}, object), storeObject), context);
          if (utilities.isArray(specifierOrId)) {
            keyFn = keyFieldsFnFromSpecifier2(specifierOrId);
          } else {
            id = specifierOrId;
            break;
          }
        }
        id = id ? String(id) : void 0;
        return context.keyObject ? [id, context.keyObject] : [id];
      };
      Policies3.prototype.addTypePolicies = function(typePolicies) {
        var _this = this;
        Object.keys(typePolicies).forEach(function(typename) {
          var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = tslib.__rest(_a2, ["queryType", "mutationType", "subscriptionType"]);
          if (queryType)
            _this.setRootTypename("Query", typename);
          if (mutationType)
            _this.setRootTypename("Mutation", typename);
          if (subscriptionType)
            _this.setRootTypename("Subscription", typename);
          if (hasOwn2.call(_this.toBeAdded, typename)) {
            _this.toBeAdded[typename].push(incoming);
          } else {
            _this.toBeAdded[typename] = [incoming];
          }
        });
      };
      Policies3.prototype.updateTypePolicy = function(typename, incoming) {
        var _this = this;
        var existing = this.getTypePolicy(typename);
        var keyFields = incoming.keyFields, fields = incoming.fields;
        function setMerge(existing2, merge) {
          existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn2 : merge === false ? mergeFalseFn2 : existing2.merge;
        }
        setMerge(existing, incoming.merge);
        existing.keyFn = keyFields === false ? nullKeyFieldsFn2 : utilities.isArray(keyFields) ? keyFieldsFnFromSpecifier2(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
        if (fields) {
          Object.keys(fields).forEach(function(fieldName) {
            var existing2 = _this.getFieldPolicy(typename, fieldName, true);
            var incoming2 = fields[fieldName];
            if (typeof incoming2 === "function") {
              existing2.read = incoming2;
            } else {
              var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;
              existing2.keyFn = keyArgs === false ? simpleKeyArgsFn2 : utilities.isArray(keyArgs) ? keyArgsFnFromSpecifier2(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
              if (typeof read === "function") {
                existing2.read = read;
              }
              setMerge(existing2, merge);
            }
            if (existing2.read && existing2.merge) {
              existing2.keyFn = existing2.keyFn || simpleKeyArgsFn2;
            }
          });
        }
      };
      Policies3.prototype.setRootTypename = function(which, typename) {
        if (typename === void 0) {
          typename = which;
        }
        var rootId = "ROOT_" + which.toUpperCase();
        var old = this.rootTypenamesById[rootId];
        if (typename !== old) {
          globals.invariant(!old || old === which, 5, which);
          if (old)
            delete this.rootIdsByTypename[old];
          this.rootIdsByTypename[typename] = rootId;
          this.rootTypenamesById[rootId] = typename;
        }
      };
      Policies3.prototype.addPossibleTypes = function(possibleTypes) {
        var _this = this;
        this.usingPossibleTypes = true;
        Object.keys(possibleTypes).forEach(function(supertype) {
          _this.getSupertypeSet(supertype, true);
          possibleTypes[supertype].forEach(function(subtype) {
            _this.getSupertypeSet(subtype, true).add(supertype);
            var match = subtype.match(TypeOrFieldNameRegExp2);
            if (!match || match[0] !== subtype) {
              _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
            }
          });
        });
      };
      Policies3.prototype.getTypePolicy = function(typename) {
        var _this = this;
        if (!hasOwn2.call(this.typePolicies, typename)) {
          var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
          policy_1.fields = /* @__PURE__ */ Object.create(null);
          var supertypes_1 = this.supertypeMap.get(typename);
          if (!supertypes_1 && this.fuzzySubtypes.size) {
            supertypes_1 = this.getSupertypeSet(typename, true);
            this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
              if (regExp.test(typename)) {
                var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
                if (fuzzySupertypes) {
                  fuzzySupertypes.forEach(function(supertype) {
                    return supertypes_1.add(supertype);
                  });
                }
              }
            });
          }
          if (supertypes_1 && supertypes_1.size) {
            supertypes_1.forEach(function(supertype) {
              var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = tslib.__rest(_a2, ["fields"]);
              Object.assign(policy_1, rest);
              Object.assign(policy_1.fields, fields);
            });
          }
        }
        var inbox = this.toBeAdded[typename];
        if (inbox && inbox.length) {
          inbox.splice(0).forEach(function(policy) {
            _this.updateTypePolicy(typename, policy);
          });
        }
        return this.typePolicies[typename];
      };
      Policies3.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
        if (typename) {
          var fieldPolicies = this.getTypePolicy(typename).fields;
          return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
        }
      };
      Policies3.prototype.getSupertypeSet = function(subtype, createIfMissing) {
        var supertypeSet = this.supertypeMap.get(subtype);
        if (!supertypeSet && createIfMissing) {
          this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
        }
        return supertypeSet;
      };
      Policies3.prototype.fragmentMatches = function(fragment, typename, result2, variables) {
        var _this = this;
        if (!fragment.typeCondition)
          return true;
        if (!typename)
          return false;
        var supertype = fragment.typeCondition.name.value;
        if (typename === supertype)
          return true;
        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
          var typenameSupertypeSet = this.getSupertypeSet(typename, true);
          var workQueue_1 = [typenameSupertypeSet];
          var maybeEnqueue_1 = function(subtype) {
            var supertypeSet2 = _this.getSupertypeSet(subtype, false);
            if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
              workQueue_1.push(supertypeSet2);
            }
          };
          var needToCheckFuzzySubtypes = !!(result2 && this.fuzzySubtypes.size);
          var checkingFuzzySubtypes = false;
          for (var i = 0; i < workQueue_1.length; ++i) {
            var supertypeSet = workQueue_1[i];
            if (supertypeSet.has(supertype)) {
              if (!typenameSupertypeSet.has(supertype)) {
                if (checkingFuzzySubtypes) {
                  globalThis.__DEV__ !== false && globals.invariant.warn(6, typename, supertype);
                }
                typenameSupertypeSet.add(supertype);
              }
              return true;
            }
            supertypeSet.forEach(maybeEnqueue_1);
            if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult2(fragment.selectionSet, result2, variables)) {
              needToCheckFuzzySubtypes = false;
              checkingFuzzySubtypes = true;
              this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
                var match = typename.match(regExp);
                if (match && match[0] === typename) {
                  maybeEnqueue_1(fuzzyString);
                }
              });
            }
          }
        }
        return false;
      };
      Policies3.prototype.hasKeyArgs = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return !!(policy && policy.keyFn);
      };
      Policies3.prototype.getStoreFieldName = function(fieldSpec) {
        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
        var policy = this.getFieldPolicy(typename, fieldName, false);
        var storeFieldName;
        var keyFn = policy && policy.keyFn;
        if (keyFn && typename) {
          var context = {
            typename,
            fieldName,
            field: fieldSpec.field || null,
            variables: fieldSpec.variables
          };
          var args = argsFromFieldSpecifier2(fieldSpec);
          while (keyFn) {
            var specifierOrString = keyFn(args, context);
            if (utilities.isArray(specifierOrString)) {
              keyFn = keyArgsFnFromSpecifier2(specifierOrString);
            } else {
              storeFieldName = specifierOrString || fieldName;
              break;
            }
          }
        }
        if (storeFieldName === void 0) {
          storeFieldName = fieldSpec.field ? utilities.storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : utilities.getStoreKeyName(fieldName, argsFromFieldSpecifier2(fieldSpec));
        }
        if (storeFieldName === false) {
          return fieldName;
        }
        return fieldName === fieldNameFromStoreName2(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
      };
      Policies3.prototype.readField = function(options, context) {
        var objectOrReference = options.from;
        if (!objectOrReference)
          return;
        var nameOrField = options.field || options.fieldName;
        if (!nameOrField)
          return;
        if (options.typename === void 0) {
          var typename = context.store.getFieldValue(objectOrReference, "__typename");
          if (typename)
            options.typename = typename;
        }
        var storeFieldName = this.getStoreFieldName(options);
        var fieldName = fieldNameFromStoreName2(storeFieldName);
        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
        var policy = this.getFieldPolicy(options.typename, fieldName, false);
        var read = policy && policy.read;
        if (read) {
          var readOptions = makeFieldFunctionOptions2(this, objectOrReference, options, context, context.store.getStorage(utilities.isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
          return cacheSlot2.withValue(this.cache, read, [
            existing,
            readOptions
          ]);
        }
        return existing;
      };
      Policies3.prototype.getReadFunction = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return policy && policy.read;
      };
      Policies3.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
        var policy = this.getFieldPolicy(parentTypename, fieldName, false);
        var merge = policy && policy.merge;
        if (!merge && childTypename) {
          policy = this.getTypePolicy(childTypename);
          merge = policy && policy.merge;
        }
        return merge;
      };
      Policies3.prototype.runMergeFunction = function(existing, incoming, _a2, context, storage) {
        var field = _a2.field, typename = _a2.typename, merge = _a2.merge;
        if (merge === mergeTrueFn2) {
          return makeMergeObjectsFunction2(context.store)(existing, incoming);
        }
        if (merge === mergeFalseFn2) {
          return incoming;
        }
        if (context.overwrite) {
          existing = void 0;
        }
        return merge(existing, incoming, makeFieldFunctionOptions2(
          this,
          void 0,
          {
            typename,
            fieldName: field.name.value,
            field,
            variables: context.variables
          },
          context,
          storage || /* @__PURE__ */ Object.create(null)
        ));
      };
      return Policies3;
    }();
    function makeFieldFunctionOptions2(policies, objectOrReference, fieldSpec, context, storage) {
      var storeFieldName = policies.getStoreFieldName(fieldSpec);
      var fieldName = fieldNameFromStoreName2(storeFieldName);
      var variables = fieldSpec.variables || context.variables;
      var _a2 = context.store, toReference = _a2.toReference, canRead = _a2.canRead;
      return {
        args: argsFromFieldSpecifier2(fieldSpec),
        field: fieldSpec.field || null,
        fieldName,
        storeFieldName,
        variables,
        isReference: utilities.isReference,
        toReference,
        storage,
        cache: policies.cache,
        canRead,
        readField: function() {
          return policies.readField(normalizeReadFieldOptions2(arguments, objectOrReference, variables), context);
        },
        mergeObjects: makeMergeObjectsFunction2(context.store)
      };
    }
    function normalizeReadFieldOptions2(readFieldArgs, objectOrReference, variables) {
      var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
      var options;
      if (typeof fieldNameOrOptions === "string") {
        options = {
          fieldName: fieldNameOrOptions,
          from: argc > 1 ? from2 : objectOrReference
        };
      } else {
        options = tslib.__assign({}, fieldNameOrOptions);
        if (!hasOwn2.call(options, "from")) {
          options.from = objectOrReference;
        }
      }
      if (globalThis.__DEV__ !== false && options.from === void 0) {
        globalThis.__DEV__ !== false && globals.invariant.warn(7, utilities.stringifyForDisplay(Array.from(readFieldArgs)));
      }
      if (void 0 === options.variables) {
        options.variables = variables;
      }
      return options;
    }
    function makeMergeObjectsFunction2(store) {
      return function mergeObjects(existing, incoming) {
        if (utilities.isArray(existing) || utilities.isArray(incoming)) {
          throw globals.newInvariantError(8);
        }
        if (utilities.isNonNullObject(existing) && utilities.isNonNullObject(incoming)) {
          var eType = store.getFieldValue(existing, "__typename");
          var iType = store.getFieldValue(incoming, "__typename");
          var typesDiffer = eType && iType && eType !== iType;
          if (typesDiffer) {
            return incoming;
          }
          if (utilities.isReference(existing) && storeValueIsStoreObject2(incoming)) {
            store.merge(existing.__ref, incoming);
            return existing;
          }
          if (storeValueIsStoreObject2(existing) && utilities.isReference(incoming)) {
            store.merge(existing, incoming.__ref);
            return incoming;
          }
          if (storeValueIsStoreObject2(existing) && storeValueIsStoreObject2(incoming)) {
            return tslib.__assign(tslib.__assign({}, existing), incoming);
          }
        }
        return incoming;
      };
    }
    function getContextFlavor2(context, clientOnly, deferred) {
      var key = "".concat(clientOnly).concat(deferred);
      var flavored = context.flavors.get(key);
      if (!flavored) {
        context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : tslib.__assign(tslib.__assign({}, context), { clientOnly, deferred }));
      }
      return flavored;
    }
    var StoreWriter2 = function() {
      function StoreWriter3(cache2, reader, fragments) {
        this.cache = cache2;
        this.reader = reader;
        this.fragments = fragments;
      }
      StoreWriter3.prototype.writeToStore = function(store, _a2) {
        var _this = this;
        var query = _a2.query, result2 = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
        var operationDefinition = utilities.getOperationDefinition(query);
        var merger = makeProcessedFieldsMerger2();
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(operationDefinition)), variables);
        var context = tslib.__assign(tslib.__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
          return merger.merge(existing, incoming);
        }, variables, varString: utilities.canonicalStringify(variables) }, extractFragmentContext2(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
        var ref = this.processSelectionSet({
          result: result2 || /* @__PURE__ */ Object.create(null),
          dataId,
          selectionSet: operationDefinition.selectionSet,
          mergeTree: { map: /* @__PURE__ */ new Map() },
          context
        });
        if (!utilities.isReference(ref)) {
          throw globals.newInvariantError(11, result2);
        }
        context.incomingById.forEach(function(_a3, dataId2) {
          var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
          var entityRef = utilities.makeReference(dataId2);
          if (mergeTree && mergeTree.map.size) {
            var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
            if (utilities.isReference(applied)) {
              return;
            }
            storeObject = applied;
          }
          if (globalThis.__DEV__ !== false && !context.overwrite) {
            var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
            fieldNodeSet.forEach(function(field) {
              if (field.selectionSet) {
                fieldsWithSelectionSets_1[field.name.value] = true;
              }
            });
            var hasSelectionSet_1 = function(storeFieldName) {
              return fieldsWithSelectionSets_1[fieldNameFromStoreName2(storeFieldName)] === true;
            };
            var hasMergeFunction_1 = function(storeFieldName) {
              var childTree = mergeTree && mergeTree.map.get(storeFieldName);
              return Boolean(childTree && childTree.info && childTree.info.merge);
            };
            Object.keys(storeObject).forEach(function(storeFieldName) {
              if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
                warnAboutDataLoss2(entityRef, storeObject, storeFieldName, context.store);
              }
            });
          }
          store.merge(dataId2, storeObject);
        });
        store.retain(ref.__ref);
        return ref;
      };
      StoreWriter3.prototype.processSelectionSet = function(_a2) {
        var _this = this;
        var dataId = _a2.dataId, result2 = _a2.result, selectionSet = _a2.selectionSet, context = _a2.context, mergeTree = _a2.mergeTree;
        var policies = this.cache.policies;
        var incoming = /* @__PURE__ */ Object.create(null);
        var typename = dataId && policies.rootTypenamesById[dataId] || utilities.getTypenameFromResult(result2, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
        if ("string" === typeof typename) {
          incoming.__typename = typename;
        }
        var readField = function() {
          var options = normalizeReadFieldOptions2(arguments, incoming, context.variables);
          if (utilities.isReference(options.from)) {
            var info = context.incomingById.get(options.from.__ref);
            if (info) {
              var result_1 = policies.readField(tslib.__assign(tslib.__assign({}, options), { from: info.storeObject }), context);
              if (result_1 !== void 0) {
                return result_1;
              }
            }
          }
          return policies.readField(options, context);
        };
        var fieldNodeSet = /* @__PURE__ */ new Set();
        this.flattenFields(
          selectionSet,
          result2,
          context,
          typename
        ).forEach(function(context2, field) {
          var _a3;
          var resultFieldKey = utilities.resultKeyNameFromField(field);
          var value = result2[resultFieldKey];
          fieldNodeSet.add(field);
          if (value !== void 0) {
            var storeFieldName = policies.getStoreFieldName({
              typename,
              fieldName: field.name.value,
              field,
              variables: context2.variables
            });
            var childTree = getChildMergeTree2(mergeTree, storeFieldName);
            var incomingValue = _this.processFieldValue(
              value,
              field,
              field.selectionSet ? getContextFlavor2(context2, false, false) : context2,
              childTree
            );
            var childTypename = void 0;
            if (field.selectionSet && (utilities.isReference(incomingValue) || storeValueIsStoreObject2(incomingValue))) {
              childTypename = readField("__typename", incomingValue);
            }
            var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
            if (merge) {
              childTree.info = {
                field,
                typename,
                merge
              };
            } else {
              maybeRecycleChildMergeTree2(mergeTree, storeFieldName);
            }
            incoming = context2.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
          } else if (globalThis.__DEV__ !== false && !context2.clientOnly && !context2.deferred && !utilities.addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {
            globalThis.__DEV__ !== false && globals.invariant.error(12, utilities.resultKeyNameFromField(field), result2);
          }
        });
        try {
          var _b = policies.identify(result2, {
            typename,
            selectionSet,
            fragmentMap: context.fragmentMap,
            storeObject: incoming,
            readField
          }), id = _b[0], keyObject = _b[1];
          dataId = dataId || id;
          if (keyObject) {
            incoming = context.merge(incoming, keyObject);
          }
        } catch (e) {
          if (!dataId)
            throw e;
        }
        if ("string" === typeof dataId) {
          var dataRef = utilities.makeReference(dataId);
          var sets = context.written[dataId] || (context.written[dataId] = []);
          if (sets.indexOf(selectionSet) >= 0)
            return dataRef;
          sets.push(selectionSet);
          if (this.reader && this.reader.isFresh(result2, dataRef, selectionSet, context)) {
            return dataRef;
          }
          var previous_1 = context.incomingById.get(dataId);
          if (previous_1) {
            previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
            previous_1.mergeTree = mergeMergeTrees2(previous_1.mergeTree, mergeTree);
            fieldNodeSet.forEach(function(field) {
              return previous_1.fieldNodeSet.add(field);
            });
          } else {
            context.incomingById.set(dataId, {
              storeObject: incoming,
              mergeTree: mergeTreeIsEmpty2(mergeTree) ? void 0 : mergeTree,
              fieldNodeSet
            });
          }
          return dataRef;
        }
        return incoming;
      };
      StoreWriter3.prototype.processFieldValue = function(value, field, context, mergeTree) {
        var _this = this;
        if (!field.selectionSet || value === null) {
          return globalThis.__DEV__ !== false ? utilities.cloneDeep(value) : value;
        }
        if (utilities.isArray(value)) {
          return value.map(function(item, i) {
            var value2 = _this.processFieldValue(item, field, context, getChildMergeTree2(mergeTree, i));
            maybeRecycleChildMergeTree2(mergeTree, i);
            return value2;
          });
        }
        return this.processSelectionSet({
          result: value,
          selectionSet: field.selectionSet,
          context,
          mergeTree
        });
      };
      StoreWriter3.prototype.flattenFields = function(selectionSet, result2, context, typename) {
        if (typename === void 0) {
          typename = utilities.getTypenameFromResult(result2, selectionSet, context.fragmentMap);
        }
        var fieldMap = /* @__PURE__ */ new Map();
        var policies = this.cache.policies;
        var limitingTrie = new trie.Trie(false);
        (function flatten(selectionSet2, inheritedContext) {
          var visitedNode = limitingTrie.lookup(
            selectionSet2,
            inheritedContext.clientOnly,
            inheritedContext.deferred
          );
          if (visitedNode.visited)
            return;
          visitedNode.visited = true;
          selectionSet2.selections.forEach(function(selection) {
            if (!utilities.shouldInclude(selection, context.variables))
              return;
            var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
            if (!(clientOnly && deferred) && utilities.isNonEmptyArray(selection.directives)) {
              selection.directives.forEach(function(dir) {
                var name = dir.name.value;
                if (name === "client")
                  clientOnly = true;
                if (name === "defer") {
                  var args = utilities.argumentsObjectFromField(dir, context.variables);
                  if (!args || args.if !== false) {
                    deferred = true;
                  }
                }
              });
            }
            if (utilities.isField(selection)) {
              var existing = fieldMap.get(selection);
              if (existing) {
                clientOnly = clientOnly && existing.clientOnly;
                deferred = deferred && existing.deferred;
              }
              fieldMap.set(selection, getContextFlavor2(context, clientOnly, deferred));
            } else {
              var fragment = utilities.getFragmentFromSelection(selection, context.lookupFragment);
              if (!fragment && selection.kind === graphql.Kind.FRAGMENT_SPREAD) {
                throw globals.newInvariantError(13, selection.name.value);
              }
              if (fragment && policies.fragmentMatches(fragment, typename, result2, context.variables)) {
                flatten(fragment.selectionSet, getContextFlavor2(context, clientOnly, deferred));
              }
            }
          });
        })(selectionSet, context);
        return fieldMap;
      };
      StoreWriter3.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
        var _a2;
        var _this = this;
        if (mergeTree.map.size && !utilities.isReference(incoming)) {
          var e_1 = !utilities.isArray(incoming) && (utilities.isReference(existing) || storeValueIsStoreObject2(existing)) ? existing : void 0;
          var i_1 = incoming;
          if (e_1 && !getStorageArgs) {
            getStorageArgs = [utilities.isReference(e_1) ? e_1.__ref : e_1];
          }
          var changedFields_1;
          var getValue_1 = function(from2, name) {
            return utilities.isArray(from2) ? typeof name === "number" ? from2[name] : void 0 : context.store.getFieldValue(from2, String(name));
          };
          mergeTree.map.forEach(function(childTree, storeFieldName) {
            var eVal = getValue_1(e_1, storeFieldName);
            var iVal = getValue_1(i_1, storeFieldName);
            if (void 0 === iVal)
              return;
            if (getStorageArgs) {
              getStorageArgs.push(storeFieldName);
            }
            var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
            if (aVal !== iVal) {
              changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
              changedFields_1.set(storeFieldName, aVal);
            }
            if (getStorageArgs) {
              globals.invariant(getStorageArgs.pop() === storeFieldName);
            }
          });
          if (changedFields_1) {
            incoming = utilities.isArray(i_1) ? i_1.slice(0) : tslib.__assign({}, i_1);
            changedFields_1.forEach(function(value, name) {
              incoming[name] = value;
            });
          }
        }
        if (mergeTree.info) {
          return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a2 = context.store).getStorage.apply(_a2, getStorageArgs));
        }
        return incoming;
      };
      return StoreWriter3;
    }();
    var emptyMergeTreePool2 = [];
    function getChildMergeTree2(_a2, name) {
      var map = _a2.map;
      if (!map.has(name)) {
        map.set(name, emptyMergeTreePool2.pop() || { map: /* @__PURE__ */ new Map() });
      }
      return map.get(name);
    }
    function mergeMergeTrees2(left, right) {
      if (left === right || !right || mergeTreeIsEmpty2(right))
        return left;
      if (!left || mergeTreeIsEmpty2(left))
        return right;
      var info = left.info && right.info ? tslib.__assign(tslib.__assign({}, left.info), right.info) : left.info || right.info;
      var needToMergeMaps = left.map.size && right.map.size;
      var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
      var merged = { info, map };
      if (needToMergeMaps) {
        var remainingRightKeys_1 = new Set(right.map.keys());
        left.map.forEach(function(leftTree, key) {
          merged.map.set(key, mergeMergeTrees2(leftTree, right.map.get(key)));
          remainingRightKeys_1.delete(key);
        });
        remainingRightKeys_1.forEach(function(key) {
          merged.map.set(key, mergeMergeTrees2(right.map.get(key), left.map.get(key)));
        });
      }
      return merged;
    }
    function mergeTreeIsEmpty2(tree) {
      return !tree || !(tree.info || tree.map.size);
    }
    function maybeRecycleChildMergeTree2(_a2, name) {
      var map = _a2.map;
      var childTree = map.get(name);
      if (childTree && mergeTreeIsEmpty2(childTree)) {
        emptyMergeTreePool2.push(childTree);
        map.delete(name);
      }
    }
    var warnings2 = /* @__PURE__ */ new Set();
    function warnAboutDataLoss2(existingRef, incomingObj, storeFieldName, store) {
      var getChild = function(objOrRef) {
        var child = store.getFieldValue(objOrRef, storeFieldName);
        return typeof child === "object" && child;
      };
      var existing = getChild(existingRef);
      if (!existing)
        return;
      var incoming = getChild(incomingObj);
      if (!incoming)
        return;
      if (utilities.isReference(existing))
        return;
      if (equal2.equal(existing, incoming))
        return;
      if (Object.keys(existing).every(function(key) {
        return store.getFieldValue(incoming, key) !== void 0;
      })) {
        return;
      }
      var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
      var fieldName = fieldNameFromStoreName2(storeFieldName);
      var typeDotName = "".concat(parentType, ".").concat(fieldName);
      if (warnings2.has(typeDotName))
        return;
      warnings2.add(typeDotName);
      var childTypenames = [];
      if (!utilities.isArray(existing) && !utilities.isArray(incoming)) {
        [existing, incoming].forEach(function(child) {
          var typename = store.getFieldValue(child, "__typename");
          if (typeof typename === "string" && !childTypenames.includes(typename)) {
            childTypenames.push(typename);
          }
        });
      }
      globalThis.__DEV__ !== false && globals.invariant.warn(14, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, tslib.__assign({}, existing), tslib.__assign({}, incoming));
    }
    var InMemoryCache2 = function(_super) {
      tslib.__extends(InMemoryCache3, _super);
      function InMemoryCache3(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this) || this;
        _this.watches = /* @__PURE__ */ new Set();
        _this.addTypenameTransform = new utilities.DocumentTransform(utilities.addTypenameToDocument);
        _this.assumeImmutableResults = true;
        _this.makeVar = makeVar2;
        _this.txCount = 0;
        _this.config = normalizeConfig2(config);
        _this.addTypename = !!_this.config.addTypename;
        _this.policies = new Policies2({
          cache: _this,
          dataIdFromObject: _this.config.dataIdFromObject,
          possibleTypes: _this.config.possibleTypes,
          typePolicies: _this.config.typePolicies
        });
        _this.init();
        return _this;
      }
      InMemoryCache3.prototype.init = function() {
        var rootStore = this.data = new exports.EntityStore.Root({
          policies: this.policies,
          resultCaching: this.config.resultCaching
        });
        this.optimisticData = rootStore.stump;
        this.resetResultCache();
      };
      InMemoryCache3.prototype.resetResultCache = function(resetResultIdentities) {
        var _this = this;
        var previousReader = this.storeReader;
        var fragments = this.config.fragments;
        this.storeWriter = new StoreWriter2(this, this.storeReader = new StoreReader2({
          cache: this,
          addTypename: this.addTypename,
          resultCacheMaxSize: this.config.resultCacheMaxSize,
          canonizeResults: shouldCanonizeResults2(this.config),
          canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
          fragments
        }), fragments);
        this.maybeBroadcastWatch = optimism.wrap(function(c, options) {
          return _this.broadcastWatch(c, options);
        }, {
          max: this.config.resultCacheMaxSize || utilities.cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
          makeCacheKey: function(c) {
            var store = c.optimistic ? _this.optimisticData : _this.data;
            if (supportsResultCaching2(store)) {
              var optimistic = c.optimistic, id = c.id, variables = c.variables;
              return store.makeCacheKey(
                c.query,
                c.callback,
                utilities.canonicalStringify({ optimistic, id, variables })
              );
            }
          }
        });
        (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
          return group.resetCaching();
        });
      };
      InMemoryCache3.prototype.restore = function(data) {
        this.init();
        if (data)
          this.data.replace(data);
        return this;
      };
      InMemoryCache3.prototype.extract = function(optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return (optimistic ? this.optimisticData : this.data).extract();
      };
      InMemoryCache3.prototype.read = function(options) {
        var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
        try {
          return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
        } catch (e) {
          if (e instanceof MissingFieldError2) {
            return null;
          }
          throw e;
        }
      };
      InMemoryCache3.prototype.write = function(options) {
        try {
          ++this.txCount;
          return this.storeWriter.writeToStore(this.data, options);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache3.prototype.modify = function(options) {
        if (hasOwn2.call(options, "id") && !options.id) {
          return false;
        }
        var store = options.optimistic ? this.optimisticData : this.data;
        try {
          ++this.txCount;
          return store.modify(options.id || "ROOT_QUERY", options.fields);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache3.prototype.diff = function(options) {
        return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
      };
      InMemoryCache3.prototype.watch = function(watch) {
        var _this = this;
        if (!this.watches.size) {
          recallCache2(this);
        }
        this.watches.add(watch);
        if (watch.immediate) {
          this.maybeBroadcastWatch(watch);
        }
        return function() {
          if (_this.watches.delete(watch) && !_this.watches.size) {
            forgetCache2(_this);
          }
          _this.maybeBroadcastWatch.forget(watch);
        };
      };
      InMemoryCache3.prototype.gc = function(options) {
        var _a2;
        utilities.canonicalStringify.reset();
        utilities.print.reset();
        this.addTypenameTransform.resetCache();
        (_a2 = this.config.fragments) === null || _a2 === void 0 ? void 0 : _a2.resetCaches();
        var ids = this.optimisticData.gc();
        if (options && !this.txCount) {
          if (options.resetResultCache) {
            this.resetResultCache(options.resetResultIdentities);
          } else if (options.resetResultIdentities) {
            this.storeReader.resetCanon();
          }
        }
        return ids;
      };
      InMemoryCache3.prototype.retain = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).retain(rootId);
      };
      InMemoryCache3.prototype.release = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).release(rootId);
      };
      InMemoryCache3.prototype.identify = function(object) {
        if (utilities.isReference(object))
          return object.__ref;
        try {
          return this.policies.identify(object)[0];
        } catch (e) {
          globalThis.__DEV__ !== false && globals.invariant.warn(e);
        }
      };
      InMemoryCache3.prototype.evict = function(options) {
        if (!options.id) {
          if (hasOwn2.call(options, "id")) {
            return false;
          }
          options = tslib.__assign(tslib.__assign({}, options), { id: "ROOT_QUERY" });
        }
        try {
          ++this.txCount;
          return this.optimisticData.evict(options, this.data);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache3.prototype.reset = function(options) {
        var _this = this;
        this.init();
        utilities.canonicalStringify.reset();
        if (options && options.discardWatches) {
          this.watches.forEach(function(watch) {
            return _this.maybeBroadcastWatch.forget(watch);
          });
          this.watches.clear();
          forgetCache2(this);
        } else {
          this.broadcastWatches();
        }
        return Promise.resolve();
      };
      InMemoryCache3.prototype.removeOptimistic = function(idToRemove) {
        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
        if (newOptimisticData !== this.optimisticData) {
          this.optimisticData = newOptimisticData;
          this.broadcastWatches();
        }
      };
      InMemoryCache3.prototype.batch = function(options) {
        var _this = this;
        var update = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
        var updateResult;
        var perform = function(layer) {
          var _a3 = _this, data = _a3.data, optimisticData = _a3.optimisticData;
          ++_this.txCount;
          if (layer) {
            _this.data = _this.optimisticData = layer;
          }
          try {
            return updateResult = update(_this);
          } finally {
            --_this.txCount;
            _this.data = data;
            _this.optimisticData = optimisticData;
          }
        };
        var alreadyDirty = /* @__PURE__ */ new Set();
        if (onWatchUpdated && !this.txCount) {
          this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function(watch) {
            alreadyDirty.add(watch);
            return false;
          } }));
        }
        if (typeof optimistic === "string") {
          this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
        } else if (optimistic === false) {
          perform(this.data);
        } else {
          perform();
        }
        if (typeof removeOptimistic === "string") {
          this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
        }
        if (onWatchUpdated && alreadyDirty.size) {
          this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function(watch, diff) {
            var result2 = onWatchUpdated.call(this, watch, diff);
            if (result2 !== false) {
              alreadyDirty.delete(watch);
            }
            return result2;
          } }));
          if (alreadyDirty.size) {
            alreadyDirty.forEach(function(watch) {
              return _this.maybeBroadcastWatch.dirty(watch);
            });
          }
        } else {
          this.broadcastWatches(options);
        }
        return updateResult;
      };
      InMemoryCache3.prototype.performTransaction = function(update, optimisticId) {
        return this.batch({
          update,
          optimistic: optimisticId || optimisticId !== null
        });
      };
      InMemoryCache3.prototype.transformDocument = function(document) {
        return this.addTypenameToDocument(this.addFragmentsToDocument(document));
      };
      InMemoryCache3.prototype.broadcastWatches = function(options) {
        var _this = this;
        if (!this.txCount) {
          this.watches.forEach(function(c) {
            return _this.maybeBroadcastWatch(c, options);
          });
        }
      };
      InMemoryCache3.prototype.addFragmentsToDocument = function(document) {
        var fragments = this.config.fragments;
        return fragments ? fragments.transform(document) : document;
      };
      InMemoryCache3.prototype.addTypenameToDocument = function(document) {
        if (this.addTypename) {
          return this.addTypenameTransform.transformDocument(document);
        }
        return document;
      };
      InMemoryCache3.prototype.broadcastWatch = function(c, options) {
        var lastDiff = c.lastDiff;
        var diff = this.diff(c);
        if (options) {
          if (c.optimistic && typeof options.optimistic === "string") {
            diff.fromOptimisticTransaction = true;
          }
          if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
            return;
          }
        }
        if (!lastDiff || !equal2.equal(lastDiff.result, diff.result)) {
          c.callback(c.lastDiff = diff, lastDiff);
        }
      };
      return InMemoryCache3;
    }(ApolloCache2);
    if (globalThis.__DEV__ !== false) {
      InMemoryCache2.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals2;
    }
    function createFragmentRegistry3() {
      var fragments = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fragments[_i] = arguments[_i];
      }
      return new (FragmentRegistry2.bind.apply(FragmentRegistry2, tslib.__spreadArray([void 0], fragments, false)))();
    }
    var FragmentRegistry2 = function() {
      function FragmentRegistry3() {
        var fragments = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fragments[_i] = arguments[_i];
        }
        this.registry = /* @__PURE__ */ Object.create(null);
        this.resetCaches();
        if (fragments.length) {
          this.register.apply(this, fragments);
        }
      }
      FragmentRegistry3.prototype.register = function() {
        var _this = this;
        var fragments = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fragments[_i] = arguments[_i];
        }
        var definitions = /* @__PURE__ */ new Map();
        fragments.forEach(function(doc) {
          utilities.getFragmentDefinitions(doc).forEach(function(node) {
            definitions.set(node.name.value, node);
          });
        });
        definitions.forEach(function(node, name) {
          if (node !== _this.registry[name]) {
            _this.registry[name] = node;
            _this.invalidate(name);
          }
        });
        return this;
      };
      FragmentRegistry3.prototype.invalidate = function(name) {
      };
      FragmentRegistry3.prototype.resetCaches = function() {
        var proto = FragmentRegistry3.prototype;
        this.invalidate = (this.lookup = optimism.wrap(proto.lookup.bind(this), {
          makeCacheKey: function(arg) {
            return arg;
          },
          max: utilities.cacheSizes["fragmentRegistry.lookup"] || 1e3
        })).dirty;
        this.transform = optimism.wrap(proto.transform.bind(this), {
          cache: caches2.WeakCache,
          max: utilities.cacheSizes["fragmentRegistry.transform"] || 2e3
        });
        this.findFragmentSpreads = optimism.wrap(proto.findFragmentSpreads.bind(this), {
          cache: caches2.WeakCache,
          max: utilities.cacheSizes["fragmentRegistry.findFragmentSpreads"] || 4e3
        });
      };
      FragmentRegistry3.prototype.lookup = function(fragmentName) {
        return this.registry[fragmentName] || null;
      };
      FragmentRegistry3.prototype.transform = function(document) {
        var _this = this;
        var defined = /* @__PURE__ */ new Map();
        utilities.getFragmentDefinitions(document).forEach(function(def) {
          defined.set(def.name.value, def);
        });
        var unbound = /* @__PURE__ */ new Set();
        var enqueue2 = function(spreadName) {
          if (!defined.has(spreadName)) {
            unbound.add(spreadName);
          }
        };
        var enqueueChildSpreads = function(node) {
          return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue2);
        };
        enqueueChildSpreads(document);
        var missing = [];
        var map = /* @__PURE__ */ Object.create(null);
        unbound.forEach(function(fragmentName) {
          var knownFragmentDef = defined.get(fragmentName);
          if (knownFragmentDef) {
            enqueueChildSpreads(map[fragmentName] = knownFragmentDef);
          } else {
            missing.push(fragmentName);
            var def = _this.lookup(fragmentName);
            if (def) {
              enqueueChildSpreads(map[fragmentName] = def);
            }
          }
        });
        if (missing.length) {
          var defsToAppend_1 = [];
          missing.forEach(function(name) {
            var def = map[name];
            if (def) {
              defsToAppend_1.push(def);
            }
          });
          if (defsToAppend_1.length) {
            document = tslib.__assign(tslib.__assign({}, document), { definitions: document.definitions.concat(defsToAppend_1) });
          }
        }
        return document;
      };
      FragmentRegistry3.prototype.findFragmentSpreads = function(root2) {
        var spreads = /* @__PURE__ */ Object.create(null);
        graphql.visit(root2, {
          FragmentSpread: function(node) {
            spreads[node.name.value] = node;
          }
        });
        return spreads;
      };
      return FragmentRegistry3;
    }();
    exports.canonicalStringify = utilities.canonicalStringify;
    exports.isReference = utilities.isReference;
    exports.makeReference = utilities.makeReference;
    exports.ApolloCache = ApolloCache2;
    exports.InMemoryCache = InMemoryCache2;
    exports.MissingFieldError = MissingFieldError2;
    exports.Policies = Policies2;
    exports.cacheSlot = cacheSlot2;
    exports.createFragmentRegistry = createFragmentRegistry3;
    exports.defaultDataIdFromObject = defaultDataIdFromObject2;
    exports.fieldNameFromStoreName = fieldNameFromStoreName2;
    exports.makeVar = makeVar2;
  }
});

// ../node_modules/@apollo/client/link/utils/utils.cjs
var require_utils = __commonJS({
  "../node_modules/@apollo/client/link/utils/utils.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var utilities = require_utilities();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var graphql = (init_graphql(), __toCommonJS(graphql_exports));
    function fromError2(errorValue) {
      return new utilities.Observable(function(observer) {
        observer.error(errorValue);
      });
    }
    function toPromise2(observable) {
      var completed = false;
      return new Promise(function(resolve, reject) {
        observable.subscribe({
          next: function(data) {
            if (completed) {
              globalThis.__DEV__ !== false && globals.invariant.warn(42);
            } else {
              completed = true;
              resolve(data);
            }
          },
          error: reject
        });
      });
    }
    function fromPromise2(promise) {
      return new utilities.Observable(function(observer) {
        promise.then(function(value) {
          observer.next(value);
          observer.complete();
        }).catch(observer.error.bind(observer));
      });
    }
    var throwServerError2 = function(response, result2, message) {
      var error = new Error(message);
      error.name = "ServerError";
      error.response = response;
      error.statusCode = response.status;
      error.result = result2;
      throw error;
    };
    function validateOperation2(operation) {
      var OPERATION_FIELDS = [
        "query",
        "operationName",
        "variables",
        "extensions",
        "context"
      ];
      for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
        var key = _a2[_i];
        if (OPERATION_FIELDS.indexOf(key) < 0) {
          throw globals.newInvariantError(43, key);
        }
      }
      return operation;
    }
    function createOperation2(starting, operation) {
      var context = tslib.__assign({}, starting);
      var setContext = function(next) {
        if (typeof next === "function") {
          context = tslib.__assign(tslib.__assign({}, context), next(context));
        } else {
          context = tslib.__assign(tslib.__assign({}, context), next);
        }
      };
      var getContext = function() {
        return tslib.__assign({}, context);
      };
      Object.defineProperty(operation, "setContext", {
        enumerable: false,
        value: setContext
      });
      Object.defineProperty(operation, "getContext", {
        enumerable: false,
        value: getContext
      });
      return operation;
    }
    function transformOperation2(operation) {
      var transformedOperation = {
        variables: operation.variables || {},
        extensions: operation.extensions || {},
        operationName: operation.operationName,
        query: operation.query
      };
      if (!transformedOperation.operationName) {
        transformedOperation.operationName = typeof transformedOperation.query !== "string" ? utilities.getOperationName(transformedOperation.query) || void 0 : "";
      }
      return transformedOperation;
    }
    function filterOperationVariables2(variables, query) {
      var result2 = tslib.__assign({}, variables);
      var unusedNames = new Set(Object.keys(variables));
      graphql.visit(query, {
        Variable: function(node, _key, parent) {
          if (parent && parent.kind !== "VariableDefinition") {
            unusedNames.delete(node.name.value);
          }
        }
      });
      unusedNames.forEach(function(name) {
        delete result2[name];
      });
      return result2;
    }
    exports.createOperation = createOperation2;
    exports.filterOperationVariables = filterOperationVariables2;
    exports.fromError = fromError2;
    exports.fromPromise = fromPromise2;
    exports.throwServerError = throwServerError2;
    exports.toPromise = toPromise2;
    exports.transformOperation = transformOperation2;
    exports.validateOperation = validateOperation2;
  }
});

// ../node_modules/@apollo/client/link/core/core.cjs
var require_core = __commonJS({
  "../node_modules/@apollo/client/link/core/core.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var utilities = require_utilities();
    var utils = require_utils();
    function passthrough2(op, forward) {
      return forward ? forward(op) : utilities.Observable.of();
    }
    function toLink2(handler) {
      return typeof handler === "function" ? new ApolloLink2(handler) : handler;
    }
    function isTerminating2(link) {
      return link.request.length <= 1;
    }
    var ApolloLink2 = function() {
      function ApolloLink3(request) {
        if (request)
          this.request = request;
      }
      ApolloLink3.empty = function() {
        return new ApolloLink3(function() {
          return utilities.Observable.of();
        });
      };
      ApolloLink3.from = function(links) {
        if (links.length === 0)
          return ApolloLink3.empty();
        return links.map(toLink2).reduce(function(x, y) {
          return x.concat(y);
        });
      };
      ApolloLink3.split = function(test, left, right) {
        var leftLink = toLink2(left);
        var rightLink = toLink2(right || new ApolloLink3(passthrough2));
        var ret;
        if (isTerminating2(leftLink) && isTerminating2(rightLink)) {
          ret = new ApolloLink3(function(operation) {
            return test(operation) ? leftLink.request(operation) || utilities.Observable.of() : rightLink.request(operation) || utilities.Observable.of();
          });
        } else {
          ret = new ApolloLink3(function(operation, forward) {
            return test(operation) ? leftLink.request(operation, forward) || utilities.Observable.of() : rightLink.request(operation, forward) || utilities.Observable.of();
          });
        }
        return Object.assign(ret, { left: leftLink, right: rightLink });
      };
      ApolloLink3.execute = function(link, operation) {
        return link.request(utils.createOperation(operation.context, utils.transformOperation(utils.validateOperation(operation)))) || utilities.Observable.of();
      };
      ApolloLink3.concat = function(first, second) {
        var firstLink = toLink2(first);
        if (isTerminating2(firstLink)) {
          globalThis.__DEV__ !== false && globals.invariant.warn(35, firstLink);
          return firstLink;
        }
        var nextLink = toLink2(second);
        var ret;
        if (isTerminating2(nextLink)) {
          ret = new ApolloLink3(function(operation) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op) || utilities.Observable.of();
            }) || utilities.Observable.of();
          });
        } else {
          ret = new ApolloLink3(function(operation, forward) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op, forward) || utilities.Observable.of();
            }) || utilities.Observable.of();
          });
        }
        return Object.assign(ret, { left: firstLink, right: nextLink });
      };
      ApolloLink3.prototype.split = function(test, left, right) {
        return this.concat(ApolloLink3.split(test, left, right || new ApolloLink3(passthrough2)));
      };
      ApolloLink3.prototype.concat = function(next) {
        return ApolloLink3.concat(this, next);
      };
      ApolloLink3.prototype.request = function(operation, forward) {
        throw globals.newInvariantError(36);
      };
      ApolloLink3.prototype.onError = function(error, observer) {
        if (observer && observer.error) {
          observer.error(error);
          return false;
        }
        throw error;
      };
      ApolloLink3.prototype.setOnError = function(fn) {
        this.onError = fn;
        return this;
      };
      return ApolloLink3;
    }();
    var empty2 = ApolloLink2.empty;
    var from2 = ApolloLink2.from;
    var split2 = ApolloLink2.split;
    var concat2 = ApolloLink2.concat;
    var execute2 = ApolloLink2.execute;
    exports.ApolloLink = ApolloLink2;
    exports.concat = concat2;
    exports.empty = empty2;
    exports.execute = execute2;
    exports.from = from2;
    exports.split = split2;
  }
});

// ../node_modules/@apollo/client/errors/errors.cjs
var require_errors = __commonJS({
  "../node_modules/@apollo/client/errors/errors.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    require_globals();
    var utilities = require_utilities();
    var PROTOCOL_ERRORS_SYMBOL2 = Symbol();
    function graphQLResultHasProtocolErrors2(result2) {
      if (result2.extensions) {
        return Array.isArray(result2.extensions[PROTOCOL_ERRORS_SYMBOL2]);
      }
      return false;
    }
    function isApolloError2(err) {
      return err.hasOwnProperty("graphQLErrors");
    }
    var generateErrorMessage2 = function(err) {
      var errors = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
      if (err.networkError)
        errors.push(err.networkError);
      return errors.map(function(err2) {
        return utilities.isNonNullObject(err2) && err2.message || "Error message not found.";
      }).join("\n");
    };
    var ApolloError2 = function(_super) {
      tslib.__extends(ApolloError3, _super);
      function ApolloError3(_a2) {
        var graphQLErrors = _a2.graphQLErrors, protocolErrors = _a2.protocolErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.name = "ApolloError";
        _this.graphQLErrors = graphQLErrors || [];
        _this.protocolErrors = protocolErrors || [];
        _this.clientErrors = clientErrors || [];
        _this.networkError = networkError || null;
        _this.message = errorMessage || generateErrorMessage2(_this);
        _this.extraInfo = extraInfo;
        _this.cause = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([
          networkError
        ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e) {
          return !!e;
        }) || null;
        _this.__proto__ = ApolloError3.prototype;
        return _this;
      }
      return ApolloError3;
    }(Error);
    exports.ApolloError = ApolloError2;
    exports.PROTOCOL_ERRORS_SYMBOL = PROTOCOL_ERRORS_SYMBOL2;
    exports.graphQLResultHasProtocolErrors = graphQLResultHasProtocolErrors2;
    exports.isApolloError = isApolloError2;
  }
});

// ../node_modules/@apollo/client/link/http/http.cjs
var require_http = __commonJS({
  "../node_modules/@apollo/client/link/http/http.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var utilities = require_utilities();
    var utils = require_utils();
    var errors = require_errors();
    var core = require_core();
    function asyncIterator2(source) {
      var _a2;
      var iterator = source[Symbol.asyncIterator]();
      return _a2 = {
        next: function() {
          return iterator.next();
        }
      }, _a2[Symbol.asyncIterator] = function() {
        return this;
      }, _a2;
    }
    function nodeStreamIterator2(stream) {
      var cleanup = null;
      var error = null;
      var done = false;
      var data = [];
      var waiting = [];
      function onData(chunk) {
        if (error)
          return;
        if (waiting.length) {
          var shiftedArr = waiting.shift();
          if (Array.isArray(shiftedArr) && shiftedArr[0]) {
            return shiftedArr[0]({ value: chunk, done: false });
          }
        }
        data.push(chunk);
      }
      function onError(err) {
        error = err;
        var all = waiting.slice();
        all.forEach(function(pair) {
          pair[1](err);
        });
        !cleanup || cleanup();
      }
      function onEnd() {
        done = true;
        var all = waiting.slice();
        all.forEach(function(pair) {
          pair[0]({ value: void 0, done: true });
        });
        !cleanup || cleanup();
      }
      cleanup = function() {
        cleanup = null;
        stream.removeListener("data", onData);
        stream.removeListener("error", onError);
        stream.removeListener("end", onEnd);
        stream.removeListener("finish", onEnd);
        stream.removeListener("close", onEnd);
      };
      stream.on("data", onData);
      stream.on("error", onError);
      stream.on("end", onEnd);
      stream.on("finish", onEnd);
      stream.on("close", onEnd);
      function getNext() {
        return new Promise(function(resolve, reject) {
          if (error)
            return reject(error);
          if (data.length)
            return resolve({ value: data.shift(), done: false });
          if (done)
            return resolve({ value: void 0, done: true });
          waiting.push([resolve, reject]);
        });
      }
      var iterator = {
        next: function() {
          return getNext();
        }
      };
      if (utilities.canUseAsyncIteratorSymbol) {
        iterator[Symbol.asyncIterator] = function() {
          return this;
        };
      }
      return iterator;
    }
    function promiseIterator2(promise) {
      var resolved = false;
      var iterator = {
        next: function() {
          if (resolved)
            return Promise.resolve({
              value: void 0,
              done: true
            });
          resolved = true;
          return new Promise(function(resolve, reject) {
            promise.then(function(value) {
              resolve({ value, done: false });
            }).catch(reject);
          });
        }
      };
      if (utilities.canUseAsyncIteratorSymbol) {
        iterator[Symbol.asyncIterator] = function() {
          return this;
        };
      }
      return iterator;
    }
    function readerIterator2(reader) {
      var iterator = {
        next: function() {
          return reader.read();
        }
      };
      if (utilities.canUseAsyncIteratorSymbol) {
        iterator[Symbol.asyncIterator] = function() {
          return this;
        };
      }
      return iterator;
    }
    function isNodeResponse2(value) {
      return !!value.body;
    }
    function isReadableStream2(value) {
      return !!value.getReader;
    }
    function isAsyncIterableIterator2(value) {
      return !!(utilities.canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
    }
    function isStreamableBlob2(value) {
      return !!value.stream;
    }
    function isBlob2(value) {
      return !!value.arrayBuffer;
    }
    function isNodeReadableStream2(value) {
      return !!value.pipe;
    }
    function responseIterator2(response) {
      var body = response;
      if (isNodeResponse2(response))
        body = response.body;
      if (isAsyncIterableIterator2(body))
        return asyncIterator2(body);
      if (isReadableStream2(body))
        return readerIterator2(body.getReader());
      if (isStreamableBlob2(body)) {
        return readerIterator2(body.stream().getReader());
      }
      if (isBlob2(body))
        return promiseIterator2(body.arrayBuffer());
      if (isNodeReadableStream2(body))
        return nodeStreamIterator2(body);
      throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
    }
    function isNonNullObject2(obj) {
      return obj !== null && typeof obj === "object";
    }
    function isApolloPayloadResult2(value) {
      return isNonNullObject2(value) && "payload" in value;
    }
    var hasOwnProperty9 = Object.prototype.hasOwnProperty;
    function readMultipartBody2(response, nextValue) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a2, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result2, next;
        var _b, _c;
        var _d;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              if (TextDecoder === void 0) {
                throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
              }
              decoder = new TextDecoder("utf-8");
              contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
              delimiter = "boundary=";
              boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
              boundary = "\r\n--".concat(boundaryVal);
              buffer = "";
              iterator = responseIterator2(response);
              running = true;
              _e.label = 1;
            case 1:
              if (!running) return [3, 3];
              return [4, iterator.next()];
            case 2:
              _a2 = _e.sent(), value = _a2.value, done = _a2.done;
              chunk = typeof value === "string" ? value : decoder.decode(value);
              searchFrom = buffer.length - boundary.length + 1;
              running = !done;
              buffer += chunk;
              bi = buffer.indexOf(boundary, searchFrom);
              while (bi > -1) {
                message = void 0;
                _b = [
                  buffer.slice(0, bi),
                  buffer.slice(bi + boundary.length)
                ], message = _b[0], buffer = _b[1];
                i = message.indexOf("\r\n\r\n");
                headers = parseHeaders2(message.slice(0, i));
                contentType_1 = headers["content-type"];
                if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
                  throw new Error("Unsupported patch content type: application/json is required.");
                }
                body = message.slice(i);
                if (body) {
                  result2 = parseJsonBody2(response, body);
                  if (Object.keys(result2).length > 1 || "data" in result2 || "incremental" in result2 || "errors" in result2 || "payload" in result2) {
                    if (isApolloPayloadResult2(result2)) {
                      next = {};
                      if ("payload" in result2) {
                        if (Object.keys(result2).length === 1 && result2.payload === null) {
                          return [2];
                        }
                        next = tslib.__assign({}, result2.payload);
                      }
                      if ("errors" in result2) {
                        next = tslib.__assign(tslib.__assign({}, next), { extensions: tslib.__assign(tslib.__assign({}, "extensions" in next ? next.extensions : null), (_c = {}, _c[errors.PROTOCOL_ERRORS_SYMBOL] = result2.errors, _c)) });
                      }
                      nextValue(next);
                    } else {
                      nextValue(result2);
                    }
                  } else if (Object.keys(result2).length === 1 && "hasNext" in result2 && !result2.hasNext) {
                    return [2];
                  }
                }
                bi = buffer.indexOf(boundary);
              }
              return [3, 1];
            case 3:
              return [2];
          }
        });
      });
    }
    function parseHeaders2(headerText) {
      var headersInit = {};
      headerText.split("\n").forEach(function(line) {
        var i = line.indexOf(":");
        if (i > -1) {
          var name_1 = line.slice(0, i).trim().toLowerCase();
          var value = line.slice(i + 1).trim();
          headersInit[name_1] = value;
        }
      });
      return headersInit;
    }
    function parseJsonBody2(response, bodyText) {
      if (response.status >= 300) {
        var getResult = function() {
          try {
            return JSON.parse(bodyText);
          } catch (err) {
            return bodyText;
          }
        };
        utils.throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
      }
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        var parseError = err;
        parseError.name = "ServerParseError";
        parseError.response = response;
        parseError.statusCode = response.status;
        parseError.bodyText = bodyText;
        throw parseError;
      }
    }
    function handleError2(err, observer) {
      if (err.result && err.result.errors && err.result.data) {
        observer.next(err.result);
      }
      observer.error(err);
    }
    function parseAndCheckHttpResponse2(operations) {
      return function(response) {
        return response.text().then(function(bodyText) {
          return parseJsonBody2(response, bodyText);
        }).then(function(result2) {
          if (!Array.isArray(result2) && !hasOwnProperty9.call(result2, "data") && !hasOwnProperty9.call(result2, "errors")) {
            utils.throwServerError(response, result2, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
              return op.operationName;
            }) : operations.operationName, "'."));
          }
          return result2;
        });
      };
    }
    var serializeFetchParameter2 = function(p, label) {
      var serialized;
      try {
        serialized = JSON.stringify(p);
      } catch (e) {
        var parseError = globals.newInvariantError(39, label, e.message);
        parseError.parseError = e;
        throw parseError;
      }
      return serialized;
    };
    var defaultHttpOptions2 = {
      includeQuery: true,
      includeExtensions: false,
      preserveHeaderCase: false
    };
    var defaultHeaders2 = {
      accept: "*/*",
      "content-type": "application/json"
    };
    var defaultOptions2 = {
      method: "POST"
    };
    var fallbackHttpConfig2 = {
      http: defaultHttpOptions2,
      headers: defaultHeaders2,
      options: defaultOptions2
    };
    var defaultPrinter2 = function(ast, printer) {
      return printer(ast);
    };
    function selectHttpOptionsAndBody2(operation, fallbackConfig) {
      var configs = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
      }
      configs.unshift(fallbackConfig);
      return selectHttpOptionsAndBodyInternal2.apply(void 0, tslib.__spreadArray([
        operation,
        defaultPrinter2
      ], configs, false));
    }
    function selectHttpOptionsAndBodyInternal2(operation, printer) {
      var configs = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
      }
      var options = {};
      var http = {};
      configs.forEach(function(config) {
        options = tslib.__assign(tslib.__assign(tslib.__assign({}, options), config.options), { headers: tslib.__assign(tslib.__assign({}, options.headers), config.headers) });
        if (config.credentials) {
          options.credentials = config.credentials;
        }
        http = tslib.__assign(tslib.__assign({}, http), config.http);
      });
      if (options.headers) {
        options.headers = removeDuplicateHeaders2(options.headers, http.preserveHeaderCase);
      }
      var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
      var body = { operationName: operationName2, variables };
      if (http.includeExtensions)
        body.extensions = extensions;
      if (http.includeQuery)
        body.query = printer(query, utilities.print);
      return {
        options,
        body
      };
    }
    function removeDuplicateHeaders2(headers, preserveHeaderCase) {
      if (!preserveHeaderCase) {
        var normalizedHeaders_1 = /* @__PURE__ */ Object.create(null);
        Object.keys(Object(headers)).forEach(function(name) {
          normalizedHeaders_1[name.toLowerCase()] = headers[name];
        });
        return normalizedHeaders_1;
      }
      var headerData = /* @__PURE__ */ Object.create(null);
      Object.keys(Object(headers)).forEach(function(name) {
        headerData[name.toLowerCase()] = {
          originalName: name,
          value: headers[name]
        };
      });
      var normalizedHeaders = /* @__PURE__ */ Object.create(null);
      Object.keys(headerData).forEach(function(name) {
        normalizedHeaders[headerData[name].originalName] = headerData[name].value;
      });
      return normalizedHeaders;
    }
    var checkFetcher2 = function(fetcher) {
      if (!fetcher && typeof fetch === "undefined") {
        throw globals.newInvariantError(37);
      }
    };
    var createSignalIfSupported2 = function() {
      if (typeof AbortController === "undefined")
        return { controller: false, signal: false };
      var controller = new AbortController();
      var signal = controller.signal;
      return { controller, signal };
    };
    var selectURI2 = function(operation, fallbackURI) {
      var context = operation.getContext();
      var contextURI = context.uri;
      if (contextURI) {
        return contextURI;
      } else if (typeof fallbackURI === "function") {
        return fallbackURI(operation);
      } else {
        return fallbackURI || "/graphql";
      }
    };
    function rewriteURIForGET2(chosenURI, body) {
      var queryParams = [];
      var addQueryParam = function(key, value) {
        queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
      };
      if ("query" in body) {
        addQueryParam("query", body.query);
      }
      if (body.operationName) {
        addQueryParam("operationName", body.operationName);
      }
      if (body.variables) {
        var serializedVariables = void 0;
        try {
          serializedVariables = serializeFetchParameter2(body.variables, "Variables map");
        } catch (parseError) {
          return { parseError };
        }
        addQueryParam("variables", serializedVariables);
      }
      if (body.extensions) {
        var serializedExtensions = void 0;
        try {
          serializedExtensions = serializeFetchParameter2(body.extensions, "Extensions map");
        } catch (parseError) {
          return { parseError };
        }
        addQueryParam("extensions", serializedExtensions);
      }
      var fragment = "", preFragment = chosenURI;
      var fragmentStart = chosenURI.indexOf("#");
      if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
      }
      var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
      var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
      return { newURI };
    }
    var backupFetch2 = utilities.maybe(function() {
      return fetch;
    });
    var createHttpLink2 = function(linkOptions) {
      if (linkOptions === void 0) {
        linkOptions = {};
      }
      var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print3 = _b === void 0 ? defaultPrinter2 : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = tslib.__rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
      if (globalThis.__DEV__ !== false) {
        checkFetcher2(preferredFetch || backupFetch2);
      }
      var linkConfig = {
        http: { includeExtensions, preserveHeaderCase },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers
      };
      return new core.ApolloLink(function(operation) {
        var chosenURI = selectURI2(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
          var _a3 = context.clientAwareness, name_1 = _a3.name, version2 = _a3.version;
          if (name_1) {
            clientAwarenessHeaders["apollographql-client-name"] = name_1;
          }
          if (version2) {
            clientAwarenessHeaders["apollographql-client-version"] = version2;
          }
        }
        var contextHeaders = tslib.__assign(tslib.__assign({}, clientAwarenessHeaders), context.headers);
        var contextConfig = {
          http: context.http,
          options: context.fetchOptions,
          credentials: context.credentials,
          headers: contextHeaders
        };
        if (utilities.hasDirectives(["client"], operation.query)) {
          var transformedQuery = utilities.removeClientSetsFromDocument(operation.query);
          if (!transformedQuery) {
            return utils.fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
          }
          operation.query = transformedQuery;
        }
        var _b2 = selectHttpOptionsAndBodyInternal2(operation, print3, fallbackHttpConfig2, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
        if (body.variables && !includeUnusedVariables) {
          body.variables = utils.filterOperationVariables(body.variables, operation.query);
        }
        var controller;
        if (!options.signal && typeof AbortController !== "undefined") {
          controller = new AbortController();
          options.signal = controller.signal;
        }
        var definitionIsMutation = function(d) {
          return d.kind === "OperationDefinition" && d.operation === "mutation";
        };
        var definitionIsSubscription = function(d) {
          return d.kind === "OperationDefinition" && d.operation === "subscription";
        };
        var isSubscription = definitionIsSubscription(utilities.getMainDefinition(operation.query));
        var hasDefer = utilities.hasDirectives(["defer"], operation.query);
        if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
          options.method = "GET";
        }
        if (hasDefer || isSubscription) {
          options.headers = options.headers || {};
          var acceptHeader = "multipart/mixed;";
          if (isSubscription && hasDefer) {
            globalThis.__DEV__ !== false && globals.invariant.warn(38);
          }
          if (isSubscription) {
            acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
          } else if (hasDefer) {
            acceptHeader += "deferSpec=20220824,application/json";
          }
          options.headers.accept = acceptHeader;
        }
        if (options.method === "GET") {
          var _c2 = rewriteURIForGET2(chosenURI, body), newURI = _c2.newURI, parseError = _c2.parseError;
          if (parseError) {
            return utils.fromError(parseError);
          }
          chosenURI = newURI;
        } else {
          try {
            options.body = serializeFetchParameter2(body, "Payload");
          } catch (parseError2) {
            return utils.fromError(parseError2);
          }
        }
        return new utilities.Observable(function(observer) {
          var currentFetch = preferredFetch || utilities.maybe(function() {
            return fetch;
          }) || backupFetch2;
          var observerNext = observer.next.bind(observer);
          currentFetch(chosenURI, options).then(function(response) {
            var _a4;
            operation.setContext({ response });
            var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
            if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
              return readMultipartBody2(response, observerNext);
            } else {
              return parseAndCheckHttpResponse2(operation)(response).then(observerNext);
            }
          }).then(function() {
            controller = void 0;
            observer.complete();
          }).catch(function(err) {
            controller = void 0;
            handleError2(err, observer);
          });
          return function() {
            if (controller)
              controller.abort();
          };
        });
      });
    };
    var HttpLink2 = function(_super) {
      tslib.__extends(HttpLink3, _super);
      function HttpLink3(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this, createHttpLink2(options).request) || this;
        _this.options = options;
        return _this;
      }
      return HttpLink3;
    }(core.ApolloLink);
    exports.HttpLink = HttpLink2;
    exports.checkFetcher = checkFetcher2;
    exports.createHttpLink = createHttpLink2;
    exports.createSignalIfSupported = createSignalIfSupported2;
    exports.defaultPrinter = defaultPrinter2;
    exports.fallbackHttpConfig = fallbackHttpConfig2;
    exports.parseAndCheckHttpResponse = parseAndCheckHttpResponse2;
    exports.rewriteURIForGET = rewriteURIForGET2;
    exports.selectHttpOptionsAndBody = selectHttpOptionsAndBody2;
    exports.selectHttpOptionsAndBodyInternal = selectHttpOptionsAndBodyInternal2;
    exports.selectURI = selectURI2;
    exports.serializeFetchParameter = serializeFetchParameter2;
  }
});

// ../node_modules/@apollo/client/core/core.cjs
var require_core2 = __commonJS({
  "../node_modules/@apollo/client/core/core.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var globals = require_globals();
    var core = require_core();
    var http = require_http();
    var equal2 = (init_lib7(), __toCommonJS(lib_exports5));
    var utilities = require_utilities();
    var cache2 = require_cache();
    var errors = require_errors();
    var trie = (init_lib2(), __toCommonJS(lib_exports2));
    var graphql = (init_graphql(), __toCommonJS(graphql_exports));
    var utils = require_utils();
    var tsInvariant = (init_invariant(), __toCommonJS(invariant_exports));
    var graphqlTag = (init_lib(), __toCommonJS(lib_exports));
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e["default"] : e;
    }
    var equal__default = _interopDefaultLegacy(equal2);
    var version2 = "3.11.1";
    function isNonNullObject2(obj) {
      return obj !== null && typeof obj === "object";
    }
    function isNonEmptyArray2(value) {
      return Array.isArray(value) && value.length > 0;
    }
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var defaultReconciler2 = function(target, source, property) {
      return this.merge(target[property], source[property]);
    };
    var DeepMerger2 = function() {
      function DeepMerger3(reconciler) {
        if (reconciler === void 0) {
          reconciler = defaultReconciler2;
        }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject2;
        this.pastCopies = /* @__PURE__ */ new Set();
      }
      DeepMerger3.prototype.merge = function(target, source) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject2(source) && isNonNullObject2(target)) {
          Object.keys(source).forEach(function(sourceKey) {
            if (hasOwnProperty$2.call(target, sourceKey)) {
              var targetValue = target[sourceKey];
              if (source[sourceKey] !== targetValue) {
                var result2 = _this.reconciler.apply(_this, tslib.__spreadArray([
                  target,
                  source,
                  sourceKey
                ], context, false));
                if (result2 !== targetValue) {
                  target = _this.shallowCopyForMerge(target);
                  target[sourceKey] = result2;
                }
              }
            } else {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = source[sourceKey];
            }
          });
          return target;
        }
        return source;
      };
      DeepMerger3.prototype.shallowCopyForMerge = function(value) {
        if (isNonNullObject2(value)) {
          if (!this.pastCopies.has(value)) {
            if (Array.isArray(value)) {
              value = value.slice(0);
            } else {
              value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
            }
            this.pastCopies.add(value);
          }
        }
        return value;
      };
      return DeepMerger3;
    }();
    function isExecutionPatchIncrementalResult2(value) {
      return "incremental" in value;
    }
    function mergeIncrementalData2(prevResult, result2) {
      var mergedData = prevResult;
      var merger = new DeepMerger2();
      if (isExecutionPatchIncrementalResult2(result2) && isNonEmptyArray2(result2.incremental)) {
        result2.incremental.forEach(function(_a2) {
          var data = _a2.data, path = _a2.path;
          for (var i = path.length - 1; i >= 0; --i) {
            var key = path[i];
            var isNumericKey = !isNaN(+key);
            var parent_1 = isNumericKey ? [] : {};
            parent_1[key] = data;
            data = parent_1;
          }
          mergedData = merger.merge(mergedData, data);
        });
      }
      return mergedData;
    }
    exports.NetworkStatus = void 0;
    (function(NetworkStatus2) {
      NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
      NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
      NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
      NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
      NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
      NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
      NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
    })(exports.NetworkStatus || (exports.NetworkStatus = {}));
    function isNetworkRequestInFlight2(networkStatus) {
      return networkStatus ? networkStatus < 7 : false;
    }
    function isNetworkRequestSettled2(networkStatus) {
      return networkStatus === 7 || networkStatus === 8;
    }
    function equalByQuery2(query, _a2, _b, variables) {
      var aData = _a2.data, aRest = tslib.__rest(_a2, ["data"]);
      var bData = _b.data, bRest = tslib.__rest(_b, ["data"]);
      return equal__default(aRest, bRest) && equalBySelectionSet2(utilities.getMainDefinition(query).selectionSet, aData, bData, {
        fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
        variables
      });
    }
    function equalBySelectionSet2(selectionSet, aResult, bResult, context) {
      if (aResult === bResult) {
        return true;
      }
      var seenSelections = /* @__PURE__ */ new Set();
      return selectionSet.selections.every(function(selection) {
        if (seenSelections.has(selection))
          return true;
        seenSelections.add(selection);
        if (!utilities.shouldInclude(selection, context.variables))
          return true;
        if (selectionHasNonreactiveDirective2(selection))
          return true;
        if (utilities.isField(selection)) {
          var resultKey = utilities.resultKeyNameFromField(selection);
          var aResultChild = aResult && aResult[resultKey];
          var bResultChild = bResult && bResult[resultKey];
          var childSelectionSet = selection.selectionSet;
          if (!childSelectionSet) {
            return equal__default(aResultChild, bResultChild);
          }
          var aChildIsArray = Array.isArray(aResultChild);
          var bChildIsArray = Array.isArray(bResultChild);
          if (aChildIsArray !== bChildIsArray)
            return false;
          if (aChildIsArray && bChildIsArray) {
            var length_1 = aResultChild.length;
            if (bResultChild.length !== length_1) {
              return false;
            }
            for (var i = 0; i < length_1; ++i) {
              if (!equalBySelectionSet2(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
                return false;
              }
            }
            return true;
          }
          return equalBySelectionSet2(childSelectionSet, aResultChild, bResultChild, context);
        } else {
          var fragment = utilities.getFragmentFromSelection(selection, context.fragmentMap);
          if (fragment) {
            if (selectionHasNonreactiveDirective2(fragment))
              return true;
            return equalBySelectionSet2(
              fragment.selectionSet,
              aResult,
              bResult,
              context
            );
          }
        }
      });
    }
    function selectionHasNonreactiveDirective2(selection) {
      return !!selection.directives && selection.directives.some(directiveIsNonreactive2);
    }
    function directiveIsNonreactive2(dir) {
      return dir.name.value === "nonreactive";
    }
    var assign2 = Object.assign;
    var hasOwnProperty$1 = Object.hasOwnProperty;
    var ObservableQuery2 = function(_super) {
      tslib.__extends(ObservableQuery3, _super);
      function ObservableQuery3(_a2) {
        var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
        var _this = _super.call(this, function(observer) {
          try {
            var subObserver = observer._subscription._observer;
            if (subObserver && !subObserver.error) {
              subObserver.error = defaultSubscriptionObserverErrorCallback2;
            }
          } catch (_a3) {
          }
          var first = !_this.observers.size;
          _this.observers.add(observer);
          var last = _this.last;
          if (last && last.error) {
            observer.error && observer.error(last.error);
          } else if (last && last.result) {
            observer.next && observer.next(last.result);
          }
          if (first) {
            _this.reobserve().catch(function() {
            });
          }
          return function() {
            if (_this.observers.delete(observer) && !_this.observers.size) {
              _this.tearDownQuery();
            }
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.subscriptions = /* @__PURE__ */ new Set();
        _this.queryInfo = queryInfo;
        _this.queryManager = queryManager;
        _this.waitForOwnResult = skipCacheDataFor2(options.fetchPolicy);
        _this.isTornDown = false;
        _this.subscribeToMore = _this.subscribeToMore.bind(_this);
        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
        _this.options = tslib.__assign(tslib.__assign({}, options), {
          initialFetchPolicy,
          fetchPolicy
        });
        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
        var opDef = utilities.getOperationDefinition(_this.query);
        _this.queryName = opDef && opDef.name && opDef.name.value;
        return _this;
      }
      Object.defineProperty(ObservableQuery3.prototype, "query", {
        get: function() {
          return this.lastQuery || this.options.query;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObservableQuery3.prototype, "variables", {
        get: function() {
          return this.options.variables;
        },
        enumerable: false,
        configurable: true
      });
      ObservableQuery3.prototype.result = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var observer = {
            next: function(result2) {
              resolve(result2);
              _this.observers.delete(observer);
              if (!_this.observers.size) {
                _this.queryManager.removeQuery(_this.queryId);
              }
              setTimeout(function() {
                subscription.unsubscribe();
              }, 0);
            },
            error: reject
          };
          var subscription = _this.subscribe(observer);
        });
      };
      ObservableQuery3.prototype.resetDiff = function() {
        this.queryInfo.resetDiff();
      };
      ObservableQuery3.prototype.getCurrentResult = function(saveAsLastResult) {
        if (saveAsLastResult === void 0) {
          saveAsLastResult = true;
        }
        var lastResult = this.getLastResult(true);
        var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || exports.NetworkStatus.ready;
        var result2 = tslib.__assign(tslib.__assign({}, lastResult), { loading: isNetworkRequestInFlight2(networkStatus), networkStatus });
        var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
        if (skipCacheDataFor2(fetchPolicy) || this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) ;
        else if (this.waitForOwnResult) {
          this.queryInfo["updateWatch"]();
        } else {
          var diff = this.queryInfo.getDiff();
          if (diff.complete || this.options.returnPartialData) {
            result2.data = diff.result;
          }
          if (equal2.equal(result2.data, {})) {
            result2.data = void 0;
          }
          if (diff.complete) {
            delete result2.partial;
            if (diff.complete && result2.networkStatus === exports.NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
              result2.networkStatus = exports.NetworkStatus.ready;
              result2.loading = false;
            }
          } else {
            result2.partial = true;
          }
          if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result2.loading && !result2.data && !result2.error) {
            logMissingFieldErrors2(diff.missing);
          }
        }
        if (saveAsLastResult) {
          this.updateLastResult(result2);
        }
        return result2;
      };
      ObservableQuery3.prototype.isDifferentFromLastResult = function(newResult, variables) {
        if (!this.last) {
          return true;
        }
        var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !equalByQuery2(this.query, this.last.result, newResult, this.variables) : !equal2.equal(this.last.result, newResult);
        return resultIsDifferent || variables && !equal2.equal(this.last.variables, variables);
      };
      ObservableQuery3.prototype.getLast = function(key, variablesMustMatch) {
        var last = this.last;
        if (last && last[key] && (!variablesMustMatch || equal2.equal(last.variables, this.variables))) {
          return last[key];
        }
      };
      ObservableQuery3.prototype.getLastResult = function(variablesMustMatch) {
        return this.getLast("result", variablesMustMatch);
      };
      ObservableQuery3.prototype.getLastError = function(variablesMustMatch) {
        return this.getLast("error", variablesMustMatch);
      };
      ObservableQuery3.prototype.resetLastResults = function() {
        delete this.last;
        this.isTornDown = false;
      };
      ObservableQuery3.prototype.resetQueryStoreErrors = function() {
        this.queryManager.resetErrors(this.queryId);
      };
      ObservableQuery3.prototype.refetch = function(variables) {
        var _a2;
        var reobserveOptions = {
          pollInterval: 0
        };
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === "cache-and-network") {
          reobserveOptions.fetchPolicy = fetchPolicy;
        } else if (fetchPolicy === "no-cache") {
          reobserveOptions.fetchPolicy = "no-cache";
        } else {
          reobserveOptions.fetchPolicy = "network-only";
        }
        if (globalThis.__DEV__ !== false && variables && hasOwnProperty$1.call(variables, "variables")) {
          var queryDef = utilities.getQueryDefinition(this.query);
          var vars = queryDef.variableDefinitions;
          if (!vars || !vars.some(function(v) {
            return v.variable.name.value === "variables";
          })) {
            globalThis.__DEV__ !== false && globals.invariant.warn(
              20,
              variables,
              ((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || queryDef
            );
          }
        }
        if (variables && !equal2.equal(this.options.variables, variables)) {
          reobserveOptions.variables = this.options.variables = tslib.__assign(tslib.__assign({}, this.options.variables), variables);
        }
        this.queryInfo.resetLastWrite();
        return this.reobserve(reobserveOptions, exports.NetworkStatus.refetch);
      };
      ObservableQuery3.prototype.fetchMore = function(fetchMoreOptions) {
        var _this = this;
        var combinedOptions = tslib.__assign(tslib.__assign({}, fetchMoreOptions.query ? fetchMoreOptions : tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: tslib.__assign(tslib.__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
          fetchPolicy: "no-cache"
        });
        combinedOptions.query = this.transformDocument(combinedOptions.query);
        var qid = this.queryManager.generateQueryId();
        this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
        var queryInfo = this.queryInfo;
        var originalNetworkStatus = queryInfo.networkStatus;
        queryInfo.networkStatus = exports.NetworkStatus.fetchMore;
        if (combinedOptions.notifyOnNetworkStatusChange) {
          this.observe();
        }
        var updatedQuerySet = /* @__PURE__ */ new Set();
        return this.queryManager.fetchQuery(qid, combinedOptions, exports.NetworkStatus.fetchMore).then(function(fetchMoreResult) {
          _this.queryManager.removeQuery(qid);
          if (queryInfo.networkStatus === exports.NetworkStatus.fetchMore) {
            queryInfo.networkStatus = originalNetworkStatus;
          }
          _this.queryManager.cache.batch({
            update: function(cache3) {
              var updateQuery = fetchMoreOptions.updateQuery;
              if (updateQuery) {
                cache3.updateQuery({
                  query: _this.query,
                  variables: _this.variables,
                  returnPartialData: true,
                  optimistic: false
                }, function(previous) {
                  return updateQuery(previous, {
                    fetchMoreResult: fetchMoreResult.data,
                    variables: combinedOptions.variables
                  });
                });
              } else {
                cache3.writeQuery({
                  query: combinedOptions.query,
                  variables: combinedOptions.variables,
                  data: fetchMoreResult.data
                });
              }
            },
            onWatchUpdated: function(watch) {
              updatedQuerySet.add(watch.query);
            }
          });
          return fetchMoreResult;
        }).finally(function() {
          if (!updatedQuerySet.has(_this.query)) {
            reobserveCacheFirst2(_this);
          }
        });
      };
      ObservableQuery3.prototype.subscribeToMore = function(options) {
        var _this = this;
        var subscription = this.queryManager.startGraphQLSubscription({
          query: options.document,
          variables: options.variables,
          context: options.context
        }).subscribe({
          next: function(subscriptionData) {
            var updateQuery = options.updateQuery;
            if (updateQuery) {
              _this.updateQuery(function(previous, _a2) {
                var variables = _a2.variables;
                return updateQuery(previous, {
                  subscriptionData,
                  variables
                });
              });
            }
          },
          error: function(err) {
            if (options.onError) {
              options.onError(err);
              return;
            }
            globalThis.__DEV__ !== false && globals.invariant.error(21, err);
          }
        });
        this.subscriptions.add(subscription);
        return function() {
          if (_this.subscriptions.delete(subscription)) {
            subscription.unsubscribe();
          }
        };
      };
      ObservableQuery3.prototype.setOptions = function(newOptions) {
        return this.reobserve(newOptions);
      };
      ObservableQuery3.prototype.silentSetOptions = function(newOptions) {
        var mergedOptions = utilities.compact(this.options, newOptions || {});
        assign2(this.options, mergedOptions);
      };
      ObservableQuery3.prototype.setVariables = function(variables) {
        if (equal2.equal(this.variables, variables)) {
          return this.observers.size ? this.result() : Promise.resolve();
        }
        this.options.variables = variables;
        if (!this.observers.size) {
          return Promise.resolve();
        }
        return this.reobserve({
          fetchPolicy: this.options.initialFetchPolicy,
          variables
        }, exports.NetworkStatus.setVariables);
      };
      ObservableQuery3.prototype.updateQuery = function(mapFn) {
        var queryManager = this.queryManager;
        var result2 = queryManager.cache.diff({
          query: this.options.query,
          variables: this.variables,
          returnPartialData: true,
          optimistic: false
        }).result;
        var newResult = mapFn(result2, {
          variables: this.variables
        });
        if (newResult) {
          queryManager.cache.writeQuery({
            query: this.options.query,
            data: newResult,
            variables: this.variables
          });
          queryManager.broadcastQueries();
        }
      };
      ObservableQuery3.prototype.startPolling = function(pollInterval) {
        this.options.pollInterval = pollInterval;
        this.updatePolling();
      };
      ObservableQuery3.prototype.stopPolling = function() {
        this.options.pollInterval = 0;
        this.updatePolling();
      };
      ObservableQuery3.prototype.applyNextFetchPolicy = function(reason, options) {
        if (options.nextFetchPolicy) {
          var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
          if (fetchPolicy === "standby") ;
          else if (typeof options.nextFetchPolicy === "function") {
            options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
              reason,
              options,
              observable: this,
              initialFetchPolicy
            });
          } else if (reason === "variables-changed") {
            options.fetchPolicy = initialFetchPolicy;
          } else {
            options.fetchPolicy = options.nextFetchPolicy;
          }
        }
        return options.fetchPolicy;
      };
      ObservableQuery3.prototype.fetch = function(options, newNetworkStatus, query) {
        this.queryManager.setObservableQuery(this);
        return this.queryManager["fetchConcastWithInfo"](this.queryId, options, newNetworkStatus, query);
      };
      ObservableQuery3.prototype.updatePolling = function() {
        var _this = this;
        if (this.queryManager.ssrMode) {
          return;
        }
        var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
        if (!pollInterval || !this.hasObservers()) {
          if (pollingInfo) {
            clearTimeout(pollingInfo.timeout);
            delete this.pollingInfo;
          }
          return;
        }
        if (pollingInfo && pollingInfo.interval === pollInterval) {
          return;
        }
        globals.invariant(pollInterval, 22);
        var info = pollingInfo || (this.pollingInfo = {});
        info.interval = pollInterval;
        var maybeFetch = function() {
          var _a3, _b;
          if (_this.pollingInfo) {
            if (!isNetworkRequestInFlight2(_this.queryInfo.networkStatus) && !((_b = (_a3 = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a3))) {
              _this.reobserve({
                fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
              }, exports.NetworkStatus.poll).then(poll, poll);
            } else {
              poll();
            }
          }
        };
        var poll = function() {
          var info2 = _this.pollingInfo;
          if (info2) {
            clearTimeout(info2.timeout);
            info2.timeout = setTimeout(maybeFetch, info2.interval);
          }
        };
        poll();
      };
      ObservableQuery3.prototype.updateLastResult = function(newResult, variables) {
        if (variables === void 0) {
          variables = this.variables;
        }
        var error = this.getLastError();
        if (error && this.last && !equal2.equal(variables, this.last.variables)) {
          error = void 0;
        }
        return this.last = tslib.__assign({ result: this.queryManager.assumeImmutableResults ? newResult : utilities.cloneDeep(newResult), variables }, error ? { error } : null);
      };
      ObservableQuery3.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
        var _this = this;
        this.isTornDown = false;
        var useDisposableConcast = newNetworkStatus === exports.NetworkStatus.refetch || newNetworkStatus === exports.NetworkStatus.fetchMore || newNetworkStatus === exports.NetworkStatus.poll;
        var oldVariables = this.options.variables;
        var oldFetchPolicy = this.options.fetchPolicy;
        var mergedOptions = utilities.compact(this.options, newOptions || {});
        var options = useDisposableConcast ? mergedOptions : assign2(this.options, mergedOptions);
        var query = this.transformDocument(options.query);
        this.lastQuery = query;
        if (!useDisposableConcast) {
          this.updatePolling();
          if (newOptions && newOptions.variables && !equal2.equal(newOptions.variables, oldVariables) && options.fetchPolicy !== "standby" && (options.fetchPolicy === oldFetchPolicy || typeof options.nextFetchPolicy === "function")) {
            this.applyNextFetchPolicy("variables-changed", options);
            if (newNetworkStatus === void 0) {
              newNetworkStatus = exports.NetworkStatus.setVariables;
            }
          }
        }
        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor2(options.fetchPolicy));
        var finishWaitingForOwnResult = function() {
          if (_this.concast === concast) {
            _this.waitForOwnResult = false;
          }
        };
        var variables = options.variables && tslib.__assign({}, options.variables);
        var _a2 = this.fetch(options, newNetworkStatus, query), concast = _a2.concast, fromLink = _a2.fromLink;
        var observer = {
          next: function(result2) {
            if (equal2.equal(_this.variables, variables)) {
              finishWaitingForOwnResult();
              _this.reportResult(result2, variables);
            }
          },
          error: function(error) {
            if (equal2.equal(_this.variables, variables)) {
              finishWaitingForOwnResult();
              _this.reportError(error, variables);
            }
          }
        };
        if (!useDisposableConcast && (fromLink || !this.concast)) {
          if (this.concast && this.observer) {
            this.concast.removeObserver(this.observer);
          }
          this.concast = concast;
          this.observer = observer;
        }
        concast.addObserver(observer);
        return concast;
      };
      ObservableQuery3.prototype.reobserve = function(newOptions, newNetworkStatus) {
        return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;
      };
      ObservableQuery3.prototype.resubscribeAfterError = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var last = this.last;
        this.resetLastResults();
        var subscription = this.subscribe.apply(this, args);
        this.last = last;
        return subscription;
      };
      ObservableQuery3.prototype.observe = function() {
        this.reportResult(
          this.getCurrentResult(false),
          this.variables
        );
      };
      ObservableQuery3.prototype.reportResult = function(result2, variables) {
        var lastError = this.getLastError();
        var isDifferent = this.isDifferentFromLastResult(result2, variables);
        if (lastError || !result2.partial || this.options.returnPartialData) {
          this.updateLastResult(result2, variables);
        }
        if (lastError || isDifferent) {
          utilities.iterateObserversSafely(this.observers, "next", result2);
        }
      };
      ObservableQuery3.prototype.reportError = function(error, variables) {
        var errorResult = tslib.__assign(tslib.__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: exports.NetworkStatus.error, loading: false });
        this.updateLastResult(errorResult, variables);
        utilities.iterateObserversSafely(this.observers, "error", this.last.error = error);
      };
      ObservableQuery3.prototype.hasObservers = function() {
        return this.observers.size > 0;
      };
      ObservableQuery3.prototype.tearDownQuery = function() {
        if (this.isTornDown)
          return;
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
          delete this.concast;
          delete this.observer;
        }
        this.stopPolling();
        this.subscriptions.forEach(function(sub) {
          return sub.unsubscribe();
        });
        this.subscriptions.clear();
        this.queryManager.stopQuery(this.queryId);
        this.observers.clear();
        this.isTornDown = true;
      };
      ObservableQuery3.prototype.transformDocument = function(document) {
        return this.queryManager.transform(document);
      };
      return ObservableQuery3;
    }(utilities.Observable);
    utilities.fixObservableSubclass(ObservableQuery2);
    function reobserveCacheFirst2(obsQuery) {
      var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
      if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
        return obsQuery.reobserve({
          fetchPolicy: "cache-first",
          nextFetchPolicy: function(currentFetchPolicy, context) {
            this.nextFetchPolicy = nextFetchPolicy;
            if (typeof this.nextFetchPolicy === "function") {
              return this.nextFetchPolicy(currentFetchPolicy, context);
            }
            return fetchPolicy;
          }
        });
      }
      return obsQuery.reobserve();
    }
    function defaultSubscriptionObserverErrorCallback2(error) {
      globalThis.__DEV__ !== false && globals.invariant.error(23, error.message, error.stack);
    }
    function logMissingFieldErrors2(missing) {
      if (globalThis.__DEV__ !== false && missing) {
        globalThis.__DEV__ !== false && globals.invariant.debug(24, missing);
      }
    }
    function skipCacheDataFor2(fetchPolicy) {
      return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
    }
    var destructiveMethodCounts2 = new (utilities.canUseWeakMap ? WeakMap : Map)();
    function wrapDestructiveCacheMethod2(cache3, methodName) {
      var original = cache3[methodName];
      if (typeof original === "function") {
        cache3[methodName] = function() {
          destructiveMethodCounts2.set(
            cache3,
            (destructiveMethodCounts2.get(cache3) + 1) % 1e15
          );
          return original.apply(this, arguments);
        };
      }
    }
    function cancelNotifyTimeout2(info) {
      if (info["notifyTimeout"]) {
        clearTimeout(info["notifyTimeout"]);
        info["notifyTimeout"] = void 0;
      }
    }
    var QueryInfo2 = function() {
      function QueryInfo3(queryManager, queryId) {
        if (queryId === void 0) {
          queryId = queryManager.generateQueryId();
        }
        this.queryId = queryId;
        this.listeners = /* @__PURE__ */ new Set();
        this.document = null;
        this.lastRequestId = 1;
        this.stopped = false;
        this.dirty = false;
        this.observableQuery = null;
        var cache3 = this.cache = queryManager.cache;
        if (!destructiveMethodCounts2.has(cache3)) {
          destructiveMethodCounts2.set(cache3, 0);
          wrapDestructiveCacheMethod2(cache3, "evict");
          wrapDestructiveCacheMethod2(cache3, "modify");
          wrapDestructiveCacheMethod2(cache3, "reset");
        }
      }
      QueryInfo3.prototype.init = function(query) {
        var networkStatus = query.networkStatus || exports.NetworkStatus.loading;
        if (this.variables && this.networkStatus !== exports.NetworkStatus.loading && !equal2.equal(this.variables, query.variables)) {
          networkStatus = exports.NetworkStatus.setVariables;
        }
        if (!equal2.equal(query.variables, this.variables)) {
          this.lastDiff = void 0;
        }
        Object.assign(this, {
          document: query.document,
          variables: query.variables,
          networkError: null,
          graphQLErrors: this.graphQLErrors || [],
          networkStatus
        });
        if (query.observableQuery) {
          this.setObservableQuery(query.observableQuery);
        }
        if (query.lastRequestId) {
          this.lastRequestId = query.lastRequestId;
        }
        return this;
      };
      QueryInfo3.prototype.reset = function() {
        cancelNotifyTimeout2(this);
        this.dirty = false;
      };
      QueryInfo3.prototype.resetDiff = function() {
        this.lastDiff = void 0;
      };
      QueryInfo3.prototype.getDiff = function() {
        var options = this.getDiffOptions();
        if (this.lastDiff && equal2.equal(options, this.lastDiff.options)) {
          return this.lastDiff.diff;
        }
        this.updateWatch(this.variables);
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return { complete: false };
        }
        var diff = this.cache.diff(options);
        this.updateLastDiff(diff, options);
        return diff;
      };
      QueryInfo3.prototype.updateLastDiff = function(diff, options) {
        this.lastDiff = diff ? {
          diff,
          options: options || this.getDiffOptions()
        } : void 0;
      };
      QueryInfo3.prototype.getDiffOptions = function(variables) {
        var _a2;
        if (variables === void 0) {
          variables = this.variables;
        }
        return {
          query: this.document,
          variables,
          returnPartialData: true,
          optimistic: true,
          canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
        };
      };
      QueryInfo3.prototype.setDiff = function(diff) {
        var _this = this;
        var _a2;
        var oldDiff = this.lastDiff && this.lastDiff.diff;
        if (diff && !diff.complete && ((_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.getLastError())) {
          return;
        }
        this.updateLastDiff(diff);
        if (!this.dirty && !equal2.equal(oldDiff && oldDiff.result, diff && diff.result)) {
          this.dirty = true;
          if (!this.notifyTimeout) {
            this.notifyTimeout = setTimeout(function() {
              return _this.notify();
            }, 0);
          }
        }
      };
      QueryInfo3.prototype.setObservableQuery = function(oq) {
        var _this = this;
        if (oq === this.observableQuery)
          return;
        if (this.oqListener) {
          this.listeners.delete(this.oqListener);
        }
        this.observableQuery = oq;
        if (oq) {
          oq["queryInfo"] = this;
          this.listeners.add(this.oqListener = function() {
            var diff = _this.getDiff();
            if (diff.fromOptimisticTransaction) {
              oq["observe"]();
            } else {
              reobserveCacheFirst2(oq);
            }
          });
        } else {
          delete this.oqListener;
        }
      };
      QueryInfo3.prototype.notify = function() {
        var _this = this;
        cancelNotifyTimeout2(this);
        if (this.shouldNotify()) {
          this.listeners.forEach(function(listener) {
            return listener(_this);
          });
        }
        this.dirty = false;
      };
      QueryInfo3.prototype.shouldNotify = function() {
        if (!this.dirty || !this.listeners.size) {
          return false;
        }
        if (isNetworkRequestInFlight2(this.networkStatus) && this.observableQuery) {
          var fetchPolicy = this.observableQuery.options.fetchPolicy;
          if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
            return false;
          }
        }
        return true;
      };
      QueryInfo3.prototype.stop = function() {
        if (!this.stopped) {
          this.stopped = true;
          this.reset();
          this.cancel();
          this.cancel = QueryInfo3.prototype.cancel;
          var oq = this.observableQuery;
          if (oq)
            oq.stopPolling();
        }
      };
      QueryInfo3.prototype.cancel = function() {
      };
      QueryInfo3.prototype.updateWatch = function(variables) {
        var _this = this;
        if (variables === void 0) {
          variables = this.variables;
        }
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return;
        }
        var watchOptions = tslib.__assign(tslib.__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
          return _this.setDiff(diff);
        } });
        if (!this.lastWatch || !equal2.equal(watchOptions, this.lastWatch)) {
          this.cancel();
          this.cancel = this.cache.watch(this.lastWatch = watchOptions);
        }
      };
      QueryInfo3.prototype.resetLastWrite = function() {
        this.lastWrite = void 0;
      };
      QueryInfo3.prototype.shouldWrite = function(result2, variables) {
        var lastWrite = this.lastWrite;
        return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts2.get(this.cache) && equal2.equal(variables, lastWrite.variables) && equal2.equal(result2.data, lastWrite.result.data));
      };
      QueryInfo3.prototype.markResult = function(result2, document, options, cacheWriteBehavior) {
        var _this = this;
        var merger = new utilities.DeepMerger();
        var graphQLErrors = utilities.isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
        this.reset();
        if ("incremental" in result2 && utilities.isNonEmptyArray(result2.incremental)) {
          var mergedData = utilities.mergeIncrementalData(this.getDiff().result, result2);
          result2.data = mergedData;
        } else if ("hasNext" in result2 && result2.hasNext) {
          var diff = this.getDiff();
          result2.data = merger.merge(diff.result, result2.data);
        }
        this.graphQLErrors = graphQLErrors;
        if (options.fetchPolicy === "no-cache") {
          this.updateLastDiff({ result: result2.data, complete: true }, this.getDiffOptions(options.variables));
        } else if (cacheWriteBehavior !== 0) {
          if (shouldWriteResult2(result2, options.errorPolicy)) {
            this.cache.performTransaction(function(cache3) {
              if (_this.shouldWrite(result2, options.variables)) {
                cache3.writeQuery({
                  query: document,
                  data: result2.data,
                  variables: options.variables,
                  overwrite: cacheWriteBehavior === 1
                });
                _this.lastWrite = {
                  result: result2,
                  variables: options.variables,
                  dmCount: destructiveMethodCounts2.get(_this.cache)
                };
              } else {
                if (_this.lastDiff && _this.lastDiff.diff.complete) {
                  result2.data = _this.lastDiff.diff.result;
                  return;
                }
              }
              var diffOptions = _this.getDiffOptions(options.variables);
              var diff2 = cache3.diff(diffOptions);
              if (!_this.stopped && equal2.equal(_this.variables, options.variables)) {
                _this.updateWatch(options.variables);
              }
              _this.updateLastDiff(diff2, diffOptions);
              if (diff2.complete) {
                result2.data = diff2.result;
              }
            });
          } else {
            this.lastWrite = void 0;
          }
        }
      };
      QueryInfo3.prototype.markReady = function() {
        this.networkError = null;
        return this.networkStatus = exports.NetworkStatus.ready;
      };
      QueryInfo3.prototype.markError = function(error) {
        this.networkStatus = exports.NetworkStatus.error;
        this.lastWrite = void 0;
        this.reset();
        if (error.graphQLErrors) {
          this.graphQLErrors = error.graphQLErrors;
        }
        if (error.networkError) {
          this.networkError = error.networkError;
        }
        return error;
      };
      return QueryInfo3;
    }();
    function shouldWriteResult2(result2, errorPolicy) {
      if (errorPolicy === void 0) {
        errorPolicy = "none";
      }
      var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
      var writeWithErrors = !utilities.graphQLResultHasError(result2);
      if (!writeWithErrors && ignoreErrors && result2.data) {
        writeWithErrors = true;
      }
      return writeWithErrors;
    }
    var hasOwnProperty9 = Object.prototype.hasOwnProperty;
    var IGNORE2 = /* @__PURE__ */ Object.create(null);
    var QueryManager2 = function() {
      function QueryManager3(options) {
        var _this = this;
        this.clientAwareness = {};
        this.queries = /* @__PURE__ */ new Map();
        this.fetchCancelFns = /* @__PURE__ */ new Map();
        this.transformCache = new utilities.AutoCleanedWeakCache(utilities.cacheSizes["queryManager.getDocumentInfo"] || 2e3);
        this.queryIdCounter = 1;
        this.requestIdCounter = 1;
        this.mutationIdCounter = 1;
        this.inFlightLinkObservables = new trie.Trie(false);
        var defaultDocumentTransform = new utilities.DocumentTransform(
          function(document) {
            return _this.cache.transformDocument(document);
          },
          { cache: false }
        );
        this.cache = options.cache;
        this.link = options.link;
        this.defaultOptions = options.defaultOptions;
        this.queryDeduplication = options.queryDeduplication;
        this.clientAwareness = options.clientAwareness;
        this.localState = options.localState;
        this.ssrMode = options.ssrMode;
        this.assumeImmutableResults = options.assumeImmutableResults;
        var documentTransform = options.documentTransform;
        this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
        this.defaultContext = options.defaultContext || /* @__PURE__ */ Object.create(null);
        if (this.onBroadcast = options.onBroadcast) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
      }
      QueryManager3.prototype.stop = function() {
        var _this = this;
        this.queries.forEach(function(_info, queryId) {
          _this.stopQueryNoBroadcast(queryId);
        });
        this.cancelPendingFetches(globals.newInvariantError(25));
      };
      QueryManager3.prototype.cancelPendingFetches = function(error) {
        this.fetchCancelFns.forEach(function(cancel) {
          return cancel(error);
        });
        this.fetchCancelFns.clear();
      };
      QueryManager3.prototype.mutate = function(_a2) {
        return tslib.__awaiter(this, arguments, void 0, function(_b) {
          var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self2;
          var _c, _d;
          var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || "network-only" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b.keepRootFields, context = _b.context;
          return tslib.__generator(this, function(_j) {
            switch (_j.label) {
              case 0:
                globals.invariant(mutation, 26);
                globals.invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 27);
                mutationId = this.generateMutationId();
                mutation = this.cache.transformForLink(this.transform(mutation));
                hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
                variables = this.getVariables(mutation, variables);
                if (!hasClientExports2) return [3, 2];
                return [4, this.localState.addExportedVariables(mutation, variables, context)];
              case 1:
                variables = _j.sent();
                _j.label = 2;
              case 2:
                mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                  mutation,
                  variables,
                  loading: true,
                  error: null
                });
                isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                  mutationId,
                  document: mutation,
                  variables,
                  fetchPolicy,
                  errorPolicy,
                  context,
                  updateQueries,
                  update: updateWithProxyFn,
                  keepRootFields
                });
                this.broadcastQueries();
                self2 = this;
                return [2, new Promise(function(resolve, reject) {
                  return utilities.asyncMap(self2.getObservableFromLink(mutation, tslib.__assign(tslib.__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result2) {
                    if (utilities.graphQLResultHasError(result2) && errorPolicy === "none") {
                      throw new errors.ApolloError({
                        graphQLErrors: utilities.getGraphQLErrorsFromResult(result2)
                      });
                    }
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = null;
                    }
                    var storeResult = tslib.__assign({}, result2);
                    if (typeof refetchQueries === "function") {
                      refetchQueries = refetchQueries(storeResult);
                    }
                    if (errorPolicy === "ignore" && utilities.graphQLResultHasError(storeResult)) {
                      delete storeResult.errors;
                    }
                    return self2.markMutationResult({
                      mutationId,
                      result: storeResult,
                      document: mutation,
                      variables,
                      fetchPolicy,
                      errorPolicy,
                      context,
                      update: updateWithProxyFn,
                      updateQueries,
                      awaitRefetchQueries,
                      refetchQueries,
                      removeOptimistic: isOptimistic ? mutationId : void 0,
                      onQueryUpdated,
                      keepRootFields
                    });
                  }).subscribe({
                    next: function(storeResult) {
                      self2.broadcastQueries();
                      if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                        resolve(storeResult);
                      }
                    },
                    error: function(err) {
                      if (mutationStoreValue) {
                        mutationStoreValue.loading = false;
                        mutationStoreValue.error = err;
                      }
                      if (isOptimistic) {
                        self2.cache.removeOptimistic(mutationId);
                      }
                      self2.broadcastQueries();
                      reject(err instanceof errors.ApolloError ? err : new errors.ApolloError({
                        networkError: err
                      }));
                    }
                  });
                })];
            }
          });
        });
      };
      QueryManager3.prototype.markMutationResult = function(mutation, cache3) {
        var _this = this;
        if (cache3 === void 0) {
          cache3 = this.cache;
        }
        var result2 = mutation.result;
        var cacheWrites = [];
        var skipCache = mutation.fetchPolicy === "no-cache";
        if (!skipCache && shouldWriteResult2(result2, mutation.errorPolicy)) {
          if (!utilities.isExecutionPatchIncrementalResult(result2)) {
            cacheWrites.push({
              result: result2.data,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
          if (utilities.isExecutionPatchIncrementalResult(result2) && utilities.isNonEmptyArray(result2.incremental)) {
            var diff = cache3.diff({
              id: "ROOT_MUTATION",
              query: this.getDocumentInfo(mutation.document).asQuery,
              variables: mutation.variables,
              optimistic: false,
              returnPartialData: true
            });
            var mergedData = void 0;
            if (diff.result) {
              mergedData = mergeIncrementalData2(diff.result, result2);
            }
            if (typeof mergedData !== "undefined") {
              result2.data = mergedData;
              cacheWrites.push({
                result: mergedData,
                dataId: "ROOT_MUTATION",
                query: mutation.document,
                variables: mutation.variables
              });
            }
          }
          var updateQueries_1 = mutation.updateQueries;
          if (updateQueries_1) {
            this.queries.forEach(function(_a2, queryId) {
              var observableQuery = _a2.observableQuery;
              var queryName = observableQuery && observableQuery.queryName;
              if (!queryName || !hasOwnProperty9.call(updateQueries_1, queryName)) {
                return;
              }
              var updater = updateQueries_1[queryName];
              var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;
              var _c = cache3.diff({
                query: document,
                variables,
                returnPartialData: true,
                optimistic: false
              }), currentQueryResult = _c.result, complete = _c.complete;
              if (complete && currentQueryResult) {
                var nextQueryResult = updater(currentQueryResult, {
                  mutationResult: result2,
                  queryName: document && utilities.getOperationName(document) || void 0,
                  queryVariables: variables
                });
                if (nextQueryResult) {
                  cacheWrites.push({
                    result: nextQueryResult,
                    dataId: "ROOT_QUERY",
                    query: document,
                    variables
                  });
                }
              }
            });
          }
        }
        if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
          var results_1 = [];
          this.refetchQueries({
            updateCache: function(cache4) {
              if (!skipCache) {
                cacheWrites.forEach(function(write) {
                  return cache4.write(write);
                });
              }
              var update = mutation.update;
              var isFinalResult = !utilities.isExecutionPatchResult(result2) || utilities.isExecutionPatchIncrementalResult(result2) && !result2.hasNext;
              if (update) {
                if (!skipCache) {
                  var diff2 = cache4.diff({
                    id: "ROOT_MUTATION",
                    query: _this.getDocumentInfo(mutation.document).asQuery,
                    variables: mutation.variables,
                    optimistic: false,
                    returnPartialData: true
                  });
                  if (diff2.complete) {
                    result2 = tslib.__assign(tslib.__assign({}, result2), { data: diff2.result });
                    if ("incremental" in result2) {
                      delete result2.incremental;
                    }
                    if ("hasNext" in result2) {
                      delete result2.hasNext;
                    }
                  }
                }
                if (isFinalResult) {
                  update(cache4, result2, {
                    context: mutation.context,
                    variables: mutation.variables
                  });
                }
              }
              if (!skipCache && !mutation.keepRootFields && isFinalResult) {
                cache4.modify({
                  id: "ROOT_MUTATION",
                  fields: function(value, _a2) {
                    var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                    return fieldName === "__typename" ? value : DELETE2;
                  }
                });
              }
            },
            include: mutation.refetchQueries,
            optimistic: false,
            removeOptimistic: mutation.removeOptimistic,
            onQueryUpdated: mutation.onQueryUpdated || null
          }).forEach(function(result3) {
            return results_1.push(result3);
          });
          if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
            return Promise.all(results_1).then(function() {
              return result2;
            });
          }
        }
        return Promise.resolve(result2);
      };
      QueryManager3.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
        var _this = this;
        var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE: IGNORE2 }) : optimisticResponse;
        if (data === IGNORE2) {
          return false;
        }
        this.cache.recordOptimisticTransaction(function(cache3) {
          try {
            _this.markMutationResult(tslib.__assign(tslib.__assign({}, mutation), { result: { data } }), cache3);
          } catch (error) {
            globalThis.__DEV__ !== false && globals.invariant.error(error);
          }
        }, mutation.mutationId);
        return true;
      };
      QueryManager3.prototype.fetchQuery = function(queryId, options, networkStatus) {
        return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;
      };
      QueryManager3.prototype.getQueryStore = function() {
        var store = /* @__PURE__ */ Object.create(null);
        this.queries.forEach(function(info, queryId) {
          store[queryId] = {
            variables: info.variables,
            networkStatus: info.networkStatus,
            networkError: info.networkError,
            graphQLErrors: info.graphQLErrors
          };
        });
        return store;
      };
      QueryManager3.prototype.resetErrors = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo) {
          queryInfo.networkError = void 0;
          queryInfo.graphQLErrors = [];
        }
      };
      QueryManager3.prototype.transform = function(document) {
        return this.documentTransform.transformDocument(document);
      };
      QueryManager3.prototype.getDocumentInfo = function(document) {
        var transformCache = this.transformCache;
        if (!transformCache.has(document)) {
          var cacheEntry = {
            hasClientExports: utilities.hasClientExports(document),
            hasForcedResolvers: this.localState.shouldForceResolvers(document),
            hasNonreactiveDirective: utilities.hasDirectives(["nonreactive"], document),
            clientQuery: this.localState.clientQuery(document),
            serverQuery: utilities.removeDirectivesFromDocument([
              { name: "client", remove: true },
              { name: "connection" },
              { name: "nonreactive" }
            ], document),
            defaultVars: utilities.getDefaultValues(utilities.getOperationDefinition(document)),
            asQuery: tslib.__assign(tslib.__assign({}, document), { definitions: document.definitions.map(function(def) {
              if (def.kind === "OperationDefinition" && def.operation !== "query") {
                return tslib.__assign(tslib.__assign({}, def), { operation: "query" });
              }
              return def;
            }) })
          };
          transformCache.set(document, cacheEntry);
        }
        return transformCache.get(document);
      };
      QueryManager3.prototype.getVariables = function(document, variables) {
        return tslib.__assign(tslib.__assign({}, this.getDocumentInfo(document).defaultVars), variables);
      };
      QueryManager3.prototype.watchQuery = function(options) {
        var query = this.transform(options.query);
        options = tslib.__assign(tslib.__assign({}, options), { variables: this.getVariables(query, options.variables) });
        if (typeof options.notifyOnNetworkStatusChange === "undefined") {
          options.notifyOnNetworkStatusChange = false;
        }
        var queryInfo = new QueryInfo2(this);
        var observable = new ObservableQuery2({
          queryManager: this,
          queryInfo,
          options
        });
        observable["lastQuery"] = query;
        this.queries.set(observable.queryId, queryInfo);
        queryInfo.init({
          document: query,
          observableQuery: observable,
          variables: observable.variables
        });
        return observable;
      };
      QueryManager3.prototype.query = function(options, queryId) {
        var _this = this;
        if (queryId === void 0) {
          queryId = this.generateQueryId();
        }
        globals.invariant(options.query, 28);
        globals.invariant(options.query.kind === "Document", 29);
        globals.invariant(!options.returnPartialData, 30);
        globals.invariant(!options.pollInterval, 31);
        return this.fetchQuery(queryId, tslib.__assign(tslib.__assign({}, options), { query: this.transform(options.query) })).finally(function() {
          return _this.stopQuery(queryId);
        });
      };
      QueryManager3.prototype.generateQueryId = function() {
        return String(this.queryIdCounter++);
      };
      QueryManager3.prototype.generateRequestId = function() {
        return this.requestIdCounter++;
      };
      QueryManager3.prototype.generateMutationId = function() {
        return String(this.mutationIdCounter++);
      };
      QueryManager3.prototype.stopQueryInStore = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager3.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo)
          queryInfo.stop();
      };
      QueryManager3.prototype.clearStore = function(options) {
        if (options === void 0) {
          options = {
            discardWatches: true
          };
        }
        this.cancelPendingFetches(globals.newInvariantError(32));
        this.queries.forEach(function(queryInfo) {
          if (queryInfo.observableQuery) {
            queryInfo.networkStatus = exports.NetworkStatus.loading;
          } else {
            queryInfo.stop();
          }
        });
        if (this.mutationStore) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
        return this.cache.reset(options);
      };
      QueryManager3.prototype.getObservableQueries = function(include) {
        var _this = this;
        if (include === void 0) {
          include = "active";
        }
        var queries = /* @__PURE__ */ new Map();
        var queryNamesAndDocs = /* @__PURE__ */ new Map();
        var legacyQueryOptions = /* @__PURE__ */ new Set();
        if (Array.isArray(include)) {
          include.forEach(function(desc) {
            if (typeof desc === "string") {
              queryNamesAndDocs.set(desc, false);
            } else if (utilities.isDocumentNode(desc)) {
              queryNamesAndDocs.set(_this.transform(desc), false);
            } else if (utilities.isNonNullObject(desc) && desc.query) {
              legacyQueryOptions.add(desc);
            }
          });
        }
        this.queries.forEach(function(_a2, queryId) {
          var oq = _a2.observableQuery, document = _a2.document;
          if (oq) {
            if (include === "all") {
              queries.set(queryId, oq);
              return;
            }
            var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
            if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
              return;
            }
            if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {
              queries.set(queryId, oq);
              if (queryName)
                queryNamesAndDocs.set(queryName, true);
              if (document)
                queryNamesAndDocs.set(document, true);
            }
          }
        });
        if (legacyQueryOptions.size) {
          legacyQueryOptions.forEach(function(options) {
            var queryId = utilities.makeUniqueId("legacyOneTimeQuery");
            var queryInfo = _this.getQuery(queryId).init({
              document: options.query,
              variables: options.variables
            });
            var oq = new ObservableQuery2({
              queryManager: _this,
              queryInfo,
              options: tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "network-only" })
            });
            globals.invariant(oq.queryId === queryId);
            queryInfo.setObservableQuery(oq);
            queries.set(queryId, oq);
          });
        }
        if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {
          queryNamesAndDocs.forEach(function(included, nameOrDoc) {
            if (!included) {
              globalThis.__DEV__ !== false && globals.invariant.warn(typeof nameOrDoc === "string" ? 33 : 34, nameOrDoc);
            }
          });
        }
        return queries;
      };
      QueryManager3.prototype.reFetchObservableQueries = function(includeStandby) {
        var _this = this;
        if (includeStandby === void 0) {
          includeStandby = false;
        }
        var observableQueryPromises = [];
        this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
          var fetchPolicy = observableQuery.options.fetchPolicy;
          observableQuery.resetLastResults();
          if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
            observableQueryPromises.push(observableQuery.refetch());
          }
          _this.getQuery(queryId).setDiff(null);
        });
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
      };
      QueryManager3.prototype.setObservableQuery = function(observableQuery) {
        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
      };
      QueryManager3.prototype.startGraphQLSubscription = function(_a2) {
        var _this = this;
        var query = _a2.query, fetchPolicy = _a2.fetchPolicy, _b = _a2.errorPolicy, errorPolicy = _b === void 0 ? "none" : _b, variables = _a2.variables, _c = _a2.context, context = _c === void 0 ? {} : _c, _d = _a2.extensions, extensions = _d === void 0 ? {} : _d;
        query = this.transform(query);
        variables = this.getVariables(query, variables);
        var makeObservable = function(variables2) {
          return _this.getObservableFromLink(query, context, variables2, extensions).map(function(result2) {
            if (fetchPolicy !== "no-cache") {
              if (shouldWriteResult2(result2, errorPolicy)) {
                _this.cache.write({
                  query,
                  result: result2.data,
                  dataId: "ROOT_SUBSCRIPTION",
                  variables: variables2
                });
              }
              _this.broadcastQueries();
            }
            var hasErrors = utilities.graphQLResultHasError(result2);
            var hasProtocolErrors = errors.graphQLResultHasProtocolErrors(result2);
            if (hasErrors || hasProtocolErrors) {
              var errors$1 = {};
              if (hasErrors) {
                errors$1.graphQLErrors = result2.errors;
              }
              if (hasProtocolErrors) {
                errors$1.protocolErrors = result2.extensions[errors.PROTOCOL_ERRORS_SYMBOL];
              }
              if (errorPolicy === "none" || hasProtocolErrors) {
                throw new errors.ApolloError(errors$1);
              }
            }
            if (errorPolicy === "ignore") {
              delete result2.errors;
            }
            return result2;
          });
        };
        if (this.getDocumentInfo(query).hasClientExports) {
          var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
          return new utilities.Observable(function(observer) {
            var sub = null;
            observablePromise_1.then(function(observable) {
              return sub = observable.subscribe(observer);
            }, observer.error);
            return function() {
              return sub && sub.unsubscribe();
            };
          });
        }
        return makeObservable(variables);
      };
      QueryManager3.prototype.stopQuery = function(queryId) {
        this.stopQueryNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager3.prototype.stopQueryNoBroadcast = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.removeQuery(queryId);
      };
      QueryManager3.prototype.removeQuery = function(queryId) {
        this.fetchCancelFns.delete(queryId);
        if (this.queries.has(queryId)) {
          this.getQuery(queryId).stop();
          this.queries.delete(queryId);
        }
      };
      QueryManager3.prototype.broadcastQueries = function() {
        if (this.onBroadcast)
          this.onBroadcast();
        this.queries.forEach(function(info) {
          return info.notify();
        });
      };
      QueryManager3.prototype.getLocalState = function() {
        return this.localState;
      };
      QueryManager3.prototype.getObservableFromLink = function(query, context, variables, extensions, deduplication) {
        var _this = this;
        var _a2;
        if (deduplication === void 0) {
          deduplication = (_a2 = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
        }
        var observable;
        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
        if (serverQuery) {
          var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
          var operation = {
            query: serverQuery,
            variables,
            operationName: utilities.getOperationName(serverQuery) || void 0,
            context: this.prepareContext(tslib.__assign(tslib.__assign({}, context), { forceFetch: !deduplication })),
            extensions
          };
          context = operation.context;
          if (deduplication) {
            var printedServerQuery_1 = utilities.print(serverQuery);
            var varJson_1 = cache2.canonicalStringify(variables);
            var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
            observable = entry.observable;
            if (!observable) {
              var concast = new utilities.Concast([
                core.execute(link, operation)
              ]);
              observable = entry.observable = concast;
              concast.beforeNext(function() {
                inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
              });
            }
          } else {
            observable = new utilities.Concast([
              core.execute(link, operation)
            ]);
          }
        } else {
          observable = new utilities.Concast([utilities.Observable.of({ data: {} })]);
          context = this.prepareContext(context);
        }
        if (clientQuery) {
          observable = utilities.asyncMap(observable, function(result2) {
            return _this.localState.runResolvers({
              document: clientQuery,
              remoteResult: result2,
              context,
              variables
            });
          });
        }
        return observable;
      };
      QueryManager3.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
        var requestId = queryInfo.lastRequestId = this.generateRequestId();
        var linkDocument = this.cache.transformForLink(options.query);
        return utilities.asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result2) {
          var graphQLErrors = utilities.getGraphQLErrorsFromResult(result2);
          var hasErrors = graphQLErrors.length > 0;
          if (requestId >= queryInfo.lastRequestId) {
            if (hasErrors && options.errorPolicy === "none") {
              throw queryInfo.markError(new errors.ApolloError({
                graphQLErrors
              }));
            }
            queryInfo.markResult(result2, linkDocument, options, cacheWriteBehavior);
            queryInfo.markReady();
          }
          var aqr = {
            data: result2.data,
            loading: false,
            networkStatus: exports.NetworkStatus.ready
          };
          if (hasErrors && options.errorPolicy !== "ignore") {
            aqr.errors = graphQLErrors;
            aqr.networkStatus = exports.NetworkStatus.error;
          }
          return aqr;
        }, function(networkError) {
          var error = errors.isApolloError(networkError) ? networkError : new errors.ApolloError({ networkError });
          if (requestId >= queryInfo.lastRequestId) {
            queryInfo.markError(error);
          }
          throw error;
        });
      };
      QueryManager3.prototype.fetchConcastWithInfo = function(queryId, options, networkStatus, query) {
        var _this = this;
        if (networkStatus === void 0) {
          networkStatus = exports.NetworkStatus.loading;
        }
        if (query === void 0) {
          query = options.query;
        }
        var variables = this.getVariables(query, options.variables);
        var queryInfo = this.getQuery(queryId);
        var defaults = this.defaultOptions.watchQuery;
        var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
        var normalized = Object.assign({}, options, {
          query,
          variables,
          fetchPolicy,
          errorPolicy,
          returnPartialData,
          notifyOnNetworkStatusChange,
          context
        });
        var fromVariables = function(variables2) {
          normalized.variables = variables2;
          var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
          if (normalized.fetchPolicy !== "standby" && sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery) {
            queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
          }
          return sourcesWithInfo2;
        };
        var cleanupCancelFn = function() {
          return _this.fetchCancelFns.delete(queryId);
        };
        this.fetchCancelFns.set(queryId, function(reason) {
          cleanupCancelFn();
          setTimeout(function() {
            return concast.cancel(reason);
          });
        });
        var concast, containsDataFromLink;
        if (this.getDocumentInfo(normalized.query).hasClientExports) {
          concast = new utilities.Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
            return sourcesWithInfo2.sources;
          }));
          containsDataFromLink = true;
        } else {
          var sourcesWithInfo = fromVariables(normalized.variables);
          containsDataFromLink = sourcesWithInfo.fromLink;
          concast = new utilities.Concast(sourcesWithInfo.sources);
        }
        concast.promise.then(cleanupCancelFn, cleanupCancelFn);
        return {
          concast,
          fromLink: containsDataFromLink
        };
      };
      QueryManager3.prototype.refetchQueries = function(_a2) {
        var _this = this;
        var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? utilities.makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
        var includedQueriesById = /* @__PURE__ */ new Map();
        if (include) {
          this.getObservableQueries(include).forEach(function(oq, queryId) {
            includedQueriesById.set(queryId, {
              oq,
              lastDiff: _this.getQuery(queryId).getDiff()
            });
          });
        }
        var results = /* @__PURE__ */ new Map();
        if (updateCache) {
          this.cache.batch({
            update: updateCache,
            optimistic: optimistic && removeOptimistic || false,
            removeOptimistic,
            onWatchUpdated: function(watch, diff, lastDiff) {
              var oq = watch.watcher instanceof QueryInfo2 && watch.watcher.observableQuery;
              if (oq) {
                if (onQueryUpdated) {
                  includedQueriesById.delete(oq.queryId);
                  var result2 = onQueryUpdated(oq, diff, lastDiff);
                  if (result2 === true) {
                    result2 = oq.refetch();
                  }
                  if (result2 !== false) {
                    results.set(oq, result2);
                  }
                  return result2;
                }
                if (onQueryUpdated !== null) {
                  includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
                }
              }
            }
          });
        }
        if (includedQueriesById.size) {
          includedQueriesById.forEach(function(_a3, queryId) {
            var oq = _a3.oq, lastDiff = _a3.lastDiff, diff = _a3.diff;
            var result2;
            if (onQueryUpdated) {
              if (!diff) {
                var info = oq["queryInfo"];
                info.reset();
                diff = info.getDiff();
              }
              result2 = onQueryUpdated(oq, diff, lastDiff);
            }
            if (!onQueryUpdated || result2 === true) {
              result2 = oq.refetch();
            }
            if (result2 !== false) {
              results.set(oq, result2);
            }
            if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
              _this.stopQueryNoBroadcast(queryId);
            }
          });
        }
        if (removeOptimistic) {
          this.cache.removeOptimistic(removeOptimistic);
        }
        return results;
      };
      QueryManager3.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
        var _this = this;
        var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
        var oldNetworkStatus = queryInfo.networkStatus;
        queryInfo.init({
          document: query,
          variables,
          networkStatus
        });
        var readCache = function() {
          return queryInfo.getDiff();
        };
        var resultsFromCache = function(diff2, networkStatus2) {
          if (networkStatus2 === void 0) {
            networkStatus2 = queryInfo.networkStatus || exports.NetworkStatus.loading;
          }
          var data = diff2.result;
          if (globalThis.__DEV__ !== false && !returnPartialData && !equal2.equal(data, {})) {
            logMissingFieldErrors2(diff2.missing);
          }
          var fromData = function(data2) {
            return utilities.Observable.of(tslib.__assign({ data: data2, loading: isNetworkRequestInFlight2(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
          };
          if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
            return _this.localState.runResolvers({
              document: query,
              remoteResult: { data },
              context,
              variables,
              onlyRunForcedResolvers: true
            }).then(function(resolved) {
              return fromData(resolved.data || void 0);
            });
          }
          if (errorPolicy === "none" && networkStatus2 === exports.NetworkStatus.refetch && Array.isArray(diff2.missing)) {
            return fromData(void 0);
          }
          return fromData(data);
        };
        var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === exports.NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
        var resultsFromLink = function() {
          return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
            query,
            variables,
            context,
            fetchPolicy,
            errorPolicy
          });
        };
        var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight2(networkStatus);
        switch (fetchPolicy) {
          default:
          case "cache-first": {
            var diff = readCache();
            if (diff.complete) {
              return {
                fromLink: false,
                sources: [resultsFromCache(diff, queryInfo.markReady())]
              };
            }
            if (returnPartialData || shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(diff), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          }
          case "cache-and-network": {
            var diff = readCache();
            if (diff.complete || returnPartialData || shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(diff), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          }
          case "cache-only":
            return {
              fromLink: false,
              sources: [resultsFromCache(readCache(), queryInfo.markReady())]
            };
          case "network-only":
            if (shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(readCache()), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          case "no-cache":
            if (shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          case "standby":
            return { fromLink: false, sources: [] };
        }
      };
      QueryManager3.prototype.getQuery = function(queryId) {
        if (queryId && !this.queries.has(queryId)) {
          this.queries.set(queryId, new QueryInfo2(this, queryId));
        }
        return this.queries.get(queryId);
      };
      QueryManager3.prototype.prepareContext = function(context) {
        if (context === void 0) {
          context = {};
        }
        var newContext = this.localState.prepareContext(context);
        return tslib.__assign(tslib.__assign(tslib.__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
      };
      return QueryManager3;
    }();
    var LocalState2 = function() {
      function LocalState3(_a2) {
        var cache3 = _a2.cache, client = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
        this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
        this.cache = cache3;
        if (client) {
          this.client = client;
        }
        if (resolvers) {
          this.addResolvers(resolvers);
        }
        if (fragmentMatcher) {
          this.setFragmentMatcher(fragmentMatcher);
        }
      }
      LocalState3.prototype.addResolvers = function(resolvers) {
        var _this = this;
        this.resolvers = this.resolvers || {};
        if (Array.isArray(resolvers)) {
          resolvers.forEach(function(resolverGroup) {
            _this.resolvers = utilities.mergeDeep(_this.resolvers, resolverGroup);
          });
        } else {
          this.resolvers = utilities.mergeDeep(this.resolvers, resolvers);
        }
      };
      LocalState3.prototype.setResolvers = function(resolvers) {
        this.resolvers = {};
        this.addResolvers(resolvers);
      };
      LocalState3.prototype.getResolvers = function() {
        return this.resolvers || {};
      };
      LocalState3.prototype.runResolvers = function(_a2) {
        return tslib.__awaiter(this, arguments, void 0, function(_b) {
          var document = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;
          return tslib.__generator(this, function(_d) {
            if (document) {
              return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
                return tslib.__assign(tslib.__assign({}, remoteResult), { data: localResult.result });
              })];
            }
            return [2, remoteResult];
          });
        });
      };
      LocalState3.prototype.setFragmentMatcher = function(fragmentMatcher) {
        this.fragmentMatcher = fragmentMatcher;
      };
      LocalState3.prototype.getFragmentMatcher = function() {
        return this.fragmentMatcher;
      };
      LocalState3.prototype.clientQuery = function(document) {
        if (utilities.hasDirectives(["client"], document)) {
          if (this.resolvers) {
            return document;
          }
        }
        return null;
      };
      LocalState3.prototype.serverQuery = function(document) {
        return utilities.removeClientSetsFromDocument(document);
      };
      LocalState3.prototype.prepareContext = function(context) {
        var cache3 = this.cache;
        return tslib.__assign(tslib.__assign({}, context), {
          cache: cache3,
          getCacheKey: function(obj) {
            return cache3.identify(obj);
          }
        });
      };
      LocalState3.prototype.addExportedVariables = function(document_1) {
        return tslib.__awaiter(this, arguments, void 0, function(document, variables, context) {
          if (variables === void 0) {
            variables = {};
          }
          if (context === void 0) {
            context = {};
          }
          return tslib.__generator(this, function(_a2) {
            if (document) {
              return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function(data) {
                return tslib.__assign(tslib.__assign({}, variables), data.exportedVariables);
              })];
            }
            return [2, tslib.__assign({}, variables)];
          });
        });
      };
      LocalState3.prototype.shouldForceResolvers = function(document) {
        var forceResolvers = false;
        graphql.visit(document, {
          Directive: {
            enter: function(node) {
              if (node.name.value === "client" && node.arguments) {
                forceResolvers = node.arguments.some(function(arg) {
                  return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
                });
                if (forceResolvers) {
                  return graphql.BREAK;
                }
              }
            }
          }
        });
        return forceResolvers;
      };
      LocalState3.prototype.buildRootValueFromCache = function(document, variables) {
        return this.cache.diff({
          query: utilities.buildQueryFromSelectionSet(document),
          variables,
          returnPartialData: true,
          optimistic: false
        }).result;
      };
      LocalState3.prototype.resolveDocument = function(document_1, rootValue_1) {
        return tslib.__awaiter(this, arguments, void 0, function(document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
          var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a2, cache3, client, execContext, isClientFieldDescendant;
          if (context === void 0) {
            context = {};
          }
          if (variables === void 0) {
            variables = {};
          }
          if (fragmentMatcher === void 0) {
            fragmentMatcher = function() {
              return true;
            };
          }
          if (onlyRunForcedResolvers === void 0) {
            onlyRunForcedResolvers = false;
          }
          return tslib.__generator(this, function(_b) {
            mainDefinition = utilities.getMainDefinition(document);
            fragments = utilities.getFragmentDefinitions(document);
            fragmentMap = utilities.createFragmentMap(fragments);
            selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
            definitionOperation = mainDefinition.operation;
            defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
            _a2 = this, cache3 = _a2.cache, client = _a2.client;
            execContext = {
              fragmentMap,
              context: tslib.__assign(tslib.__assign({}, context), { cache: cache3, client }),
              variables,
              fragmentMatcher,
              defaultOperationType,
              exportedVariables: {},
              selectionsToResolve,
              onlyRunForcedResolvers
            };
            isClientFieldDescendant = false;
            return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result2) {
              return {
                result: result2,
                exportedVariables: execContext.exportedVariables
              };
            })];
          });
        });
      };
      LocalState3.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var fragmentMap, context, variables, resultsToMerge, execute2;
          var _this = this;
          return tslib.__generator(this, function(_a2) {
            fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
            resultsToMerge = [rootValue];
            execute2 = function(selection) {
              return tslib.__awaiter(_this, void 0, void 0, function() {
                var fragment, typeCondition;
                return tslib.__generator(this, function(_a3) {
                  if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                    return [2];
                  }
                  if (!utilities.shouldInclude(selection, variables)) {
                    return [2];
                  }
                  if (utilities.isField(selection)) {
                    return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                      var _a4;
                      if (typeof fieldResult !== "undefined") {
                        resultsToMerge.push((_a4 = {}, _a4[utilities.resultKeyNameFromField(selection)] = fieldResult, _a4));
                      }
                    })];
                  }
                  if (utilities.isInlineFragment(selection)) {
                    fragment = selection;
                  } else {
                    fragment = fragmentMap[selection.name.value];
                    globals.invariant(fragment, 18, selection.name.value);
                  }
                  if (fragment && fragment.typeCondition) {
                    typeCondition = fragment.typeCondition.name.value;
                    if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                      return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                        resultsToMerge.push(fragmentResult);
                      })];
                    }
                  }
                  return [2];
                });
              });
            };
            return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
              return utilities.mergeDeepArray(resultsToMerge);
            })];
          });
        });
      };
      LocalState3.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
          var _this = this;
          return tslib.__generator(this, function(_a2) {
            if (!rootValue) {
              return [2, null];
            }
            variables = execContext.variables;
            fieldName = field.name.value;
            aliasedFieldName = utilities.resultKeyNameFromField(field);
            aliasUsed = fieldName !== aliasedFieldName;
            defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
            resultPromise = Promise.resolve(defaultResult);
            if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
              resolverType = rootValue.__typename || execContext.defaultOperationType;
              resolverMap = this.resolvers && this.resolvers[resolverType];
              if (resolverMap) {
                resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                if (resolve) {
                  resultPromise = Promise.resolve(
                    cache2.cacheSlot.withValue(this.cache, resolve, [
                      rootValue,
                      utilities.argumentsObjectFromField(field, variables),
                      execContext.context,
                      { field, fragmentMap: execContext.fragmentMap }
                    ])
                  );
                }
              }
            }
            return [2, resultPromise.then(function(result2) {
              var _a3, _b;
              if (result2 === void 0) {
                result2 = defaultResult;
              }
              if (field.directives) {
                field.directives.forEach(function(directive) {
                  if (directive.name.value === "export" && directive.arguments) {
                    directive.arguments.forEach(function(arg) {
                      if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                        execContext.exportedVariables[arg.value.value] = result2;
                      }
                    });
                  }
                });
              }
              if (!field.selectionSet) {
                return result2;
              }
              if (result2 == null) {
                return result2;
              }
              var isClientField = (_b = (_a3 = field.directives) === null || _a3 === void 0 ? void 0 : _a3.some(function(d) {
                return d.name.value === "client";
              })) !== null && _b !== void 0 ? _b : false;
              if (Array.isArray(result2)) {
                return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result2, execContext);
              }
              if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result2, execContext);
              }
            })];
          });
        });
      };
      LocalState3.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result2, execContext) {
        var _this = this;
        return Promise.all(result2.map(function(item) {
          if (item === null) {
            return null;
          }
          if (Array.isArray(item)) {
            return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
          }
        }));
      };
      LocalState3.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
        var isSingleASTNode = function(node) {
          return !Array.isArray(node);
        };
        var selectionsToResolveCache = this.selectionsToResolveCache;
        function collectByDefinition(definitionNode) {
          if (!selectionsToResolveCache.has(definitionNode)) {
            var matches_1 = /* @__PURE__ */ new Set();
            selectionsToResolveCache.set(definitionNode, matches_1);
            graphql.visit(definitionNode, {
              Directive: function(node, _, __, ___, ancestors) {
                if (node.name.value === "client") {
                  ancestors.forEach(function(node2) {
                    if (isSingleASTNode(node2) && graphql.isSelectionNode(node2)) {
                      matches_1.add(node2);
                    }
                  });
                }
              },
              FragmentSpread: function(spread, _, __, ___, ancestors) {
                var fragment = fragmentMap[spread.name.value];
                globals.invariant(fragment, 19, spread.name.value);
                var fragmentSelections = collectByDefinition(fragment);
                if (fragmentSelections.size > 0) {
                  ancestors.forEach(function(node) {
                    if (isSingleASTNode(node) && graphql.isSelectionNode(node)) {
                      matches_1.add(node);
                    }
                  });
                  matches_1.add(spread);
                  fragmentSelections.forEach(function(selection) {
                    matches_1.add(selection);
                  });
                }
              }
            });
          }
          return selectionsToResolveCache.get(definitionNode);
        }
        return collectByDefinition(mainDefinition);
      };
      return LocalState3;
    }();
    var cacheSizeSymbol2 = Symbol.for("apollo.cacheSize");
    var cacheSizes2 = tslib.__assign({}, globals.global[cacheSizeSymbol2]);
    var globalCaches2 = {};
    var getApolloClientMemoryInternals2 = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals2 : void 0;
    function getCurrentCacheSizes2() {
      var defaults = {
        parser: 1e3,
        canonicalStringify: 1e3,
        print: 2e3,
        "documentTransform.cache": 2e3,
        "queryManager.getDocumentInfo": 2e3,
        "PersistedQueryLink.persistedQueryHashes": 2e3,
        "fragmentRegistry.transform": 2e3,
        "fragmentRegistry.lookup": 1e3,
        "fragmentRegistry.findFragmentSpreads": 4e3,
        "cache.fragmentQueryDocuments": 1e3,
        "removeTypenameFromVariables.getVariableDefinitions": 2e3,
        "inMemoryCache.maybeBroadcastWatch": 5e3,
        "inMemoryCache.executeSelectionSet": 5e4,
        "inMemoryCache.executeSubSelectedArray": 1e4
      };
      return Object.fromEntries(Object.entries(defaults).map(function(_a2) {
        var k2 = _a2[0], v = _a2[1];
        return [
          k2,
          cacheSizes2[k2] || v
        ];
      }));
    }
    function _getApolloClientMemoryInternals2() {
      var _a2, _b, _c, _d, _e;
      if (!(globalThis.__DEV__ !== false))
        throw new Error("only supported in development mode");
      return {
        limits: getCurrentCacheSizes2(),
        sizes: tslib.__assign({ print: (_a2 = globalCaches2.print) === null || _a2 === void 0 ? void 0 : _a2.call(globalCaches2), parser: (_b = globalCaches2.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches2), canonicalStringify: (_c = globalCaches2.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches2), links: linkInfo2(this.link), queryManager: {
          getDocumentInfo: this["queryManager"]["transformCache"].size,
          documentTransforms: transformInfo2(this["queryManager"].documentTransform)
        } }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))
      };
    }
    function isWrapper2(f) {
      return !!f && "dirtyKey" in f;
    }
    function getWrapperInformation2(f) {
      return isWrapper2(f) ? f.size : void 0;
    }
    function isDefined2(value) {
      return value != null;
    }
    function transformInfo2(transform) {
      return recurseTransformInfo2(transform).map(function(cache3) {
        return { cache: cache3 };
      });
    }
    function recurseTransformInfo2(transform) {
      return transform ? tslib.__spreadArray(tslib.__spreadArray([
        getWrapperInformation2(transform === null || transform === void 0 ? void 0 : transform["performWork"])
      ], recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined2) : [];
    }
    function linkInfo2(link) {
      var _a2;
      return link ? tslib.__spreadArray(tslib.__spreadArray([
        (_a2 = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a2 === void 0 ? void 0 : _a2.call(link)
      ], linkInfo2(link === null || link === void 0 ? void 0 : link.left), true), linkInfo2(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined2) : [];
    }
    var hasSuggestedDevtools2 = false;
    var ApolloClient2 = function() {
      function ApolloClient3(options) {
        var _this = this;
        this.resetStoreCallbacks = [];
        this.clearStoreCallbacks = [];
        if (!options.cache) {
          throw globals.newInvariantError(15);
        }
        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache3 = options.cache, documentTransform = options.documentTransform, _a2 = options.ssrMode, ssrMode = _a2 === void 0 ? false : _a2, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions2 = options.defaultOptions, defaultContext = options.defaultContext, _d = options.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? cache3.assumeImmutableResults : _d, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version, devtools = options.devtools;
        var link = options.link;
        if (!link) {
          link = uri ? new http.HttpLink({ uri, credentials, headers }) : core.ApolloLink.empty();
        }
        this.link = link;
        this.cache = cache3;
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
        this.typeDefs = typeDefs;
        this.devtoolsConfig = tslib.__assign(tslib.__assign({}, devtools), { enabled: (devtools === null || devtools === void 0 ? void 0 : devtools.enabled) || connectToDevTools });
        if (this.devtoolsConfig.enabled === void 0) {
          this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
        }
        if (ssrForceFetchDelay) {
          setTimeout(function() {
            return _this.disableNetworkFetches = false;
          }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.watchFragment = this.watchFragment.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        this.version = version2;
        this.localState = new LocalState2({
          cache: cache3,
          client: this,
          resolvers,
          fragmentMatcher
        });
        this.queryManager = new QueryManager2({
          cache: this.cache,
          link: this.link,
          defaultOptions: this.defaultOptions,
          defaultContext,
          documentTransform,
          queryDeduplication,
          ssrMode,
          clientAwareness: {
            name: clientAwarenessName,
            version: clientAwarenessVersion
          },
          localState: this.localState,
          assumeImmutableResults,
          onBroadcast: this.devtoolsConfig.enabled ? function() {
            if (_this.devToolsHookCb) {
              _this.devToolsHookCb({
                action: {},
                state: {
                  queries: _this.queryManager.getQueryStore(),
                  mutations: _this.queryManager.mutationStore || {}
                },
                dataWithOptimisticResults: _this.cache.extract(true)
              });
            }
          } : void 0
        });
        if (this.devtoolsConfig.enabled)
          this.connectToDevTools();
      }
      ApolloClient3.prototype.connectToDevTools = function() {
        if (typeof window === "undefined") {
          return;
        }
        var windowWithDevTools = window;
        var devtoolsSymbol = Symbol.for("apollo.devtools");
        (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
        windowWithDevTools.__APOLLO_CLIENT__ = this;
        if (!hasSuggestedDevtools2 && globalThis.__DEV__ !== false) {
          hasSuggestedDevtools2 = true;
          if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
            setTimeout(function() {
              if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
                var nav = window.navigator;
                var ua = nav && nav.userAgent;
                var url = void 0;
                if (typeof ua === "string") {
                  if (ua.indexOf("Chrome/") > -1) {
                    url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                  } else if (ua.indexOf("Firefox/") > -1) {
                    url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                  }
                }
                if (url) {
                  globalThis.__DEV__ !== false && globals.invariant.log("Download the Apollo DevTools for a better development experience: %s", url);
                }
              }
            }, 1e4);
          }
        }
      };
      Object.defineProperty(ApolloClient3.prototype, "documentTransform", {
        get: function() {
          return this.queryManager.documentTransform;
        },
        enumerable: false,
        configurable: true
      });
      ApolloClient3.prototype.stop = function() {
        this.queryManager.stop();
      };
      ApolloClient3.prototype.watchQuery = function(options) {
        if (this.defaultOptions.watchQuery) {
          options = utilities.mergeOptions(this.defaultOptions.watchQuery, options);
        }
        if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
          options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.watchQuery(options);
      };
      ApolloClient3.prototype.query = function(options) {
        if (this.defaultOptions.query) {
          options = utilities.mergeOptions(this.defaultOptions.query, options);
        }
        globals.invariant(options.fetchPolicy !== "cache-and-network", 16);
        if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
          options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.query(options);
      };
      ApolloClient3.prototype.mutate = function(options) {
        if (this.defaultOptions.mutate) {
          options = utilities.mergeOptions(this.defaultOptions.mutate, options);
        }
        return this.queryManager.mutate(options);
      };
      ApolloClient3.prototype.subscribe = function(options) {
        return this.queryManager.startGraphQLSubscription(options);
      };
      ApolloClient3.prototype.readQuery = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readQuery(options, optimistic);
      };
      ApolloClient3.prototype.watchFragment = function(options) {
        return this.cache.watchFragment(options);
      };
      ApolloClient3.prototype.readFragment = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readFragment(options, optimistic);
      };
      ApolloClient3.prototype.writeQuery = function(options) {
        var ref = this.cache.writeQuery(options);
        if (options.broadcast !== false) {
          this.queryManager.broadcastQueries();
        }
        return ref;
      };
      ApolloClient3.prototype.writeFragment = function(options) {
        var ref = this.cache.writeFragment(options);
        if (options.broadcast !== false) {
          this.queryManager.broadcastQueries();
        }
        return ref;
      };
      ApolloClient3.prototype.__actionHookForDevTools = function(cb) {
        this.devToolsHookCb = cb;
      };
      ApolloClient3.prototype.__requestRaw = function(payload) {
        return core.execute(this.link, payload);
      };
      ApolloClient3.prototype.resetStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: false
          });
        }).then(function() {
          return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
            return fn();
          }));
        }).then(function() {
          return _this.reFetchObservableQueries();
        });
      };
      ApolloClient3.prototype.clearStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: true
          });
        }).then(function() {
          return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
            return fn();
          }));
        });
      };
      ApolloClient3.prototype.onResetStore = function(cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function() {
          _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient3.prototype.onClearStore = function(cb) {
        var _this = this;
        this.clearStoreCallbacks.push(cb);
        return function() {
          _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient3.prototype.reFetchObservableQueries = function(includeStandby) {
        return this.queryManager.reFetchObservableQueries(includeStandby);
      };
      ApolloClient3.prototype.refetchQueries = function(options) {
        var map = this.queryManager.refetchQueries(options);
        var queries = [];
        var results = [];
        map.forEach(function(result3, obsQuery) {
          queries.push(obsQuery);
          results.push(result3);
        });
        var result2 = Promise.all(results);
        result2.queries = queries;
        result2.results = results;
        result2.catch(function(error) {
          globalThis.__DEV__ !== false && globals.invariant.debug(17, error);
        });
        return result2;
      };
      ApolloClient3.prototype.getObservableQueries = function(include) {
        if (include === void 0) {
          include = "active";
        }
        return this.queryManager.getObservableQueries(include);
      };
      ApolloClient3.prototype.extract = function(optimistic) {
        return this.cache.extract(optimistic);
      };
      ApolloClient3.prototype.restore = function(serializedState) {
        return this.cache.restore(serializedState);
      };
      ApolloClient3.prototype.addResolvers = function(resolvers) {
        this.localState.addResolvers(resolvers);
      };
      ApolloClient3.prototype.setResolvers = function(resolvers) {
        this.localState.setResolvers(resolvers);
      };
      ApolloClient3.prototype.getResolvers = function() {
        return this.localState.getResolvers();
      };
      ApolloClient3.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
        this.localState.setFragmentMatcher(fragmentMatcher);
      };
      ApolloClient3.prototype.setLink = function(newLink) {
        this.link = this.queryManager.link = newLink;
      };
      Object.defineProperty(ApolloClient3.prototype, "defaultContext", {
        get: function() {
          return this.queryManager.defaultContext;
        },
        enumerable: false,
        configurable: true
      });
      return ApolloClient3;
    }();
    if (globalThis.__DEV__ !== false) {
      ApolloClient2.prototype.getMemoryInternals = getApolloClientMemoryInternals2;
    }
    tsInvariant.setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");
    exports.DocumentTransform = utilities.DocumentTransform;
    exports.Observable = utilities.Observable;
    exports.isReference = utilities.isReference;
    exports.makeReference = utilities.makeReference;
    exports.mergeOptions = utilities.mergeOptions;
    exports.ApolloCache = cache2.ApolloCache;
    exports.Cache = cache2.Cache;
    exports.InMemoryCache = cache2.InMemoryCache;
    exports.MissingFieldError = cache2.MissingFieldError;
    exports.defaultDataIdFromObject = cache2.defaultDataIdFromObject;
    exports.makeVar = cache2.makeVar;
    exports.ApolloError = errors.ApolloError;
    exports.isApolloError = errors.isApolloError;
    exports.fromError = utils.fromError;
    exports.fromPromise = utils.fromPromise;
    exports.throwServerError = utils.throwServerError;
    exports.toPromise = utils.toPromise;
    exports.setLogVerbosity = tsInvariant.setVerbosity;
    exports.disableExperimentalFragmentVariables = graphqlTag.disableExperimentalFragmentVariables;
    exports.disableFragmentWarnings = graphqlTag.disableFragmentWarnings;
    exports.enableExperimentalFragmentVariables = graphqlTag.enableExperimentalFragmentVariables;
    exports.gql = graphqlTag.gql;
    exports.resetCaches = graphqlTag.resetCaches;
    exports.ApolloClient = ApolloClient2;
    exports.ObservableQuery = ObservableQuery2;
    exports.isNetworkRequestSettled = isNetworkRequestSettled2;
    for (k in core) {
      if (k !== "default" && !exports.hasOwnProperty(k)) exports[k] = core[k];
    }
    var k;
    for (k in http) {
      if (k !== "default" && !exports.hasOwnProperty(k)) exports[k] = http[k];
    }
    var k;
  }
});

// ../node_modules/@apollo/client/react/context/context.cjs
var require_context = __commonJS({
  "../node_modules/@apollo/client/react/context/context.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var React24 = require_rehackt();
    var utilities = require_utilities();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React24);
    var contextKey2 = utilities.canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
    function getApolloContext2() {
      globals.invariant("createContext" in React__namespace, 45);
      var context = React__namespace.createContext[contextKey2];
      if (!context) {
        Object.defineProperty(React__namespace.createContext, contextKey2, {
          value: context = React__namespace.createContext({}),
          enumerable: false,
          writable: false,
          configurable: true
        });
        context.displayName = "ApolloContext";
      }
      return context;
    }
    var resetApolloContext2 = getApolloContext2;
    var ApolloConsumer2 = function(props) {
      var ApolloContext = getApolloContext2();
      return React__namespace.createElement(ApolloContext.Consumer, null, function(context) {
        globals.invariant(context && context.client, 44);
        return props.children(context.client);
      });
    };
    var ApolloProvider2 = function(_a2) {
      var client = _a2.client, children = _a2.children;
      var ApolloContext = getApolloContext2();
      var parentContext = React__namespace.useContext(ApolloContext);
      var context = React__namespace.useMemo(function() {
        return tslib.__assign(tslib.__assign({}, parentContext), { client: client || parentContext.client });
      }, [parentContext, client]);
      globals.invariant(context.client, 46);
      return React__namespace.createElement(ApolloContext.Provider, { value: context }, children);
    };
    exports.ApolloConsumer = ApolloConsumer2;
    exports.ApolloProvider = ApolloProvider2;
    exports.getApolloContext = getApolloContext2;
    exports.resetApolloContext = resetApolloContext2;
  }
});

// ../node_modules/@apollo/client/react/parser/parser.cjs
var require_parser = __commonJS({
  "../node_modules/@apollo/client/react/parser/parser.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var utilities = require_utilities();
    init_tslib_es6();
    var globalCaches2 = {};
    function registerGlobalCache2(name, getSize) {
      globalCaches2[name] = getSize;
    }
    exports.DocumentType = void 0;
    (function(DocumentType2) {
      DocumentType2[DocumentType2["Query"] = 0] = "Query";
      DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
      DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
    })(exports.DocumentType || (exports.DocumentType = {}));
    var cache2;
    function operationName2(type) {
      var name;
      switch (type) {
        case exports.DocumentType.Query:
          name = "Query";
          break;
        case exports.DocumentType.Mutation:
          name = "Mutation";
          break;
        case exports.DocumentType.Subscription:
          name = "Subscription";
          break;
      }
      return name;
    }
    function parser2(document) {
      if (!cache2) {
        cache2 = new utilities.AutoCleanedWeakCache(utilities.cacheSizes.parser || 1e3);
      }
      var cached = cache2.get(document);
      if (cached)
        return cached;
      var variables, type, name;
      globals.invariant(!!document && !!document.kind, 61, document);
      var fragments = [];
      var queries = [];
      var mutations = [];
      var subscriptions = [];
      for (var _i = 0, _a2 = document.definitions; _i < _a2.length; _i++) {
        var x = _a2[_i];
        if (x.kind === "FragmentDefinition") {
          fragments.push(x);
          continue;
        }
        if (x.kind === "OperationDefinition") {
          switch (x.operation) {
            case "query":
              queries.push(x);
              break;
            case "mutation":
              mutations.push(x);
              break;
            case "subscription":
              subscriptions.push(x);
              break;
          }
        }
      }
      globals.invariant(!fragments.length || queries.length || mutations.length || subscriptions.length, 62);
      globals.invariant(
        queries.length + mutations.length + subscriptions.length <= 1,
        63,
        document,
        queries.length,
        subscriptions.length,
        mutations.length
      );
      type = queries.length ? exports.DocumentType.Query : exports.DocumentType.Mutation;
      if (!queries.length && !mutations.length)
        type = exports.DocumentType.Subscription;
      var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
      globals.invariant(definitions.length === 1, 64, document, definitions.length);
      var definition = definitions[0];
      variables = definition.variableDefinitions || [];
      if (definition.name && definition.name.kind === "Name") {
        name = definition.name.value;
      } else {
        name = "data";
      }
      var payload = { name, type, variables };
      cache2.set(document, payload);
      return payload;
    }
    parser2.resetCache = function() {
      cache2 = void 0;
    };
    if (globalThis.__DEV__ !== false) {
      registerGlobalCache2("parser", function() {
        return cache2 ? cache2.size : 0;
      });
    }
    function verifyDocumentType2(document, type) {
      var operation = parser2(document);
      var requiredOperationName = operationName2(type);
      var usedOperationName = operationName2(operation.type);
      globals.invariant(
        operation.type === type,
        65,
        requiredOperationName,
        requiredOperationName,
        usedOperationName
      );
    }
    exports.operationName = operationName2;
    exports.parser = parser2;
    exports.verifyDocumentType = verifyDocumentType2;
  }
});

// ../node_modules/@apollo/client/react/internal/internal.cjs
var require_internal = __commonJS({
  "../node_modules/@apollo/client/react/internal/internal.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var trie = (init_lib2(), __toCommonJS(lib_exports2));
    var utilities = require_utilities();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var equality = (init_lib7(), __toCommonJS(lib_exports5));
    var tsInvariant = (init_invariant(), __toCommonJS(invariant_exports));
    var version2 = "3.11.1";
    function maybe3(thunk) {
      try {
        return thunk();
      } catch (_a2) {
      }
    }
    var global$1 = maybe3(function() {
      return globalThis;
    }) || maybe3(function() {
      return window;
    }) || maybe3(function() {
      return self;
    }) || maybe3(function() {
      return global;
    }) || maybe3(function() {
      return maybe3.constructor("return this")();
    });
    var prefixCounts2 = /* @__PURE__ */ new Map();
    function makeUniqueId2(prefix) {
      var count = prefixCounts2.get(prefix) || 1;
      prefixCounts2.set(prefix, count + 1);
      return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
    }
    function stringifyForDisplay2(value, space) {
      if (space === void 0) {
        space = 0;
      }
      var undefId = makeUniqueId2("stringifyForDisplay");
      return JSON.stringify(value, function(key, value2) {
        return value2 === void 0 ? undefId : value2;
      }, space).split(JSON.stringify(undefId)).join("<undefined>");
    }
    function wrap3(fn) {
      return function(message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (typeof message === "number") {
          var arg0 = message;
          message = getHandledErrorMsg2(arg0);
          if (!message) {
            message = getFallbackErrorMsg2(arg0, args);
            args = [];
          }
        }
        fn.apply(void 0, [message].concat(args));
      };
    }
    var invariant4 = Object.assign(function invariant5(condition, message) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (!condition) {
        tsInvariant.invariant(condition, getHandledErrorMsg2(message, args) || getFallbackErrorMsg2(message, args));
      }
    }, {
      debug: wrap3(tsInvariant.invariant.debug),
      log: wrap3(tsInvariant.invariant.log),
      warn: wrap3(tsInvariant.invariant.warn),
      error: wrap3(tsInvariant.invariant.error)
    });
    var ApolloErrorMessageHandler2 = Symbol.for("ApolloErrorMessageHandler_" + version2);
    function stringify2(arg) {
      if (typeof arg == "string") {
        return arg;
      }
      try {
        return stringifyForDisplay2(arg, 2).slice(0, 1e3);
      } catch (_a2) {
        return "<non-serializable>";
      }
    }
    function getHandledErrorMsg2(message, messageArgs) {
      if (messageArgs === void 0) {
        messageArgs = [];
      }
      if (!message)
        return;
      return global$1[ApolloErrorMessageHandler2] && global$1[ApolloErrorMessageHandler2](message, messageArgs.map(stringify2));
    }
    function getFallbackErrorMsg2(message, messageArgs) {
      if (messageArgs === void 0) {
        messageArgs = [];
      }
      if (!message)
        return;
      return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
        version: version2,
        message,
        args: messageArgs.map(stringify2)
      })));
    }
    var QUERY_REFERENCE_SYMBOL2 = Symbol();
    var PROMISE_SYMBOL2 = Symbol();
    function wrapQueryRef2(internalQueryRef) {
      var _a2;
      var ref = (_a2 = {
        toPromise: function() {
          return getWrappedPromise2(ref).then(function() {
            return ref;
          });
        }
      }, _a2[QUERY_REFERENCE_SYMBOL2] = internalQueryRef, _a2[PROMISE_SYMBOL2] = internalQueryRef.promise, _a2);
      return ref;
    }
    function assertWrappedQueryRef2(queryRef) {
      invariant4(!queryRef || QUERY_REFERENCE_SYMBOL2 in queryRef, 60);
    }
    function getWrappedPromise2(queryRef) {
      var internalQueryRef = unwrapQueryRef2(queryRef);
      return internalQueryRef.promise.status === "fulfilled" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL2];
    }
    function unwrapQueryRef2(queryRef) {
      return queryRef[QUERY_REFERENCE_SYMBOL2];
    }
    function updateWrappedQueryRef2(queryRef, promise) {
      queryRef[PROMISE_SYMBOL2] = promise;
    }
    var OBSERVED_CHANGED_OPTIONS2 = [
      "canonizeResults",
      "context",
      "errorPolicy",
      "fetchPolicy",
      "refetchWritePolicy",
      "returnPartialData"
    ];
    var InternalQueryReference2 = function() {
      function InternalQueryReference3(observable, options) {
        var _this = this;
        this.key = {};
        this.listeners = /* @__PURE__ */ new Set();
        this.references = 0;
        this.softReferences = 0;
        this.handleNext = this.handleNext.bind(this);
        this.handleError = this.handleError.bind(this);
        this.dispose = this.dispose.bind(this);
        this.observable = observable;
        if (options.onDispose) {
          this.onDispose = options.onDispose;
        }
        this.setResult();
        this.subscribeToQuery();
        var startDisposeTimer = function() {
          var _a2;
          if (!_this.references) {
            _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a2 = options.autoDisposeTimeoutMs) !== null && _a2 !== void 0 ? _a2 : 3e4);
          }
        };
        this.promise.then(startDisposeTimer, startDisposeTimer);
      }
      Object.defineProperty(InternalQueryReference3.prototype, "disposed", {
        get: function() {
          return this.subscription.closed;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InternalQueryReference3.prototype, "watchQueryOptions", {
        get: function() {
          return this.observable.options;
        },
        enumerable: false,
        configurable: true
      });
      InternalQueryReference3.prototype.reinitialize = function() {
        var observable = this.observable;
        var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;
        var avoidNetworkRequests = originalFetchPolicy === "no-cache" || originalFetchPolicy === "standby";
        try {
          if (avoidNetworkRequests) {
            observable.silentSetOptions({ fetchPolicy: "standby" });
          } else {
            observable.resetLastResults();
            observable.silentSetOptions({ fetchPolicy: "cache-first" });
          }
          this.subscribeToQuery();
          if (avoidNetworkRequests) {
            return;
          }
          observable.resetDiff();
          this.setResult();
        } finally {
          observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });
        }
      };
      InternalQueryReference3.prototype.retain = function() {
        var _this = this;
        this.references++;
        clearTimeout(this.autoDisposeTimeoutId);
        var disposed = false;
        return function() {
          if (disposed) {
            return;
          }
          disposed = true;
          _this.references--;
          setTimeout(function() {
            if (!_this.references) {
              _this.dispose();
            }
          });
        };
      };
      InternalQueryReference3.prototype.softRetain = function() {
        var _this = this;
        this.softReferences++;
        var disposed = false;
        return function() {
          if (disposed) {
            return;
          }
          disposed = true;
          _this.softReferences--;
          setTimeout(function() {
            if (!_this.softReferences && !_this.references) {
              _this.dispose();
            }
          });
        };
      };
      InternalQueryReference3.prototype.didChangeOptions = function(watchQueryOptions) {
        var _this = this;
        return OBSERVED_CHANGED_OPTIONS2.some(function(option) {
          return option in watchQueryOptions && !equality.equal(_this.watchQueryOptions[option], watchQueryOptions[option]);
        });
      };
      InternalQueryReference3.prototype.applyOptions = function(watchQueryOptions) {
        var _a2 = this.watchQueryOptions, currentFetchPolicy = _a2.fetchPolicy, currentCanonizeResults = _a2.canonizeResults;
        if (currentFetchPolicy === "standby" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {
          this.initiateFetch(this.observable.reobserve(watchQueryOptions));
        } else {
          this.observable.silentSetOptions(watchQueryOptions);
          if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {
            this.result = tslib.__assign(tslib.__assign({}, this.result), this.observable.getCurrentResult());
            this.promise = utilities.createFulfilledPromise(this.result);
          }
        }
        return this.promise;
      };
      InternalQueryReference3.prototype.listen = function(listener) {
        var _this = this;
        this.listeners.add(listener);
        return function() {
          _this.listeners.delete(listener);
        };
      };
      InternalQueryReference3.prototype.refetch = function(variables) {
        return this.initiateFetch(this.observable.refetch(variables));
      };
      InternalQueryReference3.prototype.fetchMore = function(options) {
        return this.initiateFetch(this.observable.fetchMore(options));
      };
      InternalQueryReference3.prototype.dispose = function() {
        this.subscription.unsubscribe();
        this.onDispose();
      };
      InternalQueryReference3.prototype.onDispose = function() {
      };
      InternalQueryReference3.prototype.handleNext = function(result2) {
        var _a2;
        switch (this.promise.status) {
          case "pending": {
            if (result2.data === void 0) {
              result2.data = this.result.data;
            }
            this.result = result2;
            (_a2 = this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, result2);
            break;
          }
          default: {
            if (result2.data === this.result.data && result2.networkStatus === this.result.networkStatus) {
              return;
            }
            if (result2.data === void 0) {
              result2.data = this.result.data;
            }
            this.result = result2;
            this.promise = utilities.createFulfilledPromise(result2);
            this.deliver(this.promise);
            break;
          }
        }
      };
      InternalQueryReference3.prototype.handleError = function(error) {
        var _a2;
        this.subscription.unsubscribe();
        this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);
        switch (this.promise.status) {
          case "pending": {
            (_a2 = this.reject) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
            break;
          }
          default: {
            this.promise = utilities.createRejectedPromise(error);
            this.deliver(this.promise);
          }
        }
      };
      InternalQueryReference3.prototype.deliver = function(promise) {
        this.listeners.forEach(function(listener) {
          return listener(promise);
        });
      };
      InternalQueryReference3.prototype.initiateFetch = function(returnedPromise) {
        var _this = this;
        this.promise = this.createPendingPromise();
        this.promise.catch(function() {
        });
        returnedPromise.then(function() {
          setTimeout(function() {
            var _a2;
            if (_this.promise.status === "pending") {
              _this.result = _this.observable.getCurrentResult();
              (_a2 = _this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(_this, _this.result);
            }
          });
        }).catch(function() {
        });
        return returnedPromise;
      };
      InternalQueryReference3.prototype.subscribeToQuery = function() {
        var _this = this;
        this.subscription = this.observable.filter(function(result2) {
          return !equality.equal(result2.data, {}) && !equality.equal(result2, _this.result);
        }).subscribe(this.handleNext, this.handleError);
      };
      InternalQueryReference3.prototype.setResult = function() {
        var result2 = this.observable.getCurrentResult(false);
        if (equality.equal(result2, this.result)) {
          return;
        }
        this.result = result2;
        this.promise = result2.data && (!result2.partial || this.watchQueryOptions.returnPartialData) ? utilities.createFulfilledPromise(result2) : this.createPendingPromise();
      };
      InternalQueryReference3.prototype.createPendingPromise = function() {
        var _this = this;
        return utilities.wrapPromiseWithState(new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        }));
      };
      return InternalQueryReference3;
    }();
    var SuspenseCache2 = function() {
      function SuspenseCache3(options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        this.queryRefs = new trie.Trie(utilities.canUseWeakMap);
        this.options = options;
      }
      SuspenseCache3.prototype.getQueryRef = function(cacheKey, createObservable) {
        var ref = this.queryRefs.lookupArray(cacheKey);
        if (!ref.current) {
          ref.current = new InternalQueryReference2(createObservable(), {
            autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,
            onDispose: function() {
              delete ref.current;
            }
          });
        }
        return ref.current;
      };
      SuspenseCache3.prototype.add = function(cacheKey, queryRef) {
        var ref = this.queryRefs.lookupArray(cacheKey);
        ref.current = queryRef;
      };
      return SuspenseCache3;
    }();
    var suspenseCacheSymbol2 = Symbol.for("apollo.suspenseCache");
    function getSuspenseCache2(client) {
      var _a2;
      if (!client[suspenseCacheSymbol2]) {
        client[suspenseCacheSymbol2] = new SuspenseCache2((_a2 = client.defaultOptions.react) === null || _a2 === void 0 ? void 0 : _a2.suspense);
      }
      return client[suspenseCacheSymbol2];
    }
    exports.InternalQueryReference = InternalQueryReference2;
    exports.assertWrappedQueryRef = assertWrappedQueryRef2;
    exports.getSuspenseCache = getSuspenseCache2;
    exports.getWrappedPromise = getWrappedPromise2;
    exports.unwrapQueryRef = unwrapQueryRef2;
    exports.updateWrappedQueryRef = updateWrappedQueryRef2;
    exports.wrapQueryRef = wrapQueryRef2;
  }
});

// ../node_modules/@apollo/client/react/hooks/hooks.cjs
var require_hooks = __commonJS({
  "../node_modules/@apollo/client/react/hooks/hooks.cjs"(exports) {
    "use strict";
    var import_dist463 = __toESM(require_dist());
    var import_dist464 = __toESM(require_dist2());
    var import_dist465 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var React24 = require_rehackt();
    var context = require_context();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var utilities = require_utilities();
    var equal2 = (init_lib7(), __toCommonJS(lib_exports5));
    var errors = require_errors();
    var core = require_core2();
    var parser2 = require_parser();
    var internal = require_internal();
    var cache2 = require_cache();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e["default"] : e;
    }
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React24);
    var equal__default = _interopDefaultLegacy(equal2);
    function useApolloClient2(override) {
      var context$1 = React__namespace.useContext(context.getApolloContext());
      var client = override || context$1.client;
      globals.invariant(!!client, 49);
      return client;
    }
    var didWarnUncachedGetSnapshot2 = false;
    var uSESKey2 = "useSyncExternalStore";
    var realHook$1 = React__namespace[uSESKey2];
    var useSyncExternalStore2 = realHook$1 || function(subscribe, getSnapshot, getServerSnapshot) {
      var value = getSnapshot();
      if (globalThis.__DEV__ !== false && !didWarnUncachedGetSnapshot2 && value !== getSnapshot()) {
        didWarnUncachedGetSnapshot2 = true;
        globalThis.__DEV__ !== false && globals.invariant.error(59);
      }
      var _a2 = React__namespace.useState({
        inst: { value, getSnapshot }
      }), inst = _a2[0].inst, forceUpdate = _a2[1];
      if (utilities.canUseLayoutEffect) {
        React__namespace.useLayoutEffect(function() {
          Object.assign(inst, { value, getSnapshot });
          if (checkIfSnapshotChanged2(inst)) {
            forceUpdate({ inst });
          }
        }, [subscribe, value, getSnapshot]);
      } else {
        Object.assign(inst, { value, getSnapshot });
      }
      React__namespace.useEffect(function() {
        if (checkIfSnapshotChanged2(inst)) {
          forceUpdate({ inst });
        }
        return subscribe(function handleStoreChange() {
          if (checkIfSnapshotChanged2(inst)) {
            forceUpdate({ inst });
          }
        });
      }, [subscribe]);
      return value;
    };
    function checkIfSnapshotChanged2(_a2) {
      var value = _a2.value, getSnapshot = _a2.getSnapshot;
      try {
        return value !== getSnapshot();
      } catch (_b) {
        return true;
      }
    }
    function useDeepMemo2(memoFn, deps) {
      var ref = React__namespace.useRef();
      if (!ref.current || !equal2.equal(ref.current.deps, deps)) {
        ref.current = { value: memoFn(), deps };
      }
      return ref.current.value;
    }
    var useIsomorphicLayoutEffect2 = utilities.canUseDOM ? React__namespace.useLayoutEffect : React__namespace.useEffect;
    var Ctx;
    function noop$1() {
    }
    function useRenderGuard2() {
      if (!Ctx) {
        Ctx = React__namespace.createContext(null);
      }
      return React__namespace.useCallback(
        function() {
          var orig = console.error;
          try {
            console.error = noop$1;
            React__namespace["useContext"](Ctx);
            return true;
          } catch (e) {
            return false;
          } finally {
            console.error = orig;
          }
        },
        []
      );
    }
    var INIT2 = {};
    function useLazyRef2(getInitialValue) {
      var ref = React__namespace.useRef(INIT2);
      if (ref.current === INIT2) {
        ref.current = getInitialValue();
      }
      return ref;
    }
    var useKey2 = "use";
    var realHook3 = React__namespace[useKey2];
    var __use2 = realHook3 || function __use3(promise) {
      var statefulPromise = utilities.wrapPromiseWithState(promise);
      switch (statefulPromise.status) {
        case "pending":
          throw statefulPromise;
        case "rejected":
          throw statefulPromise.reason;
        case "fulfilled":
          return statefulPromise.value;
      }
    };
    var wrapperSymbol2 = Symbol.for("apollo.hook.wrappers");
    function wrapHook2(hookName, useHook, clientOrObsQuery) {
      var queryManager = clientOrObsQuery["queryManager"];
      var wrappers = queryManager && queryManager[wrapperSymbol2];
      var wrapper = wrappers && wrappers[hookName];
      return wrapper ? wrapper(useHook) : useHook;
    }
    var hasOwnProperty9 = Object.prototype.hasOwnProperty;
    function noop2() {
    }
    var lastWatchOptions2 = Symbol();
    function useQuery3(query, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      return wrapHook2("useQuery", _useQuery, useApolloClient2(options && options.client))(query, options);
    }
    function _useQuery(query, options) {
      var _a2 = useQueryInternals2(query, options), result2 = _a2.result, obsQueryFields = _a2.obsQueryFields;
      return React__namespace.useMemo(function() {
        return tslib.__assign(tslib.__assign({}, result2), obsQueryFields);
      }, [result2, obsQueryFields]);
    }
    function useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {
      function createInternalState(previous) {
        var _a3;
        parser2.verifyDocumentType(query, parser2.DocumentType.Query);
        var internalState2 = {
          client,
          query,
          observable: renderPromises && renderPromises.getSSRObservable(makeWatchQueryOptions()) || client.watchQuery(getObsQueryOptions2(void 0, client, options, makeWatchQueryOptions())),
          resultData: {
            previousData: (_a3 = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a3 === void 0 ? void 0 : _a3.data
          }
        };
        return internalState2;
      }
      var _a2 = React__namespace.useState(createInternalState), internalState = _a2[0], updateInternalState = _a2[1];
      function onQueryExecuted(watchQueryOptions) {
        var _a3;
        var _b;
        Object.assign(internalState.observable, (_a3 = {}, _a3[lastWatchOptions2] = watchQueryOptions, _a3));
        var resultData = internalState.resultData;
        updateInternalState(tslib.__assign(tslib.__assign({}, internalState), {
          query: watchQueryOptions.query,
          resultData: Object.assign(resultData, {
            previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,
            current: void 0
          })
        }));
      }
      if (client !== internalState.client || query !== internalState.query) {
        var newInternalState = createInternalState(internalState);
        updateInternalState(newInternalState);
        return [newInternalState, onQueryExecuted];
      }
      return [internalState, onQueryExecuted];
    }
    function useQueryInternals2(query, options) {
      var client = useApolloClient2(options.client);
      var renderPromises = React__namespace.useContext(context.getApolloContext()).renderPromises;
      var isSyncSSR = !!renderPromises;
      var disableNetworkFetches = client.disableNetworkFetches;
      var ssrAllowed = options.ssr !== false && !options.skip;
      var partialRefetch = options.partialRefetch;
      var makeWatchQueryOptions = createMakeWatchQueryOptions2(client, query, options, isSyncSSR);
      var _a2 = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a2[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a2[1];
      var watchQueryOptions = makeWatchQueryOptions(observable);
      useResubscribeIfNecessary(
        resultData,
        observable,
        client,
        options,
        watchQueryOptions
      );
      var obsQueryFields = React__namespace.useMemo(function() {
        return bindObservableMethods(observable);
      }, [observable]);
      useRegisterSSRObservable(observable, renderPromises, ssrAllowed);
      var result2 = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {
        onCompleted: options.onCompleted || noop2,
        onError: options.onError || noop2
      });
      return {
        result: result2,
        obsQueryFields,
        observable,
        resultData,
        client,
        onQueryExecuted
      };
    }
    function useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {
      var callbackRef = React__namespace.useRef(callbacks);
      React__namespace.useEffect(function() {
        callbackRef.current = callbacks;
      });
      var resultOverride = (isSyncSSR || disableNetworkFetches) && options.ssr === false && !options.skip ? ssrDisabledResult2 : options.skip || watchQueryOptions.fetchPolicy === "standby" ? skipStandbyResult2 : void 0;
      var previousData = resultData.previousData;
      var currentResultOverride = React__namespace.useMemo(function() {
        return resultOverride && toQueryResult2(resultOverride, previousData, observable, client);
      }, [client, observable, resultOverride, previousData]);
      return useSyncExternalStore2(React__namespace.useCallback(function(handleStoreChange) {
        if (isSyncSSR) {
          return function() {
          };
        }
        var onNext = function() {
          var previousResult = resultData.current;
          var result2 = observable.getCurrentResult();
          if (previousResult && previousResult.loading === result2.loading && previousResult.networkStatus === result2.networkStatus && equal2.equal(previousResult.data, result2.data)) {
            return;
          }
          setResult(result2, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
        };
        var onError = function(error) {
          subscription.current.unsubscribe();
          subscription.current = observable.resubscribeAfterError(onNext, onError);
          if (!hasOwnProperty9.call(error, "graphQLErrors")) {
            throw error;
          }
          var previousResult = resultData.current;
          if (!previousResult || previousResult && previousResult.loading || !equal2.equal(error, previousResult.error)) {
            setResult({
              data: previousResult && previousResult.data,
              error,
              loading: false,
              networkStatus: core.NetworkStatus.error
            }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
          }
        };
        var subscription = { current: observable.subscribe(onNext, onError) };
        return function() {
          setTimeout(function() {
            return subscription.current.unsubscribe();
          });
        };
      }, [
        disableNetworkFetches,
        isSyncSSR,
        observable,
        resultData,
        partialRefetch,
        client
      ]), function() {
        return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
      }, function() {
        return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
      });
    }
    function useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {
      if (renderPromises && ssrAllowed) {
        renderPromises.registerSSRObservable(observable);
        if (observable.getCurrentResult().loading) {
          renderPromises.addObservableQueryPromise(observable);
        }
      }
    }
    function useResubscribeIfNecessary(resultData, observable, client, options, watchQueryOptions) {
      var _a2;
      if (observable[lastWatchOptions2] && !equal2.equal(observable[lastWatchOptions2], watchQueryOptions)) {
        observable.reobserve(getObsQueryOptions2(observable, client, options, watchQueryOptions));
        resultData.previousData = ((_a2 = resultData.current) === null || _a2 === void 0 ? void 0 : _a2.data) || resultData.previousData;
        resultData.current = void 0;
      }
      observable[lastWatchOptions2] = watchQueryOptions;
    }
    function createMakeWatchQueryOptions2(client, query, _a2, isSyncSSR) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var skip = _a2.skip;
      _a2.ssr;
      _a2.onCompleted;
      _a2.onError;
      var defaultOptions2 = _a2.defaultOptions, otherOptions = tslib.__rest(_a2, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]);
      return function(observable) {
        var watchQueryOptions = Object.assign(otherOptions, { query });
        if (isSyncSSR && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
          watchQueryOptions.fetchPolicy = "cache-first";
        }
        if (!watchQueryOptions.variables) {
          watchQueryOptions.variables = {};
        }
        if (skip) {
          watchQueryOptions.initialFetchPolicy = watchQueryOptions.initialFetchPolicy || watchQueryOptions.fetchPolicy || getDefaultFetchPolicy2(defaultOptions2, client.defaultOptions);
          watchQueryOptions.fetchPolicy = "standby";
        } else if (!watchQueryOptions.fetchPolicy) {
          watchQueryOptions.fetchPolicy = (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) || getDefaultFetchPolicy2(defaultOptions2, client.defaultOptions);
        }
        return watchQueryOptions;
      };
    }
    function getObsQueryOptions2(observable, client, queryHookOptions, watchQueryOptions) {
      var toMerge = [];
      var globalDefaults = client.defaultOptions.watchQuery;
      if (globalDefaults)
        toMerge.push(globalDefaults);
      if (queryHookOptions.defaultOptions) {
        toMerge.push(queryHookOptions.defaultOptions);
      }
      toMerge.push(utilities.compact(observable && observable.options, watchQueryOptions));
      return toMerge.reduce(utilities.mergeOptions);
    }
    function setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {
      var previousResult = resultData.current;
      if (previousResult && previousResult.data) {
        resultData.previousData = previousResult.data;
      }
      if (!nextResult.error && utilities.isNonEmptyArray(nextResult.errors)) {
        nextResult.error = new errors.ApolloError({ graphQLErrors: nextResult.errors });
      }
      resultData.current = toQueryResult2(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);
      forceUpdate();
      handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);
    }
    function handleErrorOrCompleted(result2, previousNetworkStatus, callbacks) {
      if (!result2.loading) {
        var error_1 = toApolloError$1(result2);
        Promise.resolve().then(function() {
          if (error_1) {
            callbacks.onError(error_1);
          } else if (result2.data && previousNetworkStatus !== result2.networkStatus && result2.networkStatus === core.NetworkStatus.ready) {
            callbacks.onCompleted(result2.data);
          }
        }).catch(function(error) {
          globalThis.__DEV__ !== false && globals.invariant.warn(error);
        });
      }
    }
    function getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {
      if (!resultData.current) {
        setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function() {
        }, callbacks);
      }
      return resultData.current;
    }
    function getDefaultFetchPolicy2(queryHookDefaultOptions, clientDefaultOptions) {
      var _a2;
      return (queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) || ((_a2 = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a2 === void 0 ? void 0 : _a2.fetchPolicy) || "cache-first";
    }
    function toApolloError$1(result2) {
      return utilities.isNonEmptyArray(result2.errors) ? new errors.ApolloError({ graphQLErrors: result2.errors }) : result2.error;
    }
    function toQueryResult2(result2, previousData, observable, client) {
      var data = result2.data;
      result2.partial;
      var resultWithoutPartial = tslib.__rest(result2, ["data", "partial"]);
      var queryResult = tslib.__assign(tslib.__assign({ data }, resultWithoutPartial), { client, observable, variables: observable.variables, called: result2 !== ssrDisabledResult2 && result2 !== skipStandbyResult2, previousData });
      return queryResult;
    }
    function unsafeHandlePartialRefetch(result2, observable, partialRefetch) {
      if (result2.partial && partialRefetch && !result2.loading && (!result2.data || Object.keys(result2.data).length === 0) && observable.options.fetchPolicy !== "cache-only") {
        observable.refetch();
        return tslib.__assign(tslib.__assign({}, result2), { loading: true, networkStatus: core.NetworkStatus.refetch });
      }
      return result2;
    }
    var ssrDisabledResult2 = utilities.maybeDeepFreeze({
      loading: true,
      data: void 0,
      error: void 0,
      networkStatus: core.NetworkStatus.loading
    });
    var skipStandbyResult2 = utilities.maybeDeepFreeze({
      loading: false,
      data: void 0,
      error: void 0,
      networkStatus: core.NetworkStatus.ready
    });
    function bindObservableMethods(observable) {
      return {
        refetch: observable.refetch.bind(observable),
        reobserve: observable.reobserve.bind(observable),
        fetchMore: observable.fetchMore.bind(observable),
        updateQuery: observable.updateQuery.bind(observable),
        startPolling: observable.startPolling.bind(observable),
        stopPolling: observable.stopPolling.bind(observable),
        subscribeToMore: observable.subscribeToMore.bind(observable)
      };
    }
    var EAGER_METHODS = [
      "refetch",
      "reobserve",
      "fetchMore",
      "updateQuery",
      "startPolling",
      "stopPolling",
      "subscribeToMore"
    ];
    function useLazyQuery(query, options) {
      var _a2;
      var execOptionsRef = React__namespace.useRef();
      var optionsRef = React__namespace.useRef();
      var queryRef = React__namespace.useRef();
      var merged = utilities.mergeOptions(options, execOptionsRef.current || {});
      var document = (_a2 = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a2 !== void 0 ? _a2 : query;
      optionsRef.current = options;
      queryRef.current = document;
      var queryHookOptions = tslib.__assign(tslib.__assign({}, merged), { skip: !execOptionsRef.current });
      var _b = useQueryInternals2(document, queryHookOptions), obsQueryFields = _b.obsQueryFields, useQueryResult = _b.result, client = _b.client, resultData = _b.resultData, observable = _b.observable, onQueryExecuted = _b.onQueryExecuted;
      var initialFetchPolicy = observable.options.initialFetchPolicy || getDefaultFetchPolicy2(queryHookOptions.defaultOptions, client.defaultOptions);
      var forceUpdateState = React__namespace.useReducer(function(tick) {
        return tick + 1;
      }, 0)[1];
      var eagerMethods = React__namespace.useMemo(function() {
        var eagerMethods2 = {};
        var _loop_1 = function(key2) {
          var method = obsQueryFields[key2];
          eagerMethods2[key2] = function() {
            if (!execOptionsRef.current) {
              execOptionsRef.current = /* @__PURE__ */ Object.create(null);
              forceUpdateState();
            }
            return method.apply(this, arguments);
          };
        };
        for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {
          var key = EAGER_METHODS_1[_i];
          _loop_1(key);
        }
        return eagerMethods2;
      }, [forceUpdateState, obsQueryFields]);
      var called = !!execOptionsRef.current;
      var result2 = React__namespace.useMemo(function() {
        return tslib.__assign(tslib.__assign(tslib.__assign({}, useQueryResult), eagerMethods), { called });
      }, [useQueryResult, eagerMethods, called]);
      var execute2 = React__namespace.useCallback(function(executeOptions) {
        execOptionsRef.current = executeOptions ? tslib.__assign(tslib.__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {
          fetchPolicy: initialFetchPolicy
        };
        var options2 = utilities.mergeOptions(optionsRef.current, tslib.__assign({ query: queryRef.current }, execOptionsRef.current));
        var promise = executeQuery(resultData, observable, client, document, tslib.__assign(tslib.__assign({}, options2), { skip: false }), onQueryExecuted).then(function(queryResult) {
          return Object.assign(queryResult, eagerMethods);
        });
        promise.catch(function() {
        });
        return promise;
      }, [
        client,
        document,
        eagerMethods,
        initialFetchPolicy,
        observable,
        resultData,
        onQueryExecuted
      ]);
      var executeRef = React__namespace.useRef(execute2);
      useIsomorphicLayoutEffect2(function() {
        executeRef.current = execute2;
      });
      var stableExecute = React__namespace.useCallback(function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return executeRef.current.apply(executeRef, args);
      }, []);
      return [stableExecute, result2];
    }
    function executeQuery(resultData, observable, client, currentQuery, options, onQueryExecuted) {
      var query = options.query || currentQuery;
      var watchQueryOptions = createMakeWatchQueryOptions2(client, query, options, false)(observable);
      var concast = observable.reobserveAsConcast(getObsQueryOptions2(observable, client, options, watchQueryOptions));
      onQueryExecuted(watchQueryOptions);
      return new Promise(function(resolve) {
        var result2;
        concast.subscribe({
          next: function(value) {
            result2 = value;
          },
          error: function() {
            resolve(toQueryResult2(observable.getCurrentResult(), resultData.previousData, observable, client));
          },
          complete: function() {
            resolve(toQueryResult2(result2, resultData.previousData, observable, client));
          }
        });
      });
    }
    function useMutation2(mutation, options) {
      var client = useApolloClient2(options === null || options === void 0 ? void 0 : options.client);
      parser2.verifyDocumentType(mutation, parser2.DocumentType.Mutation);
      var _a2 = React__namespace.useState({
        called: false,
        loading: false,
        client
      }), result2 = _a2[0], setResult2 = _a2[1];
      var ref = React__namespace.useRef({
        result: result2,
        mutationId: 0,
        isMounted: true,
        client,
        mutation,
        options
      });
      useIsomorphicLayoutEffect2(function() {
        Object.assign(ref.current, { client, options, mutation });
      });
      var execute2 = React__namespace.useCallback(function(executeOptions) {
        if (executeOptions === void 0) {
          executeOptions = {};
        }
        var _a3 = ref.current, options2 = _a3.options, mutation2 = _a3.mutation;
        var baseOptions = tslib.__assign(tslib.__assign({}, options2), { mutation: mutation2 });
        var client2 = executeOptions.client || ref.current.client;
        if (!ref.current.result.loading && !baseOptions.ignoreResults && ref.current.isMounted) {
          setResult2(ref.current.result = {
            loading: true,
            error: void 0,
            data: void 0,
            called: true,
            client: client2
          });
        }
        var mutationId = ++ref.current.mutationId;
        var clientOptions = utilities.mergeOptions(baseOptions, executeOptions);
        return client2.mutate(clientOptions).then(function(response) {
          var _a4, _b;
          var data = response.data, errors$1 = response.errors;
          var error = errors$1 && errors$1.length > 0 ? new errors.ApolloError({ graphQLErrors: errors$1 }) : void 0;
          var onError = executeOptions.onError || ((_a4 = ref.current.options) === null || _a4 === void 0 ? void 0 : _a4.onError);
          if (error && onError) {
            onError(error, clientOptions);
          }
          if (mutationId === ref.current.mutationId && !clientOptions.ignoreResults) {
            var result_1 = {
              called: true,
              loading: false,
              data,
              error,
              client: client2
            };
            if (ref.current.isMounted && !equal2.equal(ref.current.result, result_1)) {
              setResult2(ref.current.result = result_1);
            }
          }
          var onCompleted = executeOptions.onCompleted || ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onCompleted);
          if (!error) {
            onCompleted === null || onCompleted === void 0 ? void 0 : onCompleted(response.data, clientOptions);
          }
          return response;
        }).catch(function(error) {
          var _a4;
          if (mutationId === ref.current.mutationId && ref.current.isMounted) {
            var result_2 = {
              loading: false,
              error,
              data: void 0,
              called: true,
              client: client2
            };
            if (!equal2.equal(ref.current.result, result_2)) {
              setResult2(ref.current.result = result_2);
            }
          }
          var onError = executeOptions.onError || ((_a4 = ref.current.options) === null || _a4 === void 0 ? void 0 : _a4.onError);
          if (onError) {
            onError(error, clientOptions);
            return { data: void 0, errors: error };
          }
          throw error;
        });
      }, []);
      var reset = React__namespace.useCallback(function() {
        if (ref.current.isMounted) {
          var result_3 = {
            called: false,
            loading: false,
            client: ref.current.client
          };
          Object.assign(ref.current, { mutationId: 0, result: result_3 });
          setResult2(result_3);
        }
      }, []);
      React__namespace.useEffect(function() {
        var current = ref.current;
        current.isMounted = true;
        return function() {
          current.isMounted = false;
        };
      }, []);
      return [execute2, tslib.__assign({ reset }, result2)];
    }
    function useSubscription2(subscription, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      var hasIssuedDeprecationWarningRef = React__namespace.useRef(false);
      var client = useApolloClient2(options.client);
      parser2.verifyDocumentType(subscription, parser2.DocumentType.Subscription);
      if (!hasIssuedDeprecationWarningRef.current) {
        hasIssuedDeprecationWarningRef.current = true;
        if (options.onSubscriptionData) {
          globalThis.__DEV__ !== false && globals.invariant.warn(options.onData ? 52 : 53);
        }
        if (options.onSubscriptionComplete) {
          globalThis.__DEV__ !== false && globals.invariant.warn(options.onComplete ? 54 : 55);
        }
      }
      var skip = options.skip, fetchPolicy = options.fetchPolicy, errorPolicy = options.errorPolicy, shouldResubscribe = options.shouldResubscribe, context2 = options.context, extensions = options.extensions, ignoreResults = options.ignoreResults;
      var variables = useDeepMemo2(function() {
        return options.variables;
      }, [options.variables]);
      var recreate = function() {
        return createSubscription(client, subscription, variables, fetchPolicy, errorPolicy, context2, extensions);
      };
      var _a2 = React__namespace.useState(options.skip ? null : recreate), observable = _a2[0], setObservable = _a2[1];
      var recreateRef = React__namespace.useRef(recreate);
      useIsomorphicLayoutEffect2(function() {
        recreateRef.current = recreate;
      });
      if (skip) {
        if (observable) {
          setObservable(observable = null);
        }
      } else if (!observable || (client !== observable.__.client || subscription !== observable.__.query || fetchPolicy !== observable.__.fetchPolicy || errorPolicy !== observable.__.errorPolicy || !equal2.equal(variables, observable.__.variables)) && (typeof shouldResubscribe === "function" ? !!shouldResubscribe(options) : shouldResubscribe) !== false) {
        setObservable(observable = recreate());
      }
      var optionsRef = React__namespace.useRef(options);
      React__namespace.useEffect(function() {
        optionsRef.current = options;
      });
      var fallbackLoading = !skip && !ignoreResults;
      var fallbackResult = React__namespace.useMemo(function() {
        return {
          loading: fallbackLoading,
          error: void 0,
          data: void 0,
          variables
        };
      }, [fallbackLoading, variables]);
      var ignoreResultsRef = React__namespace.useRef(ignoreResults);
      useIsomorphicLayoutEffect2(function() {
        ignoreResultsRef.current = ignoreResults;
      });
      var ret = useSyncExternalStore2(React__namespace.useCallback(function(update) {
        if (!observable) {
          return function() {
          };
        }
        var subscriptionStopped = false;
        var variables2 = observable.__.variables;
        var client2 = observable.__.client;
        var subscription2 = observable.subscribe({
          next: function(fetchResult) {
            var _a3, _b;
            if (subscriptionStopped) {
              return;
            }
            var result2 = {
              loading: false,
              data: fetchResult.data,
              error: toApolloError$1(fetchResult),
              variables: variables2
            };
            observable.__.setResult(result2);
            if (!ignoreResultsRef.current)
              update();
            if (result2.error) {
              (_b = (_a3 = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a3, result2.error);
            } else if (optionsRef.current.onData) {
              optionsRef.current.onData({
                client: client2,
                data: result2
              });
            } else if (optionsRef.current.onSubscriptionData) {
              optionsRef.current.onSubscriptionData({
                client: client2,
                subscriptionData: result2
              });
            }
          },
          error: function(error) {
            var _a3, _b;
            error = error instanceof core.ApolloError ? error : new core.ApolloError({ protocolErrors: [error] });
            if (!subscriptionStopped) {
              observable.__.setResult({
                loading: false,
                data: void 0,
                error,
                variables: variables2
              });
              if (!ignoreResultsRef.current)
                update();
              (_b = (_a3 = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a3, error);
            }
          },
          complete: function() {
            if (!subscriptionStopped) {
              if (optionsRef.current.onComplete) {
                optionsRef.current.onComplete();
              } else if (optionsRef.current.onSubscriptionComplete) {
                optionsRef.current.onSubscriptionComplete();
              }
            }
          }
        });
        return function() {
          subscriptionStopped = true;
          setTimeout(function() {
            subscription2.unsubscribe();
          });
        };
      }, [observable]), function() {
        return observable && !skip && !ignoreResults ? observable.__.result : fallbackResult;
      });
      return React__namespace.useMemo(function() {
        return tslib.__assign(tslib.__assign({}, ret), { restart: function() {
          globals.invariant(!optionsRef.current.skip, 56);
          setObservable(recreateRef.current());
        } });
      }, [ret]);
    }
    function createSubscription(client, query, variables, fetchPolicy, errorPolicy, context2, extensions) {
      var options = {
        query,
        variables,
        fetchPolicy,
        errorPolicy,
        context: context2,
        extensions
      };
      var __ = tslib.__assign(tslib.__assign({}, options), { client, result: {
        loading: true,
        data: void 0,
        error: void 0,
        variables
      }, setResult: function(result2) {
        __.result = result2;
      } });
      var observable = null;
      return Object.assign(new core.Observable(function(observer) {
        if (!observable) {
          observable = client.subscribe(options);
        }
        var sub = observable.subscribe(observer);
        return function() {
          return sub.unsubscribe();
        };
      }), {
        __
      });
    }
    function useReactiveVar(rv) {
      return useSyncExternalStore2(React__namespace.useCallback(function(update) {
        return rv.onNextChange(function onNext() {
          update();
          rv.onNextChange(onNext);
        });
      }, [rv]), rv, rv);
    }
    function useFragment2(options) {
      return wrapHook2("useFragment", _useFragment2, useApolloClient2(options.client))(options);
    }
    function _useFragment2(options) {
      var cache3 = useApolloClient2(options.client).cache;
      var diffOptions = useDeepMemo2(function() {
        var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, rest = tslib.__rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
        return tslib.__assign(tslib.__assign({}, rest), { returnPartialData: true, id: typeof from2 === "string" ? from2 : cache3.identify(from2), query: cache3["getFragmentDoc"](fragment, fragmentName), optimistic });
      }, [options]);
      var resultRef = useLazyRef2(function() {
        return diffToResult2(cache3.diff(diffOptions));
      });
      var stableOptions = useDeepMemo2(function() {
        return options;
      }, [options]);
      React__namespace.useMemo(function() {
        resultRef.current = diffToResult2(cache3.diff(diffOptions));
      }, [diffOptions, cache3]);
      var getSnapshot = React__namespace.useCallback(function() {
        return resultRef.current;
      }, []);
      return useSyncExternalStore2(React__namespace.useCallback(function(forceUpdate) {
        var lastTimeout = 0;
        var subscription = cache3.watchFragment(stableOptions).subscribe({
          next: function(result2) {
            if (equal__default(result2, resultRef.current))
              return;
            resultRef.current = result2;
            clearTimeout(lastTimeout);
            lastTimeout = setTimeout(forceUpdate);
          }
        });
        return function() {
          subscription.unsubscribe();
          clearTimeout(lastTimeout);
        };
      }, [cache3, stableOptions]), getSnapshot, getSnapshot);
    }
    function diffToResult2(diff) {
      var result2 = {
        data: diff.result,
        complete: !!diff.complete
      };
      if (diff.missing) {
        result2.missing = utilities.mergeDeepArray(diff.missing.map(function(error) {
          return error.missing;
        }));
      }
      return result2;
    }
    var skipToken2 = Symbol.for("apollo.skipToken");
    function useSuspenseQuery2(query, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      return wrapHook2("useSuspenseQuery", _useSuspenseQuery, useApolloClient2(typeof options === "object" ? options.client : void 0))(query, options);
    }
    function _useSuspenseQuery(query, options) {
      var client = useApolloClient2(options.client);
      var suspenseCache = internal.getSuspenseCache(client);
      var watchQueryOptions = useWatchQueryOptions2({
        client,
        query,
        options
      });
      var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
      var _a2 = options.queryKey, queryKey = _a2 === void 0 ? [] : _a2;
      var cacheKey = tslib.__spreadArray([
        query,
        cache2.canonicalStringify(variables)
      ], [].concat(queryKey), true);
      var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
        return client.watchQuery(watchQueryOptions);
      });
      var _b = React__namespace.useState([queryRef.key, queryRef.promise]), current = _b[0], setPromise = _b[1];
      if (current[0] !== queryRef.key) {
        current[0] = queryRef.key;
        current[1] = queryRef.promise;
      }
      var promise = current[1];
      if (queryRef.didChangeOptions(watchQueryOptions)) {
        current[1] = promise = queryRef.applyOptions(watchQueryOptions);
      }
      React__namespace.useEffect(function() {
        var dispose = queryRef.retain();
        var removeListener = queryRef.listen(function(promise2) {
          setPromise([queryRef.key, promise2]);
        });
        return function() {
          removeListener();
          dispose();
        };
      }, [queryRef]);
      var skipResult = React__namespace.useMemo(function() {
        var error = toApolloError3(queryRef.result);
        return {
          loading: false,
          data: queryRef.result.data,
          networkStatus: error ? core.NetworkStatus.error : core.NetworkStatus.ready,
          error
        };
      }, [queryRef.result]);
      var result2 = fetchPolicy === "standby" ? skipResult : __use2(promise);
      var fetchMore = React__namespace.useCallback(function(options2) {
        var promise2 = queryRef.fetchMore(options2);
        setPromise([queryRef.key, queryRef.promise]);
        return promise2;
      }, [queryRef]);
      var refetch = React__namespace.useCallback(function(variables2) {
        var promise2 = queryRef.refetch(variables2);
        setPromise([queryRef.key, queryRef.promise]);
        return promise2;
      }, [queryRef]);
      var subscribeToMore = queryRef.observable.subscribeToMore;
      return React__namespace.useMemo(function() {
        return {
          client,
          data: result2.data,
          error: toApolloError3(result2),
          networkStatus: result2.networkStatus,
          fetchMore,
          refetch,
          subscribeToMore
        };
      }, [client, fetchMore, refetch, result2, subscribeToMore]);
    }
    function validateOptions(options) {
      var query = options.query, fetchPolicy = options.fetchPolicy, returnPartialData = options.returnPartialData;
      parser2.verifyDocumentType(query, parser2.DocumentType.Query);
      validateFetchPolicy(fetchPolicy);
      validatePartialDataReturn(fetchPolicy, returnPartialData);
    }
    function validateFetchPolicy(fetchPolicy) {
      if (fetchPolicy === void 0) {
        fetchPolicy = "cache-first";
      }
      var supportedFetchPolicies = [
        "cache-first",
        "network-only",
        "no-cache",
        "cache-and-network"
      ];
      globals.invariant(supportedFetchPolicies.includes(fetchPolicy), 57, fetchPolicy);
    }
    function validatePartialDataReturn(fetchPolicy, returnPartialData) {
      if (fetchPolicy === "no-cache" && returnPartialData) {
        globalThis.__DEV__ !== false && globals.invariant.warn(58);
      }
    }
    function toApolloError3(result2) {
      return utilities.isNonEmptyArray(result2.errors) ? new core.ApolloError({ graphQLErrors: result2.errors }) : result2.error;
    }
    function useWatchQueryOptions2(_a2) {
      var client = _a2.client, query = _a2.query, options = _a2.options;
      return useDeepMemo2(function() {
        var _a3;
        if (options === skipToken2) {
          return { query, fetchPolicy: "standby" };
        }
        var fetchPolicy = options.fetchPolicy || ((_a3 = client.defaultOptions.watchQuery) === null || _a3 === void 0 ? void 0 : _a3.fetchPolicy) || "cache-first";
        var watchQueryOptions = tslib.__assign(tslib.__assign({}, options), { fetchPolicy, query, notifyOnNetworkStatusChange: false, nextFetchPolicy: void 0 });
        if (globalThis.__DEV__ !== false) {
          validateOptions(watchQueryOptions);
        }
        if (options.skip) {
          watchQueryOptions.fetchPolicy = "standby";
        }
        return watchQueryOptions;
      }, [client, options, query]);
    }
    function useBackgroundQuery3(query, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      return wrapHook2("useBackgroundQuery", _useBackgroundQuery, useApolloClient2(typeof options === "object" ? options.client : void 0))(query, options);
    }
    function _useBackgroundQuery(query, options) {
      var client = useApolloClient2(options.client);
      var suspenseCache = internal.getSuspenseCache(client);
      var watchQueryOptions = useWatchQueryOptions2({ client, query, options });
      var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
      var _a2 = options.queryKey, queryKey = _a2 === void 0 ? [] : _a2;
      var didFetchResult = React__namespace.useRef(fetchPolicy !== "standby");
      didFetchResult.current || (didFetchResult.current = fetchPolicy !== "standby");
      var cacheKey = tslib.__spreadArray([
        query,
        cache2.canonicalStringify(variables)
      ], [].concat(queryKey), true);
      var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
        return client.watchQuery(watchQueryOptions);
      });
      var _b = React__namespace.useState(internal.wrapQueryRef(queryRef)), wrappedQueryRef = _b[0], setWrappedQueryRef = _b[1];
      if (internal.unwrapQueryRef(wrappedQueryRef) !== queryRef) {
        setWrappedQueryRef(internal.wrapQueryRef(queryRef));
      }
      if (queryRef.didChangeOptions(watchQueryOptions)) {
        var promise = queryRef.applyOptions(watchQueryOptions);
        internal.updateWrappedQueryRef(wrappedQueryRef, promise);
      }
      React__namespace.useEffect(function() {
        var id = setTimeout(function() {
          if (queryRef.disposed) {
            suspenseCache.add(cacheKey, queryRef);
          }
        });
        return function() {
          return clearTimeout(id);
        };
      });
      var fetchMore = React__namespace.useCallback(function(options2) {
        var promise2 = queryRef.fetchMore(options2);
        setWrappedQueryRef(internal.wrapQueryRef(queryRef));
        return promise2;
      }, [queryRef]);
      var refetch = React__namespace.useCallback(function(variables2) {
        var promise2 = queryRef.refetch(variables2);
        setWrappedQueryRef(internal.wrapQueryRef(queryRef));
        return promise2;
      }, [queryRef]);
      React__namespace.useEffect(function() {
        return queryRef.softRetain();
      }, [queryRef]);
      return [
        didFetchResult.current ? wrappedQueryRef : void 0,
        {
          fetchMore,
          refetch,
          subscribeToMore: queryRef.observable.subscribeToMore
        }
      ];
    }
    function useLoadableQuery2(query, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      var client = useApolloClient2(options.client);
      var suspenseCache = internal.getSuspenseCache(client);
      var watchQueryOptions = useWatchQueryOptions2({ client, query, options });
      var _a2 = options.queryKey, queryKey = _a2 === void 0 ? [] : _a2;
      var _b = React__namespace.useState(null), queryRef = _b[0], setQueryRef = _b[1];
      internal.assertWrappedQueryRef(queryRef);
      var internalQueryRef = queryRef && internal.unwrapQueryRef(queryRef);
      if (queryRef && (internalQueryRef === null || internalQueryRef === void 0 ? void 0 : internalQueryRef.didChangeOptions(watchQueryOptions))) {
        var promise = internalQueryRef.applyOptions(watchQueryOptions);
        internal.updateWrappedQueryRef(queryRef, promise);
      }
      var calledDuringRender = useRenderGuard2();
      var fetchMore = React__namespace.useCallback(function(options2) {
        if (!internalQueryRef) {
          throw new Error("The query has not been loaded. Please load the query.");
        }
        var promise2 = internalQueryRef.fetchMore(options2);
        setQueryRef(internal.wrapQueryRef(internalQueryRef));
        return promise2;
      }, [internalQueryRef]);
      var refetch = React__namespace.useCallback(function(options2) {
        if (!internalQueryRef) {
          throw new Error("The query has not been loaded. Please load the query.");
        }
        var promise2 = internalQueryRef.refetch(options2);
        setQueryRef(internal.wrapQueryRef(internalQueryRef));
        return promise2;
      }, [internalQueryRef]);
      var loadQuery = React__namespace.useCallback(function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        globals.invariant(!calledDuringRender(), 50);
        var variables = args[0];
        var cacheKey = tslib.__spreadArray([
          query,
          cache2.canonicalStringify(variables)
        ], [].concat(queryKey), true);
        var queryRef2 = suspenseCache.getQueryRef(cacheKey, function() {
          return client.watchQuery(tslib.__assign(tslib.__assign({}, watchQueryOptions), { variables }));
        });
        setQueryRef(internal.wrapQueryRef(queryRef2));
      }, [
        query,
        queryKey,
        suspenseCache,
        watchQueryOptions,
        calledDuringRender,
        client
      ]);
      var subscribeToMore = React__namespace.useCallback(function(options2) {
        globals.invariant(internalQueryRef, 51);
        return internalQueryRef.observable.subscribeToMore(options2);
      }, [internalQueryRef]);
      var reset = React__namespace.useCallback(function() {
        setQueryRef(null);
      }, []);
      return [loadQuery, queryRef, { fetchMore, refetch, reset, subscribeToMore }];
    }
    function useQueryRefHandlers2(queryRef) {
      var unwrapped = internal.unwrapQueryRef(queryRef);
      return wrapHook2("useQueryRefHandlers", _useQueryRefHandlers, unwrapped ? unwrapped["observable"] : useApolloClient2())(queryRef);
    }
    function _useQueryRefHandlers(queryRef) {
      internal.assertWrappedQueryRef(queryRef);
      var _a2 = React__namespace.useState(queryRef), previousQueryRef = _a2[0], setPreviousQueryRef = _a2[1];
      var _b = React__namespace.useState(queryRef), wrappedQueryRef = _b[0], setWrappedQueryRef = _b[1];
      var internalQueryRef = internal.unwrapQueryRef(queryRef);
      if (previousQueryRef !== queryRef) {
        setPreviousQueryRef(queryRef);
        setWrappedQueryRef(queryRef);
      } else {
        internal.updateWrappedQueryRef(queryRef, internal.getWrappedPromise(wrappedQueryRef));
      }
      var refetch = React__namespace.useCallback(function(variables) {
        var promise = internalQueryRef.refetch(variables);
        setWrappedQueryRef(internal.wrapQueryRef(internalQueryRef));
        return promise;
      }, [internalQueryRef]);
      var fetchMore = React__namespace.useCallback(function(options) {
        var promise = internalQueryRef.fetchMore(options);
        setWrappedQueryRef(internal.wrapQueryRef(internalQueryRef));
        return promise;
      }, [internalQueryRef]);
      return {
        refetch,
        fetchMore,
        subscribeToMore: internalQueryRef.observable.subscribeToMore
      };
    }
    function useReadQuery3(queryRef) {
      var unwrapped = internal.unwrapQueryRef(queryRef);
      return wrapHook2("useReadQuery", _useReadQuery, unwrapped ? unwrapped["observable"] : useApolloClient2())(queryRef);
    }
    function _useReadQuery(queryRef) {
      internal.assertWrappedQueryRef(queryRef);
      var internalQueryRef = React__namespace.useMemo(function() {
        return internal.unwrapQueryRef(queryRef);
      }, [queryRef]);
      var getPromise = React__namespace.useCallback(function() {
        return internal.getWrappedPromise(queryRef);
      }, [queryRef]);
      if (internalQueryRef.disposed) {
        internalQueryRef.reinitialize();
        internal.updateWrappedQueryRef(queryRef, internalQueryRef.promise);
      }
      React__namespace.useEffect(function() {
        return internalQueryRef.retain();
      }, [internalQueryRef]);
      var promise = useSyncExternalStore2(React__namespace.useCallback(function(forceUpdate) {
        return internalQueryRef.listen(function(promise2) {
          internal.updateWrappedQueryRef(queryRef, promise2);
          forceUpdate();
        });
      }, [internalQueryRef, queryRef]), getPromise, getPromise);
      var result2 = __use2(promise);
      return React__namespace.useMemo(function() {
        return {
          data: result2.data,
          networkStatus: result2.networkStatus,
          error: toApolloError3(result2)
        };
      }, [result2]);
    }
    exports.skipToken = skipToken2;
    exports.useApolloClient = useApolloClient2;
    exports.useBackgroundQuery = useBackgroundQuery3;
    exports.useFragment = useFragment2;
    exports.useLazyQuery = useLazyQuery;
    exports.useLoadableQuery = useLoadableQuery2;
    exports.useMutation = useMutation2;
    exports.useQuery = useQuery3;
    exports.useQueryRefHandlers = useQueryRefHandlers2;
    exports.useReactiveVar = useReactiveVar;
    exports.useReadQuery = useReadQuery3;
    exports.useSubscription = useSubscription2;
    exports.useSuspenseQuery = useSuspenseQuery2;
  }
});

// ../node_modules/@redwoodjs/web/dist/components/FetchConfigProvider.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var import_react = __toESM(require_react(), 1);
var getApiGraphQLUrl = () => {
  return globalThis.RWJS_API_GRAPHQL_URL;
};
var FetchConfigContext = import_react.default.createContext({
  uri: getApiGraphQLUrl()
});
var FetchConfigProvider = ({
  useAuth = useNoAuth,
  ...rest
}) => {
  const { isAuthenticated, type } = useAuth();
  if (!isAuthenticated) {
    return import_react.default.createElement(
      FetchConfigContext.Provider,
      {
        value: { uri: getApiGraphQLUrl() },
        ...rest
      }
    );
  }
  const headers = {
    "auth-provider": type
  };
  return import_react.default.createElement(
    FetchConfigContext.Provider,
    {
      value: {
        uri: getApiGraphQLUrl(),
        headers
      },
      ...rest
    }
  );
};
var useFetchConfig = () => import_react.default.useContext(FetchConfigContext);

// ../node_modules/@redwoodjs/web/dist/components/GraphQLHooksProvider.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var import_react2 = __toESM(require_react(), 1);
var GraphQLHooksContext = import_react2.default.createContext({
  useQuery: () => {
    throw new Error(
      "You must register a useQuery hook via the `GraphQLHooksProvider`"
    );
  },
  useMutation: () => {
    throw new Error(
      "You must register a useMutation hook via the `GraphQLHooksProvider`"
    );
  },
  useSubscription: () => {
    throw new Error(
      "You must register a useSubscription hook via the `GraphQLHooksProvider`"
    );
  },
  useSuspenseQuery: () => {
    throw new Error(
      "You must register a useSuspenseQuery hook via the `GraphQLHooksProvider`."
    );
  },
  //  These are apollo specific hooks!
  useBackgroundQuery: () => {
    throw new Error(
      "You must register a useBackgroundQuery hook via the `GraphQLHooksProvider`."
    );
  },
  useReadQuery: () => {
    throw new Error(
      "You must register a useReadQuery hook via the `GraphQLHooksProvider`."
    );
  }
});
var GraphQLHooksProvider = ({
  useQuery: useQuery22,
  useMutation: useMutation2,
  useSubscription: useSubscription2,
  useSuspenseQuery: useSuspenseQuery2,
  useBackgroundQuery: useBackgroundQuery22,
  useReadQuery: useReadQuery22,
  children
}) => {
  return import_react2.default.createElement(
    GraphQLHooksContext.Provider,
    {
      value: {
        useQuery: useQuery22,
        useMutation: useMutation2,
        useSubscription: useSubscription2,
        useSuspenseQuery: useSuspenseQuery2,
        useBackgroundQuery: useBackgroundQuery22,
        useReadQuery: useReadQuery22
      }
    },
    children
  );
};
function useQuery(query, options) {
  return import_react2.default.useContext(GraphQLHooksContext).useQuery(
    query,
    options
  );
}
function useMutation(mutation, options) {
  return import_react2.default.useContext(GraphQLHooksContext).useMutation(
    mutation,
    options
  );
}
function useSubscription(query, options) {
  return import_react2.default.useContext(GraphQLHooksContext).useSubscription(query, options);
}
var useBackgroundQuery = (...args) => {
  return import_react2.default.useContext(GraphQLHooksContext).useBackgroundQuery(
    ...args
  );
};
var useReadQuery = (...args) => {
  return import_react2.default.useContext(GraphQLHooksContext).useReadQuery(...args);
};

// ../node_modules/@apollo/client/link/core/ApolloLink.js
var import_dist205 = __toESM(require_dist());
var import_dist206 = __toESM(require_dist2());
var import_dist207 = __toESM(require_dist3());

// ../node_modules/@apollo/client/utilities/globals/index.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/globals/invariantWrappers.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);
init_invariant();

// ../node_modules/@apollo/client/version.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
var version = "3.11.1";

// ../node_modules/@apollo/client/utilities/globals/global.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/globals/maybe.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
function maybe(thunk) {
  try {
    return thunk();
  } catch (_a2) {
  }
}

// ../node_modules/@apollo/client/utilities/globals/global.js
var global_default = maybe(function() {
  return globalThis;
}) || maybe(function() {
  return window;
}) || maybe(function() {
  return self;
}) || maybe(function() {
  return global;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
maybe(function() {
  return maybe.constructor("return this")();
});

// ../node_modules/@apollo/client/utilities/common/stringifyForDisplay.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/common/makeUniqueId.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
var prefixCounts = /* @__PURE__ */ new Map();
function makeUniqueId(prefix) {
  var count = prefixCounts.get(prefix) || 1;
  prefixCounts.set(prefix, count + 1);
  return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
}

// ../node_modules/@apollo/client/utilities/common/stringifyForDisplay.js
function stringifyForDisplay(value, space) {
  if (space === void 0) {
    space = 0;
  }
  var undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, function(key, value2) {
    return value2 === void 0 ? undefId : value2;
  }, space).split(JSON.stringify(undefId)).join("<undefined>");
}

// ../node_modules/@apollo/client/utilities/globals/invariantWrappers.js
function wrap(fn) {
  return function(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof message === "number") {
      var arg0 = message;
      message = getHandledErrorMsg(arg0);
      if (!message) {
        message = getFallbackErrorMsg(arg0, args);
        args = [];
      }
    }
    fn.apply(void 0, [message].concat(args));
  };
}
var invariant2 = Object.assign(function invariant3(condition, message) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (!condition) {
    invariant(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));
  }
}, {
  debug: wrap(invariant.debug),
  log: wrap(invariant.log),
  warn: wrap(invariant.warn),
  error: wrap(invariant.error)
});
function newInvariantError(message) {
  var optionalParams = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    optionalParams[_i - 1] = arguments[_i];
  }
  return new InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
}
var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version);
function stringify(arg) {
  if (typeof arg == "string") {
    return arg;
  }
  try {
    return stringifyForDisplay(arg, 2).slice(0, 1e3);
  } catch (_a2) {
    return "<non-serializable>";
  }
}
function getHandledErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return global_default[ApolloErrorMessageHandler] && global_default[ApolloErrorMessageHandler](message, messageArgs.map(stringify));
}
function getFallbackErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
    version,
    message,
    args: messageArgs.map(stringify)
  })));
}

// ../node_modules/@apollo/client/utilities/globals/index.js
var DEV = globalThis.__DEV__ !== false;

// ../node_modules/@apollo/client/utilities/index.js
var import_dist175 = __toESM(require_dist(), 1);
var import_dist176 = __toESM(require_dist2(), 1);
var import_dist177 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/graphql/directives.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
init_graphql();
function shouldInclude(_a2, variables) {
  var directives = _a2.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a3) {
    var directive = _a3.directive, ifArgument = _a3.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      invariant2(evaledValue !== void 0, 69, directive.name.value);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function hasDirectives(names, root2, all) {
  var nameSet = new Set(names);
  var uniqueCount = nameSet.size;
  visit(root2, {
    Directive: function(node) {
      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
        return BREAK;
      }
    }
  });
  return all ? !nameSet.size : nameSet.size < uniqueCount;
}
function hasClientExports(document) {
  return document && hasDirectives(["client", "export"], document, true);
}
function isInclusionDirective(_a2) {
  var value = _a2.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result2 = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      invariant2(directiveArguments && directiveArguments.length === 1, 70, directiveName);
      var ifArgument = directiveArguments[0];
      invariant2(ifArgument.name && ifArgument.name.value === "if", 71, directiveName);
      var ifValue = ifArgument.value;
      invariant2(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 72, directiveName);
      result2.push({ directive, ifArgument });
    });
  }
  return result2;
}

// ../node_modules/@apollo/client/utilities/graphql/DocumentTransform.js
var import_dist100 = __toESM(require_dist(), 1);
var import_dist101 = __toESM(require_dist2(), 1);
var import_dist102 = __toESM(require_dist3(), 1);
init_lib2();

// ../node_modules/@apollo/client/utilities/common/canUse.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);
var isReactNative = maybe(function() {
  return navigator.product;
}) == "ReactNative";
var canUseWeakMap = typeof WeakMap === "function" && !(isReactNative && !global.HermesInternal);
var canUseWeakSet = typeof WeakSet === "function";
var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
var canUseDOM = typeof maybe(function() {
  return window.document.createElement;
}) === "function";
var usingJSDOM = (
  // Following advice found in this comment from @domenic (maintainer of jsdom):
  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327
  //
  // Since we control the version of Jest and jsdom used when running Apollo
  // Client tests, and that version is recent enought to include " jsdom/x.y.z"
  // at the end of the user agent string, I believe this case is all we need to
  // check. Testing for "Node.js" was recommended for backwards compatibility
  // with older version of jsdom, but we don't have that problem.
  maybe(function() {
    return navigator.userAgent.indexOf("jsdom") >= 0;
  }) || false
);
var canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;

// ../node_modules/@apollo/client/utilities/graphql/getFromAST.js
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/graphql/storeUtils.js
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/common/objects.js
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}

// ../node_modules/@apollo/client/utilities/graphql/fragments.js
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
init_tslib_es6();
function getFragmentQueryDocument(document, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw newInvariantError(
        73,
        definition.operation,
        definition.name ? " named '".concat(definition.name.value, "'") : ""
      );
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    invariant2(fragments.length === 1, 74, fragments.length);
    actualFragmentName = fragments[0].name.value;
  }
  var query = __assign(__assign({}, document), { definitions: __spreadArray([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document.definitions, true) });
  return query;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      var fragment = fragmentMap && fragmentMap[fragmentName];
      invariant2(fragment, 75, fragmentName);
      return fragment || null;
    }
    default:
      return null;
  }
}

// ../node_modules/@apollo/client/utilities/common/canonicalStringify.js
var import_dist67 = __toESM(require_dist(), 1);
var import_dist68 = __toESM(require_dist2(), 1);
var import_dist69 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/caching/index.js
var import_dist61 = __toESM(require_dist(), 1);
var import_dist62 = __toESM(require_dist2(), 1);
var import_dist63 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/caching/caches.js
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);
init_lib3();
var scheduledCleanup = /* @__PURE__ */ new WeakSet();
function schedule(cache2) {
  if (cache2.size <= (cache2.max || -1)) {
    return;
  }
  if (!scheduledCleanup.has(cache2)) {
    scheduledCleanup.add(cache2);
    setTimeout(function() {
      cache2.clean();
      scheduledCleanup.delete(cache2);
    }, 100);
  }
}
var AutoCleanedWeakCache = function(max, dispose) {
  var cache2 = new WeakCache(max, dispose);
  cache2.set = function(key, value) {
    var ret = WeakCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache2;
};
var AutoCleanedStrongCache = function(max, dispose) {
  var cache2 = new StrongCache(max, dispose);
  cache2.set = function(key, value) {
    var ret = StrongCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache2;
};

// ../node_modules/@apollo/client/utilities/caching/sizes.js
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);
init_tslib_es6();
var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
var cacheSizes = __assign({}, global_default[cacheSizeSymbol]);

// ../node_modules/@apollo/client/utilities/caching/getMemoryInternals.js
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);
init_tslib_es6();
var globalCaches = {};
function registerGlobalCache(name, getSize) {
  globalCaches[name] = getSize;
}
var getApolloClientMemoryInternals = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals : void 0;
var getInMemoryCacheMemoryInternals = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals : void 0;
var getApolloCacheMemoryInternals = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals : void 0;
function getCurrentCacheSizes() {
  var defaults = {
    parser: 1e3,
    canonicalStringify: 1e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(defaults).map(function(_a2) {
    var k = _a2[0], v = _a2[1];
    return [
      k,
      cacheSizes[k] || v
    ];
  }));
}
function _getApolloClientMemoryInternals() {
  var _a2, _b, _c, _d, _e;
  if (!(globalThis.__DEV__ !== false))
    throw new Error("only supported in development mode");
  return {
    limits: getCurrentCacheSizes(),
    sizes: __assign({ print: (_a2 = globalCaches.print) === null || _a2 === void 0 ? void 0 : _a2.call(globalCaches), parser: (_b = globalCaches.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches), canonicalStringify: (_c = globalCaches.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches), links: linkInfo(this.link), queryManager: {
      getDocumentInfo: this["queryManager"]["transformCache"].size,
      documentTransforms: transformInfo(this["queryManager"].documentTransform)
    } }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))
  };
}
function _getApolloCacheMemoryInternals() {
  return {
    cache: {
      fragmentQueryDocuments: getWrapperInformation(this["getFragmentDoc"])
    }
  };
}
function _getInMemoryCacheMemoryInternals() {
  var fragments = this.config.fragments;
  return __assign(__assign({}, _getApolloCacheMemoryInternals.apply(this)), { addTypenameDocumentTransform: transformInfo(this["addTypenameTransform"]), inMemoryCache: {
    executeSelectionSet: getWrapperInformation(this["storeReader"]["executeSelectionSet"]),
    executeSubSelectedArray: getWrapperInformation(this["storeReader"]["executeSubSelectedArray"]),
    maybeBroadcastWatch: getWrapperInformation(this["maybeBroadcastWatch"])
  }, fragmentRegistry: {
    findFragmentSpreads: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
    lookup: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
    transform: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
  } });
}
function isWrapper(f) {
  return !!f && "dirtyKey" in f;
}
function getWrapperInformation(f) {
  return isWrapper(f) ? f.size : void 0;
}
function isDefined(value) {
  return value != null;
}
function transformInfo(transform) {
  return recurseTransformInfo(transform).map(function(cache2) {
    return { cache: cache2 };
  });
}
function recurseTransformInfo(transform) {
  return transform ? __spreadArray(__spreadArray([
    getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform["performWork"])
  ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined) : [];
}
function linkInfo(link) {
  var _a2;
  return link ? __spreadArray(__spreadArray([
    (_a2 = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a2 === void 0 ? void 0 : _a2.call(link)
  ], linkInfo(link === null || link === void 0 ? void 0 : link.left), true), linkInfo(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined) : [];
}

// ../node_modules/@apollo/client/utilities/common/canonicalStringify.js
var canonicalStringify = Object.assign(function canonicalStringify2(value) {
  return JSON.stringify(value, stableObjectReplacer);
}, {
  reset: function() {
    sortingMap = new AutoCleanedStrongCache(
      cacheSizes.canonicalStringify || 1e3
      /* defaultCacheSizes.canonicalStringify */
    );
  }
});
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("canonicalStringify", function() {
    return sortingMap.size;
  });
}
var sortingMap;
canonicalStringify.reset();
function stableObjectReplacer(key, value) {
  if (value && typeof value === "object") {
    var proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
      var keys = Object.keys(value);
      if (keys.every(everyKeyInOrder))
        return value;
      var unsortedKey = JSON.stringify(keys);
      var sortedKeys = sortingMap.get(unsortedKey);
      if (!sortedKeys) {
        keys.sort();
        var sortedKey = JSON.stringify(keys);
        sortedKeys = sortingMap.get(sortedKey) || keys;
        sortingMap.set(unsortedKey, sortedKeys);
        sortingMap.set(sortedKey, sortedKeys);
      }
      var sortedObject_1 = Object.create(proto);
      sortedKeys.forEach(function(key2) {
        sortedObject_1[key2] = value[key2];
      });
      return sortedObject_1;
    }
  }
  return value;
}
function everyKeyInOrder(key, i, keys) {
  return i === 0 || keys[i - 1] <= key;
}

// ../node_modules/@apollo/client/utilities/graphql/storeUtils.js
function makeReference(id) {
  return { __ref: String(id) };
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw newInvariantError(84, name.value, value.kind);
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a2) {
          var name = _a2.name, value = _a2.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
];
var storeKeyNameStringify = canonicalStringify;
var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key) {
        filteredArgs_1[key] = args[key];
      });
      return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify(filteredArgs_1), ")");
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = storeKeyNameStringify(args);
    completeFieldName += "(".concat(stringifiedArgs, ")");
  }
  if (directives) {
    Object.keys(directives).forEach(function(key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify(directives[key]), ")");
      } else {
        completeFieldName += "@".concat(key);
      }
    });
  }
  return completeFieldName;
}, {
  setStringify: function(s) {
    var previous = storeKeyNameStringify;
    storeKeyNameStringify = s;
    return previous;
  }
});
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result2, selectionSet, fragmentMap) {
  var fragments;
  for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
    var selection = _a2[_i];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result2[resultKeyNameFromField(selection)];
      }
    } else if (fragments) {
      fragments.push(selection);
    } else {
      fragments = [selection];
    }
  }
  if (typeof result2.__typename === "string") {
    return result2.__typename;
  }
  if (fragments) {
    for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
      var selection = fragments_1[_b];
      var typename = getTypenameFromResult(result2, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}

// ../node_modules/@apollo/client/utilities/graphql/getFromAST.js
function checkDocument(doc) {
  invariant2(doc && doc.kind === "Document", 76);
  var operations = doc.definitions.filter(function(d) {
    return d.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw newInvariantError(77, definition.kind);
    }
    return definition;
  });
  invariant2(operations.length <= 1, 78, operations.length);
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && !!definition.name;
  }).map(function(x) {
    return x.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  invariant2(queryDef && queryDef.operation === "query", 79);
  return queryDef;
}
function getFragmentDefinition(doc) {
  invariant2(doc.kind === "Document", 80);
  invariant2(doc.definitions.length <= 1, 81);
  var fragmentDef = doc.definitions[0];
  invariant2(fragmentDef.kind === "FragmentDefinition", 82);
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
    var definition = _a2[_i];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw newInvariantError(83);
}
function getDefaultValues(definition) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}

// ../node_modules/@apollo/client/utilities/graphql/DocumentTransform.js
init_lib3();
init_lib6();
function identity(document) {
  return document;
}
var DocumentTransform = (
  /** @class */
  function() {
    function DocumentTransform2(transform, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      this.resultCache = canUseWeakSet ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
      this.transform = transform;
      if (options.getCacheKey) {
        this.getCacheKey = options.getCacheKey;
      }
      this.cached = options.cache !== false;
      this.resetCache();
    }
    DocumentTransform2.prototype.getCacheKey = function(document) {
      return [document];
    };
    DocumentTransform2.identity = function() {
      return new DocumentTransform2(identity, { cache: false });
    };
    DocumentTransform2.split = function(predicate, left, right) {
      if (right === void 0) {
        right = DocumentTransform2.identity();
      }
      return Object.assign(new DocumentTransform2(
        function(document) {
          var documentTransform = predicate(document) ? left : right;
          return documentTransform.transformDocument(document);
        },
        // Reasonably assume both `left` and `right` transforms handle their own caching
        { cache: false }
      ), { left, right });
    };
    DocumentTransform2.prototype.resetCache = function() {
      var _this = this;
      if (this.cached) {
        var stableCacheKeys_1 = new Trie(canUseWeakMap);
        this.performWork = wrap2(DocumentTransform2.prototype.performWork.bind(this), {
          makeCacheKey: function(document) {
            var cacheKeys = _this.getCacheKey(document);
            if (cacheKeys) {
              invariant2(Array.isArray(cacheKeys), 68);
              return stableCacheKeys_1.lookupArray(cacheKeys);
            }
          },
          max: cacheSizes["documentTransform.cache"],
          cache: WeakCache
        });
      }
    };
    DocumentTransform2.prototype.performWork = function(document) {
      checkDocument(document);
      return this.transform(document);
    };
    DocumentTransform2.prototype.transformDocument = function(document) {
      if (this.resultCache.has(document)) {
        return document;
      }
      var transformedDocument = this.performWork(document);
      this.resultCache.add(transformedDocument);
      return transformedDocument;
    };
    DocumentTransform2.prototype.concat = function(otherTransform) {
      var _this = this;
      return Object.assign(new DocumentTransform2(
        function(document) {
          return otherTransform.transformDocument(_this.transformDocument(document));
        },
        // Reasonably assume both transforms handle their own caching
        { cache: false }
      ), {
        left: this,
        right: otherTransform
      });
    };
    return DocumentTransform2;
  }()
);

// ../node_modules/@apollo/client/utilities/graphql/print.js
var import_dist103 = __toESM(require_dist(), 1);
var import_dist104 = __toESM(require_dist2(), 1);
var import_dist105 = __toESM(require_dist3(), 1);
init_graphql();
var printCache;
var print2 = Object.assign(function(ast) {
  var result2 = printCache.get(ast);
  if (!result2) {
    result2 = print(ast);
    printCache.set(ast, result2);
  }
  return result2;
}, {
  reset: function() {
    printCache = new AutoCleanedWeakCache(
      cacheSizes.print || 2e3
      /* defaultCacheSizes.print */
    );
  }
});
print2.reset();
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("print", function() {
    return printCache ? printCache.size : 0;
  });
}

// ../node_modules/@apollo/client/utilities/graphql/transform.js
var import_dist109 = __toESM(require_dist(), 1);
var import_dist110 = __toESM(require_dist2(), 1);
var import_dist111 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_graphql();

// ../node_modules/@apollo/client/utilities/common/arrays.js
var import_dist106 = __toESM(require_dist(), 1);
var import_dist107 = __toESM(require_dist2(), 1);
var import_dist108 = __toESM(require_dist3(), 1);
var isArray = Array.isArray;
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}

// ../node_modules/@apollo/client/utilities/graphql/transform.js
var TYPENAME_FIELD = {
  kind: Kind.FIELD,
  name: {
    kind: Kind.NAME,
    value: "__typename"
  }
};
function isEmpty(op, fragmentMap) {
  return !op || op.selectionSet.selections.every(function(selection) {
    return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(configs) {
  var names = /* @__PURE__ */ new Map();
  var tests = /* @__PURE__ */ new Map();
  configs.forEach(function(directive) {
    if (directive) {
      if (directive.name) {
        names.set(directive.name, directive);
      } else if (directive.test) {
        tests.set(directive.test, directive);
      }
    }
  });
  return function(directive) {
    var config = names.get(directive.name.value);
    if (!config && tests.size) {
      tests.forEach(function(testConfig, test) {
        if (test(directive)) {
          config = testConfig;
        }
      });
    }
    return config;
  };
}
function makeInUseGetterFunction(defaultKey) {
  var map = /* @__PURE__ */ new Map();
  return function inUseGetterFunction(key) {
    if (key === void 0) {
      key = defaultKey;
    }
    var inUse = map.get(key);
    if (!inUse) {
      map.set(key, inUse = {
        // Variable and fragment spread names used directly within this
        // operation or fragment definition, as identified by key. These sets
        // will be populated during the first traversal of the document in
        // removeDirectivesFromDocument below.
        variables: /* @__PURE__ */ new Set(),
        fragmentSpreads: /* @__PURE__ */ new Set()
      });
    }
    return inUse;
  };
}
function removeDirectivesFromDocument(directives, doc) {
  checkDocument(doc);
  var getInUseByOperationName = makeInUseGetterFunction("");
  var getInUseByFragmentName = makeInUseGetterFunction("");
  var getInUse = function(ancestors) {
    for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
      if (isArray(ancestor))
        continue;
      if (ancestor.kind === Kind.OPERATION_DEFINITION) {
        return getInUseByOperationName(ancestor.name && ancestor.name.value);
      }
      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {
        return getInUseByFragmentName(ancestor.name.value);
      }
    }
    globalThis.__DEV__ !== false && invariant2.error(85);
    return null;
  };
  var operationCount = 0;
  for (var i = doc.definitions.length - 1; i >= 0; --i) {
    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {
      ++operationCount;
    }
  }
  var directiveMatcher = getDirectiveMatcher(directives);
  var shouldRemoveField = function(nodeDirectives) {
    return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
      return config && config.remove;
    });
  };
  var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
  var firstVisitMadeChanges = false;
  var fieldOrInlineFragmentVisitor = {
    enter: function(node) {
      if (shouldRemoveField(node.directives)) {
        firstVisitMadeChanges = true;
        return null;
      }
    }
  };
  var docWithoutDirectiveSubtrees = visit(doc, {
    // These two AST node types share the same implementation, defined above.
    Field: fieldOrInlineFragmentVisitor,
    InlineFragment: fieldOrInlineFragmentVisitor,
    VariableDefinition: {
      enter: function() {
        return false;
      }
    },
    Variable: {
      enter: function(node, _key, _parent, _path, ancestors) {
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.variables.add(node.name.value);
        }
      }
    },
    FragmentSpread: {
      enter: function(node, _key, _parent, _path, ancestors) {
        if (shouldRemoveField(node.directives)) {
          firstVisitMadeChanges = true;
          return null;
        }
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.fragmentSpreads.add(node.name.value);
        }
      }
    },
    FragmentDefinition: {
      enter: function(node, _key, _parent, path) {
        originalFragmentDefsByPath.set(JSON.stringify(path), node);
      },
      leave: function(node, _key, _parent, path) {
        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
        if (node === originalNode) {
          return node;
        }
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          operationCount > 0 && node.selectionSet.selections.every(function(selection) {
            return selection.kind === Kind.FIELD && selection.name.value === "__typename";
          })
        ) {
          getInUseByFragmentName(node.name.value).removed = true;
          firstVisitMadeChanges = true;
          return null;
        }
      }
    },
    Directive: {
      leave: function(node) {
        if (directiveMatcher(node)) {
          firstVisitMadeChanges = true;
          return null;
        }
      }
    }
  });
  if (!firstVisitMadeChanges) {
    return doc;
  }
  var populateTransitiveVars = function(inUse) {
    if (!inUse.transitiveVars) {
      inUse.transitiveVars = new Set(inUse.variables);
      if (!inUse.removed) {
        inUse.fragmentSpreads.forEach(function(childFragmentName) {
          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
            inUse.transitiveVars.add(varName);
          });
        });
      }
    }
    return inUse;
  };
  var allFragmentNamesUsed = /* @__PURE__ */ new Set();
  docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
    if (def.kind === Kind.OPERATION_DEFINITION) {
      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
        allFragmentNamesUsed.add(childFragmentName);
      });
    } else if (def.kind === Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
      allFragmentNamesUsed.add(def.name.value);
    }
  });
  allFragmentNamesUsed.forEach(function(fragmentName) {
    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
      allFragmentNamesUsed.add(childFragmentName);
    });
  });
  var fragmentWillBeRemoved = function(fragmentName) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
  };
  var enterVisitor = {
    enter: function(node) {
      if (fragmentWillBeRemoved(node.name.value)) {
        return null;
      }
    }
  };
  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: enterVisitor,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: enterVisitor,
    OperationDefinition: {
      leave: function(node) {
        if (node.variableDefinitions) {
          var usedVariableNames_1 = populateTransitiveVars(
            // If an operation is anonymous, we use the empty string as its key.
            getInUseByOperationName(node.name && node.name.value)
          ).transitiveVars;
          if (usedVariableNames_1.size < node.variableDefinitions.length) {
            return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
              return usedVariableNames_1.has(varDef.variable.name.value);
            }) });
          }
        }
      }
    }
  }));
}
var addTypenameToDocument = Object.assign(function(doc) {
  return visit(doc, {
    SelectionSet: {
      enter: function(node, _key, parent) {
        if (parent && parent.kind === Kind.OPERATION_DEFINITION) {
          return;
        }
        var selections = node.selections;
        if (!selections) {
          return;
        }
        var skip = selections.some(function(selection) {
          return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip) {
          return;
        }
        var field = parent;
        if (isField(field) && field.directives && field.directives.some(function(d) {
          return d.name.value === "export";
        })) {
          return;
        }
        return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
      }
    }
  });
}, {
  added: function(field) {
    return field === TYPENAME_FIELD;
  }
});
function buildQueryFromSelectionSet(document) {
  var definition = getMainDefinition(document);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document;
  }
  var modifiedDoc = visit(document, {
    OperationDefinition: {
      enter: function(node) {
        return __assign(__assign({}, node), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document) {
  checkDocument(document);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document);
  return modifiedDoc;
}

// ../node_modules/@apollo/client/utilities/graphql/operations.js
var import_dist112 = __toESM(require_dist(), 1);
var import_dist113 = __toESM(require_dist2(), 1);
var import_dist114 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/policies/pagination.js
var import_dist118 = __toESM(require_dist(), 1);
var import_dist119 = __toESM(require_dist2(), 1);
var import_dist120 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_tslib_es6();

// ../node_modules/@apollo/client/utilities/common/mergeDeep.js
var import_dist115 = __toESM(require_dist(), 1);
var import_dist116 = __toESM(require_dist2(), 1);
var import_dist117 = __toESM(require_dist3(), 1);
init_tslib_es6();
var hasOwnProperty4 = Object.prototype.hasOwnProperty;
function mergeDeep() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count = sources.length;
  if (count > 1) {
    var merger = new DeepMerger();
    for (var i = 1; i < count; ++i) {
      target = merger.merge(target, sources[i]);
    }
  }
  return target;
}
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = (
  /** @class */
  function() {
    function DeepMerger2(reconciler) {
      if (reconciler === void 0) {
        reconciler = defaultReconciler;
      }
      this.reconciler = reconciler;
      this.isObject = isNonNullObject;
      this.pastCopies = /* @__PURE__ */ new Set();
    }
    DeepMerger2.prototype.merge = function(target, source) {
      var _this = this;
      var context = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        context[_i - 2] = arguments[_i];
      }
      if (isNonNullObject(source) && isNonNullObject(target)) {
        Object.keys(source).forEach(function(sourceKey) {
          if (hasOwnProperty4.call(target, sourceKey)) {
            var targetValue = target[sourceKey];
            if (source[sourceKey] !== targetValue) {
              var result2 = _this.reconciler.apply(_this, __spreadArray([
                target,
                source,
                sourceKey
              ], context, false));
              if (result2 !== targetValue) {
                target = _this.shallowCopyForMerge(target);
                target[sourceKey] = result2;
              }
            }
          } else {
            target = _this.shallowCopyForMerge(target);
            target[sourceKey] = source[sourceKey];
          }
        });
        return target;
      }
      return source;
    };
    DeepMerger2.prototype.shallowCopyForMerge = function(value) {
      if (isNonNullObject(value)) {
        if (!this.pastCopies.has(value)) {
          if (Array.isArray(value)) {
            value = value.slice(0);
          } else {
            value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          this.pastCopies.add(value);
        }
      }
      return value;
    };
    return DeepMerger2;
  }()
);

// ../node_modules/@apollo/client/utilities/observables/Observable.js
var import_dist130 = __toESM(require_dist());
var import_dist131 = __toESM(require_dist2());
var import_dist132 = __toESM(require_dist3());
init_module();
init_es();
var prototype = Observable.prototype;
var fakeObsSymbol = "@@observable";
if (!prototype[fakeObsSymbol]) {
  prototype[fakeObsSymbol] = function() {
    return this;
  };
}

// ../node_modules/@apollo/client/utilities/promises/decoration.js
var import_dist133 = __toESM(require_dist(), 1);
var import_dist134 = __toESM(require_dist2(), 1);
var import_dist135 = __toESM(require_dist3(), 1);
function createFulfilledPromise(value) {
  var promise = Promise.resolve(value);
  promise.status = "fulfilled";
  promise.value = value;
  return promise;
}
function createRejectedPromise(reason) {
  var promise = Promise.reject(reason);
  promise.catch(function() {
  });
  promise.status = "rejected";
  promise.reason = reason;
  return promise;
}
function isStatefulPromise(promise) {
  return "status" in promise;
}
function wrapPromiseWithState(promise) {
  if (isStatefulPromise(promise)) {
    return promise;
  }
  var pendingPromise = promise;
  pendingPromise.status = "pending";
  pendingPromise.then(function(value) {
    if (pendingPromise.status === "pending") {
      var fulfilledPromise = pendingPromise;
      fulfilledPromise.status = "fulfilled";
      fulfilledPromise.value = value;
    }
  }, function(reason) {
    if (pendingPromise.status === "pending") {
      var rejectedPromise = pendingPromise;
      rejectedPromise.status = "rejected";
      rejectedPromise.reason = reason;
    }
  });
  return promise;
}

// ../node_modules/@apollo/client/utilities/common/cloneDeep.js
var import_dist136 = __toESM(require_dist(), 1);
var import_dist137 = __toESM(require_dist2(), 1);
var import_dist138 = __toESM(require_dist3(), 1);
var toString = Object.prototype.toString;
function cloneDeep(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen) {
  switch (toString.call(val)) {
    case "[object Array]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_1 = val.slice(0);
      seen.set(val, copy_1);
      copy_1.forEach(function(child, i) {
        copy_1[i] = cloneDeepHelper(child, seen);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper(val[key], seen);
      });
      return copy_2;
    }
    default:
      return val;
  }
}

// ../node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js
var import_dist139 = __toESM(require_dist(), 1);
var import_dist140 = __toESM(require_dist2(), 1);
var import_dist141 = __toESM(require_dist3(), 1);
function deepFreeze(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        if (isNonNullObject(obj[name]))
          workSet.add(obj[name]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e) {
      if (e instanceof TypeError)
        return null;
      throw e;
    }
  }
  return obj;
}
function maybeDeepFreeze(obj) {
  if (globalThis.__DEV__ !== false) {
    deepFreeze(obj);
  }
  return obj;
}

// ../node_modules/@apollo/client/utilities/observables/iteration.js
var import_dist142 = __toESM(require_dist(), 1);
var import_dist143 = __toESM(require_dist2(), 1);
var import_dist144 = __toESM(require_dist3(), 1);
function iterateObserversSafely(observers, method, argument) {
  var observersWithMethod = [];
  observers.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}

// ../node_modules/@apollo/client/utilities/observables/asyncMap.js
var import_dist145 = __toESM(require_dist(), 1);
var import_dist146 = __toESM(require_dist2(), 1);
var import_dist147 = __toESM(require_dist3(), 1);
function asyncMap(observable, mapFn, catchFn) {
  return new Observable(function(observer) {
    var promiseQueue = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(callback) {
        return new Promise(function(resolve) {
          return resolve(callback());
        });
      }
    };
    function makeCallback(examiner, key) {
      return function(arg) {
        if (examiner) {
          var both = function() {
            return observer.closed ? (
              /* will be swallowed */
              0
            ) : examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result2) {
            return observer.next(result2);
          }, function(error) {
            return observer.error(error);
          });
        } else {
          observer[key](arg);
        }
      };
    }
    var handler = {
      next: makeCallback(mapFn, "next"),
      error: makeCallback(catchFn, "error"),
      complete: function() {
        promiseQueue.then(function() {
          return observer.complete();
        });
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}

// ../node_modules/@apollo/client/utilities/observables/Concast.js
var import_dist151 = __toESM(require_dist(), 1);
var import_dist152 = __toESM(require_dist2(), 1);
var import_dist153 = __toESM(require_dist3(), 1);
init_tslib_es6();

// ../node_modules/@apollo/client/utilities/observables/subclassing.js
var import_dist148 = __toESM(require_dist(), 1);
var import_dist149 = __toESM(require_dist2(), 1);
var import_dist150 = __toESM(require_dist3(), 1);
function fixObservableSubclass(subclass) {
  function set(key) {
    Object.defineProperty(subclass, key, { value: Observable });
  }
  if (canUseSymbol && Symbol.species) {
    set(Symbol.species);
  }
  set("@@species");
  return subclass;
}

// ../node_modules/@apollo/client/utilities/observables/Concast.js
function isPromiseLike2(value) {
  return value && typeof value.then === "function";
}
var Concast = (
  /** @class */
  function(_super) {
    __extends(Concast2, _super);
    function Concast2(sources) {
      var _this = _super.call(this, function(observer) {
        _this.addObserver(observer);
        return function() {
          return _this.removeObserver(observer);
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      _this.handlers = {
        next: function(result2) {
          if (_this.sub !== null) {
            _this.latest = ["next", result2];
            _this.notify("next", result2);
            iterateObserversSafely(_this.observers, "next", result2);
          }
        },
        error: function(error) {
          var sub = _this.sub;
          if (sub !== null) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            _this.latest = ["error", error];
            _this.reject(error);
            _this.notify("error", error);
            iterateObserversSafely(_this.observers, "error", error);
          }
        },
        complete: function() {
          var _a2 = _this, sub = _a2.sub, _b = _a2.sources, sources2 = _b === void 0 ? [] : _b;
          if (sub !== null) {
            var value = sources2.shift();
            if (!value) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              if (_this.latest && _this.latest[0] === "next") {
                _this.resolve(_this.latest[1]);
              } else {
                _this.resolve();
              }
              _this.notify("complete");
              iterateObserversSafely(_this.observers, "complete");
            } else if (isPromiseLike2(value)) {
              value.then(function(obs) {
                return _this.sub = obs.subscribe(_this.handlers);
              }, _this.handlers.error);
            } else {
              _this.sub = value.subscribe(_this.handlers);
            }
          }
        }
      };
      _this.nextResultListeners = /* @__PURE__ */ new Set();
      _this.cancel = function(reason) {
        _this.reject(reason);
        _this.sources = [];
        _this.handlers.complete();
      };
      _this.promise.catch(function(_) {
      });
      if (typeof sources === "function") {
        sources = [new Observable(sources)];
      }
      if (isPromiseLike2(sources)) {
        sources.then(function(iterable) {
          return _this.start(iterable);
        }, _this.handlers.error);
      } else {
        _this.start(sources);
      }
      return _this;
    }
    Concast2.prototype.start = function(sources) {
      if (this.sub !== void 0)
        return;
      this.sources = Array.from(sources);
      this.handlers.complete();
    };
    Concast2.prototype.deliverLastMessage = function(observer) {
      if (this.latest) {
        var nextOrError = this.latest[0];
        var method = observer[nextOrError];
        if (method) {
          method.call(observer, this.latest[1]);
        }
        if (this.sub === null && nextOrError === "next" && observer.complete) {
          observer.complete();
        }
      }
    };
    Concast2.prototype.addObserver = function(observer) {
      if (!this.observers.has(observer)) {
        this.deliverLastMessage(observer);
        this.observers.add(observer);
      }
    };
    Concast2.prototype.removeObserver = function(observer) {
      if (this.observers.delete(observer) && this.observers.size < 1) {
        this.handlers.complete();
      }
    };
    Concast2.prototype.notify = function(method, arg) {
      var nextResultListeners = this.nextResultListeners;
      if (nextResultListeners.size) {
        this.nextResultListeners = /* @__PURE__ */ new Set();
        nextResultListeners.forEach(function(listener) {
          return listener(method, arg);
        });
      }
    };
    Concast2.prototype.beforeNext = function(callback) {
      var called = false;
      this.nextResultListeners.add(function(method, arg) {
        if (!called) {
          called = true;
          callback(method, arg);
        }
      });
    };
    return Concast2;
  }(Observable)
);
fixObservableSubclass(Concast);

// ../node_modules/@apollo/client/utilities/common/errorHandling.js
var import_dist157 = __toESM(require_dist(), 1);
var import_dist158 = __toESM(require_dist2(), 1);
var import_dist159 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/common/incrementalResult.js
var import_dist154 = __toESM(require_dist(), 1);
var import_dist155 = __toESM(require_dist2(), 1);
var import_dist156 = __toESM(require_dist3(), 1);
function isExecutionPatchIncrementalResult(value) {
  return "incremental" in value;
}
function isExecutionPatchInitialResult(value) {
  return "hasNext" in value && "data" in value;
}
function isExecutionPatchResult(value) {
  return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);
}
function isApolloPayloadResult(value) {
  return isNonNullObject(value) && "payload" in value;
}
function mergeIncrementalData(prevResult, result2) {
  var mergedData = prevResult;
  var merger = new DeepMerger();
  if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
    result2.incremental.forEach(function(_a2) {
      var data = _a2.data, path = _a2.path;
      for (var i = path.length - 1; i >= 0; --i) {
        var key = path[i];
        var isNumericKey = !isNaN(+key);
        var parent_1 = isNumericKey ? [] : {};
        parent_1[key] = data;
        data = parent_1;
      }
      mergedData = merger.merge(mergedData, data);
    });
  }
  return mergedData;
}

// ../node_modules/@apollo/client/utilities/common/errorHandling.js
function graphQLResultHasError(result2) {
  var errors = getGraphQLErrorsFromResult(result2);
  return isNonEmptyArray(errors);
}
function getGraphQLErrorsFromResult(result2) {
  var graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
  if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
    result2.incremental.forEach(function(incrementalResult) {
      if (incrementalResult.errors) {
        graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
      }
    });
  }
  return graphQLErrors;
}

// ../node_modules/@apollo/client/utilities/common/compact.js
var import_dist160 = __toESM(require_dist(), 1);
var import_dist161 = __toESM(require_dist2(), 1);
var import_dist162 = __toESM(require_dist3(), 1);
function compact() {
  var objects = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    objects[_i] = arguments[_i];
  }
  var result2 = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result2[key] = value;
      }
    });
  });
  return result2;
}

// ../node_modules/@apollo/client/utilities/common/mergeOptions.js
var import_dist163 = __toESM(require_dist(), 1);
var import_dist164 = __toESM(require_dist2(), 1);
var import_dist165 = __toESM(require_dist3(), 1);
init_tslib_es6();
function mergeOptions(defaults, options) {
  return compact(defaults, options, options.variables && {
    variables: compact(__assign(__assign({}, defaults && defaults.variables), options.variables))
  });
}

// ../node_modules/@apollo/client/utilities/common/omitDeep.js
var import_dist166 = __toESM(require_dist(), 1);
var import_dist167 = __toESM(require_dist2(), 1);
var import_dist168 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/common/stripTypename.js
var import_dist169 = __toESM(require_dist(), 1);
var import_dist170 = __toESM(require_dist2(), 1);
var import_dist171 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/utilities/types/IsStrictlyAny.js
var import_dist172 = __toESM(require_dist(), 1);
var import_dist173 = __toESM(require_dist2(), 1);
var import_dist174 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/link/utils/index.js
var import_dist202 = __toESM(require_dist(), 1);
var import_dist203 = __toESM(require_dist2(), 1);
var import_dist204 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/link/utils/fromError.js
var import_dist178 = __toESM(require_dist(), 1);
var import_dist179 = __toESM(require_dist2(), 1);
var import_dist180 = __toESM(require_dist3(), 1);
function fromError(errorValue) {
  return new Observable(function(observer) {
    observer.error(errorValue);
  });
}

// ../node_modules/@apollo/client/link/utils/toPromise.js
var import_dist181 = __toESM(require_dist(), 1);
var import_dist182 = __toESM(require_dist2(), 1);
var import_dist183 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/link/utils/fromPromise.js
var import_dist184 = __toESM(require_dist(), 1);
var import_dist185 = __toESM(require_dist2(), 1);
var import_dist186 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/link/utils/throwServerError.js
var import_dist187 = __toESM(require_dist(), 1);
var import_dist188 = __toESM(require_dist2(), 1);
var import_dist189 = __toESM(require_dist3(), 1);
var throwServerError = function(response, result2, message) {
  var error = new Error(message);
  error.name = "ServerError";
  error.response = response;
  error.statusCode = response.status;
  error.result = result2;
  throw error;
};

// ../node_modules/@apollo/client/link/utils/validateOperation.js
var import_dist190 = __toESM(require_dist(), 1);
var import_dist191 = __toESM(require_dist2(), 1);
var import_dist192 = __toESM(require_dist3(), 1);
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
    var key = _a2[_i];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw newInvariantError(43, key);
    }
  }
  return operation;
}

// ../node_modules/@apollo/client/link/utils/createOperation.js
var import_dist193 = __toESM(require_dist(), 1);
var import_dist194 = __toESM(require_dist2(), 1);
var import_dist195 = __toESM(require_dist3(), 1);
init_tslib_es6();
function createOperation(starting, operation) {
  var context = __assign({}, starting);
  var setContext = function(next) {
    if (typeof next === "function") {
      context = __assign(__assign({}, context), next(context));
    } else {
      context = __assign(__assign({}, context), next);
    }
  };
  var getContext = function() {
    return __assign({}, context);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  return operation;
}

// ../node_modules/@apollo/client/link/utils/transformOperation.js
var import_dist196 = __toESM(require_dist(), 1);
var import_dist197 = __toESM(require_dist2(), 1);
var import_dist198 = __toESM(require_dist3(), 1);
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}

// ../node_modules/@apollo/client/link/utils/filterOperationVariables.js
var import_dist199 = __toESM(require_dist(), 1);
var import_dist200 = __toESM(require_dist2(), 1);
var import_dist201 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_graphql();
function filterOperationVariables(variables, query) {
  var result2 = __assign({}, variables);
  var unusedNames = new Set(Object.keys(variables));
  visit(query, {
    Variable: function(node, _key, parent) {
      if (parent && parent.kind !== "VariableDefinition") {
        unusedNames.delete(node.name.value);
      }
    }
  });
  unusedNames.forEach(function(name) {
    delete result2[name];
  });
  return result2;
}

// ../node_modules/@apollo/client/link/core/ApolloLink.js
function passthrough(op, forward) {
  return forward ? forward(op) : Observable.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
  return link.request.length <= 1;
}
var ApolloLink = (
  /** @class */
  function() {
    function ApolloLink2(request) {
      if (request)
        this.request = request;
    }
    ApolloLink2.empty = function() {
      return new ApolloLink2(function() {
        return Observable.of();
      });
    };
    ApolloLink2.from = function(links) {
      if (links.length === 0)
        return ApolloLink2.empty();
      return links.map(toLink).reduce(function(x, y) {
        return x.concat(y);
      });
    };
    ApolloLink2.split = function(test, left, right) {
      var leftLink = toLink(left);
      var rightLink = toLink(right || new ApolloLink2(passthrough));
      var ret;
      if (isTerminating(leftLink) && isTerminating(rightLink)) {
        ret = new ApolloLink2(function(operation) {
          return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
        });
      } else {
        ret = new ApolloLink2(function(operation, forward) {
          return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
        });
      }
      return Object.assign(ret, { left: leftLink, right: rightLink });
    };
    ApolloLink2.execute = function(link, operation) {
      return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
    };
    ApolloLink2.concat = function(first, second) {
      var firstLink = toLink(first);
      if (isTerminating(firstLink)) {
        globalThis.__DEV__ !== false && invariant2.warn(35, firstLink);
        return firstLink;
      }
      var nextLink = toLink(second);
      var ret;
      if (isTerminating(nextLink)) {
        ret = new ApolloLink2(function(operation) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op) || Observable.of();
          }) || Observable.of();
        });
      } else {
        ret = new ApolloLink2(function(operation, forward) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op, forward) || Observable.of();
          }) || Observable.of();
        });
      }
      return Object.assign(ret, { left: firstLink, right: nextLink });
    };
    ApolloLink2.prototype.split = function(test, left, right) {
      return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
    };
    ApolloLink2.prototype.concat = function(next) {
      return ApolloLink2.concat(this, next);
    };
    ApolloLink2.prototype.request = function(operation, forward) {
      throw newInvariantError(36);
    };
    ApolloLink2.prototype.onError = function(error, observer) {
      if (observer && observer.error) {
        observer.error(error);
        return false;
      }
      throw error;
    };
    ApolloLink2.prototype.setOnError = function(fn) {
      this.onError = fn;
      return this;
    };
    return ApolloLink2;
  }()
);

// ../node_modules/@apollo/client/link/core/split.js
var import_dist208 = __toESM(require_dist(), 1);
var import_dist209 = __toESM(require_dist2(), 1);
var import_dist210 = __toESM(require_dist3(), 1);
var split = ApolloLink.split;

// ../node_modules/@apollo/client/link/core/index.js
var import_dist226 = __toESM(require_dist(), 1);
var import_dist227 = __toESM(require_dist2(), 1);
var import_dist228 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/link/core/empty.js
var import_dist211 = __toESM(require_dist(), 1);
var import_dist212 = __toESM(require_dist2(), 1);
var import_dist213 = __toESM(require_dist3(), 1);
var empty = ApolloLink.empty;

// ../node_modules/@apollo/client/link/core/from.js
var import_dist214 = __toESM(require_dist(), 1);
var import_dist215 = __toESM(require_dist2(), 1);
var import_dist216 = __toESM(require_dist3(), 1);
var from = ApolloLink.from;

// ../node_modules/@apollo/client/link/core/concat.js
var import_dist217 = __toESM(require_dist(), 1);
var import_dist218 = __toESM(require_dist2(), 1);
var import_dist219 = __toESM(require_dist3(), 1);
var concat = ApolloLink.concat;

// ../node_modules/@apollo/client/link/core/execute.js
var import_dist220 = __toESM(require_dist(), 1);
var import_dist221 = __toESM(require_dist2(), 1);
var import_dist222 = __toESM(require_dist3(), 1);
var execute = ApolloLink.execute;

// ../node_modules/@apollo/client/link/core/types.js
var import_dist223 = __toESM(require_dist(), 1);
var import_dist224 = __toESM(require_dist2(), 1);
var import_dist225 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js
var import_dist268 = __toESM(require_dist(), 1);
var import_dist269 = __toESM(require_dist2(), 1);
var import_dist270 = __toESM(require_dist3(), 1);
init_tslib_es6();

// ../node_modules/@apollo/client/cache/inmemory/fixPolyfills.js
var import_dist229 = __toESM(require_dist(), 1);
var import_dist230 = __toESM(require_dist2(), 1);
var import_dist231 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js
init_lib6();
init_lib7();

// ../node_modules/@apollo/client/cache/core/cache.js
var import_dist238 = __toESM(require_dist(), 1);
var import_dist239 = __toESM(require_dist2(), 1);
var import_dist240 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_lib6();
init_lib3();

// ../node_modules/@apollo/client/core/equalByQuery.js
var import_dist235 = __toESM(require_dist(), 1);
var import_dist236 = __toESM(require_dist2(), 1);
var import_dist237 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_lib7();
function equalByQuery(query, _a2, _b, variables) {
  var aData = _a2.data, aRest = __rest(_a2, ["data"]);
  var bData = _b.data, bRest = __rest(_b, ["data"]);
  return lib_default(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {
    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
    variables
  });
}
function equalBySelectionSet(selectionSet, aResult, bResult, context) {
  if (aResult === bResult) {
    return true;
  }
  var seenSelections = /* @__PURE__ */ new Set();
  return selectionSet.selections.every(function(selection) {
    if (seenSelections.has(selection))
      return true;
    seenSelections.add(selection);
    if (!shouldInclude(selection, context.variables))
      return true;
    if (selectionHasNonreactiveDirective(selection))
      return true;
    if (isField(selection)) {
      var resultKey = resultKeyNameFromField(selection);
      var aResultChild = aResult && aResult[resultKey];
      var bResultChild = bResult && bResult[resultKey];
      var childSelectionSet = selection.selectionSet;
      if (!childSelectionSet) {
        return lib_default(aResultChild, bResultChild);
      }
      var aChildIsArray = Array.isArray(aResultChild);
      var bChildIsArray = Array.isArray(bResultChild);
      if (aChildIsArray !== bChildIsArray)
        return false;
      if (aChildIsArray && bChildIsArray) {
        var length_1 = aResultChild.length;
        if (bResultChild.length !== length_1) {
          return false;
        }
        for (var i = 0; i < length_1; ++i) {
          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
            return false;
          }
        }
        return true;
      }
      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);
    } else {
      var fragment = getFragmentFromSelection(selection, context.fragmentMap);
      if (fragment) {
        if (selectionHasNonreactiveDirective(fragment))
          return true;
        return equalBySelectionSet(
          fragment.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          aResult,
          bResult,
          context
        );
      }
    }
  });
}
function selectionHasNonreactiveDirective(selection) {
  return !!selection.directives && selection.directives.some(directiveIsNonreactive);
}
function directiveIsNonreactive(dir) {
  return dir.name.value === "nonreactive";
}

// ../node_modules/@apollo/client/cache/core/cache.js
var ApolloCache = (
  /** @class */
  function() {
    function ApolloCache2() {
      this.assumeImmutableResults = false;
      this.getFragmentDoc = wrap2(getFragmentQueryDocument, {
        max: cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
        cache: WeakCache
      });
    }
    ApolloCache2.prototype.batch = function(options) {
      var _this = this;
      var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
      var updateResult;
      this.performTransaction(function() {
        return updateResult = options.update(_this);
      }, optimisticId);
      return updateResult;
    };
    ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
      this.performTransaction(transaction, optimisticId);
    };
    ApolloCache2.prototype.transformDocument = function(document) {
      return document;
    };
    ApolloCache2.prototype.transformForLink = function(document) {
      return document;
    };
    ApolloCache2.prototype.identify = function(object) {
      return;
    };
    ApolloCache2.prototype.gc = function() {
      return [];
    };
    ApolloCache2.prototype.modify = function(options) {
      return false;
    };
    ApolloCache2.prototype.readQuery = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options.optimistic;
      }
      return this.read(__assign(__assign({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
    };
    ApolloCache2.prototype.watchFragment = function(options) {
      var _this = this;
      var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, otherOptions = __rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
      var query = this.getFragmentDoc(fragment, fragmentName);
      var diffOptions = __assign(__assign({}, otherOptions), { returnPartialData: true, id: typeof from2 === "string" ? from2 : this.identify(from2), query, optimistic });
      var latestDiff;
      return new Observable(function(observer) {
        return _this.watch(__assign(__assign({}, diffOptions), { immediate: true, callback: function(diff) {
          if (
            // Always ensure we deliver the first result
            latestDiff && equalByQuery(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data: diff.result })
          ) {
            return;
          }
          var result2 = {
            data: diff.result,
            complete: !!diff.complete
          };
          if (diff.missing) {
            result2.missing = mergeDeepArray(diff.missing.map(function(error) {
              return error.missing;
            }));
          }
          latestDiff = diff;
          observer.next(result2);
        } }));
      });
    };
    ApolloCache2.prototype.readFragment = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options.optimistic;
      }
      return this.read(__assign(__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
    };
    ApolloCache2.prototype.writeQuery = function(_a2) {
      var id = _a2.id, data = _a2.data, options = __rest(_a2, ["id", "data"]);
      return this.write(Object.assign(options, {
        dataId: id || "ROOT_QUERY",
        result: data
      }));
    };
    ApolloCache2.prototype.writeFragment = function(_a2) {
      var id = _a2.id, data = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = __rest(_a2, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(options, {
        query: this.getFragmentDoc(fragment, fragmentName),
        dataId: id,
        result: data
      }));
    };
    ApolloCache2.prototype.updateQuery = function(options, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readQuery(options);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeQuery(__assign(__assign({}, options), { data }));
          return data;
        }
      });
    };
    ApolloCache2.prototype.updateFragment = function(options, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readFragment(options);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeFragment(__assign(__assign({}, options), { data }));
          return data;
        }
      });
    };
    return ApolloCache2;
  }()
);
if (globalThis.__DEV__ !== false) {
  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;
}

// ../node_modules/@apollo/client/cache/core/types/common.js
var import_dist241 = __toESM(require_dist(), 1);
var import_dist242 = __toESM(require_dist2(), 1);
var import_dist243 = __toESM(require_dist3(), 1);
init_tslib_es6();
var MissingFieldError = (
  /** @class */
  function(_super) {
    __extends(MissingFieldError2, _super);
    function MissingFieldError2(message, path, query, variables) {
      var _a2;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.path = path;
      _this.query = query;
      _this.variables = variables;
      if (Array.isArray(_this.path)) {
        _this.missing = _this.message;
        for (var i = _this.path.length - 1; i >= 0; --i) {
          _this.missing = (_a2 = {}, _a2[_this.path[i]] = _this.missing, _a2);
        }
      } else {
        _this.missing = _this.path;
      }
      _this.__proto__ = MissingFieldError2.prototype;
      return _this;
    }
    return MissingFieldError2;
  }(Error)
);

// ../node_modules/@apollo/client/cache/inmemory/readFromStore.js
var import_dist253 = __toESM(require_dist(), 1);
var import_dist254 = __toESM(require_dist2(), 1);
var import_dist255 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_graphql();
init_lib6();

// ../node_modules/@apollo/client/cache/inmemory/entityStore.js
var import_dist247 = __toESM(require_dist(), 1);
var import_dist248 = __toESM(require_dist2(), 1);
var import_dist249 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_lib6();
init_lib7();
init_lib2();

// ../node_modules/@apollo/client/cache/inmemory/helpers.js
var import_dist244 = __toESM(require_dist(), 1);
var import_dist245 = __toESM(require_dist2(), 1);
var import_dist246 = __toESM(require_dist3(), 1);
var hasOwn = Object.prototype.hasOwnProperty;
function isNullish(value) {
  return value === null || value === void 0;
}
function defaultDataIdFromObject(_a2, context) {
  var __typename = _a2.__typename, id = _a2.id, _id = _a2._id;
  if (typeof __typename === "string") {
    if (context) {
      context.keyObject = !isNullish(id) ? { id } : !isNullish(_id) ? { _id } : void 0;
    }
    if (isNullish(id) && !isNullish(_id)) {
      id = _id;
    }
    if (!isNullish(id)) {
      return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
    }
  }
}
var defaultConfig = {
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  // Thanks to the shouldCanonizeResults helper, this should be the only line
  // you have to change to reenable canonization by default in the future.
  canonizeResults: false
};
function normalizeConfig(config) {
  return compact(defaultConfig, config);
}
function shouldCanonizeResults(config) {
  var value = config.canonizeResults;
  return value === void 0 ? defaultConfig.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  var match = storeFieldName.match(TypeOrFieldNameRegExp);
  return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result2, variables) {
  if (isNonNullObject(result2)) {
    return isArray(result2) ? result2.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField(field) && shouldInclude(field, variables)) {
        var key = resultKeyNameFromField(field);
        return hasOwn.call(result2, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result2[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject(value) && !isReference(value) && !isArray(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}
function extractFragmentContext(document, fragments) {
  var fragmentMap = createFragmentMap(getFragmentDefinitions(document));
  return {
    fragmentMap,
    lookupFragment: function(name) {
      var def = fragmentMap[name];
      if (!def && fragments) {
        def = fragments.lookup(name);
      }
      return def || null;
    }
  };
}

// ../node_modules/@apollo/client/cache/inmemory/entityStore.js
var DELETE = /* @__PURE__ */ Object.create(null);
var delModifier = function() {
  return DELETE;
};
var INVALIDATE = /* @__PURE__ */ Object.create(null);
var EntityStore = (
  /** @class */
  function() {
    function EntityStore2(policies, group) {
      var _this = this;
      this.policies = policies;
      this.group = group;
      this.data = /* @__PURE__ */ Object.create(null);
      this.rootIds = /* @__PURE__ */ Object.create(null);
      this.refs = /* @__PURE__ */ Object.create(null);
      this.getFieldValue = function(objectOrReference, storeFieldName) {
        return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
      };
      this.canRead = function(objOrRef) {
        return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
      };
      this.toReference = function(objOrIdOrRef, mergeIntoStore) {
        if (typeof objOrIdOrRef === "string") {
          return makeReference(objOrIdOrRef);
        }
        if (isReference(objOrIdOrRef)) {
          return objOrIdOrRef;
        }
        var id = _this.policies.identify(objOrIdOrRef)[0];
        if (id) {
          var ref = makeReference(id);
          if (mergeIntoStore) {
            _this.merge(id, objOrIdOrRef);
          }
          return ref;
        }
      };
    }
    EntityStore2.prototype.toObject = function() {
      return __assign({}, this.data);
    };
    EntityStore2.prototype.has = function(dataId) {
      return this.lookup(dataId, true) !== void 0;
    };
    EntityStore2.prototype.get = function(dataId, fieldName) {
      this.group.depend(dataId, fieldName);
      if (hasOwn.call(this.data, dataId)) {
        var storeObject = this.data[dataId];
        if (storeObject && hasOwn.call(storeObject, fieldName)) {
          return storeObject[fieldName];
        }
      }
      if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
        return this.policies.rootTypenamesById[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.get(dataId, fieldName);
      }
    };
    EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
      if (dependOnExistence)
        this.group.depend(dataId, "__exists");
      if (hasOwn.call(this.data, dataId)) {
        return this.data[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.lookup(dataId, dependOnExistence);
      }
      if (this.policies.rootTypenamesById[dataId]) {
        return /* @__PURE__ */ Object.create(null);
      }
    };
    EntityStore2.prototype.merge = function(older, newer) {
      var _this = this;
      var dataId;
      if (isReference(older))
        older = older.__ref;
      if (isReference(newer))
        newer = newer.__ref;
      var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
      var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
      if (!incoming)
        return;
      invariant2(typeof dataId === "string", 1);
      var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
      this.data[dataId] = merged;
      if (merged !== existing) {
        delete this.refs[dataId];
        if (this.group.caching) {
          var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
          if (!existing)
            fieldsToDirty_1.__exists = 1;
          Object.keys(incoming).forEach(function(storeFieldName) {
            if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
              fieldsToDirty_1[storeFieldName] = 1;
              var fieldName = fieldNameFromStoreName(storeFieldName);
              if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                fieldsToDirty_1[fieldName] = 1;
              }
              if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                delete merged[storeFieldName];
              }
            }
          });
          if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings
          // automatically from store.get, we don't need to dirty the
          // ROOT_QUERY.__typename field if merged.__typename is equal
          // to the default string (usually "Query").
          this.policies.rootTypenamesById[dataId] === merged.__typename) {
            delete fieldsToDirty_1.__typename;
          }
          Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
            return _this.group.dirty(dataId, fieldName);
          });
        }
      }
    };
    EntityStore2.prototype.modify = function(dataId, fields) {
      var _this = this;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var changedFields_1 = /* @__PURE__ */ Object.create(null);
        var needToMerge_1 = false;
        var allDeleted_1 = true;
        var sharedDetails_1 = {
          DELETE,
          INVALIDATE,
          isReference,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(fieldNameOrOptions, from2) {
            return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
              fieldName: fieldNameOrOptions,
              from: from2 || makeReference(dataId)
            } : fieldNameOrOptions, { store: _this });
          }
        };
        Object.keys(storeObject).forEach(function(storeFieldName) {
          var fieldName = fieldNameFromStoreName(storeFieldName);
          var fieldValue = storeObject[storeFieldName];
          if (fieldValue === void 0)
            return;
          var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
          if (modify) {
            var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
            if (newValue === INVALIDATE) {
              _this.group.dirty(dataId, storeFieldName);
            } else {
              if (newValue === DELETE)
                newValue = void 0;
              if (newValue !== fieldValue) {
                changedFields_1[storeFieldName] = newValue;
                needToMerge_1 = true;
                fieldValue = newValue;
                if (globalThis.__DEV__ !== false) {
                  var checkReference = function(ref) {
                    if (_this.lookup(ref.__ref) === void 0) {
                      globalThis.__DEV__ !== false && invariant2.warn(2, ref);
                      return true;
                    }
                  };
                  if (isReference(newValue)) {
                    checkReference(newValue);
                  } else if (Array.isArray(newValue)) {
                    var seenReference = false;
                    var someNonReference = void 0;
                    for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {
                      var value = newValue_1[_i];
                      if (isReference(value)) {
                        seenReference = true;
                        if (checkReference(value))
                          break;
                      } else {
                        if (typeof value === "object" && !!value) {
                          var id = _this.policies.identify(value)[0];
                          if (id) {
                            someNonReference = value;
                          }
                        }
                      }
                      if (seenReference && someNonReference !== void 0) {
                        globalThis.__DEV__ !== false && invariant2.warn(3, someNonReference);
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          if (fieldValue !== void 0) {
            allDeleted_1 = false;
          }
        });
        if (needToMerge_1) {
          this.merge(dataId, changedFields_1);
          if (allDeleted_1) {
            if (this instanceof Layer) {
              this.data[dataId] = void 0;
            } else {
              delete this.data[dataId];
            }
            this.group.dirty(dataId, "__exists");
          }
          return true;
        }
      }
      return false;
    };
    EntityStore2.prototype.delete = function(dataId, fieldName, args) {
      var _a2;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var typename = this.getFieldValue(storeObject, "__typename");
        var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
        return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier, _a2) : delModifier);
      }
      return false;
    };
    EntityStore2.prototype.evict = function(options, limit) {
      var evicted = false;
      if (options.id) {
        if (hasOwn.call(this.data, options.id)) {
          evicted = this.delete(options.id, options.fieldName, options.args);
        }
        if (this instanceof Layer && this !== limit) {
          evicted = this.parent.evict(options, limit) || evicted;
        }
        if (options.fieldName || evicted) {
          this.group.dirty(options.id, options.fieldName || "__exists");
        }
      }
      return evicted;
    };
    EntityStore2.prototype.clear = function() {
      this.replace(null);
    };
    EntityStore2.prototype.extract = function() {
      var _this = this;
      var obj = this.toObject();
      var extraRootIds = [];
      this.getRootIdSet().forEach(function(id) {
        if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
          extraRootIds.push(id);
        }
      });
      if (extraRootIds.length) {
        obj.__META = { extraRootIds: extraRootIds.sort() };
      }
      return obj;
    };
    EntityStore2.prototype.replace = function(newData) {
      var _this = this;
      Object.keys(this.data).forEach(function(dataId) {
        if (!(newData && hasOwn.call(newData, dataId))) {
          _this.delete(dataId);
        }
      });
      if (newData) {
        var __META = newData.__META, rest_1 = __rest(newData, ["__META"]);
        Object.keys(rest_1).forEach(function(dataId) {
          _this.merge(dataId, rest_1[dataId]);
        });
        if (__META) {
          __META.extraRootIds.forEach(this.retain, this);
        }
      }
    };
    EntityStore2.prototype.retain = function(rootId) {
      return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
    };
    EntityStore2.prototype.release = function(rootId) {
      if (this.rootIds[rootId] > 0) {
        var count = --this.rootIds[rootId];
        if (!count)
          delete this.rootIds[rootId];
        return count;
      }
      return 0;
    };
    EntityStore2.prototype.getRootIdSet = function(ids) {
      if (ids === void 0) {
        ids = /* @__PURE__ */ new Set();
      }
      Object.keys(this.rootIds).forEach(ids.add, ids);
      if (this instanceof Layer) {
        this.parent.getRootIdSet(ids);
      } else {
        Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
      }
      return ids;
    };
    EntityStore2.prototype.gc = function() {
      var _this = this;
      var ids = this.getRootIdSet();
      var snapshot = this.toObject();
      ids.forEach(function(id) {
        if (hasOwn.call(snapshot, id)) {
          Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
          delete snapshot[id];
        }
      });
      var idsToRemove = Object.keys(snapshot);
      if (idsToRemove.length) {
        var root_1 = this;
        while (root_1 instanceof Layer)
          root_1 = root_1.parent;
        idsToRemove.forEach(function(id) {
          return root_1.delete(id);
        });
      }
      return idsToRemove;
    };
    EntityStore2.prototype.findChildRefIds = function(dataId) {
      if (!hasOwn.call(this.refs, dataId)) {
        var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
        var root2 = this.data[dataId];
        if (!root2)
          return found_1;
        var workSet_1 = /* @__PURE__ */ new Set([root2]);
        workSet_1.forEach(function(obj) {
          if (isReference(obj)) {
            found_1[obj.__ref] = true;
          }
          if (isNonNullObject(obj)) {
            Object.keys(obj).forEach(function(key) {
              var child = obj[key];
              if (isNonNullObject(child)) {
                workSet_1.add(child);
              }
            });
          }
        });
      }
      return this.refs[dataId];
    };
    EntityStore2.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    };
    return EntityStore2;
  }()
);
var CacheGroup = (
  /** @class */
  function() {
    function CacheGroup2(caching, parent) {
      if (parent === void 0) {
        parent = null;
      }
      this.caching = caching;
      this.parent = parent;
      this.d = null;
      this.resetCaching();
    }
    CacheGroup2.prototype.resetCaching = function() {
      this.d = this.caching ? dep() : null;
      this.keyMaker = new Trie(canUseWeakMap);
    };
    CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
      if (this.d) {
        this.d(makeDepKey(dataId, storeFieldName));
        var fieldName = fieldNameFromStoreName(storeFieldName);
        if (fieldName !== storeFieldName) {
          this.d(makeDepKey(dataId, fieldName));
        }
        if (this.parent) {
          this.parent.depend(dataId, storeFieldName);
        }
      }
    };
    CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
      if (this.d) {
        this.d.dirty(
          makeDepKey(dataId, storeFieldName),
          // When storeFieldName === "__exists", that means the entity identified
          // by dataId has either disappeared from the cache or was newly added,
          // so the result caching system would do well to "forget everything it
          // knows" about that object. To achieve that kind of invalidation, we
          // not only dirty the associated result cache entry, but also remove it
          // completely from the dependency graph. For the optimism implementation
          // details, see https://github.com/benjamn/optimism/pull/195.
          storeFieldName === "__exists" ? "forget" : "setDirty"
        );
      }
    };
    return CacheGroup2;
  }()
);
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
(function(EntityStore2) {
  var Root = (
    /** @class */
    function(_super) {
      __extends(Root2, _super);
      function Root2(_a2) {
        var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
        var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
        _this.stump = new Stump(_this);
        _this.storageTrie = new Trie(canUseWeakMap);
        if (seed)
          _this.replace(seed);
        return _this;
      }
      Root2.prototype.addLayer = function(layerId, replay) {
        return this.stump.addLayer(layerId, replay);
      };
      Root2.prototype.removeLayer = function() {
        return this;
      };
      Root2.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      };
      return Root2;
    }(EntityStore2)
  );
  EntityStore2.Root = Root;
})(EntityStore || (EntityStore = {}));
var Layer = (
  /** @class */
  function(_super) {
    __extends(Layer2, _super);
    function Layer2(id, parent, replay, group) {
      var _this = _super.call(this, parent.policies, group) || this;
      _this.id = id;
      _this.parent = parent;
      _this.replay = replay;
      _this.group = group;
      replay(_this);
      return _this;
    }
    Layer2.prototype.addLayer = function(layerId, replay) {
      return new Layer2(layerId, this, replay, this.group);
    };
    Layer2.prototype.removeLayer = function(layerId) {
      var _this = this;
      var parent = this.parent.removeLayer(layerId);
      if (layerId === this.id) {
        if (this.group.caching) {
          Object.keys(this.data).forEach(function(dataId) {
            var ownStoreObject = _this.data[dataId];
            var parentStoreObject = parent["lookup"](dataId);
            if (!parentStoreObject) {
              _this.delete(dataId);
            } else if (!ownStoreObject) {
              _this.group.dirty(dataId, "__exists");
              Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                _this.group.dirty(dataId, storeFieldName);
              });
            } else if (ownStoreObject !== parentStoreObject) {
              Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                  _this.group.dirty(dataId, storeFieldName);
                }
              });
            }
          });
        }
        return parent;
      }
      if (parent === this.parent)
        return this;
      return parent.addLayer(this.id, this.replay);
    };
    Layer2.prototype.toObject = function() {
      return __assign(__assign({}, this.parent.toObject()), this.data);
    };
    Layer2.prototype.findChildRefIds = function(dataId) {
      var fromParent = this.parent.findChildRefIds(dataId);
      return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
    };
    Layer2.prototype.getStorage = function() {
      var p = this.parent;
      while (p.parent)
        p = p.parent;
      return p.getStorage.apply(
        p,
        // @ts-expect-error
        arguments
      );
    };
    return Layer2;
  }(EntityStore)
);
var Stump = (
  /** @class */
  function(_super) {
    __extends(Stump2, _super);
    function Stump2(root2) {
      return _super.call(this, "EntityStore.Stump", root2, function() {
      }, new CacheGroup(root2.group.caching, root2.group)) || this;
    }
    Stump2.prototype.removeLayer = function() {
      return this;
    };
    Stump2.prototype.merge = function(older, newer) {
      return this.parent.merge(older, newer);
    };
    return Stump2;
  }(Layer)
);
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}

// ../node_modules/@apollo/client/cache/inmemory/object-canon.js
var import_dist250 = __toESM(require_dist(), 1);
var import_dist251 = __toESM(require_dist2(), 1);
var import_dist252 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_lib2();
function shallowCopy(value) {
  if (isNonNullObject(value)) {
    return isArray(value) ? value.slice(0) : __assign({ __proto__: Object.getPrototypeOf(value) }, value);
  }
  return value;
}
var ObjectCanon = (
  /** @class */
  function() {
    function ObjectCanon2() {
      this.known = new (canUseWeakSet ? WeakSet : Set)();
      this.pool = new Trie(canUseWeakMap);
      this.passes = /* @__PURE__ */ new WeakMap();
      this.keysByJSON = /* @__PURE__ */ new Map();
      this.empty = this.admit({});
    }
    ObjectCanon2.prototype.isKnown = function(value) {
      return isNonNullObject(value) && this.known.has(value);
    };
    ObjectCanon2.prototype.pass = function(value) {
      if (isNonNullObject(value)) {
        var copy = shallowCopy(value);
        this.passes.set(copy, value);
        return copy;
      }
      return value;
    };
    ObjectCanon2.prototype.admit = function(value) {
      var _this = this;
      if (isNonNullObject(value)) {
        var original = this.passes.get(value);
        if (original)
          return original;
        var proto = Object.getPrototypeOf(value);
        switch (proto) {
          case Array.prototype: {
            if (this.known.has(value))
              return value;
            var array = value.map(this.admit, this);
            var node = this.pool.lookupArray(array);
            if (!node.array) {
              this.known.add(node.array = array);
              if (globalThis.__DEV__ !== false) {
                Object.freeze(array);
              }
            }
            return node.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(value))
              return value;
            var proto_1 = Object.getPrototypeOf(value);
            var array_1 = [proto_1];
            var keys = this.sortedKeys(value);
            array_1.push(keys.json);
            var firstValueIndex_1 = array_1.length;
            keys.sorted.forEach(function(key) {
              array_1.push(_this.admit(value[key]));
            });
            var node = this.pool.lookupArray(array_1);
            if (!node.object) {
              var obj_1 = node.object = Object.create(proto_1);
              this.known.add(obj_1);
              keys.sorted.forEach(function(key, i) {
                obj_1[key] = array_1[firstValueIndex_1 + i];
              });
              if (globalThis.__DEV__ !== false) {
                Object.freeze(obj_1);
              }
            }
            return node.object;
          }
        }
      }
      return value;
    };
    ObjectCanon2.prototype.sortedKeys = function(obj) {
      var keys = Object.keys(obj);
      var node = this.pool.lookupArray(keys);
      if (!node.keys) {
        keys.sort();
        var json = JSON.stringify(keys);
        if (!(node.keys = this.keysByJSON.get(json))) {
          this.keysByJSON.set(json, node.keys = { sorted: keys, json });
        }
      }
      return node.keys;
    };
    return ObjectCanon2;
  }()
);

// ../node_modules/@apollo/client/cache/inmemory/readFromStore.js
function execSelectionSetKeyArgs(options) {
  return [
    options.selectionSet,
    options.objectOrReference,
    options.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    options.context.canonizeResults
  ];
}
var StoreReader = (
  /** @class */
  function() {
    function StoreReader2(config) {
      var _this = this;
      this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
      this.config = compact(config, {
        addTypename: config.addTypename !== false,
        canonizeResults: shouldCanonizeResults(config)
      });
      this.canon = config.canon || new ObjectCanon();
      this.executeSelectionSet = wrap2(function(options) {
        var _a2;
        var canonizeResults = options.context.canonizeResults;
        var peekArgs = execSelectionSetKeyArgs(options);
        peekArgs[3] = !canonizeResults;
        var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
        if (other) {
          if (canonizeResults) {
            return __assign(__assign({}, other), {
              // If we previously read this result without canonizing it, we can
              // reuse that result simply by canonizing it now.
              result: _this.canon.admit(other.result)
            });
          }
          return other;
        }
        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
        return _this.execSelectionSetImpl(options);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
        keyArgs: execSelectionSetKeyArgs,
        // Note that the parameters of makeCacheKey are determined by the
        // array returned by keyArgs.
        makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
          if (supportsResultCaching(context.store)) {
            return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
          }
        }
      });
      this.executeSubSelectedArray = wrap2(function(options) {
        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
        return _this.execSubSelectedArrayImpl(options);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
        makeCacheKey: function(_a2) {
          var field = _a2.field, array = _a2.array, context = _a2.context;
          if (supportsResultCaching(context.store)) {
            return context.store.makeCacheKey(field, array, context.varString);
          }
        }
      });
    }
    StoreReader2.prototype.resetCanon = function() {
      this.canon = new ObjectCanon();
    };
    StoreReader2.prototype.diffQueryAgainstStore = function(_a2) {
      var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
      var policies = this.config.cache.policies;
      variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);
      var rootRef = makeReference(rootId);
      var execResult = this.executeSelectionSet({
        selectionSet: getMainDefinition(query).selectionSet,
        objectOrReference: rootRef,
        enclosingRef: rootRef,
        context: __assign({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
      });
      var missing;
      if (execResult.missing) {
        missing = [
          new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)
        ];
        if (!returnPartialData) {
          throw missing[0];
        }
      }
      return {
        result: execResult.result,
        complete: !missing,
        missing
      };
    };
    StoreReader2.prototype.isFresh = function(result2, parent, selectionSet, context) {
      if (supportsResultCaching(context.store) && this.knownResults.get(result2) === selectionSet) {
        var latest = this.executeSelectionSet.peek(
          selectionSet,
          parent,
          context,
          // If result is canonical, then it could only have been previously
          // cached by the canonizing version of executeSelectionSet, so we can
          // avoid checking both possibilities here.
          this.canon.isKnown(result2)
        );
        if (latest && result2 === latest.result) {
          return true;
        }
      }
      return false;
    };
    StoreReader2.prototype.execSelectionSetImpl = function(_a2) {
      var _this = this;
      var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context = _a2.context;
      if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
        };
      }
      var variables = context.variables, policies = context.policies, store = context.store;
      var typename = store.getFieldValue(objectOrReference, "__typename");
      var objectsToMerge = [];
      var missing;
      var missingMerger = new DeepMerger();
      if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
        objectsToMerge.push({ __typename: typename });
      }
      function handleMissing(result3, resultName) {
        var _a3;
        if (result3.missing) {
          missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result3.missing, _a3));
        }
        return result3.result;
      }
      var workSet = new Set(selectionSet.selections);
      workSet.forEach(function(selection) {
        var _a3, _b;
        if (!shouldInclude(selection, variables))
          return;
        if (isField(selection)) {
          var fieldValue = policies.readField({
            fieldName: selection.name.value,
            field: selection,
            variables: context.variables,
            from: objectOrReference
          }, context);
          var resultName = resultKeyNameFromField(selection);
          if (fieldValue === void 0) {
            if (!addTypenameToDocument.added(selection)) {
              missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
            }
          } else if (isArray(fieldValue)) {
            if (fieldValue.length > 0) {
              fieldValue = handleMissing(_this.executeSubSelectedArray({
                field: selection,
                array: fieldValue,
                enclosingRef,
                context
              }), resultName);
            }
          } else if (!selection.selectionSet) {
            if (context.canonizeResults) {
              fieldValue = _this.canon.pass(fieldValue);
            }
          } else if (fieldValue != null) {
            fieldValue = handleMissing(_this.executeSelectionSet({
              selectionSet: selection.selectionSet,
              objectOrReference: fieldValue,
              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
              context
            }), resultName);
          }
          if (fieldValue !== void 0) {
            objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
          }
        } else {
          var fragment = getFragmentFromSelection(selection, context.lookupFragment);
          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
            throw newInvariantError(9, selection.name.value);
          }
          if (fragment && policies.fragmentMatches(fragment, typename)) {
            fragment.selectionSet.selections.forEach(workSet.add, workSet);
          }
        }
      });
      var result2 = mergeDeepArray(objectsToMerge);
      var finalResult = { result: result2, missing };
      var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
      if (frozen.result) {
        this.knownResults.set(frozen.result, selectionSet);
      }
      return frozen;
    };
    StoreReader2.prototype.execSubSelectedArrayImpl = function(_a2) {
      var _this = this;
      var field = _a2.field, array = _a2.array, enclosingRef = _a2.enclosingRef, context = _a2.context;
      var missing;
      var missingMerger = new DeepMerger();
      function handleMissing(childResult, i) {
        var _a3;
        if (childResult.missing) {
          missing = missingMerger.merge(missing, (_a3 = {}, _a3[i] = childResult.missing, _a3));
        }
        return childResult.result;
      }
      if (field.selectionSet) {
        array = array.filter(context.store.canRead);
      }
      array = array.map(function(item, i) {
        if (item === null) {
          return null;
        }
        if (isArray(item)) {
          return handleMissing(_this.executeSubSelectedArray({
            field,
            array: item,
            enclosingRef,
            context
          }), i);
        }
        if (field.selectionSet) {
          return handleMissing(_this.executeSelectionSet({
            selectionSet: field.selectionSet,
            objectOrReference: item,
            enclosingRef: isReference(item) ? item : enclosingRef,
            context
          }), i);
        }
        if (globalThis.__DEV__ !== false) {
          assertSelectionSetForIdValue(context.store, field, item);
        }
        return item;
      });
      return {
        result: context.canonizeResults ? this.canon.admit(array) : array,
        missing
      };
    };
    return StoreReader2;
  }()
);
function firstMissing(tree) {
  try {
    JSON.stringify(tree, function(_, value) {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result2) {
    return result2;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
    workSet_1.forEach(function(value) {
      if (isNonNullObject(value)) {
        invariant2(
          !isReference(value),
          10,
          getTypenameFromStoreObject(store, value),
          field.name.value
        );
        Object.values(value).forEach(workSet_1.add, workSet_1);
      }
    });
  }
}

// ../node_modules/@apollo/client/cache/inmemory/writeToStore.js
var import_dist265 = __toESM(require_dist(), 1);
var import_dist266 = __toESM(require_dist2(), 1);
var import_dist267 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_lib7();
init_lib2();
init_graphql();

// ../node_modules/@apollo/client/cache/inmemory/policies.js
var import_dist262 = __toESM(require_dist(), 1);
var import_dist263 = __toESM(require_dist2(), 1);
var import_dist264 = __toESM(require_dist3(), 1);
init_tslib_es6();

// ../node_modules/@apollo/client/cache/inmemory/reactiveVars.js
var import_dist256 = __toESM(require_dist(), 1);
var import_dist257 = __toESM(require_dist2(), 1);
var import_dist258 = __toESM(require_dist3(), 1);
init_lib6();
var cacheSlot = new Slot();
var cacheInfoMap = /* @__PURE__ */ new WeakMap();
function getCacheInfo(cache2) {
  var info = cacheInfoMap.get(cache2);
  if (!info) {
    cacheInfoMap.set(cache2, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.forgetCache(cache2);
  });
}
function recallCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.attachCache(cache2);
  });
}
function makeVar(value) {
  var caches2 = /* @__PURE__ */ new Set();
  var listeners = /* @__PURE__ */ new Set();
  var rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches2.forEach(function(cache3) {
          getCacheInfo(cache3).dep.dirty(rv);
          broadcast(cache3);
        });
        var oldListeners = Array.from(listeners);
        listeners.clear();
        oldListeners.forEach(function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache2 = cacheSlot.getValue();
      if (cache2) {
        attach(cache2);
        getCacheInfo(cache2).dep(rv);
      }
    }
    return value;
  };
  rv.onNextChange = function(listener) {
    listeners.add(listener);
    return function() {
      listeners.delete(listener);
    };
  };
  var attach = rv.attachCache = function(cache2) {
    caches2.add(cache2);
    getCacheInfo(cache2).vars.add(rv);
    return rv;
  };
  rv.forgetCache = function(cache2) {
    return caches2.delete(cache2);
  };
  return rv;
}
function broadcast(cache2) {
  if (cache2.broadcastWatches) {
    cache2.broadcastWatches();
  }
}

// ../node_modules/@apollo/client/cache/inmemory/key-extractor.js
var import_dist259 = __toESM(require_dist(), 1);
var import_dist260 = __toESM(require_dist2(), 1);
var import_dist261 = __toESM(require_dist3(), 1);
var specifierInfoCache = /* @__PURE__ */ Object.create(null);
function lookupSpecifierInfo(spec) {
  var cacheKey = JSON.stringify(spec);
  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {
    var extract = function(from2, key) {
      return context.readField(key, from2);
    };
    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
      var extracted = extractKeyPath(
        context.storeObject,
        schemaKeyPath,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        extract
      );
      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {
        extracted = extractKeyPath(object, schemaKeyPath, extractKey);
      }
      invariant2(extracted !== void 0, 4, schemaKeyPath.join("."), object);
      return extracted;
    });
    return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
  });
}
function keyArgsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
    var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
    var collected = collectSpecifierPaths(specifier, function(keyPath) {
      var firstKey = keyPath[0];
      var firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray(field.directives)) {
          var directiveName_1 = firstKey.slice(1);
          var d = field.directives.find(function(d2) {
            return d2.name.value === directiveName_1;
          });
          var directiveArgs = d && argumentsObjectFromField(d, variables);
          return directiveArgs && extractKeyPath(
            directiveArgs,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            keyPath.slice(1)
          );
        }
        return;
      }
      if (firstChar === "$") {
        var variableName = firstKey.slice(1);
        if (variables && hasOwn.call(variables, variableName)) {
          var varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    var suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  var merger = new DeepMerger();
  return getSpecifierPaths(specifier).reduce(function(collected, path) {
    var _a2;
    var toMerge = extractor(path);
    if (toMerge !== void 0) {
      for (var i = path.length - 1; i >= 0; --i) {
        toMerge = (_a2 = {}, _a2[path[i]] = toMerge, _a2);
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, /* @__PURE__ */ Object.create(null));
}
function getSpecifierPaths(spec) {
  var info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    var paths_1 = info.paths = [];
    var currentPath_1 = [];
    spec.forEach(function(s, i) {
      if (isArray(s)) {
        getSpecifierPaths(s).forEach(function(p) {
          return paths_1.push(currentPath_1.concat(p));
        });
        currentPath_1.length = 0;
      } else {
        currentPath_1.push(s);
        if (!isArray(spec[i + 1])) {
          paths_1.push(currentPath_1.slice(0));
          currentPath_1.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object, key) {
  return object[key];
}
function extractKeyPath(object, path, extract) {
  extract = extract || extractKey;
  return normalize(path.reduce(function reducer(obj, key) {
    return isArray(obj) ? obj.map(function(child) {
      return reducer(child, key);
    }) : obj && extract(obj, key);
  }, object));
}
function normalize(value) {
  if (isNonNullObject(value)) {
    if (isArray(value)) {
      return value.map(normalize);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
      return extractKeyPath(value, path);
    });
  }
  return value;
}

// ../node_modules/@apollo/client/cache/inmemory/policies.js
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function() {
  return void 0;
};
var simpleKeyArgsFn = function(_args, context) {
  return context.fieldName;
};
var mergeTrueFn = function(existing, incoming, _a2) {
  var mergeObjects = _a2.mergeObjects;
  return mergeObjects(existing, incoming);
};
var mergeFalseFn = function(_, incoming) {
  return incoming;
};
var Policies = (
  /** @class */
  function() {
    function Policies2(config) {
      this.config = config;
      this.typePolicies = /* @__PURE__ */ Object.create(null);
      this.toBeAdded = /* @__PURE__ */ Object.create(null);
      this.supertypeMap = /* @__PURE__ */ new Map();
      this.fuzzySubtypes = /* @__PURE__ */ new Map();
      this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
      this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
      this.usingPossibleTypes = false;
      this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);
      this.cache = this.config.cache;
      this.setRootTypename("Query");
      this.setRootTypename("Mutation");
      this.setRootTypename("Subscription");
      if (config.possibleTypes) {
        this.addPossibleTypes(config.possibleTypes);
      }
      if (config.typePolicies) {
        this.addTypePolicies(config.typePolicies);
      }
    }
    Policies2.prototype.identify = function(object, partialContext) {
      var _a2;
      var policies = this;
      var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object.__typename;
      if (typename === this.rootTypenamesById.ROOT_QUERY) {
        return ["ROOT_QUERY"];
      }
      var storeObject = partialContext && partialContext.storeObject || object;
      var context = __assign(__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
        var options = normalizeReadFieldOptions(arguments, storeObject);
        return policies.readField(options, {
          store: policies.cache["data"],
          variables: options.variables
        });
      } });
      var id;
      var policy = typename && this.getTypePolicy(typename);
      var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
      while (keyFn) {
        var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);
        if (isArray(specifierOrId)) {
          keyFn = keyFieldsFnFromSpecifier(specifierOrId);
        } else {
          id = specifierOrId;
          break;
        }
      }
      id = id ? String(id) : void 0;
      return context.keyObject ? [id, context.keyObject] : [id];
    };
    Policies2.prototype.addTypePolicies = function(typePolicies) {
      var _this = this;
      Object.keys(typePolicies).forEach(function(typename) {
        var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = __rest(_a2, ["queryType", "mutationType", "subscriptionType"]);
        if (queryType)
          _this.setRootTypename("Query", typename);
        if (mutationType)
          _this.setRootTypename("Mutation", typename);
        if (subscriptionType)
          _this.setRootTypename("Subscription", typename);
        if (hasOwn.call(_this.toBeAdded, typename)) {
          _this.toBeAdded[typename].push(incoming);
        } else {
          _this.toBeAdded[typename] = [incoming];
        }
      });
    };
    Policies2.prototype.updateTypePolicy = function(typename, incoming) {
      var _this = this;
      var existing = this.getTypePolicy(typename);
      var keyFields = incoming.keyFields, fields = incoming.fields;
      function setMerge(existing2, merge) {
        existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
      }
      setMerge(existing, incoming.merge);
      existing.keyFn = // Pass false to disable normalization for this typename.
      keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
      if (fields) {
        Object.keys(fields).forEach(function(fieldName) {
          var existing2 = _this.getFieldPolicy(typename, fieldName, true);
          var incoming2 = fields[fieldName];
          if (typeof incoming2 === "function") {
            existing2.read = incoming2;
          } else {
            var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;
            existing2.keyFn = // Pass false to disable argument-based differentiation of
            // field identities.
            keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
            if (typeof read === "function") {
              existing2.read = read;
            }
            setMerge(existing2, merge);
          }
          if (existing2.read && existing2.merge) {
            existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
          }
        });
      }
    };
    Policies2.prototype.setRootTypename = function(which, typename) {
      if (typename === void 0) {
        typename = which;
      }
      var rootId = "ROOT_" + which.toUpperCase();
      var old = this.rootTypenamesById[rootId];
      if (typename !== old) {
        invariant2(!old || old === which, 5, which);
        if (old)
          delete this.rootIdsByTypename[old];
        this.rootIdsByTypename[typename] = rootId;
        this.rootTypenamesById[rootId] = typename;
      }
    };
    Policies2.prototype.addPossibleTypes = function(possibleTypes) {
      var _this = this;
      this.usingPossibleTypes = true;
      Object.keys(possibleTypes).forEach(function(supertype) {
        _this.getSupertypeSet(supertype, true);
        possibleTypes[supertype].forEach(function(subtype) {
          _this.getSupertypeSet(subtype, true).add(supertype);
          var match = subtype.match(TypeOrFieldNameRegExp);
          if (!match || match[0] !== subtype) {
            _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
          }
        });
      });
    };
    Policies2.prototype.getTypePolicy = function(typename) {
      var _this = this;
      if (!hasOwn.call(this.typePolicies, typename)) {
        var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
        policy_1.fields = /* @__PURE__ */ Object.create(null);
        var supertypes_1 = this.supertypeMap.get(typename);
        if (!supertypes_1 && this.fuzzySubtypes.size) {
          supertypes_1 = this.getSupertypeSet(typename, true);
          this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
            if (regExp.test(typename)) {
              var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
              if (fuzzySupertypes) {
                fuzzySupertypes.forEach(function(supertype) {
                  return supertypes_1.add(supertype);
                });
              }
            }
          });
        }
        if (supertypes_1 && supertypes_1.size) {
          supertypes_1.forEach(function(supertype) {
            var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = __rest(_a2, ["fields"]);
            Object.assign(policy_1, rest);
            Object.assign(policy_1.fields, fields);
          });
        }
      }
      var inbox = this.toBeAdded[typename];
      if (inbox && inbox.length) {
        inbox.splice(0).forEach(function(policy) {
          _this.updateTypePolicy(typename, policy);
        });
      }
      return this.typePolicies[typename];
    };
    Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
      if (typename) {
        var fieldPolicies = this.getTypePolicy(typename).fields;
        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
      }
    };
    Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
      var supertypeSet = this.supertypeMap.get(subtype);
      if (!supertypeSet && createIfMissing) {
        this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
      }
      return supertypeSet;
    };
    Policies2.prototype.fragmentMatches = function(fragment, typename, result2, variables) {
      var _this = this;
      if (!fragment.typeCondition)
        return true;
      if (!typename)
        return false;
      var supertype = fragment.typeCondition.name.value;
      if (typename === supertype)
        return true;
      if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
        var typenameSupertypeSet = this.getSupertypeSet(typename, true);
        var workQueue_1 = [typenameSupertypeSet];
        var maybeEnqueue_1 = function(subtype) {
          var supertypeSet2 = _this.getSupertypeSet(subtype, false);
          if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
            workQueue_1.push(supertypeSet2);
          }
        };
        var needToCheckFuzzySubtypes = !!(result2 && this.fuzzySubtypes.size);
        var checkingFuzzySubtypes = false;
        for (var i = 0; i < workQueue_1.length; ++i) {
          var supertypeSet = workQueue_1[i];
          if (supertypeSet.has(supertype)) {
            if (!typenameSupertypeSet.has(supertype)) {
              if (checkingFuzzySubtypes) {
                globalThis.__DEV__ !== false && invariant2.warn(6, typename, supertype);
              }
              typenameSupertypeSet.add(supertype);
            }
            return true;
          }
          supertypeSet.forEach(maybeEnqueue_1);
          if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all
          // non-fuzzy subtypes (after the final iteration of the loop).
          i === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result
          // after we verify the supertype, but this check is often less
          // expensive than that search, and we will have to do the
          // comparison anyway whenever we find a potential match.
          selectionSetMatchesResult(fragment.selectionSet, result2, variables)) {
            needToCheckFuzzySubtypes = false;
            checkingFuzzySubtypes = true;
            this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
              var match = typename.match(regExp);
              if (match && match[0] === typename) {
                maybeEnqueue_1(fuzzyString);
              }
            });
          }
        }
      }
      return false;
    };
    Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return !!(policy && policy.keyFn);
    };
    Policies2.prototype.getStoreFieldName = function(fieldSpec) {
      var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
      var policy = this.getFieldPolicy(typename, fieldName, false);
      var storeFieldName;
      var keyFn = policy && policy.keyFn;
      if (keyFn && typename) {
        var context = {
          typename,
          fieldName,
          field: fieldSpec.field || null,
          variables: fieldSpec.variables
        };
        var args = argsFromFieldSpecifier(fieldSpec);
        while (keyFn) {
          var specifierOrString = keyFn(args, context);
          if (isArray(specifierOrString)) {
            keyFn = keyArgsFnFromSpecifier(specifierOrString);
          } else {
            storeFieldName = specifierOrString || fieldName;
            break;
          }
        }
      }
      if (storeFieldName === void 0) {
        storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
      }
      if (storeFieldName === false) {
        return fieldName;
      }
      return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
    };
    Policies2.prototype.readField = function(options, context) {
      var objectOrReference = options.from;
      if (!objectOrReference)
        return;
      var nameOrField = options.field || options.fieldName;
      if (!nameOrField)
        return;
      if (options.typename === void 0) {
        var typename = context.store.getFieldValue(objectOrReference, "__typename");
        if (typename)
          options.typename = typename;
      }
      var storeFieldName = this.getStoreFieldName(options);
      var fieldName = fieldNameFromStoreName(storeFieldName);
      var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
      var policy = this.getFieldPolicy(options.typename, fieldName, false);
      var read = policy && policy.read;
      if (read) {
        var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
        return cacheSlot.withValue(this.cache, read, [
          existing,
          readOptions
        ]);
      }
      return existing;
    };
    Policies2.prototype.getReadFunction = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return policy && policy.read;
    };
    Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
      var policy = this.getFieldPolicy(parentTypename, fieldName, false);
      var merge = policy && policy.merge;
      if (!merge && childTypename) {
        policy = this.getTypePolicy(childTypename);
        merge = policy && policy.merge;
      }
      return merge;
    };
    Policies2.prototype.runMergeFunction = function(existing, incoming, _a2, context, storage) {
      var field = _a2.field, typename = _a2.typename, merge = _a2.merge;
      if (merge === mergeTrueFn) {
        return makeMergeObjectsFunction(context.store)(existing, incoming);
      }
      if (merge === mergeFalseFn) {
        return incoming;
      }
      if (context.overwrite) {
        existing = void 0;
      }
      return merge(existing, incoming, makeFieldFunctionOptions(
        this,
        // Unlike options.readField for read functions, we do not fall
        // back to the current object if no foreignObjOrRef is provided,
        // because it's not clear what the current object should be for
        // merge functions: the (possibly undefined) existing object, or
        // the incoming object? If you think your merge function needs
        // to read sibling fields in order to produce a new value for
        // the current field, you might want to rethink your strategy,
        // because that's a recipe for making merge behavior sensitive
        // to the order in which fields are written into the cache.
        // However, readField(name, ref) is useful for merge functions
        // that need to deduplicate child objects and references.
        void 0,
        {
          typename,
          fieldName: field.name.value,
          field,
          variables: context.variables
        },
        context,
        storage || /* @__PURE__ */ Object.create(null)
      ));
    };
    return Policies2;
  }()
);
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context.variables;
  var _a2 = context.store, toReference = _a2.toReference, canRead = _a2.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function() {
      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
    },
    mergeObjects: makeMergeObjectsFunction(context.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
  var options;
  if (typeof fieldNameOrOptions === "string") {
    options = {
      fieldName: fieldNameOrOptions,
      // Default to objectOrReference only when no second argument was
      // passed for the from parameter, not when undefined is explicitly
      // passed as the second argument.
      from: argc > 1 ? from2 : objectOrReference
    };
  } else {
    options = __assign({}, fieldNameOrOptions);
    if (!hasOwn.call(options, "from")) {
      options.from = objectOrReference;
    }
  }
  if (globalThis.__DEV__ !== false && options.from === void 0) {
    globalThis.__DEV__ !== false && invariant2.warn(7, stringifyForDisplay(Array.from(readFieldArgs)));
  }
  if (void 0 === options.variables) {
    options.variables = variables;
  }
  return options;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray(existing) || isArray(incoming)) {
      throw newInvariantError(8);
    }
    if (isNonNullObject(existing) && isNonNullObject(incoming)) {
      var eType = store.getFieldValue(existing, "__typename");
      var iType = store.getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return __assign(__assign({}, existing), incoming);
      }
    }
    return incoming;
  };
}

// ../node_modules/@apollo/client/cache/inmemory/writeToStore.js
function getContextFlavor(context, clientOnly, deferred) {
  var key = "".concat(clientOnly).concat(deferred);
  var flavored = context.flavors.get(key);
  if (!flavored) {
    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), { clientOnly, deferred }));
  }
  return flavored;
}
var StoreWriter = (
  /** @class */
  function() {
    function StoreWriter2(cache2, reader, fragments) {
      this.cache = cache2;
      this.reader = reader;
      this.fragments = fragments;
    }
    StoreWriter2.prototype.writeToStore = function(store, _a2) {
      var _this = this;
      var query = _a2.query, result2 = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
      var operationDefinition = getOperationDefinition(query);
      var merger = makeProcessedFieldsMerger();
      variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);
      var context = __assign(__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
        return merger.merge(existing, incoming);
      }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
      var ref = this.processSelectionSet({
        result: result2 || /* @__PURE__ */ Object.create(null),
        dataId,
        selectionSet: operationDefinition.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context
      });
      if (!isReference(ref)) {
        throw newInvariantError(11, result2);
      }
      context.incomingById.forEach(function(_a3, dataId2) {
        var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
        var entityRef = makeReference(dataId2);
        if (mergeTree && mergeTree.map.size) {
          var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
          if (isReference(applied)) {
            return;
          }
          storeObject = applied;
        }
        if (globalThis.__DEV__ !== false && !context.overwrite) {
          var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
          fieldNodeSet.forEach(function(field) {
            if (field.selectionSet) {
              fieldsWithSelectionSets_1[field.name.value] = true;
            }
          });
          var hasSelectionSet_1 = function(storeFieldName) {
            return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
          };
          var hasMergeFunction_1 = function(storeFieldName) {
            var childTree = mergeTree && mergeTree.map.get(storeFieldName);
            return Boolean(childTree && childTree.info && childTree.info.merge);
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
              warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
            }
          });
        }
        store.merge(dataId2, storeObject);
      });
      store.retain(ref.__ref);
      return ref;
    };
    StoreWriter2.prototype.processSelectionSet = function(_a2) {
      var _this = this;
      var dataId = _a2.dataId, result2 = _a2.result, selectionSet = _a2.selectionSet, context = _a2.context, mergeTree = _a2.mergeTree;
      var policies = this.cache.policies;
      var incoming = /* @__PURE__ */ Object.create(null);
      var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result2, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
      if ("string" === typeof typename) {
        incoming.__typename = typename;
      }
      var readField = function() {
        var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
        if (isReference(options.from)) {
          var info = context.incomingById.get(options.from.__ref);
          if (info) {
            var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);
            if (result_1 !== void 0) {
              return result_1;
            }
          }
        }
        return policies.readField(options, context);
      };
      var fieldNodeSet = /* @__PURE__ */ new Set();
      this.flattenFields(
        selectionSet,
        result2,
        // This WriteContext will be the default context value for fields returned
        // by the flattenFields method, but some fields may be assigned a modified
        // context, depending on the presence of @client and other directives.
        context,
        typename
      ).forEach(function(context2, field) {
        var _a3;
        var resultFieldKey = resultKeyNameFromField(field);
        var value = result2[resultFieldKey];
        fieldNodeSet.add(field);
        if (value !== void 0) {
          var storeFieldName = policies.getStoreFieldName({
            typename,
            fieldName: field.name.value,
            field,
            variables: context2.variables
          });
          var childTree = getChildMergeTree(mergeTree, storeFieldName);
          var incomingValue = _this.processFieldValue(
            value,
            field,
            // Reset context.clientOnly and context.deferred to their default
            // values before processing nested selection sets.
            field.selectionSet ? getContextFlavor(context2, false, false) : context2,
            childTree
          );
          var childTypename = void 0;
          if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
            childTypename = readField("__typename", incomingValue);
          }
          var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
          if (merge) {
            childTree.info = {
              // TODO Check compatibility against any existing childTree.field?
              field,
              typename,
              merge
            };
          } else {
            maybeRecycleChildMergeTree(mergeTree, storeFieldName);
          }
          incoming = context2.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
        } else if (globalThis.__DEV__ !== false && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && // If the field has a read function, it may be a synthetic field or
        // provide a default value, so its absence from the written data should
        // not be cause for alarm.
        !policies.getReadFunction(typename, field.name.value)) {
          globalThis.__DEV__ !== false && invariant2.error(12, resultKeyNameFromField(field), result2);
        }
      });
      try {
        var _b = policies.identify(result2, {
          typename,
          selectionSet,
          fragmentMap: context.fragmentMap,
          storeObject: incoming,
          readField
        }), id = _b[0], keyObject = _b[1];
        dataId = dataId || id;
        if (keyObject) {
          incoming = context.merge(incoming, keyObject);
        }
      } catch (e) {
        if (!dataId)
          throw e;
      }
      if ("string" === typeof dataId) {
        var dataRef = makeReference(dataId);
        var sets = context.written[dataId] || (context.written[dataId] = []);
        if (sets.indexOf(selectionSet) >= 0)
          return dataRef;
        sets.push(selectionSet);
        if (this.reader && this.reader.isFresh(result2, dataRef, selectionSet, context)) {
          return dataRef;
        }
        var previous_1 = context.incomingById.get(dataId);
        if (previous_1) {
          previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
          previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
          fieldNodeSet.forEach(function(field) {
            return previous_1.fieldNodeSet.add(field);
          });
        } else {
          context.incomingById.set(dataId, {
            storeObject: incoming,
            // Save a reference to mergeTree only if it is not empty, because
            // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
            // reused for entirely different parts of the result tree.
            mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
            fieldNodeSet
          });
        }
        return dataRef;
      }
      return incoming;
    };
    StoreWriter2.prototype.processFieldValue = function(value, field, context, mergeTree) {
      var _this = this;
      if (!field.selectionSet || value === null) {
        return globalThis.__DEV__ !== false ? cloneDeep(value) : value;
      }
      if (isArray(value)) {
        return value.map(function(item, i) {
          var value2 = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));
          maybeRecycleChildMergeTree(mergeTree, i);
          return value2;
        });
      }
      return this.processSelectionSet({
        result: value,
        selectionSet: field.selectionSet,
        context,
        mergeTree
      });
    };
    StoreWriter2.prototype.flattenFields = function(selectionSet, result2, context, typename) {
      if (typename === void 0) {
        typename = getTypenameFromResult(result2, selectionSet, context.fragmentMap);
      }
      var fieldMap = /* @__PURE__ */ new Map();
      var policies = this.cache.policies;
      var limitingTrie = new Trie(false);
      (function flatten(selectionSet2, inheritedContext) {
        var visitedNode = limitingTrie.lookup(
          selectionSet2,
          // Because we take inheritedClientOnly and inheritedDeferred into
          // consideration here (in addition to selectionSet), it's possible for
          // the same selection set to be flattened more than once, if it appears
          // in the query with different @client and/or @directive configurations.
          inheritedContext.clientOnly,
          inheritedContext.deferred
        );
        if (visitedNode.visited)
          return;
        visitedNode.visited = true;
        selectionSet2.selections.forEach(function(selection) {
          if (!shouldInclude(selection, context.variables))
            return;
          var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
          if (
            // Since the presence of @client or @defer on this field can only
            // cause clientOnly or deferred to become true, we can skip the
            // forEach loop if both clientOnly and deferred are already true.
            !(clientOnly && deferred) && isNonEmptyArray(selection.directives)
          ) {
            selection.directives.forEach(function(dir) {
              var name = dir.name.value;
              if (name === "client")
                clientOnly = true;
              if (name === "defer") {
                var args = argumentsObjectFromField(dir, context.variables);
                if (!args || args.if !== false) {
                  deferred = true;
                }
              }
            });
          }
          if (isField(selection)) {
            var existing = fieldMap.get(selection);
            if (existing) {
              clientOnly = clientOnly && existing.clientOnly;
              deferred = deferred && existing.deferred;
            }
            fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
          } else {
            var fragment = getFragmentFromSelection(selection, context.lookupFragment);
            if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
              throw newInvariantError(13, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename, result2, context.variables)) {
              flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
            }
          }
        });
      })(selectionSet, context);
      return fieldMap;
    };
    StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
      var _a2;
      var _this = this;
      if (mergeTree.map.size && !isReference(incoming)) {
        var e_1 = (
          // Items in the same position in different arrays are not
          // necessarily related to each other, so when incoming is an array
          // we process its elements as if there was no existing data.
          !isArray(incoming) && // Likewise, existing must be either a Reference or a StoreObject
          // in order for its fields to be safe to merge with the fields of
          // the incoming object.
          (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0
        );
        var i_1 = incoming;
        if (e_1 && !getStorageArgs) {
          getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
        }
        var changedFields_1;
        var getValue_1 = function(from2, name) {
          return isArray(from2) ? typeof name === "number" ? from2[name] : void 0 : context.store.getFieldValue(from2, String(name));
        };
        mergeTree.map.forEach(function(childTree, storeFieldName) {
          var eVal = getValue_1(e_1, storeFieldName);
          var iVal = getValue_1(i_1, storeFieldName);
          if (void 0 === iVal)
            return;
          if (getStorageArgs) {
            getStorageArgs.push(storeFieldName);
          }
          var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
          if (aVal !== iVal) {
            changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
            changedFields_1.set(storeFieldName, aVal);
          }
          if (getStorageArgs) {
            invariant2(getStorageArgs.pop() === storeFieldName);
          }
        });
        if (changedFields_1) {
          incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);
          changedFields_1.forEach(function(value, name) {
            incoming[name] = value;
          });
        }
      }
      if (mergeTree.info) {
        return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a2 = context.store).getStorage.apply(_a2, getStorageArgs));
      }
      return incoming;
    };
    return StoreWriter2;
  }()
);
var emptyMergeTreePool = [];
function getChildMergeTree(_a2, name) {
  var map = _a2.map;
  if (!map.has(name)) {
    map.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map.get(name);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;
  var needToMergeMaps = left.map.size && right.map.size;
  var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  var merged = { info, map };
  if (needToMergeMaps) {
    var remainingRightKeys_1 = new Set(right.map.keys());
    left.map.forEach(function(leftTree, key) {
      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
      remainingRightKeys_1.delete(key);
    });
    remainingRightKeys_1.forEach(function(key) {
      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree) {
  return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree(_a2, name) {
  var map = _a2.map;
  var childTree = map.get(name);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map.delete(name);
  }
}
var warnings = /* @__PURE__ */ new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  var getChild = function(objOrRef) {
    var child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  var existing = getChild(existingRef);
  if (!existing)
    return;
  var incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference(existing))
    return;
  if (equal(existing, incoming))
    return;
  if (Object.keys(existing).every(function(key) {
    return store.getFieldValue(incoming, key) !== void 0;
  })) {
    return;
  }
  var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var typeDotName = "".concat(parentType, ".").concat(fieldName);
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  var childTypenames = [];
  if (!isArray(existing) && !isArray(incoming)) {
    [existing, incoming].forEach(function(child) {
      var typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  globalThis.__DEV__ !== false && invariant2.warn(14, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, __assign({}, existing), __assign({}, incoming));
}

// ../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js
var InMemoryCache = (
  /** @class */
  function(_super) {
    __extends(InMemoryCache2, _super);
    function InMemoryCache2(config) {
      if (config === void 0) {
        config = {};
      }
      var _this = _super.call(this) || this;
      _this.watches = /* @__PURE__ */ new Set();
      _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);
      _this.assumeImmutableResults = true;
      _this.makeVar = makeVar;
      _this.txCount = 0;
      _this.config = normalizeConfig(config);
      _this.addTypename = !!_this.config.addTypename;
      _this.policies = new Policies({
        cache: _this,
        dataIdFromObject: _this.config.dataIdFromObject,
        possibleTypes: _this.config.possibleTypes,
        typePolicies: _this.config.typePolicies
      });
      _this.init();
      return _this;
    }
    InMemoryCache2.prototype.init = function() {
      var rootStore = this.data = new EntityStore.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = rootStore.stump;
      this.resetResultCache();
    };
    InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
      var _this = this;
      var previousReader = this.storeReader;
      var fragments = this.config.fragments;
      this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: shouldCanonizeResults(this.config),
        canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
        fragments
      }), fragments);
      this.maybeBroadcastWatch = wrap2(function(c, options) {
        return _this.broadcastWatch(c, options);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
        makeCacheKey: function(c) {
          var store = c.optimistic ? _this.optimisticData : _this.data;
          if (supportsResultCaching(store)) {
            var optimistic = c.optimistic, id = c.id, variables = c.variables;
            return store.makeCacheKey(
              c.query,
              // Different watches can have the same query, optimistic
              // status, rootId, and variables, but if their callbacks are
              // different, the (identical) result needs to be delivered to
              // each distinct callback. The easiest way to achieve that
              // separation is to include c.callback in the cache key for
              // maybeBroadcastWatch calls. See issue #5733.
              c.callback,
              canonicalStringify({ optimistic, id, variables })
            );
          }
        }
      });
      (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
        return group.resetCaching();
      });
    };
    InMemoryCache2.prototype.restore = function(data) {
      this.init();
      if (data)
        this.data.replace(data);
      return this;
    };
    InMemoryCache2.prototype.extract = function(optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return (optimistic ? this.optimisticData : this.data).extract();
    };
    InMemoryCache2.prototype.read = function(options) {
      var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
      try {
        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
      } catch (e) {
        if (e instanceof MissingFieldError) {
          return null;
        }
        throw e;
      }
    };
    InMemoryCache2.prototype.write = function(options) {
      try {
        ++this.txCount;
        return this.storeWriter.writeToStore(this.data, options);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.modify = function(options) {
      if (hasOwn.call(options, "id") && !options.id) {
        return false;
      }
      var store = options.optimistic ? this.optimisticData : this.data;
      try {
        ++this.txCount;
        return store.modify(options.id || "ROOT_QUERY", options.fields);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.diff = function(options) {
      return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
    };
    InMemoryCache2.prototype.watch = function(watch) {
      var _this = this;
      if (!this.watches.size) {
        recallCache(this);
      }
      this.watches.add(watch);
      if (watch.immediate) {
        this.maybeBroadcastWatch(watch);
      }
      return function() {
        if (_this.watches.delete(watch) && !_this.watches.size) {
          forgetCache(_this);
        }
        _this.maybeBroadcastWatch.forget(watch);
      };
    };
    InMemoryCache2.prototype.gc = function(options) {
      var _a2;
      canonicalStringify.reset();
      print2.reset();
      this.addTypenameTransform.resetCache();
      (_a2 = this.config.fragments) === null || _a2 === void 0 ? void 0 : _a2.resetCaches();
      var ids = this.optimisticData.gc();
      if (options && !this.txCount) {
        if (options.resetResultCache) {
          this.resetResultCache(options.resetResultIdentities);
        } else if (options.resetResultIdentities) {
          this.storeReader.resetCanon();
        }
      }
      return ids;
    };
    InMemoryCache2.prototype.retain = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).retain(rootId);
    };
    InMemoryCache2.prototype.release = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).release(rootId);
    };
    InMemoryCache2.prototype.identify = function(object) {
      if (isReference(object))
        return object.__ref;
      try {
        return this.policies.identify(object)[0];
      } catch (e) {
        globalThis.__DEV__ !== false && invariant2.warn(e);
      }
    };
    InMemoryCache2.prototype.evict = function(options) {
      if (!options.id) {
        if (hasOwn.call(options, "id")) {
          return false;
        }
        options = __assign(__assign({}, options), { id: "ROOT_QUERY" });
      }
      try {
        ++this.txCount;
        return this.optimisticData.evict(options, this.data);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.reset = function(options) {
      var _this = this;
      this.init();
      canonicalStringify.reset();
      if (options && options.discardWatches) {
        this.watches.forEach(function(watch) {
          return _this.maybeBroadcastWatch.forget(watch);
        });
        this.watches.clear();
        forgetCache(this);
      } else {
        this.broadcastWatches();
      }
      return Promise.resolve();
    };
    InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
      var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
      if (newOptimisticData !== this.optimisticData) {
        this.optimisticData = newOptimisticData;
        this.broadcastWatches();
      }
    };
    InMemoryCache2.prototype.batch = function(options) {
      var _this = this;
      var update = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
      var updateResult;
      var perform = function(layer) {
        var _a3 = _this, data = _a3.data, optimisticData = _a3.optimisticData;
        ++_this.txCount;
        if (layer) {
          _this.data = _this.optimisticData = layer;
        }
        try {
          return updateResult = update(_this);
        } finally {
          --_this.txCount;
          _this.data = data;
          _this.optimisticData = optimisticData;
        }
      };
      var alreadyDirty = /* @__PURE__ */ new Set();
      if (onWatchUpdated && !this.txCount) {
        this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function(watch) {
          alreadyDirty.add(watch);
          return false;
        } }));
      }
      if (typeof optimistic === "string") {
        this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
      } else if (optimistic === false) {
        perform(this.data);
      } else {
        perform();
      }
      if (typeof removeOptimistic === "string") {
        this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
      }
      if (onWatchUpdated && alreadyDirty.size) {
        this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function(watch, diff) {
          var result2 = onWatchUpdated.call(this, watch, diff);
          if (result2 !== false) {
            alreadyDirty.delete(watch);
          }
          return result2;
        } }));
        if (alreadyDirty.size) {
          alreadyDirty.forEach(function(watch) {
            return _this.maybeBroadcastWatch.dirty(watch);
          });
        }
      } else {
        this.broadcastWatches(options);
      }
      return updateResult;
    };
    InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
      return this.batch({
        update,
        optimistic: optimisticId || optimisticId !== null
      });
    };
    InMemoryCache2.prototype.transformDocument = function(document) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(document));
    };
    InMemoryCache2.prototype.broadcastWatches = function(options) {
      var _this = this;
      if (!this.txCount) {
        this.watches.forEach(function(c) {
          return _this.maybeBroadcastWatch(c, options);
        });
      }
    };
    InMemoryCache2.prototype.addFragmentsToDocument = function(document) {
      var fragments = this.config.fragments;
      return fragments ? fragments.transform(document) : document;
    };
    InMemoryCache2.prototype.addTypenameToDocument = function(document) {
      if (this.addTypename) {
        return this.addTypenameTransform.transformDocument(document);
      }
      return document;
    };
    InMemoryCache2.prototype.broadcastWatch = function(c, options) {
      var lastDiff = c.lastDiff;
      var diff = this.diff(c);
      if (options) {
        if (c.optimistic && typeof options.optimistic === "string") {
          diff.fromOptimisticTransaction = true;
        }
        if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
          return;
        }
      }
      if (!lastDiff || !equal(lastDiff.result, diff.result)) {
        c.callback(c.lastDiff = diff, lastDiff);
      }
    };
    return InMemoryCache2;
  }(ApolloCache)
);
if (globalThis.__DEV__ !== false) {
  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;
}

// ../node_modules/@apollo/client/cache/index.js
var import_dist280 = __toESM(require_dist(), 1);
var import_dist281 = __toESM(require_dist2(), 1);
var import_dist282 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/cache/core/types/Cache.js
var import_dist271 = __toESM(require_dist(), 1);
var import_dist272 = __toESM(require_dist2(), 1);
var import_dist273 = __toESM(require_dist3(), 1);
var Cache;
/* @__PURE__ */ (function(Cache2) {
})(Cache || (Cache = {}));

// ../node_modules/@apollo/client/cache/inmemory/fragmentRegistry.js
var import_dist274 = __toESM(require_dist(), 1);
var import_dist275 = __toESM(require_dist2(), 1);
var import_dist276 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_graphql();
init_lib6();
init_lib3();
var FragmentRegistry = (
  /** @class */
  function() {
    function FragmentRegistry2() {
      var fragments = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fragments[_i] = arguments[_i];
      }
      this.registry = /* @__PURE__ */ Object.create(null);
      this.resetCaches();
      if (fragments.length) {
        this.register.apply(this, fragments);
      }
    }
    FragmentRegistry2.prototype.register = function() {
      var _this = this;
      var fragments = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fragments[_i] = arguments[_i];
      }
      var definitions = /* @__PURE__ */ new Map();
      fragments.forEach(function(doc) {
        getFragmentDefinitions(doc).forEach(function(node) {
          definitions.set(node.name.value, node);
        });
      });
      definitions.forEach(function(node, name) {
        if (node !== _this.registry[name]) {
          _this.registry[name] = node;
          _this.invalidate(name);
        }
      });
      return this;
    };
    FragmentRegistry2.prototype.invalidate = function(name) {
    };
    FragmentRegistry2.prototype.resetCaches = function() {
      var proto = FragmentRegistry2.prototype;
      this.invalidate = (this.lookup = wrap2(proto.lookup.bind(this), {
        makeCacheKey: function(arg) {
          return arg;
        },
        max: cacheSizes["fragmentRegistry.lookup"] || 1e3
      })).dirty;
      this.transform = wrap2(proto.transform.bind(this), {
        cache: WeakCache,
        max: cacheSizes["fragmentRegistry.transform"] || 2e3
      });
      this.findFragmentSpreads = wrap2(proto.findFragmentSpreads.bind(this), {
        cache: WeakCache,
        max: cacheSizes["fragmentRegistry.findFragmentSpreads"] || 4e3
      });
    };
    FragmentRegistry2.prototype.lookup = function(fragmentName) {
      return this.registry[fragmentName] || null;
    };
    FragmentRegistry2.prototype.transform = function(document) {
      var _this = this;
      var defined = /* @__PURE__ */ new Map();
      getFragmentDefinitions(document).forEach(function(def) {
        defined.set(def.name.value, def);
      });
      var unbound = /* @__PURE__ */ new Set();
      var enqueue2 = function(spreadName) {
        if (!defined.has(spreadName)) {
          unbound.add(spreadName);
        }
      };
      var enqueueChildSpreads = function(node) {
        return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue2);
      };
      enqueueChildSpreads(document);
      var missing = [];
      var map = /* @__PURE__ */ Object.create(null);
      unbound.forEach(function(fragmentName) {
        var knownFragmentDef = defined.get(fragmentName);
        if (knownFragmentDef) {
          enqueueChildSpreads(map[fragmentName] = knownFragmentDef);
        } else {
          missing.push(fragmentName);
          var def = _this.lookup(fragmentName);
          if (def) {
            enqueueChildSpreads(map[fragmentName] = def);
          }
        }
      });
      if (missing.length) {
        var defsToAppend_1 = [];
        missing.forEach(function(name) {
          var def = map[name];
          if (def) {
            defsToAppend_1.push(def);
          }
        });
        if (defsToAppend_1.length) {
          document = __assign(__assign({}, document), { definitions: document.definitions.concat(defsToAppend_1) });
        }
      }
      return document;
    };
    FragmentRegistry2.prototype.findFragmentSpreads = function(root2) {
      var spreads = /* @__PURE__ */ Object.create(null);
      visit(root2, {
        FragmentSpread: function(node) {
          spreads[node.name.value] = node;
        }
      });
      return spreads;
    };
    return FragmentRegistry2;
  }()
);

// ../node_modules/@apollo/client/cache/inmemory/types.js
var import_dist277 = __toESM(require_dist(), 1);
var import_dist278 = __toESM(require_dist2(), 1);
var import_dist279 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/core/ApolloClient.js
var import_dist346 = __toESM(require_dist(), 1);
var import_dist347 = __toESM(require_dist2(), 1);
var import_dist348 = __toESM(require_dist3(), 1);
init_tslib_es6();

// ../node_modules/@apollo/client/link/http/index.js
var import_dist328 = __toESM(require_dist(), 1);
var import_dist329 = __toESM(require_dist2(), 1);
var import_dist330 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js
var import_dist301 = __toESM(require_dist());
var import_dist302 = __toESM(require_dist2());
var import_dist303 = __toESM(require_dist3());
init_tslib_es6();

// ../node_modules/@apollo/client/link/http/responseIterator.js
var import_dist295 = __toESM(require_dist(), 1);
var import_dist296 = __toESM(require_dist2(), 1);
var import_dist297 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/link/http/iterators/async.js
var import_dist283 = __toESM(require_dist(), 1);
var import_dist284 = __toESM(require_dist2(), 1);
var import_dist285 = __toESM(require_dist3(), 1);
function asyncIterator(source) {
  var _a2;
  var iterator = source[Symbol.asyncIterator]();
  return _a2 = {
    next: function() {
      return iterator.next();
    }
  }, _a2[Symbol.asyncIterator] = function() {
    return this;
  }, _a2;
}

// ../node_modules/@apollo/client/link/http/iterators/nodeStream.js
var import_dist286 = __toESM(require_dist(), 1);
var import_dist287 = __toESM(require_dist2(), 1);
var import_dist288 = __toESM(require_dist3(), 1);
function nodeStreamIterator(stream) {
  var cleanup = null;
  var error = null;
  var done = false;
  var data = [];
  var waiting = [];
  function onData(chunk) {
    if (error)
      return;
    if (waiting.length) {
      var shiftedArr = waiting.shift();
      if (Array.isArray(shiftedArr) && shiftedArr[0]) {
        return shiftedArr[0]({ value: chunk, done: false });
      }
    }
    data.push(chunk);
  }
  function onError(err) {
    error = err;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[1](err);
    });
    !cleanup || cleanup();
  }
  function onEnd() {
    done = true;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[0]({ value: void 0, done: true });
    });
    !cleanup || cleanup();
  }
  cleanup = function() {
    cleanup = null;
    stream.removeListener("data", onData);
    stream.removeListener("error", onError);
    stream.removeListener("end", onEnd);
    stream.removeListener("finish", onEnd);
    stream.removeListener("close", onEnd);
  };
  stream.on("data", onData);
  stream.on("error", onError);
  stream.on("end", onEnd);
  stream.on("finish", onEnd);
  stream.on("close", onEnd);
  function getNext() {
    return new Promise(function(resolve, reject) {
      if (error)
        return reject(error);
      if (data.length)
        return resolve({ value: data.shift(), done: false });
      if (done)
        return resolve({ value: void 0, done: true });
      waiting.push([resolve, reject]);
    });
  }
  var iterator = {
    next: function() {
      return getNext();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}

// ../node_modules/@apollo/client/link/http/iterators/promise.js
var import_dist289 = __toESM(require_dist(), 1);
var import_dist290 = __toESM(require_dist2(), 1);
var import_dist291 = __toESM(require_dist3(), 1);
function promiseIterator(promise) {
  var resolved = false;
  var iterator = {
    next: function() {
      if (resolved)
        return Promise.resolve({
          value: void 0,
          done: true
        });
      resolved = true;
      return new Promise(function(resolve, reject) {
        promise.then(function(value) {
          resolve({ value, done: false });
        }).catch(reject);
      });
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}

// ../node_modules/@apollo/client/link/http/iterators/reader.js
var import_dist292 = __toESM(require_dist(), 1);
var import_dist293 = __toESM(require_dist2(), 1);
var import_dist294 = __toESM(require_dist3(), 1);
function readerIterator(reader) {
  var iterator = {
    next: function() {
      return reader.read();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}

// ../node_modules/@apollo/client/link/http/responseIterator.js
function isNodeResponse(value) {
  return !!value.body;
}
function isReadableStream(value) {
  return !!value.getReader;
}
function isAsyncIterableIterator(value) {
  return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
}
function isStreamableBlob(value) {
  return !!value.stream;
}
function isBlob(value) {
  return !!value.arrayBuffer;
}
function isNodeReadableStream(value) {
  return !!value.pipe;
}
function responseIterator(response) {
  var body = response;
  if (isNodeResponse(response))
    body = response.body;
  if (isAsyncIterableIterator(body))
    return asyncIterator(body);
  if (isReadableStream(body))
    return readerIterator(body.getReader());
  if (isStreamableBlob(body)) {
    return readerIterator(body.stream().getReader());
  }
  if (isBlob(body))
    return promiseIterator(body.arrayBuffer());
  if (isNodeReadableStream(body))
    return nodeStreamIterator(body);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}

// ../node_modules/@apollo/client/errors/index.js
var import_dist298 = __toESM(require_dist(), 1);
var import_dist299 = __toESM(require_dist2(), 1);
var import_dist300 = __toESM(require_dist3(), 1);
init_tslib_es6();
var PROTOCOL_ERRORS_SYMBOL = Symbol();
function graphQLResultHasProtocolErrors(result2) {
  if (result2.extensions) {
    return Array.isArray(result2.extensions[PROTOCOL_ERRORS_SYMBOL]);
  }
  return false;
}
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var errors = __spreadArray(__spreadArray(__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
  if (err.networkError)
    errors.push(err.networkError);
  return errors.map(function(err2) {
    return isNonNullObject(err2) && err2.message || "Error message not found.";
  }).join("\n");
};
var ApolloError = (
  /** @class */
  function(_super) {
    __extends(ApolloError2, _super);
    function ApolloError2(_a2) {
      var graphQLErrors = _a2.graphQLErrors, protocolErrors = _a2.protocolErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
      var _this = _super.call(this, errorMessage) || this;
      _this.name = "ApolloError";
      _this.graphQLErrors = graphQLErrors || [];
      _this.protocolErrors = protocolErrors || [];
      _this.clientErrors = clientErrors || [];
      _this.networkError = networkError || null;
      _this.message = errorMessage || generateErrorMessage(_this);
      _this.extraInfo = extraInfo;
      _this.cause = __spreadArray(__spreadArray(__spreadArray([
        networkError
      ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e) {
        return !!e;
      }) || null;
      _this.__proto__ = ApolloError2.prototype;
      return _this;
    }
    return ApolloError2;
  }(Error)
);

// ../node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js
var hasOwnProperty6 = Object.prototype.hasOwnProperty;
function readMultipartBody(response, nextValue) {
  return __awaiter(this, void 0, void 0, function() {
    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a2, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result2, next;
    var _b, _c;
    var _d;
    return __generator(this, function(_e) {
      switch (_e.label) {
        case 0:
          if (TextDecoder === void 0) {
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          }
          decoder = new TextDecoder("utf-8");
          contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
          delimiter = "boundary=";
          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
          boundary = "\r\n--".concat(boundaryVal);
          buffer = "";
          iterator = responseIterator(response);
          running = true;
          _e.label = 1;
        case 1:
          if (!running) return [3, 3];
          return [4, iterator.next()];
        case 2:
          _a2 = _e.sent(), value = _a2.value, done = _a2.done;
          chunk = typeof value === "string" ? value : decoder.decode(value);
          searchFrom = buffer.length - boundary.length + 1;
          running = !done;
          buffer += chunk;
          bi = buffer.indexOf(boundary, searchFrom);
          while (bi > -1) {
            message = void 0;
            _b = [
              buffer.slice(0, bi),
              buffer.slice(bi + boundary.length)
            ], message = _b[0], buffer = _b[1];
            i = message.indexOf("\r\n\r\n");
            headers = parseHeaders(message.slice(0, i));
            contentType_1 = headers["content-type"];
            if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
              throw new Error("Unsupported patch content type: application/json is required.");
            }
            body = message.slice(i);
            if (body) {
              result2 = parseJsonBody(response, body);
              if (Object.keys(result2).length > 1 || "data" in result2 || "incremental" in result2 || "errors" in result2 || "payload" in result2) {
                if (isApolloPayloadResult(result2)) {
                  next = {};
                  if ("payload" in result2) {
                    if (Object.keys(result2).length === 1 && result2.payload === null) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    next = __assign({}, result2.payload);
                  }
                  if ("errors" in result2) {
                    next = __assign(__assign({}, next), { extensions: __assign(__assign({}, "extensions" in next ? next.extensions : null), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result2.errors, _c)) });
                  }
                  nextValue(next);
                } else {
                  nextValue(result2);
                }
              } else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(result2).length === 1 && "hasNext" in result2 && !result2.hasNext
              ) {
                return [
                  2
                  /*return*/
                ];
              }
            }
            bi = buffer.indexOf(boundary);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function parseHeaders(headerText) {
  var headersInit = {};
  headerText.split("\n").forEach(function(line) {
    var i = line.indexOf(":");
    if (i > -1) {
      var name_1 = line.slice(0, i).trim().toLowerCase();
      var value = line.slice(i + 1).trim();
      headersInit[name_1] = value;
    }
  });
  return headersInit;
}
function parseJsonBody(response, bodyText) {
  if (response.status >= 300) {
    var getResult = function() {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        return bodyText;
      }
    };
    throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
  }
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    var parseError = err;
    parseError.name = "ServerParseError";
    parseError.response = response;
    parseError.statusCode = response.status;
    parseError.bodyText = bodyText;
    throw parseError;
  }
}
function handleError(err, observer) {
  if (err.result && err.result.errors && err.result.data) {
    observer.next(err.result);
  }
  observer.error(err);
}
function parseAndCheckHttpResponse(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      return parseJsonBody(response, bodyText);
    }).then(function(result2) {
      if (!Array.isArray(result2) && !hasOwnProperty6.call(result2, "data") && !hasOwnProperty6.call(result2, "errors")) {
        throwServerError(response, result2, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName, "'."));
      }
      return result2;
    });
  };
}

// ../node_modules/@apollo/client/link/http/serializeFetchParameter.js
var import_dist304 = __toESM(require_dist());
var import_dist305 = __toESM(require_dist2());
var import_dist306 = __toESM(require_dist3());
var serializeFetchParameter = function(p, label) {
  var serialized;
  try {
    serialized = JSON.stringify(p);
  } catch (e) {
    var parseError = newInvariantError(39, label, e.message);
    parseError.parseError = e;
    throw parseError;
  }
  return serialized;
};

// ../node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js
var import_dist307 = __toESM(require_dist());
var import_dist308 = __toESM(require_dist2());
var import_dist309 = __toESM(require_dist3());
init_tslib_es6();
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false,
  preserveHeaderCase: false
};
var defaultHeaders = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "*/*",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
};
var defaultOptions = {
  method: "POST"
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions
};
var defaultPrinter = function(ast, printer) {
  return printer(ast);
};
function selectHttpOptionsAndBodyInternal(operation, printer) {
  var configs = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }
  var options = {};
  var http = {};
  configs.forEach(function(config) {
    options = __assign(__assign(__assign({}, options), config.options), { headers: __assign(__assign({}, options.headers), config.headers) });
    if (config.credentials) {
      options.credentials = config.credentials;
    }
    http = __assign(__assign({}, http), config.http);
  });
  if (options.headers) {
    options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
  }
  var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
  var body = { operationName: operationName2, variables };
  if (http.includeExtensions)
    body.extensions = extensions;
  if (http.includeQuery)
    body.query = printer(query, print2);
  return {
    options,
    body
  };
}
function removeDuplicateHeaders(headers, preserveHeaderCase) {
  if (!preserveHeaderCase) {
    var normalizedHeaders_1 = /* @__PURE__ */ Object.create(null);
    Object.keys(Object(headers)).forEach(function(name) {
      normalizedHeaders_1[name.toLowerCase()] = headers[name];
    });
    return normalizedHeaders_1;
  }
  var headerData = /* @__PURE__ */ Object.create(null);
  Object.keys(Object(headers)).forEach(function(name) {
    headerData[name.toLowerCase()] = {
      originalName: name,
      value: headers[name]
    };
  });
  var normalizedHeaders = /* @__PURE__ */ Object.create(null);
  Object.keys(headerData).forEach(function(name) {
    normalizedHeaders[headerData[name].originalName] = headerData[name].value;
  });
  return normalizedHeaders;
}

// ../node_modules/@apollo/client/link/http/checkFetcher.js
var import_dist310 = __toESM(require_dist(), 1);
var import_dist311 = __toESM(require_dist2(), 1);
var import_dist312 = __toESM(require_dist3(), 1);
var checkFetcher = function(fetcher) {
  if (!fetcher && typeof fetch === "undefined") {
    throw newInvariantError(37);
  }
};

// ../node_modules/@apollo/client/link/http/createSignalIfSupported.js
var import_dist313 = __toESM(require_dist());
var import_dist314 = __toESM(require_dist2());
var import_dist315 = __toESM(require_dist3());
var createSignalIfSupported = function() {
  if (typeof AbortController === "undefined")
    return { controller: false, signal: false };
  var controller = new AbortController();
  var signal = controller.signal;
  return { controller, signal };
};

// ../node_modules/@apollo/client/link/http/selectURI.js
var import_dist316 = __toESM(require_dist());
var import_dist317 = __toESM(require_dist2());
var import_dist318 = __toESM(require_dist3());
var selectURI = function(operation, fallbackURI) {
  var context = operation.getContext();
  var contextURI = context.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};

// ../node_modules/@apollo/client/link/http/createHttpLink.js
var import_dist322 = __toESM(require_dist(), 1);
var import_dist323 = __toESM(require_dist2(), 1);
var import_dist324 = __toESM(require_dist3(), 1);
init_tslib_es6();

// ../node_modules/@apollo/client/link/http/rewriteURIForGET.js
var import_dist319 = __toESM(require_dist());
var import_dist320 = __toESM(require_dist2());
var import_dist321 = __toESM(require_dist3());
function rewriteURIForGET(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}

// ../node_modules/@apollo/client/link/http/createHttpLink.js
var backupFetch = maybe(function() {
  return fetch;
});
var createHttpLink = function(linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }
  var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print3 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  if (globalThis.__DEV__ !== false) {
    checkFetcher(preferredFetch || backupFetch);
  }
  var linkConfig = {
    http: { includeExtensions, preserveHeaderCase },
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new ApolloLink(function(operation) {
    var chosenURI = selectURI(operation, uri);
    var context = operation.getContext();
    var clientAwarenessHeaders = {};
    if (context.clientAwareness) {
      var _a3 = context.clientAwareness, name_1 = _a3.name, version2 = _a3.version;
      if (name_1) {
        clientAwarenessHeaders["apollographql-client-name"] = name_1;
      }
      if (version2) {
        clientAwarenessHeaders["apollographql-client-version"] = version2;
      }
    }
    var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);
    var contextConfig = {
      http: context.http,
      options: context.fetchOptions,
      credentials: context.credentials,
      headers: contextHeaders
    };
    if (hasDirectives(["client"], operation.query)) {
      var transformedQuery = removeClientSetsFromDocument(operation.query);
      if (!transformedQuery) {
        return fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
      }
      operation.query = transformedQuery;
    }
    var _b2 = selectHttpOptionsAndBodyInternal(operation, print3, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
    if (body.variables && !includeUnusedVariables) {
      body.variables = filterOperationVariables(body.variables, operation.query);
    }
    var controller;
    if (!options.signal && typeof AbortController !== "undefined") {
      controller = new AbortController();
      options.signal = controller.signal;
    }
    var definitionIsMutation = function(d) {
      return d.kind === "OperationDefinition" && d.operation === "mutation";
    };
    var definitionIsSubscription = function(d) {
      return d.kind === "OperationDefinition" && d.operation === "subscription";
    };
    var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));
    var hasDefer = hasDirectives(["defer"], operation.query);
    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options.method = "GET";
    }
    if (hasDefer || isSubscription) {
      options.headers = options.headers || {};
      var acceptHeader = "multipart/mixed;";
      if (isSubscription && hasDefer) {
        globalThis.__DEV__ !== false && invariant2.warn(38);
      }
      if (isSubscription) {
        acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
      } else if (hasDefer) {
        acceptHeader += "deferSpec=20220824,application/json";
      }
      options.headers.accept = acceptHeader;
    }
    if (options.method === "GET") {
      var _c2 = rewriteURIForGET(chosenURI, body), newURI = _c2.newURI, parseError = _c2.parseError;
      if (parseError) {
        return fromError(parseError);
      }
      chosenURI = newURI;
    } else {
      try {
        options.body = serializeFetchParameter(body, "Payload");
      } catch (parseError2) {
        return fromError(parseError2);
      }
    }
    return new Observable(function(observer) {
      var currentFetch = preferredFetch || maybe(function() {
        return fetch;
      }) || backupFetch;
      var observerNext = observer.next.bind(observer);
      currentFetch(chosenURI, options).then(function(response) {
        var _a4;
        operation.setContext({ response });
        var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
        if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
          return readMultipartBody(response, observerNext);
        } else {
          return parseAndCheckHttpResponse(operation)(response).then(observerNext);
        }
      }).then(function() {
        controller = void 0;
        observer.complete();
      }).catch(function(err) {
        controller = void 0;
        handleError(err, observer);
      });
      return function() {
        if (controller)
          controller.abort();
      };
    });
  });
};

// ../node_modules/@apollo/client/link/http/HttpLink.js
var import_dist325 = __toESM(require_dist(), 1);
var import_dist326 = __toESM(require_dist2(), 1);
var import_dist327 = __toESM(require_dist3(), 1);
init_tslib_es6();
var HttpLink = (
  /** @class */
  function(_super) {
    __extends(HttpLink2, _super);
    function HttpLink2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = _super.call(this, createHttpLink(options).request) || this;
      _this.options = options;
      return _this;
    }
    return HttpLink2;
  }(ApolloLink)
);

// ../node_modules/@apollo/client/core/QueryManager.js
var import_dist340 = __toESM(require_dist(), 1);
var import_dist341 = __toESM(require_dist2(), 1);
var import_dist342 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_lib7();

// ../node_modules/@apollo/client/core/ObservableQuery.js
var import_dist334 = __toESM(require_dist(), 1);
var import_dist335 = __toESM(require_dist2(), 1);
var import_dist336 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_lib7();

// ../node_modules/@apollo/client/core/networkStatus.js
var import_dist331 = __toESM(require_dist(), 1);
var import_dist332 = __toESM(require_dist2(), 1);
var import_dist333 = __toESM(require_dist3(), 1);
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}

// ../node_modules/@apollo/client/core/ObservableQuery.js
var assign = Object.assign;
var hasOwnProperty7 = Object.hasOwnProperty;
var ObservableQuery = (
  /** @class */
  function(_super) {
    __extends(ObservableQuery2, _super);
    function ObservableQuery2(_a2) {
      var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
      var _this = _super.call(this, function(observer) {
        try {
          var subObserver = observer._subscription._observer;
          if (subObserver && !subObserver.error) {
            subObserver.error = defaultSubscriptionObserverErrorCallback;
          }
        } catch (_a3) {
        }
        var first = !_this.observers.size;
        _this.observers.add(observer);
        var last = _this.last;
        if (last && last.error) {
          observer.error && observer.error(last.error);
        } else if (last && last.result) {
          observer.next && observer.next(last.result);
        }
        if (first) {
          _this.reobserve().catch(function() {
          });
        }
        return function() {
          if (_this.observers.delete(observer) && !_this.observers.size) {
            _this.tearDownQuery();
          }
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.subscriptions = /* @__PURE__ */ new Set();
      _this.queryInfo = queryInfo;
      _this.queryManager = queryManager;
      _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);
      _this.isTornDown = false;
      _this.subscribeToMore = _this.subscribeToMore.bind(_this);
      var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
      var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
      _this.options = __assign(__assign({}, options), {
        // Remember the initial options.fetchPolicy so we can revert back to this
        // policy when variables change. This information can also be specified
        // (or overridden) by providing options.initialFetchPolicy explicitly.
        initialFetchPolicy,
        // This ensures this.options.fetchPolicy always has a string value, in
        // case options.fetchPolicy was not provided.
        fetchPolicy
      });
      _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
      var opDef = getOperationDefinition(_this.query);
      _this.queryName = opDef && opDef.name && opDef.name.value;
      return _this;
    }
    Object.defineProperty(ObservableQuery2.prototype, "query", {
      // The `query` computed property will always reflect the document transformed
      // by the last run query. `this.options.query` will always reflect the raw
      // untransformed query to ensure document transforms with runtime conditionals
      // are run on the original document.
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservableQuery2.prototype, "variables", {
      // Computed shorthand for this.options.variables, preserved for
      // backwards compatibility.
      /**
       * An object containing the variables that were provided for the query.
       */
      get: function() {
        return this.options.variables;
      },
      enumerable: false,
      configurable: true
    });
    ObservableQuery2.prototype.result = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var observer = {
          next: function(result2) {
            resolve(result2);
            _this.observers.delete(observer);
            if (!_this.observers.size) {
              _this.queryManager.removeQuery(_this.queryId);
            }
            setTimeout(function() {
              subscription.unsubscribe();
            }, 0);
          },
          error: reject
        };
        var subscription = _this.subscribe(observer);
      });
    };
    ObservableQuery2.prototype.resetDiff = function() {
      this.queryInfo.resetDiff();
    };
    ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
      if (saveAsLastResult === void 0) {
        saveAsLastResult = true;
      }
      var lastResult = this.getLastResult(true);
      var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
      var result2 = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
      var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
      if (
        // These fetch policies should never deliver data from the cache, unless
        // redelivering a previously delivered result.
        skipCacheDataFor(fetchPolicy) || // If this.options.query has @client(always: true) fields, we cannot
        // trust diff.result, since it was read from the cache without running
        // local resolvers (and it's too late to run resolvers now, since we must
        // return a result synchronously).
        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers
      ) {
      } else if (this.waitForOwnResult) {
        this.queryInfo["updateWatch"]();
      } else {
        var diff = this.queryInfo.getDiff();
        if (diff.complete || this.options.returnPartialData) {
          result2.data = diff.result;
        }
        if (equal(result2.data, {})) {
          result2.data = void 0;
        }
        if (diff.complete) {
          delete result2.partial;
          if (diff.complete && result2.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
            result2.networkStatus = NetworkStatus.ready;
            result2.loading = false;
          }
        } else {
          result2.partial = true;
        }
        if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result2.loading && !result2.data && !result2.error) {
          logMissingFieldErrors(diff.missing);
        }
      }
      if (saveAsLastResult) {
        this.updateLastResult(result2);
      }
      return result2;
    };
    ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
      if (!this.last) {
        return true;
      }
      var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !equalByQuery(this.query, this.last.result, newResult, this.variables) : !equal(this.last.result, newResult);
      return resultIsDifferent || variables && !equal(this.last.variables, variables);
    };
    ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
      var last = this.last;
      if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {
        return last[key];
      }
    };
    ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
      return this.getLast("result", variablesMustMatch);
    };
    ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
      return this.getLast("error", variablesMustMatch);
    };
    ObservableQuery2.prototype.resetLastResults = function() {
      delete this.last;
      this.isTornDown = false;
    };
    ObservableQuery2.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    };
    ObservableQuery2.prototype.refetch = function(variables) {
      var _a2;
      var reobserveOptions = {
        // Always disable polling for refetches.
        pollInterval: 0
      };
      var fetchPolicy = this.options.fetchPolicy;
      if (fetchPolicy === "cache-and-network") {
        reobserveOptions.fetchPolicy = fetchPolicy;
      } else if (fetchPolicy === "no-cache") {
        reobserveOptions.fetchPolicy = "no-cache";
      } else {
        reobserveOptions.fetchPolicy = "network-only";
      }
      if (globalThis.__DEV__ !== false && variables && hasOwnProperty7.call(variables, "variables")) {
        var queryDef = getQueryDefinition(this.query);
        var vars = queryDef.variableDefinitions;
        if (!vars || !vars.some(function(v) {
          return v.variable.name.value === "variables";
        })) {
          globalThis.__DEV__ !== false && invariant2.warn(
            20,
            variables,
            ((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || queryDef
          );
        }
      }
      if (variables && !equal(this.options.variables, variables)) {
        reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);
      }
      this.queryInfo.resetLastWrite();
      return this.reobserve(reobserveOptions, NetworkStatus.refetch);
    };
    ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
      var _this = this;
      var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
        // The fetchMore request goes immediately to the network and does
        // not automatically write its result to the cache (hence no-cache
        // instead of network-only), because we allow the caller of
        // fetchMore to provide an updateQuery callback that determines how
        // the data gets written to the cache.
        fetchPolicy: "no-cache"
      });
      combinedOptions.query = this.transformDocument(combinedOptions.query);
      var qid = this.queryManager.generateQueryId();
      this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
      var queryInfo = this.queryInfo;
      var originalNetworkStatus = queryInfo.networkStatus;
      queryInfo.networkStatus = NetworkStatus.fetchMore;
      if (combinedOptions.notifyOnNetworkStatusChange) {
        this.observe();
      }
      var updatedQuerySet = /* @__PURE__ */ new Set();
      return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
        _this.queryManager.removeQuery(qid);
        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
          queryInfo.networkStatus = originalNetworkStatus;
        }
        _this.queryManager.cache.batch({
          update: function(cache2) {
            var updateQuery = fetchMoreOptions.updateQuery;
            if (updateQuery) {
              cache2.updateQuery({
                query: _this.query,
                variables: _this.variables,
                returnPartialData: true,
                optimistic: false
              }, function(previous) {
                return updateQuery(previous, {
                  fetchMoreResult: fetchMoreResult.data,
                  variables: combinedOptions.variables
                });
              });
            } else {
              cache2.writeQuery({
                query: combinedOptions.query,
                variables: combinedOptions.variables,
                data: fetchMoreResult.data
              });
            }
          },
          onWatchUpdated: function(watch) {
            updatedQuerySet.add(watch.query);
          }
        });
        return fetchMoreResult;
      }).finally(function() {
        if (!updatedQuerySet.has(_this.query)) {
          reobserveCacheFirst(_this);
        }
      });
    };
    ObservableQuery2.prototype.subscribeToMore = function(options) {
      var _this = this;
      var subscription = this.queryManager.startGraphQLSubscription({
        query: options.document,
        variables: options.variables,
        context: options.context
      }).subscribe({
        next: function(subscriptionData) {
          var updateQuery = options.updateQuery;
          if (updateQuery) {
            _this.updateQuery(function(previous, _a2) {
              var variables = _a2.variables;
              return updateQuery(previous, {
                subscriptionData,
                variables
              });
            });
          }
        },
        error: function(err) {
          if (options.onError) {
            options.onError(err);
            return;
          }
          globalThis.__DEV__ !== false && invariant2.error(21, err);
        }
      });
      this.subscriptions.add(subscription);
      return function() {
        if (_this.subscriptions.delete(subscription)) {
          subscription.unsubscribe();
        }
      };
    };
    ObservableQuery2.prototype.setOptions = function(newOptions) {
      return this.reobserve(newOptions);
    };
    ObservableQuery2.prototype.silentSetOptions = function(newOptions) {
      var mergedOptions = compact(this.options, newOptions || {});
      assign(this.options, mergedOptions);
    };
    ObservableQuery2.prototype.setVariables = function(variables) {
      if (equal(this.variables, variables)) {
        return this.observers.size ? this.result() : Promise.resolve();
      }
      this.options.variables = variables;
      if (!this.observers.size) {
        return Promise.resolve();
      }
      return this.reobserve({
        // Reset options.fetchPolicy to its original value.
        fetchPolicy: this.options.initialFetchPolicy,
        variables
      }, NetworkStatus.setVariables);
    };
    ObservableQuery2.prototype.updateQuery = function(mapFn) {
      var queryManager = this.queryManager;
      var result2 = queryManager.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: true,
        optimistic: false
      }).result;
      var newResult = mapFn(result2, {
        variables: this.variables
      });
      if (newResult) {
        queryManager.cache.writeQuery({
          query: this.options.query,
          data: newResult,
          variables: this.variables
        });
        queryManager.broadcastQueries();
      }
    };
    ObservableQuery2.prototype.startPolling = function(pollInterval) {
      this.options.pollInterval = pollInterval;
      this.updatePolling();
    };
    ObservableQuery2.prototype.stopPolling = function() {
      this.options.pollInterval = 0;
      this.updatePolling();
    };
    ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
      if (options.nextFetchPolicy) {
        var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
        if (fetchPolicy === "standby") {
        } else if (typeof options.nextFetchPolicy === "function") {
          options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
            reason,
            options,
            observable: this,
            initialFetchPolicy
          });
        } else if (reason === "variables-changed") {
          options.fetchPolicy = initialFetchPolicy;
        } else {
          options.fetchPolicy = options.nextFetchPolicy;
        }
      }
      return options.fetchPolicy;
    };
    ObservableQuery2.prototype.fetch = function(options, newNetworkStatus, query) {
      this.queryManager.setObservableQuery(this);
      return this.queryManager["fetchConcastWithInfo"](this.queryId, options, newNetworkStatus, query);
    };
    ObservableQuery2.prototype.updatePolling = function() {
      var _this = this;
      if (this.queryManager.ssrMode) {
        return;
      }
      var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
      if (!pollInterval || !this.hasObservers()) {
        if (pollingInfo) {
          clearTimeout(pollingInfo.timeout);
          delete this.pollingInfo;
        }
        return;
      }
      if (pollingInfo && pollingInfo.interval === pollInterval) {
        return;
      }
      invariant2(pollInterval, 22);
      var info = pollingInfo || (this.pollingInfo = {});
      info.interval = pollInterval;
      var maybeFetch = function() {
        var _a3, _b;
        if (_this.pollingInfo) {
          if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a3 = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a3))) {
            _this.reobserve({
              // Most fetchPolicy options don't make sense to use in a polling context, as
              // users wouldn't want to be polling the cache directly. However, network-only and
              // no-cache are both useful for when the user wants to control whether or not the
              // polled results are written to the cache.
              fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, NetworkStatus.poll).then(poll, poll);
          } else {
            poll();
          }
        }
      };
      var poll = function() {
        var info2 = _this.pollingInfo;
        if (info2) {
          clearTimeout(info2.timeout);
          info2.timeout = setTimeout(maybeFetch, info2.interval);
        }
      };
      poll();
    };
    ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
      if (variables === void 0) {
        variables = this.variables;
      }
      var error = this.getLastError();
      if (error && this.last && !equal(variables, this.last.variables)) {
        error = void 0;
      }
      return this.last = __assign({ result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables }, error ? { error } : null);
    };
    ObservableQuery2.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
      var _this = this;
      this.isTornDown = false;
      var useDisposableConcast = (
        // Refetching uses a disposable Concast to allow refetches using different
        // options/variables, without permanently altering the options of the
        // original ObservableQuery.
        newNetworkStatus === NetworkStatus.refetch || // The fetchMore method does not actually call the reobserve method, but,
        // if it did, it would definitely use a disposable Concast.
        newNetworkStatus === NetworkStatus.fetchMore || // Polling uses a disposable Concast so the polling options (which force
        // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
        newNetworkStatus === NetworkStatus.poll
      );
      var oldVariables = this.options.variables;
      var oldFetchPolicy = this.options.fetchPolicy;
      var mergedOptions = compact(this.options, newOptions || {});
      var options = useDisposableConcast ? (
        // Disposable Concast fetches receive a shallow copy of this.options
        // (merged with newOptions), leaving this.options unmodified.
        mergedOptions
      ) : assign(this.options, mergedOptions);
      var query = this.transformDocument(options.query);
      this.lastQuery = query;
      if (!useDisposableConcast) {
        this.updatePolling();
        if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently "standby".
        options.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
        (options.fetchPolicy === oldFetchPolicy || // A `nextFetchPolicy` function has even higher priority, though,
        // so in that case `applyNextFetchPolicy` must be called.
        typeof options.nextFetchPolicy === "function")) {
          this.applyNextFetchPolicy("variables-changed", options);
          if (newNetworkStatus === void 0) {
            newNetworkStatus = NetworkStatus.setVariables;
          }
        }
      }
      this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));
      var finishWaitingForOwnResult = function() {
        if (_this.concast === concast) {
          _this.waitForOwnResult = false;
        }
      };
      var variables = options.variables && __assign({}, options.variables);
      var _a2 = this.fetch(options, newNetworkStatus, query), concast = _a2.concast, fromLink = _a2.fromLink;
      var observer = {
        next: function(result2) {
          if (equal(_this.variables, variables)) {
            finishWaitingForOwnResult();
            _this.reportResult(result2, variables);
          }
        },
        error: function(error) {
          if (equal(_this.variables, variables)) {
            finishWaitingForOwnResult();
            _this.reportError(error, variables);
          }
        }
      };
      if (!useDisposableConcast && (fromLink || !this.concast)) {
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
        }
        this.concast = concast;
        this.observer = observer;
      }
      concast.addObserver(observer);
      return concast;
    };
    ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
      return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;
    };
    ObservableQuery2.prototype.resubscribeAfterError = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var last = this.last;
      this.resetLastResults();
      var subscription = this.subscribe.apply(this, args);
      this.last = last;
      return subscription;
    };
    ObservableQuery2.prototype.observe = function() {
      this.reportResult(
        // Passing false is important so that this.getCurrentResult doesn't
        // save the fetchMore result as this.lastResult, causing it to be
        // ignored due to the this.isDifferentFromLastResult check in
        // this.reportResult.
        this.getCurrentResult(false),
        this.variables
      );
    };
    ObservableQuery2.prototype.reportResult = function(result2, variables) {
      var lastError = this.getLastError();
      var isDifferent = this.isDifferentFromLastResult(result2, variables);
      if (lastError || !result2.partial || this.options.returnPartialData) {
        this.updateLastResult(result2, variables);
      }
      if (lastError || isDifferent) {
        iterateObserversSafely(this.observers, "next", result2);
      }
    };
    ObservableQuery2.prototype.reportError = function(error, variables) {
      var errorResult = __assign(__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
      this.updateLastResult(errorResult, variables);
      iterateObserversSafely(this.observers, "error", this.last.error = error);
    };
    ObservableQuery2.prototype.hasObservers = function() {
      return this.observers.size > 0;
    };
    ObservableQuery2.prototype.tearDownQuery = function() {
      if (this.isTornDown)
        return;
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
        delete this.concast;
        delete this.observer;
      }
      this.stopPolling();
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      this.subscriptions.clear();
      this.queryManager.stopQuery(this.queryId);
      this.observers.clear();
      this.isTornDown = true;
    };
    ObservableQuery2.prototype.transformDocument = function(document) {
      return this.queryManager.transform(document);
    };
    return ObservableQuery2;
  }(Observable)
);
fixObservableSubclass(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
  var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
  if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
    return obsQuery.reobserve({
      fetchPolicy: "cache-first",
      // Use a temporary nextFetchPolicy function that replaces itself with the
      // previous nextFetchPolicy value and returns the original fetchPolicy.
      nextFetchPolicy: function(currentFetchPolicy, context) {
        this.nextFetchPolicy = nextFetchPolicy;
        if (typeof this.nextFetchPolicy === "function") {
          return this.nextFetchPolicy(currentFetchPolicy, context);
        }
        return fetchPolicy;
      }
    });
  }
  return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
  globalThis.__DEV__ !== false && invariant2.error(23, error.message, error.stack);
}
function logMissingFieldErrors(missing) {
  if (globalThis.__DEV__ !== false && missing) {
    globalThis.__DEV__ !== false && invariant2.debug(24, missing);
  }
}
function skipCacheDataFor(fetchPolicy) {
  return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
}

// ../node_modules/@apollo/client/core/QueryInfo.js
var import_dist337 = __toESM(require_dist(), 1);
var import_dist338 = __toESM(require_dist2(), 1);
var import_dist339 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_lib7();
var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache2, methodName) {
  var original = cache2[methodName];
  if (typeof original === "function") {
    cache2[methodName] = function() {
      destructiveMethodCounts.set(
        cache2,
        // The %1e15 allows the count to wrap around to 0 safely every
        // quadrillion evictions, so there's no risk of overflow. To be
        // clear, this is more of a pedantic principle than something
        // that matters in any conceivable practical scenario.
        (destructiveMethodCounts.get(cache2) + 1) % 1e15
      );
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
var QueryInfo = (
  /** @class */
  function() {
    function QueryInfo2(queryManager, queryId) {
      if (queryId === void 0) {
        queryId = queryManager.generateQueryId();
      }
      this.queryId = queryId;
      this.listeners = /* @__PURE__ */ new Set();
      this.document = null;
      this.lastRequestId = 1;
      this.stopped = false;
      this.dirty = false;
      this.observableQuery = null;
      var cache2 = this.cache = queryManager.cache;
      if (!destructiveMethodCounts.has(cache2)) {
        destructiveMethodCounts.set(cache2, 0);
        wrapDestructiveCacheMethod(cache2, "evict");
        wrapDestructiveCacheMethod(cache2, "modify");
        wrapDestructiveCacheMethod(cache2, "reset");
      }
    }
    QueryInfo2.prototype.init = function(query) {
      var networkStatus = query.networkStatus || NetworkStatus.loading;
      if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {
        networkStatus = NetworkStatus.setVariables;
      }
      if (!equal(query.variables, this.variables)) {
        this.lastDiff = void 0;
      }
      Object.assign(this, {
        document: query.document,
        variables: query.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus
      });
      if (query.observableQuery) {
        this.setObservableQuery(query.observableQuery);
      }
      if (query.lastRequestId) {
        this.lastRequestId = query.lastRequestId;
      }
      return this;
    };
    QueryInfo2.prototype.reset = function() {
      cancelNotifyTimeout(this);
      this.dirty = false;
    };
    QueryInfo2.prototype.resetDiff = function() {
      this.lastDiff = void 0;
    };
    QueryInfo2.prototype.getDiff = function() {
      var options = this.getDiffOptions();
      if (this.lastDiff && equal(options, this.lastDiff.options)) {
        return this.lastDiff.diff;
      }
      this.updateWatch(this.variables);
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return { complete: false };
      }
      var diff = this.cache.diff(options);
      this.updateLastDiff(diff, options);
      return diff;
    };
    QueryInfo2.prototype.updateLastDiff = function(diff, options) {
      this.lastDiff = diff ? {
        diff,
        options: options || this.getDiffOptions()
      } : void 0;
    };
    QueryInfo2.prototype.getDiffOptions = function(variables) {
      var _a2;
      if (variables === void 0) {
        variables = this.variables;
      }
      return {
        query: this.document,
        variables,
        returnPartialData: true,
        optimistic: true,
        canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
      };
    };
    QueryInfo2.prototype.setDiff = function(diff) {
      var _this = this;
      var _a2;
      var oldDiff = this.lastDiff && this.lastDiff.diff;
      if (diff && !diff.complete && ((_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.getLastError())) {
        return;
      }
      this.updateLastDiff(diff);
      if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {
        this.dirty = true;
        if (!this.notifyTimeout) {
          this.notifyTimeout = setTimeout(function() {
            return _this.notify();
          }, 0);
        }
      }
    };
    QueryInfo2.prototype.setObservableQuery = function(oq) {
      var _this = this;
      if (oq === this.observableQuery)
        return;
      if (this.oqListener) {
        this.listeners.delete(this.oqListener);
      }
      this.observableQuery = oq;
      if (oq) {
        oq["queryInfo"] = this;
        this.listeners.add(this.oqListener = function() {
          var diff = _this.getDiff();
          if (diff.fromOptimisticTransaction) {
            oq["observe"]();
          } else {
            reobserveCacheFirst(oq);
          }
        });
      } else {
        delete this.oqListener;
      }
    };
    QueryInfo2.prototype.notify = function() {
      var _this = this;
      cancelNotifyTimeout(this);
      if (this.shouldNotify()) {
        this.listeners.forEach(function(listener) {
          return listener(_this);
        });
      }
      this.dirty = false;
    };
    QueryInfo2.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size) {
        return false;
      }
      if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
        var fetchPolicy = this.observableQuery.options.fetchPolicy;
        if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
          return false;
        }
      }
      return true;
    };
    QueryInfo2.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = true;
        this.reset();
        this.cancel();
        this.cancel = QueryInfo2.prototype.cancel;
        var oq = this.observableQuery;
        if (oq)
          oq.stopPolling();
      }
    };
    QueryInfo2.prototype.cancel = function() {
    };
    QueryInfo2.prototype.updateWatch = function(variables) {
      var _this = this;
      if (variables === void 0) {
        variables = this.variables;
      }
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return;
      }
      var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
        return _this.setDiff(diff);
      } });
      if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {
        this.cancel();
        this.cancel = this.cache.watch(this.lastWatch = watchOptions);
      }
    };
    QueryInfo2.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    };
    QueryInfo2.prototype.shouldWrite = function(result2, variables) {
      var lastWrite = this.lastWrite;
      return !(lastWrite && // If cache.evict has been called since the last time we wrote this
      // data into the cache, there's a chance writing this result into
      // the cache will repair what was evicted.
      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result2.data, lastWrite.result.data));
    };
    QueryInfo2.prototype.markResult = function(result2, document, options, cacheWriteBehavior) {
      var _this = this;
      var merger = new DeepMerger();
      var graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
      this.reset();
      if ("incremental" in result2 && isNonEmptyArray(result2.incremental)) {
        var mergedData = mergeIncrementalData(this.getDiff().result, result2);
        result2.data = mergedData;
      } else if ("hasNext" in result2 && result2.hasNext) {
        var diff = this.getDiff();
        result2.data = merger.merge(diff.result, result2.data);
      }
      this.graphQLErrors = graphQLErrors;
      if (options.fetchPolicy === "no-cache") {
        this.updateLastDiff({ result: result2.data, complete: true }, this.getDiffOptions(options.variables));
      } else if (cacheWriteBehavior !== 0) {
        if (shouldWriteResult(result2, options.errorPolicy)) {
          this.cache.performTransaction(function(cache2) {
            if (_this.shouldWrite(result2, options.variables)) {
              cache2.writeQuery({
                query: document,
                data: result2.data,
                variables: options.variables,
                overwrite: cacheWriteBehavior === 1
              });
              _this.lastWrite = {
                result: result2,
                variables: options.variables,
                dmCount: destructiveMethodCounts.get(_this.cache)
              };
            } else {
              if (_this.lastDiff && _this.lastDiff.diff.complete) {
                result2.data = _this.lastDiff.diff.result;
                return;
              }
            }
            var diffOptions = _this.getDiffOptions(options.variables);
            var diff2 = cache2.diff(diffOptions);
            if (!_this.stopped && equal(_this.variables, options.variables)) {
              _this.updateWatch(options.variables);
            }
            _this.updateLastDiff(diff2, diffOptions);
            if (diff2.complete) {
              result2.data = diff2.result;
            }
          });
        } else {
          this.lastWrite = void 0;
        }
      }
    };
    QueryInfo2.prototype.markReady = function() {
      this.networkError = null;
      return this.networkStatus = NetworkStatus.ready;
    };
    QueryInfo2.prototype.markError = function(error) {
      this.networkStatus = NetworkStatus.error;
      this.lastWrite = void 0;
      this.reset();
      if (error.graphQLErrors) {
        this.graphQLErrors = error.graphQLErrors;
      }
      if (error.networkError) {
        this.networkError = error.networkError;
      }
      return error;
    };
    return QueryInfo2;
  }()
);
function shouldWriteResult(result2, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError(result2);
  if (!writeWithErrors && ignoreErrors && result2.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}

// ../node_modules/@apollo/client/core/QueryManager.js
init_lib2();
var hasOwnProperty8 = Object.prototype.hasOwnProperty;
var IGNORE = /* @__PURE__ */ Object.create(null);
var QueryManager = (
  /** @class */
  function() {
    function QueryManager2(options) {
      var _this = this;
      this.clientAwareness = {};
      this.queries = /* @__PURE__ */ new Map();
      this.fetchCancelFns = /* @__PURE__ */ new Map();
      this.transformCache = new AutoCleanedWeakCache(
        cacheSizes["queryManager.getDocumentInfo"] || 2e3
        /* defaultCacheSizes["queryManager.getDocumentInfo"] */
      );
      this.queryIdCounter = 1;
      this.requestIdCounter = 1;
      this.mutationIdCounter = 1;
      this.inFlightLinkObservables = new Trie(false);
      var defaultDocumentTransform = new DocumentTransform(
        function(document) {
          return _this.cache.transformDocument(document);
        },
        // Allow the apollo cache to manage its own transform caches
        { cache: false }
      );
      this.cache = options.cache;
      this.link = options.link;
      this.defaultOptions = options.defaultOptions;
      this.queryDeduplication = options.queryDeduplication;
      this.clientAwareness = options.clientAwareness;
      this.localState = options.localState;
      this.ssrMode = options.ssrMode;
      this.assumeImmutableResults = options.assumeImmutableResults;
      var documentTransform = options.documentTransform;
      this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
      this.defaultContext = options.defaultContext || /* @__PURE__ */ Object.create(null);
      if (this.onBroadcast = options.onBroadcast) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
    }
    QueryManager2.prototype.stop = function() {
      var _this = this;
      this.queries.forEach(function(_info, queryId) {
        _this.stopQueryNoBroadcast(queryId);
      });
      this.cancelPendingFetches(newInvariantError(25));
    };
    QueryManager2.prototype.cancelPendingFetches = function(error) {
      this.fetchCancelFns.forEach(function(cancel) {
        return cancel(error);
      });
      this.fetchCancelFns.clear();
    };
    QueryManager2.prototype.mutate = function(_a2) {
      return __awaiter(this, arguments, void 0, function(_b) {
        var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self2;
        var _c, _d;
        var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || "network-only" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b.keepRootFields, context = _b.context;
        return __generator(this, function(_j) {
          switch (_j.label) {
            case 0:
              invariant2(mutation, 26);
              invariant2(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 27);
              mutationId = this.generateMutationId();
              mutation = this.cache.transformForLink(this.transform(mutation));
              hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
              variables = this.getVariables(mutation, variables);
              if (!hasClientExports2) return [3, 2];
              return [4, this.localState.addExportedVariables(mutation, variables, context)];
            case 1:
              variables = _j.sent();
              _j.label = 2;
            case 2:
              mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                mutation,
                variables,
                loading: true,
                error: null
              });
              isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                mutationId,
                document: mutation,
                variables,
                fetchPolicy,
                errorPolicy,
                context,
                updateQueries,
                update: updateWithProxyFn,
                keepRootFields
              });
              this.broadcastQueries();
              self2 = this;
              return [2, new Promise(function(resolve, reject) {
                return asyncMap(self2.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result2) {
                  if (graphQLResultHasError(result2) && errorPolicy === "none") {
                    throw new ApolloError({
                      graphQLErrors: getGraphQLErrorsFromResult(result2)
                    });
                  }
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = null;
                  }
                  var storeResult = __assign({}, result2);
                  if (typeof refetchQueries === "function") {
                    refetchQueries = refetchQueries(storeResult);
                  }
                  if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                    delete storeResult.errors;
                  }
                  return self2.markMutationResult({
                    mutationId,
                    result: storeResult,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context,
                    update: updateWithProxyFn,
                    updateQueries,
                    awaitRefetchQueries,
                    refetchQueries,
                    removeOptimistic: isOptimistic ? mutationId : void 0,
                    onQueryUpdated,
                    keepRootFields
                  });
                }).subscribe({
                  next: function(storeResult) {
                    self2.broadcastQueries();
                    if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                      resolve(storeResult);
                    }
                  },
                  error: function(err) {
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = err;
                    }
                    if (isOptimistic) {
                      self2.cache.removeOptimistic(mutationId);
                    }
                    self2.broadcastQueries();
                    reject(err instanceof ApolloError ? err : new ApolloError({
                      networkError: err
                    }));
                  }
                });
              })];
          }
        });
      });
    };
    QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
      var _this = this;
      if (cache2 === void 0) {
        cache2 = this.cache;
      }
      var result2 = mutation.result;
      var cacheWrites = [];
      var skipCache = mutation.fetchPolicy === "no-cache";
      if (!skipCache && shouldWriteResult(result2, mutation.errorPolicy)) {
        if (!isExecutionPatchIncrementalResult(result2)) {
          cacheWrites.push({
            result: result2.data,
            dataId: "ROOT_MUTATION",
            query: mutation.document,
            variables: mutation.variables
          });
        }
        if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
          var diff = cache2.diff({
            id: "ROOT_MUTATION",
            // The cache complains if passed a mutation where it expects a
            // query, so we transform mutations and subscriptions to queries
            // (only once, thanks to this.transformCache).
            query: this.getDocumentInfo(mutation.document).asQuery,
            variables: mutation.variables,
            optimistic: false,
            returnPartialData: true
          });
          var mergedData = void 0;
          if (diff.result) {
            mergedData = mergeIncrementalData(diff.result, result2);
          }
          if (typeof mergedData !== "undefined") {
            result2.data = mergedData;
            cacheWrites.push({
              result: mergedData,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
        }
        var updateQueries_1 = mutation.updateQueries;
        if (updateQueries_1) {
          this.queries.forEach(function(_a2, queryId) {
            var observableQuery = _a2.observableQuery;
            var queryName = observableQuery && observableQuery.queryName;
            if (!queryName || !hasOwnProperty8.call(updateQueries_1, queryName)) {
              return;
            }
            var updater = updateQueries_1[queryName];
            var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;
            var _c = cache2.diff({
              query: document,
              variables,
              returnPartialData: true,
              optimistic: false
            }), currentQueryResult = _c.result, complete = _c.complete;
            if (complete && currentQueryResult) {
              var nextQueryResult = updater(currentQueryResult, {
                mutationResult: result2,
                queryName: document && getOperationName(document) || void 0,
                queryVariables: variables
              });
              if (nextQueryResult) {
                cacheWrites.push({
                  result: nextQueryResult,
                  dataId: "ROOT_QUERY",
                  query: document,
                  variables
                });
              }
            }
          });
        }
      }
      if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
        var results_1 = [];
        this.refetchQueries({
          updateCache: function(cache3) {
            if (!skipCache) {
              cacheWrites.forEach(function(write) {
                return cache3.write(write);
              });
            }
            var update = mutation.update;
            var isFinalResult = !isExecutionPatchResult(result2) || isExecutionPatchIncrementalResult(result2) && !result2.hasNext;
            if (update) {
              if (!skipCache) {
                var diff2 = cache3.diff({
                  id: "ROOT_MUTATION",
                  // The cache complains if passed a mutation where it expects a
                  // query, so we transform mutations and subscriptions to queries
                  // (only once, thanks to this.transformCache).
                  query: _this.getDocumentInfo(mutation.document).asQuery,
                  variables: mutation.variables,
                  optimistic: false,
                  returnPartialData: true
                });
                if (diff2.complete) {
                  result2 = __assign(__assign({}, result2), { data: diff2.result });
                  if ("incremental" in result2) {
                    delete result2.incremental;
                  }
                  if ("hasNext" in result2) {
                    delete result2.hasNext;
                  }
                }
              }
              if (isFinalResult) {
                update(cache3, result2, {
                  context: mutation.context,
                  variables: mutation.variables
                });
              }
            }
            if (!skipCache && !mutation.keepRootFields && isFinalResult) {
              cache3.modify({
                id: "ROOT_MUTATION",
                fields: function(value, _a2) {
                  var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                  return fieldName === "__typename" ? value : DELETE2;
                }
              });
            }
          },
          include: mutation.refetchQueries,
          // Write the final mutation.result to the root layer of the cache.
          optimistic: false,
          // Remove the corresponding optimistic layer at the same time as we
          // write the final non-optimistic result.
          removeOptimistic: mutation.removeOptimistic,
          // Let the caller of client.mutate optionally determine the refetching
          // behavior for watched queries after the mutation.update function runs.
          // If no onQueryUpdated function was provided for this mutation, pass
          // null instead of undefined to disable the default refetching behavior.
          onQueryUpdated: mutation.onQueryUpdated || null
        }).forEach(function(result3) {
          return results_1.push(result3);
        });
        if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
          return Promise.all(results_1).then(function() {
            return result2;
          });
        }
      }
      return Promise.resolve(result2);
    };
    QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
      var _this = this;
      var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE }) : optimisticResponse;
      if (data === IGNORE) {
        return false;
      }
      this.cache.recordOptimisticTransaction(function(cache2) {
        try {
          _this.markMutationResult(__assign(__assign({}, mutation), { result: { data } }), cache2);
        } catch (error) {
          globalThis.__DEV__ !== false && invariant2.error(error);
        }
      }, mutation.mutationId);
      return true;
    };
    QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
      return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;
    };
    QueryManager2.prototype.getQueryStore = function() {
      var store = /* @__PURE__ */ Object.create(null);
      this.queries.forEach(function(info, queryId) {
        store[queryId] = {
          variables: info.variables,
          networkStatus: info.networkStatus,
          networkError: info.networkError,
          graphQLErrors: info.graphQLErrors
        };
      });
      return store;
    };
    QueryManager2.prototype.resetErrors = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo) {
        queryInfo.networkError = void 0;
        queryInfo.graphQLErrors = [];
      }
    };
    QueryManager2.prototype.transform = function(document) {
      return this.documentTransform.transformDocument(document);
    };
    QueryManager2.prototype.getDocumentInfo = function(document) {
      var transformCache = this.transformCache;
      if (!transformCache.has(document)) {
        var cacheEntry = {
          // TODO These three calls (hasClientExports, shouldForceResolvers, and
          // usesNonreactiveDirective) are performing independent full traversals
          // of the transformed document. We should consider merging these
          // traversals into a single pass in the future, though the work is
          // cached after the first time.
          hasClientExports: hasClientExports(document),
          hasForcedResolvers: this.localState.shouldForceResolvers(document),
          hasNonreactiveDirective: hasDirectives(["nonreactive"], document),
          clientQuery: this.localState.clientQuery(document),
          serverQuery: removeDirectivesFromDocument([
            { name: "client", remove: true },
            { name: "connection" },
            { name: "nonreactive" }
          ], document),
          defaultVars: getDefaultValues(getOperationDefinition(document)),
          // Transform any mutation or subscription operations to query operations
          // so we can read/write them from/to the cache.
          asQuery: __assign(__assign({}, document), { definitions: document.definitions.map(function(def) {
            if (def.kind === "OperationDefinition" && def.operation !== "query") {
              return __assign(__assign({}, def), { operation: "query" });
            }
            return def;
          }) })
        };
        transformCache.set(document, cacheEntry);
      }
      return transformCache.get(document);
    };
    QueryManager2.prototype.getVariables = function(document, variables) {
      return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);
    };
    QueryManager2.prototype.watchQuery = function(options) {
      var query = this.transform(options.query);
      options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });
      if (typeof options.notifyOnNetworkStatusChange === "undefined") {
        options.notifyOnNetworkStatusChange = false;
      }
      var queryInfo = new QueryInfo(this);
      var observable = new ObservableQuery({
        queryManager: this,
        queryInfo,
        options
      });
      observable["lastQuery"] = query;
      this.queries.set(observable.queryId, queryInfo);
      queryInfo.init({
        document: query,
        observableQuery: observable,
        variables: observable.variables
      });
      return observable;
    };
    QueryManager2.prototype.query = function(options, queryId) {
      var _this = this;
      if (queryId === void 0) {
        queryId = this.generateQueryId();
      }
      invariant2(options.query, 28);
      invariant2(options.query.kind === "Document", 29);
      invariant2(!options.returnPartialData, 30);
      invariant2(!options.pollInterval, 31);
      return this.fetchQuery(queryId, __assign(__assign({}, options), { query: this.transform(options.query) })).finally(function() {
        return _this.stopQuery(queryId);
      });
    };
    QueryManager2.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    };
    QueryManager2.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    };
    QueryManager2.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    };
    QueryManager2.prototype.stopQueryInStore = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo)
        queryInfo.stop();
    };
    QueryManager2.prototype.clearStore = function(options) {
      if (options === void 0) {
        options = {
          discardWatches: true
        };
      }
      this.cancelPendingFetches(newInvariantError(32));
      this.queries.forEach(function(queryInfo) {
        if (queryInfo.observableQuery) {
          queryInfo.networkStatus = NetworkStatus.loading;
        } else {
          queryInfo.stop();
        }
      });
      if (this.mutationStore) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
      return this.cache.reset(options);
    };
    QueryManager2.prototype.getObservableQueries = function(include) {
      var _this = this;
      if (include === void 0) {
        include = "active";
      }
      var queries = /* @__PURE__ */ new Map();
      var queryNamesAndDocs = /* @__PURE__ */ new Map();
      var legacyQueryOptions = /* @__PURE__ */ new Set();
      if (Array.isArray(include)) {
        include.forEach(function(desc) {
          if (typeof desc === "string") {
            queryNamesAndDocs.set(desc, false);
          } else if (isDocumentNode(desc)) {
            queryNamesAndDocs.set(_this.transform(desc), false);
          } else if (isNonNullObject(desc) && desc.query) {
            legacyQueryOptions.add(desc);
          }
        });
      }
      this.queries.forEach(function(_a2, queryId) {
        var oq = _a2.observableQuery, document = _a2.document;
        if (oq) {
          if (include === "all") {
            queries.set(queryId, oq);
            return;
          }
          var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
          if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
            return;
          }
          if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {
            queries.set(queryId, oq);
            if (queryName)
              queryNamesAndDocs.set(queryName, true);
            if (document)
              queryNamesAndDocs.set(document, true);
          }
        }
      });
      if (legacyQueryOptions.size) {
        legacyQueryOptions.forEach(function(options) {
          var queryId = makeUniqueId("legacyOneTimeQuery");
          var queryInfo = _this.getQuery(queryId).init({
            document: options.query,
            variables: options.variables
          });
          var oq = new ObservableQuery({
            queryManager: _this,
            queryInfo,
            options: __assign(__assign({}, options), { fetchPolicy: "network-only" })
          });
          invariant2(oq.queryId === queryId);
          queryInfo.setObservableQuery(oq);
          queries.set(queryId, oq);
        });
      }
      if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {
        queryNamesAndDocs.forEach(function(included, nameOrDoc) {
          if (!included) {
            globalThis.__DEV__ !== false && invariant2.warn(typeof nameOrDoc === "string" ? 33 : 34, nameOrDoc);
          }
        });
      }
      return queries;
    };
    QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
      var _this = this;
      if (includeStandby === void 0) {
        includeStandby = false;
      }
      var observableQueryPromises = [];
      this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();
        if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
          observableQueryPromises.push(observableQuery.refetch());
        }
        _this.getQuery(queryId).setDiff(null);
      });
      this.broadcastQueries();
      return Promise.all(observableQueryPromises);
    };
    QueryManager2.prototype.setObservableQuery = function(observableQuery) {
      this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
    };
    QueryManager2.prototype.startGraphQLSubscription = function(_a2) {
      var _this = this;
      var query = _a2.query, fetchPolicy = _a2.fetchPolicy, _b = _a2.errorPolicy, errorPolicy = _b === void 0 ? "none" : _b, variables = _a2.variables, _c = _a2.context, context = _c === void 0 ? {} : _c, _d = _a2.extensions, extensions = _d === void 0 ? {} : _d;
      query = this.transform(query);
      variables = this.getVariables(query, variables);
      var makeObservable = function(variables2) {
        return _this.getObservableFromLink(query, context, variables2, extensions).map(function(result2) {
          if (fetchPolicy !== "no-cache") {
            if (shouldWriteResult(result2, errorPolicy)) {
              _this.cache.write({
                query,
                result: result2.data,
                dataId: "ROOT_SUBSCRIPTION",
                variables: variables2
              });
            }
            _this.broadcastQueries();
          }
          var hasErrors = graphQLResultHasError(result2);
          var hasProtocolErrors = graphQLResultHasProtocolErrors(result2);
          if (hasErrors || hasProtocolErrors) {
            var errors = {};
            if (hasErrors) {
              errors.graphQLErrors = result2.errors;
            }
            if (hasProtocolErrors) {
              errors.protocolErrors = result2.extensions[PROTOCOL_ERRORS_SYMBOL];
            }
            if (errorPolicy === "none" || hasProtocolErrors) {
              throw new ApolloError(errors);
            }
          }
          if (errorPolicy === "ignore") {
            delete result2.errors;
          }
          return result2;
        });
      };
      if (this.getDocumentInfo(query).hasClientExports) {
        var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
        return new Observable(function(observer) {
          var sub = null;
          observablePromise_1.then(function(observable) {
            return sub = observable.subscribe(observer);
          }, observer.error);
          return function() {
            return sub && sub.unsubscribe();
          };
        });
      }
      return makeObservable(variables);
    };
    QueryManager2.prototype.stopQuery = function(queryId) {
      this.stopQueryNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.removeQuery(queryId);
    };
    QueryManager2.prototype.removeQuery = function(queryId) {
      this.fetchCancelFns.delete(queryId);
      if (this.queries.has(queryId)) {
        this.getQuery(queryId).stop();
        this.queries.delete(queryId);
      }
    };
    QueryManager2.prototype.broadcastQueries = function() {
      if (this.onBroadcast)
        this.onBroadcast();
      this.queries.forEach(function(info) {
        return info.notify();
      });
    };
    QueryManager2.prototype.getLocalState = function() {
      return this.localState;
    };
    QueryManager2.prototype.getObservableFromLink = function(query, context, variables, extensions, deduplication) {
      var _this = this;
      var _a2;
      if (deduplication === void 0) {
        deduplication = (_a2 = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
      }
      var observable;
      var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
      if (serverQuery) {
        var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
        var operation = {
          query: serverQuery,
          variables,
          operationName: getOperationName(serverQuery) || void 0,
          context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),
          extensions
        };
        context = operation.context;
        if (deduplication) {
          var printedServerQuery_1 = print2(serverQuery);
          var varJson_1 = canonicalStringify(variables);
          var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
          observable = entry.observable;
          if (!observable) {
            var concast = new Concast([
              execute(link, operation)
            ]);
            observable = entry.observable = concast;
            concast.beforeNext(function() {
              inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
            });
          }
        } else {
          observable = new Concast([
            execute(link, operation)
          ]);
        }
      } else {
        observable = new Concast([Observable.of({ data: {} })]);
        context = this.prepareContext(context);
      }
      if (clientQuery) {
        observable = asyncMap(observable, function(result2) {
          return _this.localState.runResolvers({
            document: clientQuery,
            remoteResult: result2,
            context,
            variables
          });
        });
      }
      return observable;
    };
    QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
      var requestId = queryInfo.lastRequestId = this.generateRequestId();
      var linkDocument = this.cache.transformForLink(options.query);
      return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result2) {
        var graphQLErrors = getGraphQLErrorsFromResult(result2);
        var hasErrors = graphQLErrors.length > 0;
        if (requestId >= queryInfo.lastRequestId) {
          if (hasErrors && options.errorPolicy === "none") {
            throw queryInfo.markError(new ApolloError({
              graphQLErrors
            }));
          }
          queryInfo.markResult(result2, linkDocument, options, cacheWriteBehavior);
          queryInfo.markReady();
        }
        var aqr = {
          data: result2.data,
          loading: false,
          networkStatus: NetworkStatus.ready
        };
        if (hasErrors && options.errorPolicy !== "ignore") {
          aqr.errors = graphQLErrors;
          aqr.networkStatus = NetworkStatus.error;
        }
        return aqr;
      }, function(networkError) {
        var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
        if (requestId >= queryInfo.lastRequestId) {
          queryInfo.markError(error);
        }
        throw error;
      });
    };
    QueryManager2.prototype.fetchConcastWithInfo = function(queryId, options, networkStatus, query) {
      var _this = this;
      if (networkStatus === void 0) {
        networkStatus = NetworkStatus.loading;
      }
      if (query === void 0) {
        query = options.query;
      }
      var variables = this.getVariables(query, options.variables);
      var queryInfo = this.getQuery(queryId);
      var defaults = this.defaultOptions.watchQuery;
      var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
      var normalized = Object.assign({}, options, {
        query,
        variables,
        fetchPolicy,
        errorPolicy,
        returnPartialData,
        notifyOnNetworkStatusChange,
        context
      });
      var fromVariables = function(variables2) {
        normalized.variables = variables2;
        var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        if (
          // If we're in standby, postpone advancing options.fetchPolicy using
          // applyNextFetchPolicy.
          normalized.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
          // this is another way to detect when nothing was done/fetched.
          sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery
        ) {
          queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
        }
        return sourcesWithInfo2;
      };
      var cleanupCancelFn = function() {
        return _this.fetchCancelFns.delete(queryId);
      };
      this.fetchCancelFns.set(queryId, function(reason) {
        cleanupCancelFn();
        setTimeout(function() {
          return concast.cancel(reason);
        });
      });
      var concast, containsDataFromLink;
      if (this.getDocumentInfo(normalized.query).hasClientExports) {
        concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
          return sourcesWithInfo2.sources;
        }));
        containsDataFromLink = true;
      } else {
        var sourcesWithInfo = fromVariables(normalized.variables);
        containsDataFromLink = sourcesWithInfo.fromLink;
        concast = new Concast(sourcesWithInfo.sources);
      }
      concast.promise.then(cleanupCancelFn, cleanupCancelFn);
      return {
        concast,
        fromLink: containsDataFromLink
      };
    };
    QueryManager2.prototype.refetchQueries = function(_a2) {
      var _this = this;
      var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
      var includedQueriesById = /* @__PURE__ */ new Map();
      if (include) {
        this.getObservableQueries(include).forEach(function(oq, queryId) {
          includedQueriesById.set(queryId, {
            oq,
            lastDiff: _this.getQuery(queryId).getDiff()
          });
        });
      }
      var results = /* @__PURE__ */ new Map();
      if (updateCache) {
        this.cache.batch({
          update: updateCache,
          // Since you can perform any combination of cache reads and/or writes in
          // the cache.batch update function, its optimistic option can be either
          // a boolean or a string, representing three distinct modes of
          // operation:
          //
          // * false: read/write only the root layer
          // * true: read/write the topmost layer
          // * string: read/write a fresh optimistic layer with that ID string
          //
          // When typeof optimistic === "string", a new optimistic layer will be
          // temporarily created within cache.batch with that string as its ID. If
          // we then pass that same string as the removeOptimistic option, we can
          // make cache.batch immediately remove the optimistic layer after
          // running the updateCache function, triggering only one broadcast.
          //
          // However, the refetchQueries method accepts only true or false for its
          // optimistic option (not string). We interpret true to mean a temporary
          // optimistic layer should be created, to allow efficiently rolling back
          // the effect of the updateCache function, which involves passing a
          // string instead of true as the optimistic option to cache.batch, when
          // refetchQueries receives optimistic: true.
          //
          // In other words, we are deliberately not supporting the use case of
          // writing to an *existing* optimistic layer (using the refetchQueries
          // updateCache function), since that would potentially interfere with
          // other optimistic updates in progress. Instead, you can read/write
          // only the root layer by passing optimistic: false to refetchQueries,
          // or you can read/write a brand new optimistic layer that will be
          // automatically removed by passing optimistic: true.
          optimistic: optimistic && removeOptimistic || false,
          // The removeOptimistic option can also be provided by itself, even if
          // optimistic === false, to remove some previously-added optimistic
          // layer safely and efficiently, like we do in markMutationResult.
          //
          // If an explicit removeOptimistic string is provided with optimistic:
          // true, the removeOptimistic string will determine the ID of the
          // temporary optimistic layer, in case that ever matters.
          removeOptimistic,
          onWatchUpdated: function(watch, diff, lastDiff) {
            var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
            if (oq) {
              if (onQueryUpdated) {
                includedQueriesById.delete(oq.queryId);
                var result2 = onQueryUpdated(oq, diff, lastDiff);
                if (result2 === true) {
                  result2 = oq.refetch();
                }
                if (result2 !== false) {
                  results.set(oq, result2);
                }
                return result2;
              }
              if (onQueryUpdated !== null) {
                includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
              }
            }
          }
        });
      }
      if (includedQueriesById.size) {
        includedQueriesById.forEach(function(_a3, queryId) {
          var oq = _a3.oq, lastDiff = _a3.lastDiff, diff = _a3.diff;
          var result2;
          if (onQueryUpdated) {
            if (!diff) {
              var info = oq["queryInfo"];
              info.reset();
              diff = info.getDiff();
            }
            result2 = onQueryUpdated(oq, diff, lastDiff);
          }
          if (!onQueryUpdated || result2 === true) {
            result2 = oq.refetch();
          }
          if (result2 !== false) {
            results.set(oq, result2);
          }
          if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
            _this.stopQueryNoBroadcast(queryId);
          }
        });
      }
      if (removeOptimistic) {
        this.cache.removeOptimistic(removeOptimistic);
      }
      return results;
    };
    QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
      var _this = this;
      var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
      var oldNetworkStatus = queryInfo.networkStatus;
      queryInfo.init({
        document: query,
        variables,
        networkStatus
      });
      var readCache = function() {
        return queryInfo.getDiff();
      };
      var resultsFromCache = function(diff2, networkStatus2) {
        if (networkStatus2 === void 0) {
          networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
        }
        var data = diff2.result;
        if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {
          logMissingFieldErrors(diff2.missing);
        }
        var fromData = function(data2) {
          return Observable.of(__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
        };
        if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
          return _this.localState.runResolvers({
            document: query,
            remoteResult: { data },
            context,
            variables,
            onlyRunForcedResolvers: true
          }).then(function(resolved) {
            return fromData(resolved.data || void 0);
          });
        }
        if (errorPolicy === "none" && networkStatus2 === NetworkStatus.refetch && Array.isArray(diff2.missing)) {
          return fromData(void 0);
        }
        return fromData(data);
      };
      var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
      var resultsFromLink = function() {
        return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
          query,
          variables,
          context,
          fetchPolicy,
          errorPolicy
        });
      };
      var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
      switch (fetchPolicy) {
        default:
        case "cache-first": {
          var diff = readCache();
          if (diff.complete) {
            return {
              fromLink: false,
              sources: [resultsFromCache(diff, queryInfo.markReady())]
            };
          }
          if (returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-and-network": {
          var diff = readCache();
          if (diff.complete || returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-only":
          return {
            fromLink: false,
            sources: [resultsFromCache(readCache(), queryInfo.markReady())]
          };
        case "network-only":
          if (shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(readCache()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "no-cache":
          if (shouldNotify) {
            return {
              fromLink: true,
              // Note that queryInfo.getDiff() for no-cache queries does not call
              // cache.diff, but instead returns a { complete: false } stub result
              // when there is no queryInfo.diff already defined.
              sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "standby":
          return { fromLink: false, sources: [] };
      }
    };
    QueryManager2.prototype.getQuery = function(queryId) {
      if (queryId && !this.queries.has(queryId)) {
        this.queries.set(queryId, new QueryInfo(this, queryId));
      }
      return this.queries.get(queryId);
    };
    QueryManager2.prototype.prepareContext = function(context) {
      if (context === void 0) {
        context = {};
      }
      var newContext = this.localState.prepareContext(context);
      return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
    };
    return QueryManager2;
  }()
);

// ../node_modules/@apollo/client/core/LocalState.js
var import_dist343 = __toESM(require_dist(), 1);
var import_dist344 = __toESM(require_dist2(), 1);
var import_dist345 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_graphql();
var LocalState = (
  /** @class */
  function() {
    function LocalState2(_a2) {
      var cache2 = _a2.cache, client = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
      this.cache = cache2;
      if (client) {
        this.client = client;
      }
      if (resolvers) {
        this.addResolvers(resolvers);
      }
      if (fragmentMatcher) {
        this.setFragmentMatcher(fragmentMatcher);
      }
    }
    LocalState2.prototype.addResolvers = function(resolvers) {
      var _this = this;
      this.resolvers = this.resolvers || {};
      if (Array.isArray(resolvers)) {
        resolvers.forEach(function(resolverGroup) {
          _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
        });
      } else {
        this.resolvers = mergeDeep(this.resolvers, resolvers);
      }
    };
    LocalState2.prototype.setResolvers = function(resolvers) {
      this.resolvers = {};
      this.addResolvers(resolvers);
    };
    LocalState2.prototype.getResolvers = function() {
      return this.resolvers || {};
    };
    LocalState2.prototype.runResolvers = function(_a2) {
      return __awaiter(this, arguments, void 0, function(_b) {
        var document = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;
        return __generator(this, function(_d) {
          if (document) {
            return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
              return __assign(__assign({}, remoteResult), { data: localResult.result });
            })];
          }
          return [2, remoteResult];
        });
      });
    };
    LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
      this.fragmentMatcher = fragmentMatcher;
    };
    LocalState2.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    };
    LocalState2.prototype.clientQuery = function(document) {
      if (hasDirectives(["client"], document)) {
        if (this.resolvers) {
          return document;
        }
      }
      return null;
    };
    LocalState2.prototype.serverQuery = function(document) {
      return removeClientSetsFromDocument(document);
    };
    LocalState2.prototype.prepareContext = function(context) {
      var cache2 = this.cache;
      return __assign(__assign({}, context), {
        cache: cache2,
        // Getting an entry's cache key is useful for local state resolvers.
        getCacheKey: function(obj) {
          return cache2.identify(obj);
        }
      });
    };
    LocalState2.prototype.addExportedVariables = function(document_1) {
      return __awaiter(this, arguments, void 0, function(document, variables, context) {
        if (variables === void 0) {
          variables = {};
        }
        if (context === void 0) {
          context = {};
        }
        return __generator(this, function(_a2) {
          if (document) {
            return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function(data) {
              return __assign(__assign({}, variables), data.exportedVariables);
            })];
          }
          return [2, __assign({}, variables)];
        });
      });
    };
    LocalState2.prototype.shouldForceResolvers = function(document) {
      var forceResolvers = false;
      visit(document, {
        Directive: {
          enter: function(node) {
            if (node.name.value === "client" && node.arguments) {
              forceResolvers = node.arguments.some(function(arg) {
                return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
              });
              if (forceResolvers) {
                return BREAK;
              }
            }
          }
        }
      });
      return forceResolvers;
    };
    LocalState2.prototype.buildRootValueFromCache = function(document, variables) {
      return this.cache.diff({
        query: buildQueryFromSelectionSet(document),
        variables,
        returnPartialData: true,
        optimistic: false
      }).result;
    };
    LocalState2.prototype.resolveDocument = function(document_1, rootValue_1) {
      return __awaiter(this, arguments, void 0, function(document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
        var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a2, cache2, client, execContext, isClientFieldDescendant;
        if (context === void 0) {
          context = {};
        }
        if (variables === void 0) {
          variables = {};
        }
        if (fragmentMatcher === void 0) {
          fragmentMatcher = function() {
            return true;
          };
        }
        if (onlyRunForcedResolvers === void 0) {
          onlyRunForcedResolvers = false;
        }
        return __generator(this, function(_b) {
          mainDefinition = getMainDefinition(document);
          fragments = getFragmentDefinitions(document);
          fragmentMap = createFragmentMap(fragments);
          selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
          definitionOperation = mainDefinition.operation;
          defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
          _a2 = this, cache2 = _a2.cache, client = _a2.client;
          execContext = {
            fragmentMap,
            context: __assign(__assign({}, context), { cache: cache2, client }),
            variables,
            fragmentMatcher,
            defaultOperationType,
            exportedVariables: {},
            selectionsToResolve,
            onlyRunForcedResolvers
          };
          isClientFieldDescendant = false;
          return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result2) {
            return {
              result: result2,
              exportedVariables: execContext.exportedVariables
            };
          })];
        });
      });
    };
    LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter(this, void 0, void 0, function() {
        var fragmentMap, context, variables, resultsToMerge, execute2;
        var _this = this;
        return __generator(this, function(_a2) {
          fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
          resultsToMerge = [rootValue];
          execute2 = function(selection) {
            return __awaiter(_this, void 0, void 0, function() {
              var fragment, typeCondition;
              return __generator(this, function(_a3) {
                if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (!shouldInclude(selection, variables)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (isField(selection)) {
                  return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                    var _a4;
                    if (typeof fieldResult !== "undefined") {
                      resultsToMerge.push((_a4 = {}, _a4[resultKeyNameFromField(selection)] = fieldResult, _a4));
                    }
                  })];
                }
                if (isInlineFragment(selection)) {
                  fragment = selection;
                } else {
                  fragment = fragmentMap[selection.name.value];
                  invariant2(fragment, 18, selection.name.value);
                }
                if (fragment && fragment.typeCondition) {
                  typeCondition = fragment.typeCondition.name.value;
                  if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                    return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                      resultsToMerge.push(fragmentResult);
                    })];
                  }
                }
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
            return mergeDeepArray(resultsToMerge);
          })];
        });
      });
    };
    LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter(this, void 0, void 0, function() {
        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
        var _this = this;
        return __generator(this, function(_a2) {
          if (!rootValue) {
            return [2, null];
          }
          variables = execContext.variables;
          fieldName = field.name.value;
          aliasedFieldName = resultKeyNameFromField(field);
          aliasUsed = fieldName !== aliasedFieldName;
          defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
          resultPromise = Promise.resolve(defaultResult);
          if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
            resolverType = rootValue.__typename || execContext.defaultOperationType;
            resolverMap = this.resolvers && this.resolvers[resolverType];
            if (resolverMap) {
              resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
              if (resolve) {
                resultPromise = Promise.resolve(
                  // In case the resolve function accesses reactive variables,
                  // set cacheSlot to the current cache instance.
                  cacheSlot.withValue(this.cache, resolve, [
                    rootValue,
                    argumentsObjectFromField(field, variables),
                    execContext.context,
                    { field, fragmentMap: execContext.fragmentMap }
                  ])
                );
              }
            }
          }
          return [2, resultPromise.then(function(result2) {
            var _a3, _b;
            if (result2 === void 0) {
              result2 = defaultResult;
            }
            if (field.directives) {
              field.directives.forEach(function(directive) {
                if (directive.name.value === "export" && directive.arguments) {
                  directive.arguments.forEach(function(arg) {
                    if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                      execContext.exportedVariables[arg.value.value] = result2;
                    }
                  });
                }
              });
            }
            if (!field.selectionSet) {
              return result2;
            }
            if (result2 == null) {
              return result2;
            }
            var isClientField = (_b = (_a3 = field.directives) === null || _a3 === void 0 ? void 0 : _a3.some(function(d) {
              return d.name.value === "client";
            })) !== null && _b !== void 0 ? _b : false;
            if (Array.isArray(result2)) {
              return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result2, execContext);
            }
            if (field.selectionSet) {
              return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result2, execContext);
            }
          })];
        });
      });
    };
    LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result2, execContext) {
      var _this = this;
      return Promise.all(result2.map(function(item) {
        if (item === null) {
          return null;
        }
        if (Array.isArray(item)) {
          return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
        }
        if (field.selectionSet) {
          return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
        }
      }));
    };
    LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
      var isSingleASTNode = function(node) {
        return !Array.isArray(node);
      };
      var selectionsToResolveCache = this.selectionsToResolveCache;
      function collectByDefinition(definitionNode) {
        if (!selectionsToResolveCache.has(definitionNode)) {
          var matches_1 = /* @__PURE__ */ new Set();
          selectionsToResolveCache.set(definitionNode, matches_1);
          visit(definitionNode, {
            Directive: function(node, _, __, ___, ancestors) {
              if (node.name.value === "client") {
                ancestors.forEach(function(node2) {
                  if (isSingleASTNode(node2) && isSelectionNode(node2)) {
                    matches_1.add(node2);
                  }
                });
              }
            },
            FragmentSpread: function(spread, _, __, ___, ancestors) {
              var fragment = fragmentMap[spread.name.value];
              invariant2(fragment, 19, spread.name.value);
              var fragmentSelections = collectByDefinition(fragment);
              if (fragmentSelections.size > 0) {
                ancestors.forEach(function(node) {
                  if (isSingleASTNode(node) && isSelectionNode(node)) {
                    matches_1.add(node);
                  }
                });
                matches_1.add(spread);
                fragmentSelections.forEach(function(selection) {
                  matches_1.add(selection);
                });
              }
            }
          });
        }
        return selectionsToResolveCache.get(definitionNode);
      }
      return collectByDefinition(mainDefinition);
    };
    return LocalState2;
  }()
);

// ../node_modules/@apollo/client/core/ApolloClient.js
var hasSuggestedDevtools = false;
var ApolloClient = (
  /** @class */
  function() {
    function ApolloClient2(options) {
      var _this = this;
      this.resetStoreCallbacks = [];
      this.clearStoreCallbacks = [];
      if (!options.cache) {
        throw newInvariantError(15);
      }
      var uri = options.uri, credentials = options.credentials, headers = options.headers, cache2 = options.cache, documentTransform = options.documentTransform, _a2 = options.ssrMode, ssrMode = _a2 === void 0 ? false : _a2, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions2 = options.defaultOptions, defaultContext = options.defaultContext, _d = options.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? cache2.assumeImmutableResults : _d, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version, devtools = options.devtools;
      var link = options.link;
      if (!link) {
        link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
      }
      this.link = link;
      this.cache = cache2;
      this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
      this.queryDeduplication = queryDeduplication;
      this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
      this.typeDefs = typeDefs;
      this.devtoolsConfig = __assign(__assign({}, devtools), { enabled: (devtools === null || devtools === void 0 ? void 0 : devtools.enabled) || connectToDevTools });
      if (this.devtoolsConfig.enabled === void 0) {
        this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
      }
      if (ssrForceFetchDelay) {
        setTimeout(function() {
          return _this.disableNetworkFetches = false;
        }, ssrForceFetchDelay);
      }
      this.watchQuery = this.watchQuery.bind(this);
      this.query = this.query.bind(this);
      this.mutate = this.mutate.bind(this);
      this.watchFragment = this.watchFragment.bind(this);
      this.resetStore = this.resetStore.bind(this);
      this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
      this.version = version;
      this.localState = new LocalState({
        cache: cache2,
        client: this,
        resolvers,
        fragmentMatcher
      });
      this.queryManager = new QueryManager({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        defaultContext,
        documentTransform,
        queryDeduplication,
        ssrMode,
        clientAwareness: {
          name: clientAwarenessName,
          version: clientAwarenessVersion
        },
        localState: this.localState,
        assumeImmutableResults,
        onBroadcast: this.devtoolsConfig.enabled ? function() {
          if (_this.devToolsHookCb) {
            _this.devToolsHookCb({
              action: {},
              state: {
                queries: _this.queryManager.getQueryStore(),
                mutations: _this.queryManager.mutationStore || {}
              },
              dataWithOptimisticResults: _this.cache.extract(true)
            });
          }
        } : void 0
      });
      if (this.devtoolsConfig.enabled)
        this.connectToDevTools();
    }
    ApolloClient2.prototype.connectToDevTools = function() {
      if (typeof window === "undefined") {
        return;
      }
      var windowWithDevTools = window;
      var devtoolsSymbol = Symbol.for("apollo.devtools");
      (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
      windowWithDevTools.__APOLLO_CLIENT__ = this;
      if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {
        hasSuggestedDevtools = true;
        if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
          setTimeout(function() {
            if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
              var nav = window.navigator;
              var ua = nav && nav.userAgent;
              var url = void 0;
              if (typeof ua === "string") {
                if (ua.indexOf("Chrome/") > -1) {
                  url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                } else if (ua.indexOf("Firefox/") > -1) {
                  url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                }
              }
              if (url) {
                globalThis.__DEV__ !== false && invariant2.log("Download the Apollo DevTools for a better development experience: %s", url);
              }
            }
          }, 1e4);
        }
      }
    };
    Object.defineProperty(ApolloClient2.prototype, "documentTransform", {
      /**
       * The `DocumentTransform` used to modify GraphQL documents before a request
       * is made. If a custom `DocumentTransform` is not provided, this will be the
       * default document transform.
       */
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: false,
      configurable: true
    });
    ApolloClient2.prototype.stop = function() {
      this.queryManager.stop();
    };
    ApolloClient2.prototype.watchQuery = function(options) {
      if (this.defaultOptions.watchQuery) {
        options = mergeOptions(this.defaultOptions.watchQuery, options);
      }
      if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
        options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.watchQuery(options);
    };
    ApolloClient2.prototype.query = function(options) {
      if (this.defaultOptions.query) {
        options = mergeOptions(this.defaultOptions.query, options);
      }
      invariant2(options.fetchPolicy !== "cache-and-network", 16);
      if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
        options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.query(options);
    };
    ApolloClient2.prototype.mutate = function(options) {
      if (this.defaultOptions.mutate) {
        options = mergeOptions(this.defaultOptions.mutate, options);
      }
      return this.queryManager.mutate(options);
    };
    ApolloClient2.prototype.subscribe = function(options) {
      return this.queryManager.startGraphQLSubscription(options);
    };
    ApolloClient2.prototype.readQuery = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readQuery(options, optimistic);
    };
    ApolloClient2.prototype.watchFragment = function(options) {
      return this.cache.watchFragment(options);
    };
    ApolloClient2.prototype.readFragment = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readFragment(options, optimistic);
    };
    ApolloClient2.prototype.writeQuery = function(options) {
      var ref = this.cache.writeQuery(options);
      if (options.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.writeFragment = function(options) {
      var ref = this.cache.writeFragment(options);
      if (options.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
      this.devToolsHookCb = cb;
    };
    ApolloClient2.prototype.__requestRaw = function(payload) {
      return execute(this.link, payload);
    };
    ApolloClient2.prototype.resetStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: false
        });
      }).then(function() {
        return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
          return fn();
        }));
      }).then(function() {
        return _this.reFetchObservableQueries();
      });
    };
    ApolloClient2.prototype.clearStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: true
        });
      }).then(function() {
        return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
          return fn();
        }));
      });
    };
    ApolloClient2.prototype.onResetStore = function(cb) {
      var _this = this;
      this.resetStoreCallbacks.push(cb);
      return function() {
        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
          return c !== cb;
        });
      };
    };
    ApolloClient2.prototype.onClearStore = function(cb) {
      var _this = this;
      this.clearStoreCallbacks.push(cb);
      return function() {
        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
          return c !== cb;
        });
      };
    };
    ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
      return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient2.prototype.refetchQueries = function(options) {
      var map = this.queryManager.refetchQueries(options);
      var queries = [];
      var results = [];
      map.forEach(function(result3, obsQuery) {
        queries.push(obsQuery);
        results.push(result3);
      });
      var result2 = Promise.all(results);
      result2.queries = queries;
      result2.results = results;
      result2.catch(function(error) {
        globalThis.__DEV__ !== false && invariant2.debug(17, error);
      });
      return result2;
    };
    ApolloClient2.prototype.getObservableQueries = function(include) {
      if (include === void 0) {
        include = "active";
      }
      return this.queryManager.getObservableQueries(include);
    };
    ApolloClient2.prototype.extract = function(optimistic) {
      return this.cache.extract(optimistic);
    };
    ApolloClient2.prototype.restore = function(serializedState) {
      return this.cache.restore(serializedState);
    };
    ApolloClient2.prototype.addResolvers = function(resolvers) {
      this.localState.addResolvers(resolvers);
    };
    ApolloClient2.prototype.setResolvers = function(resolvers) {
      this.localState.setResolvers(resolvers);
    };
    ApolloClient2.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    };
    ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
      this.localState.setFragmentMatcher(fragmentMatcher);
    };
    ApolloClient2.prototype.setLink = function(newLink) {
      this.link = this.queryManager.link = newLink;
    };
    Object.defineProperty(ApolloClient2.prototype, "defaultContext", {
      get: function() {
        return this.queryManager.defaultContext;
      },
      enumerable: false,
      configurable: true
    });
    return ApolloClient2;
  }()
);
if (globalThis.__DEV__ !== false) {
  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;
}

// ../node_modules/@apollo/client/core/index.js
var import_dist352 = __toESM(require_dist(), 1);
var import_dist353 = __toESM(require_dist2(), 1);
var import_dist354 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/core/types.js
var import_dist349 = __toESM(require_dist(), 1);
var import_dist350 = __toESM(require_dist2(), 1);
var import_dist351 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/core/index.js
init_invariant();
init_lib();
setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");

// ../node_modules/@apollo/client/react/context/ApolloProvider.js
var import_dist358 = __toESM(require_dist(), 1);
var import_dist359 = __toESM(require_dist2(), 1);
var import_dist360 = __toESM(require_dist3(), 1);
init_tslib_es6();
var React4 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/context/ApolloContext.js
var import_dist355 = __toESM(require_dist(), 1);
var import_dist356 = __toESM(require_dist2(), 1);
var import_dist357 = __toESM(require_dist3(), 1);
var React3 = __toESM(require_rehackt(), 1);
var contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function getApolloContext() {
  invariant2("createContext" in React3, 45);
  var context = React3.createContext[contextKey];
  if (!context) {
    Object.defineProperty(React3.createContext, contextKey, {
      value: context = React3.createContext({}),
      enumerable: false,
      writable: false,
      configurable: true
    });
    context.displayName = "ApolloContext";
  }
  return context;
}

// ../node_modules/@apollo/client/react/context/ApolloProvider.js
var ApolloProvider = function(_a2) {
  var client = _a2.client, children = _a2.children;
  var ApolloContext = getApolloContext();
  var parentContext = React4.useContext(ApolloContext);
  var context = React4.useMemo(function() {
    return __assign(__assign({}, parentContext), { client: client || parentContext.client });
  }, [parentContext, client]);
  invariant2(context.client, 46);
  return React4.createElement(ApolloContext.Provider, { value: context }, children);
};

// ../node_modules/@apollo/client/react/context/index.js
var import_dist364 = __toESM(require_dist(), 1);
var import_dist365 = __toESM(require_dist2(), 1);
var import_dist366 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/react/context/ApolloConsumer.js
var import_dist361 = __toESM(require_dist(), 1);
var import_dist362 = __toESM(require_dist2(), 1);
var import_dist363 = __toESM(require_dist3(), 1);
var React5 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/index.js
var import_dist454 = __toESM(require_dist(), 1);
var import_dist455 = __toESM(require_dist2(), 1);
var import_dist456 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/react/hooks/index.js
var import_dist445 = __toESM(require_dist(), 1);
var import_dist446 = __toESM(require_dist2(), 1);
var import_dist447 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/react/hooks/useApolloClient.js
var import_dist367 = __toESM(require_dist(), 1);
var import_dist368 = __toESM(require_dist2(), 1);
var import_dist369 = __toESM(require_dist3(), 1);
var React6 = __toESM(require_rehackt(), 1);
function useApolloClient(override) {
  var context = React6.useContext(getApolloContext());
  var client = override || context.client;
  invariant2(!!client, 49);
  return client;
}

// ../node_modules/@apollo/client/react/hooks/useLazyQuery.js
var import_dist400 = __toESM(require_dist(), 1);
var import_dist401 = __toESM(require_dist2(), 1);
var import_dist402 = __toESM(require_dist3(), 1);
init_tslib_es6();
var React14 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/hooks/useQuery.js
var import_dist397 = __toESM(require_dist(), 1);
var import_dist398 = __toESM(require_dist2(), 1);
var import_dist399 = __toESM(require_dist3(), 1);
init_tslib_es6();
var React13 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/hooks/useSyncExternalStore.js
var import_dist370 = __toESM(require_dist(), 1);
var import_dist371 = __toESM(require_dist2(), 1);
var import_dist372 = __toESM(require_dist3(), 1);
var React7 = __toESM(require_rehackt(), 1);
var didWarnUncachedGetSnapshot = false;
var uSESKey = "useSyncExternalStore";
var realHook = React7[uSESKey];
var useSyncExternalStore = realHook || function(subscribe, getSnapshot, getServerSnapshot) {
  var value = getSnapshot();
  if (
    // DEVIATION: Using __DEV__
    globalThis.__DEV__ !== false && !didWarnUncachedGetSnapshot && // DEVIATION: Not using Object.is because we know our snapshots will never
    // be exotic primitive values like NaN, which is !== itself.
    value !== getSnapshot()
  ) {
    didWarnUncachedGetSnapshot = true;
    globalThis.__DEV__ !== false && invariant2.error(59);
  }
  var _a2 = React7.useState({
    inst: { value, getSnapshot }
  }), inst = _a2[0].inst, forceUpdate = _a2[1];
  if (canUseLayoutEffect) {
    React7.useLayoutEffect(function() {
      Object.assign(inst, { value, getSnapshot });
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    }, [subscribe, value, getSnapshot]);
  } else {
    Object.assign(inst, { value, getSnapshot });
  }
  React7.useEffect(function() {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({ inst });
    }
    return subscribe(function handleStoreChange() {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    });
  }, [subscribe]);
  return value;
};
function checkIfSnapshotChanged(_a2) {
  var value = _a2.value, getSnapshot = _a2.getSnapshot;
  try {
    return value !== getSnapshot();
  } catch (_b) {
    return true;
  }
}

// ../node_modules/@apollo/client/react/hooks/useQuery.js
init_lib7();

// ../node_modules/@apollo/client/react/parser/index.js
var import_dist373 = __toESM(require_dist(), 1);
var import_dist374 = __toESM(require_dist2(), 1);
var import_dist375 = __toESM(require_dist3(), 1);
var DocumentType;
(function(DocumentType2) {
  DocumentType2[DocumentType2["Query"] = 0] = "Query";
  DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
  DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
})(DocumentType || (DocumentType = {}));
var cache;
function parser(document) {
  if (!cache) {
    cache = new AutoCleanedWeakCache(
      cacheSizes.parser || 1e3
      /* defaultCacheSizes.parser */
    );
  }
  var cached = cache.get(document);
  if (cached)
    return cached;
  var variables, type, name;
  invariant2(!!document && !!document.kind, 61, document);
  var fragments = [];
  var queries = [];
  var mutations = [];
  var subscriptions = [];
  for (var _i = 0, _a2 = document.definitions; _i < _a2.length; _i++) {
    var x = _a2[_i];
    if (x.kind === "FragmentDefinition") {
      fragments.push(x);
      continue;
    }
    if (x.kind === "OperationDefinition") {
      switch (x.operation) {
        case "query":
          queries.push(x);
          break;
        case "mutation":
          mutations.push(x);
          break;
        case "subscription":
          subscriptions.push(x);
          break;
      }
    }
  }
  invariant2(!fragments.length || queries.length || mutations.length || subscriptions.length, 62);
  invariant2(
    queries.length + mutations.length + subscriptions.length <= 1,
    63,
    document,
    queries.length,
    subscriptions.length,
    mutations.length
  );
  type = queries.length ? DocumentType.Query : DocumentType.Mutation;
  if (!queries.length && !mutations.length)
    type = DocumentType.Subscription;
  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
  invariant2(definitions.length === 1, 64, document, definitions.length);
  var definition = definitions[0];
  variables = definition.variableDefinitions || [];
  if (definition.name && definition.name.kind === "Name") {
    name = definition.name.value;
  } else {
    name = "data";
  }
  var payload = { name, type, variables };
  cache.set(document, payload);
  return payload;
}
parser.resetCache = function() {
  cache = void 0;
};
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("parser", function() {
    return cache ? cache.size : 0;
  });
}

// ../node_modules/@apollo/client/react/hooks/internal/index.js
var import_dist394 = __toESM(require_dist(), 1);
var import_dist395 = __toESM(require_dist2(), 1);
var import_dist396 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/react/hooks/internal/useDeepMemo.js
var import_dist376 = __toESM(require_dist(), 1);
var import_dist377 = __toESM(require_dist2(), 1);
var import_dist378 = __toESM(require_dist3(), 1);
var React8 = __toESM(require_rehackt(), 1);
init_lib7();
function useDeepMemo(memoFn, deps) {
  var ref = React8.useRef();
  if (!ref.current || !equal(ref.current.deps, deps)) {
    ref.current = { value: memoFn(), deps };
  }
  return ref.current.value;
}

// ../node_modules/@apollo/client/react/hooks/internal/useIsomorphicLayoutEffect.js
var import_dist379 = __toESM(require_dist(), 1);
var import_dist380 = __toESM(require_dist2(), 1);
var import_dist381 = __toESM(require_dist3(), 1);
var React9 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/hooks/internal/useRenderGuard.js
var import_dist382 = __toESM(require_dist(), 1);
var import_dist383 = __toESM(require_dist2(), 1);
var import_dist384 = __toESM(require_dist3(), 1);
var React10 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/hooks/internal/useLazyRef.js
var import_dist385 = __toESM(require_dist(), 1);
var import_dist386 = __toESM(require_dist2(), 1);
var import_dist387 = __toESM(require_dist3(), 1);
var React11 = __toESM(require_rehackt(), 1);
var INIT = {};
function useLazyRef(getInitialValue) {
  var ref = React11.useRef(INIT);
  if (ref.current === INIT) {
    ref.current = getInitialValue();
  }
  return ref;
}

// ../node_modules/@apollo/client/react/hooks/internal/__use.js
var import_dist388 = __toESM(require_dist(), 1);
var import_dist389 = __toESM(require_dist2(), 1);
var import_dist390 = __toESM(require_dist3(), 1);
var React12 = __toESM(require_rehackt(), 1);
var useKey = "use";
var realHook2 = React12[useKey];

// ../node_modules/@apollo/client/react/hooks/internal/wrapHook.js
var import_dist391 = __toESM(require_dist(), 1);
var import_dist392 = __toESM(require_dist2(), 1);
var import_dist393 = __toESM(require_dist3(), 1);
var wrapperSymbol = Symbol.for("apollo.hook.wrappers");
function wrapHook(hookName, useHook, clientOrObsQuery) {
  var queryManager = clientOrObsQuery["queryManager"];
  var wrappers = queryManager && queryManager[wrapperSymbol];
  var wrapper = wrappers && wrappers[hookName];
  return wrapper ? wrapper(useHook) : useHook;
}

// ../node_modules/@apollo/client/react/hooks/useQuery.js
var lastWatchOptions = Symbol();
var ssrDisabledResult = maybeDeepFreeze({
  loading: true,
  data: void 0,
  error: void 0,
  networkStatus: NetworkStatus.loading
});
var skipStandbyResult = maybeDeepFreeze({
  loading: false,
  data: void 0,
  error: void 0,
  networkStatus: NetworkStatus.ready
});

// ../node_modules/@apollo/client/react/hooks/useMutation.js
var import_dist403 = __toESM(require_dist(), 1);
var import_dist404 = __toESM(require_dist2(), 1);
var import_dist405 = __toESM(require_dist3(), 1);
init_tslib_es6();
var React15 = __toESM(require_rehackt(), 1);
init_lib7();

// ../node_modules/@apollo/client/react/hooks/useSubscription.js
var import_dist406 = __toESM(require_dist(), 1);
var import_dist407 = __toESM(require_dist2(), 1);
var import_dist408 = __toESM(require_dist3(), 1);
init_tslib_es6();
var React16 = __toESM(require_rehackt(), 1);
init_lib7();

// ../node_modules/@apollo/client/react/hooks/useReactiveVar.js
var import_dist409 = __toESM(require_dist(), 1);
var import_dist410 = __toESM(require_dist2(), 1);
var import_dist411 = __toESM(require_dist3(), 1);
var React17 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/hooks/useFragment.js
var import_dist412 = __toESM(require_dist(), 1);
var import_dist413 = __toESM(require_dist2(), 1);
var import_dist414 = __toESM(require_dist3(), 1);
init_tslib_es6();
var React18 = __toESM(require_rehackt(), 1);
init_lib7();
function useFragment(options) {
  return wrapHook("useFragment", _useFragment, useApolloClient(options.client))(options);
}
function _useFragment(options) {
  var cache2 = useApolloClient(options.client).cache;
  var diffOptions = useDeepMemo(function() {
    var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, rest = __rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
    return __assign(__assign({}, rest), { returnPartialData: true, id: typeof from2 === "string" ? from2 : cache2.identify(from2), query: cache2["getFragmentDoc"](fragment, fragmentName), optimistic });
  }, [options]);
  var resultRef = useLazyRef(function() {
    return diffToResult(cache2.diff(diffOptions));
  });
  var stableOptions = useDeepMemo(function() {
    return options;
  }, [options]);
  React18.useMemo(function() {
    resultRef.current = diffToResult(cache2.diff(diffOptions));
  }, [diffOptions, cache2]);
  var getSnapshot = React18.useCallback(function() {
    return resultRef.current;
  }, []);
  return useSyncExternalStore(React18.useCallback(function(forceUpdate) {
    var lastTimeout = 0;
    var subscription = cache2.watchFragment(stableOptions).subscribe({
      next: function(result2) {
        if (lib_default(result2, resultRef.current))
          return;
        resultRef.current = result2;
        clearTimeout(lastTimeout);
        lastTimeout = setTimeout(forceUpdate);
      }
    });
    return function() {
      subscription.unsubscribe();
      clearTimeout(lastTimeout);
    };
  }, [cache2, stableOptions]), getSnapshot, getSnapshot);
}
function diffToResult(diff) {
  var result2 = {
    data: diff.result,
    complete: !!diff.complete
  };
  if (diff.missing) {
    result2.missing = mergeDeepArray(diff.missing.map(function(error) {
      return error.missing;
    }));
  }
  return result2;
}

// ../node_modules/@apollo/client/react/hooks/useSuspenseQuery.js
var import_dist430 = __toESM(require_dist(), 1);
var import_dist431 = __toESM(require_dist2(), 1);
var import_dist432 = __toESM(require_dist3(), 1);
init_tslib_es6();
var React19 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/internal/index.js
var import_dist424 = __toESM(require_dist(), 1);
var import_dist425 = __toESM(require_dist2(), 1);
var import_dist426 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/react/internal/cache/getSuspenseCache.js
var import_dist421 = __toESM(require_dist(), 1);
var import_dist422 = __toESM(require_dist2(), 1);
var import_dist423 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/react/internal/cache/SuspenseCache.js
var import_dist418 = __toESM(require_dist(), 1);
var import_dist419 = __toESM(require_dist2(), 1);
var import_dist420 = __toESM(require_dist3(), 1);
init_lib2();

// ../node_modules/@apollo/client/react/internal/cache/QueryReference.js
var import_dist415 = __toESM(require_dist(), 1);
var import_dist416 = __toESM(require_dist2(), 1);
var import_dist417 = __toESM(require_dist3(), 1);
init_tslib_es6();
init_lib7();
var QUERY_REFERENCE_SYMBOL = Symbol();
var PROMISE_SYMBOL = Symbol();
var OBSERVED_CHANGED_OPTIONS = [
  "canonizeResults",
  "context",
  "errorPolicy",
  "fetchPolicy",
  "refetchWritePolicy",
  "returnPartialData"
];
var InternalQueryReference = (
  /** @class */
  function() {
    function InternalQueryReference2(observable, options) {
      var _this = this;
      this.key = {};
      this.listeners = /* @__PURE__ */ new Set();
      this.references = 0;
      this.softReferences = 0;
      this.handleNext = this.handleNext.bind(this);
      this.handleError = this.handleError.bind(this);
      this.dispose = this.dispose.bind(this);
      this.observable = observable;
      if (options.onDispose) {
        this.onDispose = options.onDispose;
      }
      this.setResult();
      this.subscribeToQuery();
      var startDisposeTimer = function() {
        var _a2;
        if (!_this.references) {
          _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a2 = options.autoDisposeTimeoutMs) !== null && _a2 !== void 0 ? _a2 : 3e4);
        }
      };
      this.promise.then(startDisposeTimer, startDisposeTimer);
    }
    Object.defineProperty(InternalQueryReference2.prototype, "disposed", {
      get: function() {
        return this.subscription.closed;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InternalQueryReference2.prototype, "watchQueryOptions", {
      get: function() {
        return this.observable.options;
      },
      enumerable: false,
      configurable: true
    });
    InternalQueryReference2.prototype.reinitialize = function() {
      var observable = this.observable;
      var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;
      var avoidNetworkRequests = originalFetchPolicy === "no-cache" || originalFetchPolicy === "standby";
      try {
        if (avoidNetworkRequests) {
          observable.silentSetOptions({ fetchPolicy: "standby" });
        } else {
          observable.resetLastResults();
          observable.silentSetOptions({ fetchPolicy: "cache-first" });
        }
        this.subscribeToQuery();
        if (avoidNetworkRequests) {
          return;
        }
        observable.resetDiff();
        this.setResult();
      } finally {
        observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });
      }
    };
    InternalQueryReference2.prototype.retain = function() {
      var _this = this;
      this.references++;
      clearTimeout(this.autoDisposeTimeoutId);
      var disposed = false;
      return function() {
        if (disposed) {
          return;
        }
        disposed = true;
        _this.references--;
        setTimeout(function() {
          if (!_this.references) {
            _this.dispose();
          }
        });
      };
    };
    InternalQueryReference2.prototype.softRetain = function() {
      var _this = this;
      this.softReferences++;
      var disposed = false;
      return function() {
        if (disposed) {
          return;
        }
        disposed = true;
        _this.softReferences--;
        setTimeout(function() {
          if (!_this.softReferences && !_this.references) {
            _this.dispose();
          }
        });
      };
    };
    InternalQueryReference2.prototype.didChangeOptions = function(watchQueryOptions) {
      var _this = this;
      return OBSERVED_CHANGED_OPTIONS.some(function(option) {
        return option in watchQueryOptions && !equal(_this.watchQueryOptions[option], watchQueryOptions[option]);
      });
    };
    InternalQueryReference2.prototype.applyOptions = function(watchQueryOptions) {
      var _a2 = this.watchQueryOptions, currentFetchPolicy = _a2.fetchPolicy, currentCanonizeResults = _a2.canonizeResults;
      if (currentFetchPolicy === "standby" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {
        this.initiateFetch(this.observable.reobserve(watchQueryOptions));
      } else {
        this.observable.silentSetOptions(watchQueryOptions);
        if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {
          this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());
          this.promise = createFulfilledPromise(this.result);
        }
      }
      return this.promise;
    };
    InternalQueryReference2.prototype.listen = function(listener) {
      var _this = this;
      this.listeners.add(listener);
      return function() {
        _this.listeners.delete(listener);
      };
    };
    InternalQueryReference2.prototype.refetch = function(variables) {
      return this.initiateFetch(this.observable.refetch(variables));
    };
    InternalQueryReference2.prototype.fetchMore = function(options) {
      return this.initiateFetch(this.observable.fetchMore(options));
    };
    InternalQueryReference2.prototype.dispose = function() {
      this.subscription.unsubscribe();
      this.onDispose();
    };
    InternalQueryReference2.prototype.onDispose = function() {
    };
    InternalQueryReference2.prototype.handleNext = function(result2) {
      var _a2;
      switch (this.promise.status) {
        case "pending": {
          if (result2.data === void 0) {
            result2.data = this.result.data;
          }
          this.result = result2;
          (_a2 = this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, result2);
          break;
        }
        default: {
          if (result2.data === this.result.data && result2.networkStatus === this.result.networkStatus) {
            return;
          }
          if (result2.data === void 0) {
            result2.data = this.result.data;
          }
          this.result = result2;
          this.promise = createFulfilledPromise(result2);
          this.deliver(this.promise);
          break;
        }
      }
    };
    InternalQueryReference2.prototype.handleError = function(error) {
      var _a2;
      this.subscription.unsubscribe();
      this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);
      switch (this.promise.status) {
        case "pending": {
          (_a2 = this.reject) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
          break;
        }
        default: {
          this.promise = createRejectedPromise(error);
          this.deliver(this.promise);
        }
      }
    };
    InternalQueryReference2.prototype.deliver = function(promise) {
      this.listeners.forEach(function(listener) {
        return listener(promise);
      });
    };
    InternalQueryReference2.prototype.initiateFetch = function(returnedPromise) {
      var _this = this;
      this.promise = this.createPendingPromise();
      this.promise.catch(function() {
      });
      returnedPromise.then(function() {
        setTimeout(function() {
          var _a2;
          if (_this.promise.status === "pending") {
            _this.result = _this.observable.getCurrentResult();
            (_a2 = _this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(_this, _this.result);
          }
        });
      }).catch(function() {
      });
      return returnedPromise;
    };
    InternalQueryReference2.prototype.subscribeToQuery = function() {
      var _this = this;
      this.subscription = this.observable.filter(function(result2) {
        return !equal(result2.data, {}) && !equal(result2, _this.result);
      }).subscribe(this.handleNext, this.handleError);
    };
    InternalQueryReference2.prototype.setResult = function() {
      var result2 = this.observable.getCurrentResult(false);
      if (equal(result2, this.result)) {
        return;
      }
      this.result = result2;
      this.promise = result2.data && (!result2.partial || this.watchQueryOptions.returnPartialData) ? createFulfilledPromise(result2) : this.createPendingPromise();
    };
    InternalQueryReference2.prototype.createPendingPromise = function() {
      var _this = this;
      return wrapPromiseWithState(new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      }));
    };
    return InternalQueryReference2;
  }()
);

// ../node_modules/@apollo/client/react/internal/cache/SuspenseCache.js
var SuspenseCache = (
  /** @class */
  function() {
    function SuspenseCache2(options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      this.queryRefs = new Trie(canUseWeakMap);
      this.options = options;
    }
    SuspenseCache2.prototype.getQueryRef = function(cacheKey, createObservable) {
      var ref = this.queryRefs.lookupArray(cacheKey);
      if (!ref.current) {
        ref.current = new InternalQueryReference(createObservable(), {
          autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,
          onDispose: function() {
            delete ref.current;
          }
        });
      }
      return ref.current;
    };
    SuspenseCache2.prototype.add = function(cacheKey, queryRef) {
      var ref = this.queryRefs.lookupArray(cacheKey);
      ref.current = queryRef;
    };
    return SuspenseCache2;
  }()
);

// ../node_modules/@apollo/client/react/internal/cache/getSuspenseCache.js
var suspenseCacheSymbol = Symbol.for("apollo.suspenseCache");

// ../node_modules/@apollo/client/react/hooks/constants.js
var import_dist427 = __toESM(require_dist(), 1);
var import_dist428 = __toESM(require_dist2(), 1);
var import_dist429 = __toESM(require_dist3(), 1);
var skipToken = Symbol.for("apollo.skipToken");

// ../node_modules/@apollo/client/react/hooks/useBackgroundQuery.js
var import_dist433 = __toESM(require_dist(), 1);
var import_dist434 = __toESM(require_dist2(), 1);
var import_dist435 = __toESM(require_dist3(), 1);
init_tslib_es6();
var React20 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/hooks/useLoadableQuery.js
var import_dist436 = __toESM(require_dist(), 1);
var import_dist437 = __toESM(require_dist2(), 1);
var import_dist438 = __toESM(require_dist3(), 1);
init_tslib_es6();
var React21 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/hooks/useQueryRefHandlers.js
var import_dist439 = __toESM(require_dist(), 1);
var import_dist440 = __toESM(require_dist2(), 1);
var import_dist441 = __toESM(require_dist3(), 1);
var React22 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/hooks/useReadQuery.js
var import_dist442 = __toESM(require_dist(), 1);
var import_dist443 = __toESM(require_dist2(), 1);
var import_dist444 = __toESM(require_dist3(), 1);
var React23 = __toESM(require_rehackt(), 1);

// ../node_modules/@apollo/client/react/query-preloader/createQueryPreloader.js
var import_dist448 = __toESM(require_dist(), 1);
var import_dist449 = __toESM(require_dist2(), 1);
var import_dist450 = __toESM(require_dist3(), 1);
init_tslib_es6();

// ../node_modules/@apollo/client/react/types/types.js
var import_dist451 = __toESM(require_dist(), 1);
var import_dist452 = __toESM(require_dist2(), 1);
var import_dist453 = __toESM(require_dist3(), 1);

// ../node_modules/@apollo/client/index.js
var import_dist457 = __toESM(require_dist());
var import_dist458 = __toESM(require_dist2());
var import_dist459 = __toESM(require_dist3());

// ../node_modules/@redwoodjs/web/dist/apollo/fragmentRegistry.js
var import_dist460 = __toESM(require_dist(), 1);
var import_dist461 = __toESM(require_dist2(), 1);
var import_dist462 = __toESM(require_dist3(), 1);
var import_cache9 = __toESM(require_cache(), 1);
var import_utilities50 = __toESM(require_utilities(), 1);
var getTypenameFromFragment = (fragment) => {
  const [definition] = (0, import_utilities50.getFragmentDefinitions)(fragment);
  return definition.typeCondition.name.value;
};
var useRegisteredFragmentHook = (fragment, id) => {
  const from2 = { __typename: getTypenameFromFragment(fragment), id };
  return useFragment({
    fragment,
    from: from2
  });
};
var fragmentRegistry = (0, import_cache9.createFragmentRegistry)();
var registerFragments = (fragments) => {
  return fragments.map(registerFragment);
};
var registerFragment = (fragment) => {
  fragmentRegistry.register(fragment);
  const typename = getTypenameFromFragment(fragment);
  const getCacheKey = (id) => {
    return { __typename: typename, id };
  };
  const useRegisteredFragment = (id) => {
    return useRegisteredFragmentHook(fragment, id);
  };
  return {
    fragment,
    typename,
    getCacheKey,
    useRegisteredFragment
  };
};

export {
  FetchConfigProvider,
  useFetchConfig,
  GraphQLHooksProvider,
  useQuery,
  useMutation,
  useSubscription,
  useBackgroundQuery,
  useReadQuery,
  Observable,
  ApolloLink,
  split,
  parseAndCheckHttpResponse,
  serializeFetchParameter,
  fallbackHttpConfig,
  defaultPrinter,
  selectHttpOptionsAndBodyInternal,
  createSignalIfSupported,
  selectURI,
  rewriteURIForGET,
  InMemoryCache,
  ApolloClient,
  ApolloProvider,
  require_globals,
  require_utilities,
  fragmentRegistry,
  registerFragments,
  registerFragment,
  require_core,
  require_core2,
  require_hooks
};
//# sourceMappingURL=chunk-Q6ZC44NB.js.map
