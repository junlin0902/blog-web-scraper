import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  ApolloClient,
  ApolloLink,
  ApolloProvider,
  FetchConfigProvider,
  GraphQLHooksProvider,
  InMemoryCache,
  Observable,
  createSignalIfSupported,
  defaultPrinter,
  fallbackHttpConfig,
  fragmentRegistry,
  parseAndCheckHttpResponse,
  registerFragment,
  registerFragments,
  require_core,
  require_core2,
  require_globals,
  require_hooks,
  require_utilities,
  rewriteURIForGET,
  selectHttpOptionsAndBodyInternal,
  selectURI,
  serializeFetchParameter,
  split,
  useFetchConfig
} from "./chunk-Q6ZC44NB.js";
import {
  useNoAuth
} from "./chunk-RINCEELR.js";
import {
  Kind,
  OperationTypeNode,
  init_graphql,
  init_tslib_es6,
  print,
  tslib_es6_exports
} from "./chunk-G6BOFV44.js";
import {
  require_react
} from "./chunk-ZILOSMTM.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-USKKUMLC.js";

// ../node_modules/@apollo/client/link/context/context.cjs
var require_context = __commonJS({
  "../node_modules/@apollo/client/link/context/context.cjs"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var core = require_core();
    var utilities = require_utilities();
    function setContext2(setter) {
      return new core.ApolloLink(function(operation, forward) {
        var request = tslib.__rest(operation, []);
        return new utilities.Observable(function(observer) {
          var handle;
          var closed = false;
          Promise.resolve(request).then(function(req) {
            return setter(req, operation.getContext());
          }).then(operation.setContext).then(function() {
            if (closed)
              return;
            handle = forward(operation).subscribe({
              next: observer.next.bind(observer),
              error: observer.error.bind(observer),
              complete: observer.complete.bind(observer)
            });
          }).catch(observer.error.bind(observer));
          return function() {
            closed = true;
            if (handle)
              handle.unsubscribe();
          };
        });
      });
    }
    exports.setContext = setContext2;
  }
});

// ../node_modules/@apollo/client/link/persisted-queries/persisted-queries.cjs
var require_persisted_queries = __commonJS({
  "../node_modules/@apollo/client/link/persisted-queries/persisted-queries.cjs"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var globals = require_globals();
    var utilities = require_utilities();
    var core = require_core();
    var VERSION = 1;
    function processErrors(graphQLErrors) {
      var byMessage = /* @__PURE__ */ Object.create(null), byCode = /* @__PURE__ */ Object.create(null);
      if (utilities.isNonEmptyArray(graphQLErrors)) {
        graphQLErrors.forEach(function(error) {
          var _a;
          byMessage[error.message] = error;
          if (typeof ((_a = error.extensions) === null || _a === void 0 ? void 0 : _a.code) == "string")
            byCode[error.extensions.code] = error;
        });
      }
      return {
        persistedQueryNotSupported: !!(byMessage.PersistedQueryNotSupported || byCode.PERSISTED_QUERY_NOT_SUPPORTED),
        persistedQueryNotFound: !!(byMessage.PersistedQueryNotFound || byCode.PERSISTED_QUERY_NOT_FOUND)
      };
    }
    var defaultOptions = {
      disable: function(_a) {
        var meta = _a.meta;
        return meta.persistedQueryNotSupported;
      },
      retry: function(_a) {
        var meta = _a.meta;
        return meta.persistedQueryNotSupported || meta.persistedQueryNotFound;
      },
      useGETForHashedQueries: false
    };
    function operationDefinesMutation(operation) {
      return operation.query.definitions.some(function(d) {
        return d.kind === "OperationDefinition" && d.operation === "mutation";
      });
    }
    var createPersistedQueryLink2 = function(options) {
      var hashesByQuery;
      function resetHashCache() {
        hashesByQuery = void 0;
      }
      globals.invariant(options && (typeof options.sha256 === "function" || typeof options.generateHash === "function"), 40);
      var _a = utilities.compact(defaultOptions, options), sha256 = _a.sha256, _b = _a.generateHash, generateHash = _b === void 0 ? function(query) {
        return Promise.resolve(sha256(utilities.print(query)));
      } : _b, disable = _a.disable, retry = _a.retry, useGETForHashedQueries = _a.useGETForHashedQueries;
      var supportsPersistedQueries = true;
      var getHashPromise = function(query) {
        return new Promise(function(resolve) {
          return resolve(generateHash(query));
        });
      };
      function getQueryHash(query) {
        if (!query || typeof query !== "object") {
          return getHashPromise(query);
        }
        if (!hashesByQuery) {
          hashesByQuery = new utilities.AutoCleanedWeakCache(utilities.cacheSizes["PersistedQueryLink.persistedQueryHashes"] || 2e3);
        }
        var hash = hashesByQuery.get(query);
        if (!hash)
          hashesByQuery.set(query, hash = getHashPromise(query));
        return hash;
      }
      return Object.assign(new core.ApolloLink(function(operation, forward) {
        globals.invariant(forward, 41);
        var query = operation.query;
        return new utilities.Observable(function(observer) {
          var subscription;
          var retried = false;
          var originalFetchOptions;
          var setFetchOptions = false;
          var maybeRetry = function(_a2, cb) {
            var response = _a2.response, networkError = _a2.networkError;
            if (!retried && (response && response.errors || networkError)) {
              retried = true;
              var graphQLErrors = [];
              var responseErrors = response && response.errors;
              if (utilities.isNonEmptyArray(responseErrors)) {
                graphQLErrors.push.apply(graphQLErrors, responseErrors);
              }
              var networkErrors = void 0;
              if (typeof (networkError === null || networkError === void 0 ? void 0 : networkError.result) !== "string") {
                networkErrors = networkError && networkError.result && networkError.result.errors;
              }
              if (utilities.isNonEmptyArray(networkErrors)) {
                graphQLErrors.push.apply(graphQLErrors, networkErrors);
              }
              var disablePayload = {
                response,
                networkError,
                operation,
                graphQLErrors: utilities.isNonEmptyArray(graphQLErrors) ? graphQLErrors : void 0,
                meta: processErrors(graphQLErrors)
              };
              supportsPersistedQueries = !disable(disablePayload);
              if (!supportsPersistedQueries) {
                resetHashCache();
              }
              if (retry(disablePayload)) {
                if (subscription)
                  subscription.unsubscribe();
                operation.setContext({
                  http: {
                    includeQuery: true,
                    includeExtensions: supportsPersistedQueries
                  },
                  fetchOptions: {
                    method: "POST"
                  }
                });
                if (setFetchOptions) {
                  operation.setContext({ fetchOptions: originalFetchOptions });
                }
                subscription = forward(operation).subscribe(handler);
                return;
              }
            }
            cb();
          };
          var handler = {
            next: function(response) {
              maybeRetry({ response }, function() {
                return observer.next(response);
              });
            },
            error: function(networkError) {
              maybeRetry({ networkError }, function() {
                return observer.error(networkError);
              });
            },
            complete: observer.complete.bind(observer)
          };
          operation.setContext({
            http: {
              includeQuery: !supportsPersistedQueries,
              includeExtensions: supportsPersistedQueries
            }
          });
          if (useGETForHashedQueries && supportsPersistedQueries && !operationDefinesMutation(operation)) {
            operation.setContext(function(_a2) {
              var _b2 = _a2.fetchOptions, fetchOptions = _b2 === void 0 ? {} : _b2;
              originalFetchOptions = fetchOptions;
              return {
                fetchOptions: tslib.__assign(tslib.__assign({}, fetchOptions), { method: "GET" })
              };
            });
            setFetchOptions = true;
          }
          if (supportsPersistedQueries) {
            getQueryHash(query).then(function(sha256Hash) {
              operation.extensions.persistedQuery = {
                version: VERSION,
                sha256Hash
              };
              subscription = forward(operation).subscribe(handler);
            }).catch(observer.error.bind(observer));
          } else {
            subscription = forward(operation).subscribe(handler);
          }
          return function() {
            if (subscription)
              subscription.unsubscribe();
          };
        });
      }), {
        resetHashCache
      }, globalThis.__DEV__ !== false ? {
        getMemoryInternals: function() {
          var _a2;
          return {
            PersistedQueryLink: {
              persistedQueryHashes: (_a2 = hashesByQuery === null || hashesByQuery === void 0 ? void 0 : hashesByQuery.size) !== null && _a2 !== void 0 ? _a2 : 0
            }
          };
        }
      } : {});
    };
    exports.VERSION = VERSION;
    exports.createPersistedQueryLink = createPersistedQueryLink2;
  }
});

// ../node_modules/graphql/language/characterClasses.js
var require_characterClasses = __commonJS({
  "../node_modules/graphql/language/characterClasses.js"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isDigit = isDigit;
    exports.isLetter = isLetter;
    exports.isNameContinue = isNameContinue;
    exports.isNameStart = isNameStart;
    exports.isWhiteSpace = isWhiteSpace;
    function isWhiteSpace(code) {
      return code === 9 || code === 32;
    }
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isLetter(code) {
      return code >= 97 && code <= 122 || // A-Z
      code >= 65 && code <= 90;
    }
    function isNameStart(code) {
      return isLetter(code) || code === 95;
    }
    function isNameContinue(code) {
      return isLetter(code) || isDigit(code) || code === 95;
    }
  }
});

// ../node_modules/graphql/language/blockString.js
var require_blockString = __commonJS({
  "../node_modules/graphql/language/blockString.js"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.dedentBlockStringLines = dedentBlockStringLines;
    exports.isPrintableAsBlockString = isPrintableAsBlockString;
    exports.printBlockString = printBlockString;
    var _characterClasses = require_characterClasses();
    function dedentBlockStringLines(lines) {
      var _firstNonEmptyLine2;
      let commonIndent = Number.MAX_SAFE_INTEGER;
      let firstNonEmptyLine = null;
      let lastNonEmptyLine = -1;
      for (let i = 0; i < lines.length; ++i) {
        var _firstNonEmptyLine;
        const line = lines[i];
        const indent = leadingWhitespace(line);
        if (indent === line.length) {
          continue;
        }
        firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
        lastNonEmptyLine = i;
        if (i !== 0 && indent < commonIndent) {
          commonIndent = indent;
        }
      }
      return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
        (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
        lastNonEmptyLine + 1
      );
    }
    function leadingWhitespace(str) {
      let i = 0;
      while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
        ++i;
      }
      return i;
    }
    function isPrintableAsBlockString(value) {
      if (value === "") {
        return true;
      }
      let isEmptyLine = true;
      let hasIndent = false;
      let hasCommonIndent = true;
      let seenNonEmptyLine = false;
      for (let i = 0; i < value.length; ++i) {
        switch (value.codePointAt(i)) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 11:
          case 12:
          case 14:
          case 15:
            return false;
          case 13:
            return false;
          case 10:
            if (isEmptyLine && !seenNonEmptyLine) {
              return false;
            }
            seenNonEmptyLine = true;
            isEmptyLine = true;
            hasIndent = false;
            break;
          case 9:
          case 32:
            hasIndent || (hasIndent = isEmptyLine);
            break;
          default:
            hasCommonIndent && (hasCommonIndent = hasIndent);
            isEmptyLine = false;
        }
      }
      if (isEmptyLine) {
        return false;
      }
      if (hasCommonIndent && seenNonEmptyLine) {
        return false;
      }
      return true;
    }
    function printBlockString(value, options) {
      const escapedValue = value.replace(/"""/g, '\\"""');
      const lines = escapedValue.split(/\r\n|[\n\r]/g);
      const isSingleLine = lines.length === 1;
      const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
        (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
      );
      const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
      const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
      const hasTrailingSlash = value.endsWith("\\");
      const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
      const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
      (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
      let result = "";
      const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
      if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
        result += "\n";
      }
      result += escapedValue;
      if (printAsMultipleLines || forceTrailingNewline) {
        result += "\n";
      }
      return '"""' + result + '"""';
    }
  }
});

// ../node_modules/graphql/language/printString.js
var require_printString = __commonJS({
  "../node_modules/graphql/language/printString.js"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printString = printString;
    function printString(str) {
      return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
    }
    var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function escapedReplacer(str) {
      return escapeSequences[str.charCodeAt(0)];
    }
    var escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 2F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 3F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 4F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      // 5F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 6F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// ../node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS({
  "../node_modules/graphql/jsutils/devAssert.js"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.devAssert = devAssert;
    function devAssert(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message);
      }
    }
  }
});

// ../node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS({
  "../node_modules/graphql/jsutils/inspect.js"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inspect = inspect;
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH = 2;
    function inspect(value) {
      return formatValue(value, []);
    }
    function formatValue(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatObjectValue(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    function isJSONable(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      const properties = entries.map(
        ([key, value]) => key + ": " + formatValue(value, seenValues)
      );
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      const len = Math.min(MAX_ARRAY_LENGTH, array.length);
      const remaining = array.length - len;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// ../node_modules/graphql/language/ast.js
var require_ast = __commonJS({
  "../node_modules/graphql/language/ast.js"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = void 0;
    exports.isNode = isNode;
    var Location = class {
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The Token at which this Node begins.
       */
      /**
       * The Token at which this Node ends.
       */
      /**
       * The Source document the AST represents.
       */
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    exports.Location = Location;
    var Token = class {
      /**
       * The kind of Token.
       */
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The 1-indexed line number on which this Token appears.
       */
      /**
       * The 1-indexed column number at which this Token begins.
       */
      /**
       * For non-punctuation tokens, represents the interpreted value of the token.
       *
       * Note: is undefined for punctuation tokens, but typed as string for
       * convenience in the parser.
       */
      /**
       * Tokens exist as nodes in a double-linked-list amongst all tokens
       * including ignored tokens. <SOF> is always the first node and <EOF>
       * the last.
       */
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    exports.Token = Token;
    var QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        // Note: fragment variable definitions are deprecated and will removed in v17.0.0
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    exports.QueryDocumentKeys = QueryDocumentKeys;
    var kindValues = new Set(Object.keys(QueryDocumentKeys));
    function isNode(maybeNode) {
      const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
      return typeof maybeKind === "string" && kindValues.has(maybeKind);
    }
    var OperationTypeNode2;
    exports.OperationTypeNode = OperationTypeNode2;
    (function(OperationTypeNode3) {
      OperationTypeNode3["QUERY"] = "query";
      OperationTypeNode3["MUTATION"] = "mutation";
      OperationTypeNode3["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode2 || (exports.OperationTypeNode = OperationTypeNode2 = {}));
  }
});

// ../node_modules/graphql/language/kinds.js
var require_kinds = __commonJS({
  "../node_modules/graphql/language/kinds.js"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Kind = void 0;
    var Kind2;
    exports.Kind = Kind2;
    (function(Kind3) {
      Kind3["NAME"] = "Name";
      Kind3["DOCUMENT"] = "Document";
      Kind3["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind3["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind3["SELECTION_SET"] = "SelectionSet";
      Kind3["FIELD"] = "Field";
      Kind3["ARGUMENT"] = "Argument";
      Kind3["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind3["INLINE_FRAGMENT"] = "InlineFragment";
      Kind3["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind3["VARIABLE"] = "Variable";
      Kind3["INT"] = "IntValue";
      Kind3["FLOAT"] = "FloatValue";
      Kind3["STRING"] = "StringValue";
      Kind3["BOOLEAN"] = "BooleanValue";
      Kind3["NULL"] = "NullValue";
      Kind3["ENUM"] = "EnumValue";
      Kind3["LIST"] = "ListValue";
      Kind3["OBJECT"] = "ObjectValue";
      Kind3["OBJECT_FIELD"] = "ObjectField";
      Kind3["DIRECTIVE"] = "Directive";
      Kind3["NAMED_TYPE"] = "NamedType";
      Kind3["LIST_TYPE"] = "ListType";
      Kind3["NON_NULL_TYPE"] = "NonNullType";
      Kind3["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind3["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind3["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind3["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind3["FIELD_DEFINITION"] = "FieldDefinition";
      Kind3["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind3["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind3["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind3["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind3["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind3["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind3["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind3["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind3["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind3["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind3["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind3["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind3["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind3["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind2 || (exports.Kind = Kind2 = {}));
  }
});

// ../node_modules/graphql/language/visitor.js
var require_visitor = __commonJS({
  "../node_modules/graphql/language/visitor.js"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BREAK = void 0;
    exports.getEnterLeaveForKind = getEnterLeaveForKind;
    exports.getVisitFn = getVisitFn;
    exports.visit = visit;
    exports.visitInParallel = visitInParallel;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _ast = require_ast();
    var _kinds = require_kinds();
    var BREAK = Object.freeze({});
    exports.BREAK = BREAK;
    function visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
      const enterLeaveMap = /* @__PURE__ */ new Map();
      for (const kind of Object.values(_kinds.Kind)) {
        enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
      }
      let stack = void 0;
      let inArray = Array.isArray(root);
      let keys = [root];
      let index = -1;
      let edits = [];
      let node = root;
      let key = void 0;
      let parent = void 0;
      const path = [];
      const ancestors = [];
      do {
        index++;
        const isLeaving = index === keys.length;
        const isEdited = isLeaving && edits.length !== 0;
        if (isLeaving) {
          key = ancestors.length === 0 ? void 0 : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();
          if (isEdited) {
            if (inArray) {
              node = node.slice();
              let editOffset = 0;
              for (const [editKey, editValue] of edits) {
                const arrayKey = editKey - editOffset;
                if (editValue === null) {
                  node.splice(arrayKey, 1);
                  editOffset++;
                } else {
                  node[arrayKey] = editValue;
                }
              }
            } else {
              node = Object.defineProperties(
                {},
                Object.getOwnPropertyDescriptors(node)
              );
              for (const [editKey, editValue] of edits) {
                node[editKey] = editValue;
              }
            }
          }
          index = stack.index;
          keys = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else if (parent) {
          key = inArray ? index : keys[index];
          node = parent[key];
          if (node === null || node === void 0) {
            continue;
          }
          path.push(key);
        }
        let result;
        if (!Array.isArray(node)) {
          var _enterLeaveMap$get, _enterLeaveMap$get2;
          (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
            false,
            `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
          );
          const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
          result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
          if (result === BREAK) {
            break;
          }
          if (result === false) {
            if (!isLeaving) {
              path.pop();
              continue;
            }
          } else if (result !== void 0) {
            edits.push([key, result]);
            if (!isLeaving) {
              if ((0, _ast.isNode)(result)) {
                node = result;
              } else {
                path.pop();
                continue;
              }
            }
          }
        }
        if (result === void 0 && isEdited) {
          edits.push([key, node]);
        }
        if (isLeaving) {
          path.pop();
        } else {
          var _node$kind;
          stack = {
            inArray,
            index,
            keys,
            edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
          index = -1;
          edits = [];
          if (parent) {
            ancestors.push(parent);
          }
          parent = node;
        }
      } while (stack !== void 0);
      if (edits.length !== 0) {
        return edits[edits.length - 1][1];
      }
      return root;
    }
    function visitInParallel(visitors) {
      const skipping = new Array(visitors.length).fill(null);
      const mergedVisitor = /* @__PURE__ */ Object.create(null);
      for (const kind of Object.values(_kinds.Kind)) {
        let hasVisitor = false;
        const enterList = new Array(visitors.length).fill(void 0);
        const leaveList = new Array(visitors.length).fill(void 0);
        for (let i = 0; i < visitors.length; ++i) {
          const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
          hasVisitor || (hasVisitor = enter != null || leave != null);
          enterList[i] = enter;
          leaveList[i] = leave;
        }
        if (!hasVisitor) {
          continue;
        }
        const mergedEnterLeave = {
          enter(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _enterList$i;
                const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                if (result === false) {
                  skipping[i] = node;
                } else if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0) {
                  return result;
                }
              }
            }
          },
          leave(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _leaveList$i;
                const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0 && result !== false) {
                  return result;
                }
              } else if (skipping[i] === node) {
                skipping[i] = null;
              }
            }
          }
        };
        mergedVisitor[kind] = mergedEnterLeave;
      }
      return mergedVisitor;
    }
    function getEnterLeaveForKind(visitor, kind) {
      const kindVisitor = visitor[kind];
      if (typeof kindVisitor === "object") {
        return kindVisitor;
      } else if (typeof kindVisitor === "function") {
        return {
          enter: kindVisitor,
          leave: void 0
        };
      }
      return {
        enter: visitor.enter,
        leave: visitor.leave
      };
    }
    function getVisitFn(visitor, kind, isLeaving) {
      const { enter, leave } = getEnterLeaveForKind(visitor, kind);
      return isLeaving ? leave : enter;
    }
  }
});

// ../node_modules/graphql/language/printer.js
var require_printer = __commonJS({
  "../node_modules/graphql/language/printer.js"(exports) {
    "use strict";
    var import_dist52 = __toESM(require_dist());
    var import_dist53 = __toESM(require_dist2());
    var import_dist54 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.print = print4;
    var _blockString = require_blockString();
    var _printString = require_printString();
    var _visitor = require_visitor();
    function print4(ast) {
      return (0, _visitor.visit)(ast, printDocASTReducer);
    }
    var MAX_LINE_LENGTH = 80;
    var printDocASTReducer = {
      Name: {
        leave: (node) => node.value
      },
      Variable: {
        leave: (node) => "$" + node.name
      },
      // Document
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join(
            [
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
      },
      SelectionSet: {
        leave: ({ selections }) => block(selections)
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(
          [
            "...",
            wrap("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ],
          " "
        )
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: {
        leave: ({ value }) => value
      },
      FloatValue: {
        leave: ({ value }) => value
      },
      StringValue: {
        leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
      },
      BooleanValue: {
        leave: ({ value }) => value ? "true" : "false"
      },
      NullValue: {
        leave: () => "null"
      },
      EnumValue: {
        leave: ({ value }) => value
      },
      ListValue: {
        leave: ({ values }) => "[" + join(values, ", ") + "]"
      },
      ObjectValue: {
        leave: ({ fields }) => "{" + join(fields, ", ") + "}"
      },
      ObjectField: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
      },
      // Type
      NamedType: {
        leave: ({ name }) => name
      },
      ListType: {
        leave: ({ type }) => "[" + type + "]"
      },
      NonNullType: {
        leave: ({ type }) => type + "!"
      },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      FieldDefinition: {
        leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
          [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
          " "
        )
      },
      InterfaceTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeDefinition: {
        leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
          ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
          " "
        )
      },
      EnumTypeDefinition: {
        leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(
          ["extend schema", join(directives, " "), block(operationTypes)],
          " "
        )
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(
          [
            "extend union",
            name,
            join(directives, " "),
            wrap("= ", join(types, " | "))
          ],
          " "
        )
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
    function join(maybeArray, separator = "") {
      var _maybeArray$filter$jo;
      return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
    }
    function block(array) {
      return wrap("{\n", indent(join(array, "\n")), "\n}");
    }
    function wrap(start, maybeString, end = "") {
      return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
    }
    function indent(str) {
      return wrap("  ", str.replace(/\n/g, "\n  "));
    }
    function hasMultilineItems(maybeArray) {
      var _maybeArray$some;
      return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
    }
  }
});

// ../node_modules/@redwoodjs/web/dist/apollo/index.js
var import_dist49 = __toESM(require_dist());
var import_dist50 = __toESM(require_dist2());
var import_dist51 = __toESM(require_dist3());
var import_react = __toESM(require_react());
var import_core2 = __toESM(require_core2());
var import_context = __toESM(require_context());
var import_persisted_queries = __toESM(require_persisted_queries());
var import_hooks2 = __toESM(require_hooks());
var import_utilities2 = __toESM(require_utilities());
var import_printer = __toESM(require_printer());

// ../node_modules/@redwoodjs/web/dist/apollo/typeOverride.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);

// ../node_modules/@redwoodjs/web/dist/bundled/apollo-upload-client.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// ../node_modules/apollo-upload-client/createUploadLink.mjs
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);

// ../node_modules/extract-files/extractFiles.mjs
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);

// ../node_modules/is-plain-obj/index.js
var import_dist4 = __toESM(require_dist());
var import_dist5 = __toESM(require_dist2());
var import_dist6 = __toESM(require_dist3());
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// ../node_modules/extract-files/extractFiles.mjs
function extractFiles(value, isExtractable, path = "") {
  if (!arguments.length) throw new TypeError("Argument 1 `value` is required.");
  if (typeof isExtractable !== "function")
    throw new TypeError("Argument 2 `isExtractable` must be a function.");
  if (typeof path !== "string")
    throw new TypeError("Argument 3 `path` must be a string.");
  const clones = /* @__PURE__ */ new Map();
  const files = /* @__PURE__ */ new Map();
  function recurse(value2, path2, recursed) {
    if (isExtractable(value2)) {
      const filePaths = files.get(value2);
      filePaths ? filePaths.push(path2) : files.set(value2, [path2]);
      return null;
    }
    const valueIsList = Array.isArray(value2) || typeof FileList !== "undefined" && value2 instanceof FileList;
    const valueIsPlainObject = isPlainObject(value2);
    if (valueIsList || valueIsPlainObject) {
      let clone = clones.get(value2);
      const uncloned = !clone;
      if (uncloned) {
        clone = valueIsList ? [] : (
          // Replicate if the plain object is an `Object` instance.
          value2 instanceof /** @type {any} */
          Object ? {} : /* @__PURE__ */ Object.create(null)
        );
        clones.set(
          value2,
          /** @type {Clone} */
          clone
        );
      }
      if (!recursed.has(value2)) {
        const pathPrefix = path2 ? `${path2}.` : "";
        const recursedDeeper = new Set(recursed).add(value2);
        if (valueIsList) {
          let index = 0;
          for (const item of value2) {
            const itemClone = recurse(
              item,
              pathPrefix + index++,
              recursedDeeper
            );
            if (uncloned) clone.push(itemClone);
          }
        } else
          for (const key in value2) {
            const propertyClone = recurse(
              value2[key],
              pathPrefix + key,
              recursedDeeper
            );
            if (uncloned)
              clone[key] = propertyClone;
          }
      }
      return clone;
    }
    return value2;
  }
  return {
    clone: recurse(value, path, /* @__PURE__ */ new Set()),
    files
  };
}

// ../node_modules/apollo-upload-client/formDataAppendFile.mjs
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
function formDataAppendFile(formData, fieldName, file) {
  "name" in file ? formData.append(fieldName, file, file.name) : formData.append(fieldName, file);
}

// ../node_modules/apollo-upload-client/isExtractableFile.mjs
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);

// ../node_modules/extract-files/isExtractableFile.mjs
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
function isExtractableFile(value) {
  return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob;
}

// ../node_modules/apollo-upload-client/createUploadLink.mjs
function createUploadLink({
  uri: fetchUri = "/graphql",
  useGETForQueries,
  isExtractableFile: customIsExtractableFile = isExtractableFile,
  FormData: CustomFormData,
  formDataAppendFile: customFormDataAppendFile = formDataAppendFile,
  print: print4 = defaultPrinter,
  fetch: customFetch,
  fetchOptions,
  credentials,
  headers,
  includeExtensions
} = {}) {
  const linkConfig = {
    http: { includeExtensions },
    options: fetchOptions,
    credentials,
    headers
  };
  return new ApolloLink((operation) => {
    const context = (
      /**
       * @type {import("@apollo/client/core/types.js").DefaultContext & {
       *   clientAwareness?: {
       *     name?: string,
       *     version?: string,
       *   },
       * }}
       */
      operation.getContext()
    );
    const {
      // Apollo Studio client awareness `name` and `version` can be configured
      // via `ApolloClient` constructor options:
      // https://www.apollographql.com/docs/graphos/metrics/client-awareness/#setup
      clientAwareness: { name, version } = {},
      headers: headers2
    } = context;
    const contextConfig = {
      http: context.http,
      options: context.fetchOptions,
      credentials: context.credentials,
      headers: {
        // Client awareness headers can be overridden by context `headers`.
        ...name && { "apollographql-client-name": name },
        ...version && { "apollographql-client-version": version },
        ...headers2
      }
    };
    const { options, body } = selectHttpOptionsAndBodyInternal(
      operation,
      print4,
      fallbackHttpConfig,
      linkConfig,
      contextConfig
    );
    const { clone, files } = extractFiles(body, customIsExtractableFile, "");
    let uri = selectURI(operation, fetchUri);
    if (files.size) {
      if (options.headers)
        delete options.headers["content-type"];
      const RuntimeFormData = CustomFormData || FormData;
      const form = new RuntimeFormData();
      form.append("operations", serializeFetchParameter(clone, "Payload"));
      const map = {};
      let i = 0;
      files.forEach((paths) => {
        map[++i] = paths;
      });
      form.append("map", JSON.stringify(map));
      i = 0;
      files.forEach((_paths, file) => {
        customFormDataAppendFile(form, String(++i), file);
      });
      options.body = form;
    } else {
      if (useGETForQueries && // If the operation contains some mutations GET shouldn’t be used.
      !operation.query.definitions.some(
        (definition) => definition.kind === "OperationDefinition" && definition.operation === "mutation"
      ))
        options.method = "GET";
      if (options.method === "GET") {
        const { newURI, parseError } = rewriteURIForGET(uri, body);
        if (parseError)
          return new Observable((observer) => {
            observer.error(parseError);
          });
        uri = newURI;
      } else options.body = serializeFetchParameter(clone, "Payload");
    }
    const { controller } = createSignalIfSupported();
    if (typeof controller !== "boolean") {
      if (options.signal)
        options.signal.aborted ? (
          // Signal already aborted, so immediately abort.
          controller.abort()
        ) : (
          // Signal not already aborted, so setup a listener to abort when it
          // does.
          options.signal.addEventListener(
            "abort",
            () => {
              controller.abort();
            },
            {
              // Prevent a memory leak if the user configured abort controller
              // is long lasting, or controls multiple things.
              once: true
            }
          )
        );
      options.signal = controller.signal;
    }
    const runtimeFetch = customFetch || fetch;
    return new Observable((observer) => {
      let cleaningUp;
      runtimeFetch(uri, options).then((response) => {
        operation.setContext({ response });
        return response;
      }).then(parseAndCheckHttpResponse(operation)).then((result) => {
        observer.next(result);
        observer.complete();
      }).catch((error) => {
        if (!cleaningUp) {
          if (error.result && error.result.errors && error.result.data)
            observer.next(error.result);
          observer.error(error);
        }
      });
      return () => {
        cleaningUp = true;
        if (typeof controller !== "boolean") controller.abort();
      };
    });
  });
}

// ../node_modules/@redwoodjs/web/dist/apollo/sseLink.js
var sseLink_exports = {};
__export(sseLink_exports, {
  SSELink: () => SSELink,
  isLiveQuery: () => isLiveQuery,
  isSubscription: () => isSubscription
});
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
var import_core = __toESM(require_core(), 1);
var import_utilities = __toESM(require_utilities(), 1);
init_graphql();

// ../node_modules/graphql-sse/lib/index.mjs
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);

// ../node_modules/graphql-sse/lib/common.mjs
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);

// ../node_modules/graphql-sse/lib/utils.mjs
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);
function isObject(val) {
  return typeof val === "object" && val !== null;
}

// ../node_modules/graphql-sse/lib/common.mjs
var TOKEN_HEADER_KEY = "x-graphql-event-stream-token";
function validateStreamEvent(e) {
  e = e;
  if (e !== "next" && e !== "complete")
    throw new Error(`Invalid stream event "${e}"`);
  return e;
}
function parseStreamData(e, data) {
  if (data) {
    try {
      data = JSON.parse(data);
    } catch {
      throw new Error("Invalid stream data");
    }
  }
  if (e === "next" && !data)
    throw new Error('Stream data must be an object for "next" events');
  return data || null;
}

// ../node_modules/graphql-sse/lib/handler.mjs
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
init_graphql();

// ../node_modules/graphql-sse/lib/client.mjs
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);

// ../node_modules/graphql-sse/lib/parser.mjs
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);
var ControlChars;
(function(ControlChars2) {
  ControlChars2[ControlChars2["NewLine"] = 10] = "NewLine";
  ControlChars2[ControlChars2["CchunkiageReturn"] = 13] = "CchunkiageReturn";
  ControlChars2[ControlChars2["Space"] = 32] = "Space";
  ControlChars2[ControlChars2["Colon"] = 58] = "Colon";
})(ControlChars || (ControlChars = {}));
function createParser() {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  let message = { event: "", data: "" };
  let pending = [];
  const decoder = new TextDecoder();
  return function parse2(chunk) {
    if (buffer === void 0) {
      buffer = chunk;
      position = 0;
      fieldLength = -1;
    } else {
      const concat = new Uint8Array(buffer.length + chunk.length);
      concat.set(buffer);
      concat.set(chunk, buffer.length);
      buffer = concat;
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === ControlChars.NewLine) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case ControlChars.Colon:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case ControlChars.CchunkiageReturn:
            discardTrailingNewline = true;
          case ControlChars.NewLine:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      } else if (lineStart === lineEnd) {
        if (message.event || message.data) {
          if (!message.event)
            throw new Error("Missing message event");
          const event = validateStreamEvent(message.event);
          const data = parseStreamData(event, message.data);
          pending.push({
            event,
            data
          });
          message = { event: "", data: "" };
        }
      } else if (fieldLength > 0) {
        const line = buffer.subarray(lineStart, lineEnd);
        const field = decoder.decode(line.subarray(0, fieldLength));
        const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);
        const value = decoder.decode(line.subarray(valueOffset));
        switch (field) {
          case "event":
            message.event = value;
            break;
          case "data":
            message.data = message.data ? message.data + "\n" + value : value;
            break;
        }
      }
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
      const messages = [...pending];
      pending = [];
      return messages;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}

// ../node_modules/graphql-sse/lib/client.mjs
function createClient(options) {
  const {
    singleConnection = false,
    lazy = true,
    lazyCloseTimeout = 0,
    onNonLazyError = console.error,
    /**
     * Generates a v4 UUID to be used as the ID using `Math`
     * as the random number generator. Supply your own generator
     * in case you need more uniqueness.
     *
     * Reference: https://gist.github.com/jed/982883
     */
    generateID = function generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    },
    retryAttempts = 5,
    retry = async function randomisedExponentialBackoff(retries2) {
      let retryDelay = 1e3;
      for (let i = 0; i < retries2; i++) {
        retryDelay *= 2;
      }
      await new Promise((resolve) => setTimeout(resolve, retryDelay + // add random timeout from 300ms to 3s
      Math.floor(Math.random() * (3e3 - 300) + 300)));
    },
    credentials = "same-origin",
    referrer,
    referrerPolicy,
    onMessage,
    on: clientOn
  } = options;
  const fetchFn = options.fetchFn || fetch;
  const AbortControllerImpl = options.abortControllerImpl || AbortController;
  const client = /* @__PURE__ */ (() => {
    let disposed = false;
    const listeners = [];
    return {
      get disposed() {
        return disposed;
      },
      onDispose(cb) {
        if (disposed) {
          setTimeout(() => cb(), 0);
          return () => {
          };
        }
        listeners.push(cb);
        return () => {
          listeners.splice(listeners.indexOf(cb), 1);
        };
      },
      dispose() {
        if (disposed)
          return;
        disposed = true;
        for (const listener of [...listeners]) {
          listener();
        }
      }
    };
  })();
  let connCtrl, conn, locks = 0, retryingErr = null, retries = 0;
  async function getOrConnect() {
    try {
      if (client.disposed)
        throw new Error("Client has been disposed");
      return await (conn !== null && conn !== void 0 ? conn : conn = (async () => {
        var _a, _b, _c;
        if (retryingErr) {
          await retry(retries);
          if (connCtrl.signal.aborted)
            throw new Error("Connection aborted by the client");
          retries++;
        }
        (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connecting) === null || _a === void 0 ? void 0 : _a.call(clientOn, !!retryingErr);
        connCtrl = new AbortControllerImpl();
        const unlistenDispose = client.onDispose(() => connCtrl.abort());
        connCtrl.signal.addEventListener("abort", () => {
          unlistenDispose();
          conn = void 0;
        });
        const url = typeof options.url === "function" ? await options.url() : options.url;
        if (connCtrl.signal.aborted)
          throw new Error("Connection aborted by the client");
        const headers = typeof options.headers === "function" ? await options.headers() : (_b = options.headers) !== null && _b !== void 0 ? _b : {};
        if (connCtrl.signal.aborted)
          throw new Error("Connection aborted by the client");
        let res;
        try {
          res = await fetchFn(url, {
            signal: connCtrl.signal,
            method: "PUT",
            credentials,
            referrer,
            referrerPolicy,
            headers
          });
        } catch (err) {
          throw new NetworkError(err);
        }
        if (res.status !== 201)
          throw new NetworkError(res);
        const token = await res.text();
        headers[TOKEN_HEADER_KEY] = token;
        const connected = await connect({
          signal: connCtrl.signal,
          headers,
          credentials,
          referrer,
          referrerPolicy,
          url,
          fetchFn,
          onMessage: (msg) => {
            var _a2;
            (_a2 = clientOn === null || clientOn === void 0 ? void 0 : clientOn.message) === null || _a2 === void 0 ? void 0 : _a2.call(clientOn, msg);
            onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg);
          }
        });
        (_c = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connected) === null || _c === void 0 ? void 0 : _c.call(clientOn, !!retryingErr);
        connected.waitForThrow().catch(() => conn = void 0);
        return connected;
      })());
    } catch (err) {
      conn = void 0;
      throw err;
    }
  }
  if (singleConnection && !lazy) {
    (async () => {
      locks++;
      for (; ; ) {
        try {
          const { waitForThrow } = await getOrConnect();
          await waitForThrow();
        } catch (err) {
          if (client.disposed)
            return;
          if (!(err instanceof NetworkError))
            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);
          conn = void 0;
          if (!retryAttempts || retries >= retryAttempts)
            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);
          retryingErr = err;
        }
      }
    })();
  }
  function subscribe2(request, sink, on) {
    if (!singleConnection) {
      const control2 = new AbortControllerImpl();
      const unlisten2 = client.onDispose(() => {
        unlisten2();
        control2.abort();
      });
      (async () => {
        var _a, _b, _c, _d, _e;
        let retryingErr2 = null, retries2 = 0;
        for (; ; ) {
          try {
            if (retryingErr2) {
              await retry(retries2);
              if (control2.signal.aborted)
                throw new Error("Connection aborted by the client");
              retries2++;
            }
            (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connecting) === null || _a === void 0 ? void 0 : _a.call(clientOn, !!retryingErr2);
            (_b = on === null || on === void 0 ? void 0 : on.connecting) === null || _b === void 0 ? void 0 : _b.call(on, !!retryingErr2);
            const url = typeof options.url === "function" ? await options.url() : options.url;
            if (control2.signal.aborted)
              throw new Error("Connection aborted by the client");
            const headers = typeof options.headers === "function" ? await options.headers() : (_c = options.headers) !== null && _c !== void 0 ? _c : {};
            if (control2.signal.aborted)
              throw new Error("Connection aborted by the client");
            const { getResults } = await connect({
              signal: control2.signal,
              headers: {
                ...headers,
                "content-type": "application/json; charset=utf-8"
              },
              credentials,
              referrer,
              referrerPolicy,
              url,
              body: JSON.stringify(request),
              fetchFn,
              onMessage: (msg) => {
                var _a2, _b2;
                (_a2 = clientOn === null || clientOn === void 0 ? void 0 : clientOn.message) === null || _a2 === void 0 ? void 0 : _a2.call(clientOn, msg);
                (_b2 = on === null || on === void 0 ? void 0 : on.message) === null || _b2 === void 0 ? void 0 : _b2.call(on, msg);
                onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg);
              }
            });
            (_d = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connected) === null || _d === void 0 ? void 0 : _d.call(clientOn, !!retryingErr2);
            (_e = on === null || on === void 0 ? void 0 : on.connected) === null || _e === void 0 ? void 0 : _e.call(on, !!retryingErr2);
            for await (const result of getResults()) {
              retryingErr2 = null;
              retries2 = 0;
              sink.next(result);
            }
            return control2.abort();
          } catch (err) {
            if (control2.signal.aborted)
              return;
            if (!(err instanceof NetworkError))
              throw err;
            if (!retryAttempts || retries2 >= retryAttempts)
              throw err;
            retryingErr2 = err;
          }
        }
      })().then(() => sink.complete()).catch((err) => sink.error(err));
      return () => control2.abort();
    }
    locks++;
    const control = new AbortControllerImpl();
    const unlisten = client.onDispose(() => {
      unlisten();
      control.abort();
    });
    (async () => {
      const operationId = generateID();
      request = {
        ...request,
        extensions: { ...request.extensions, operationId }
      };
      let complete = null;
      for (; ; ) {
        complete = null;
        try {
          const { url, headers, getResults } = await getOrConnect();
          let res;
          try {
            res = await fetchFn(url, {
              signal: control.signal,
              method: "POST",
              credentials,
              referrer,
              referrerPolicy,
              headers: {
                ...headers,
                "content-type": "application/json; charset=utf-8"
              },
              body: JSON.stringify(request)
            });
          } catch (err) {
            throw new NetworkError(err);
          }
          if (res.status !== 202)
            throw new NetworkError(res);
          complete = async () => {
            let res2;
            try {
              const control2 = new AbortControllerImpl();
              const unlisten2 = client.onDispose(() => {
                unlisten2();
                control2.abort();
              });
              res2 = await fetchFn(url + "?operationId=" + operationId, {
                signal: control2.signal,
                method: "DELETE",
                credentials,
                referrer,
                referrerPolicy,
                headers
              });
            } catch (err) {
              throw new NetworkError(err);
            }
            if (res2.status !== 200)
              throw new NetworkError(res2);
          };
          for await (const result of getResults({
            signal: control.signal,
            operationId
          })) {
            retryingErr = null;
            retries = 0;
            sink.next(result);
          }
          complete = null;
          return control.abort();
        } catch (err) {
          if (control.signal.aborted)
            return await (complete === null || complete === void 0 ? void 0 : complete());
          if (!(err instanceof NetworkError)) {
            control.abort();
            throw err;
          }
          if (lazy) {
            conn = void 0;
          }
          if (!retryAttempts || retries >= retryAttempts) {
            control.abort();
            throw err;
          }
          retryingErr = err;
        } finally {
          if (control.signal.aborted && --locks === 0) {
            if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {
              setTimeout(() => {
                if (!locks)
                  connCtrl.abort();
              }, lazyCloseTimeout);
            } else {
              connCtrl.abort();
            }
          }
        }
      }
    })().then(() => sink.complete()).catch((err) => sink.error(err));
    return () => control.abort();
  }
  return {
    subscribe: subscribe2,
    iterate(request, on) {
      const pending = [];
      const deferred = {
        done: false,
        error: null,
        resolve: () => {
        }
      };
      const dispose = subscribe2(request, {
        next(val) {
          pending.push(val);
          deferred.resolve();
        },
        error(err) {
          deferred.done = true;
          deferred.error = err;
          deferred.resolve();
        },
        complete() {
          deferred.done = true;
          deferred.resolve();
        }
      }, on);
      const iterator = async function* iterator2() {
        for (; ; ) {
          if (!pending.length) {
            await new Promise((resolve) => deferred.resolve = resolve);
          }
          while (pending.length) {
            yield pending.shift();
          }
          if (deferred.error) {
            throw deferred.error;
          }
          if (deferred.done) {
            return;
          }
        }
      }();
      iterator.throw = async (err) => {
        if (!deferred.done) {
          deferred.done = true;
          deferred.error = err;
          deferred.resolve();
        }
        return { done: true, value: void 0 };
      };
      iterator.return = async () => {
        dispose();
        return { done: true, value: void 0 };
      };
      return iterator;
    },
    dispose() {
      client.dispose();
    }
  };
}
var NetworkError = class extends Error {
  constructor(msgOrErrOrResponse) {
    let message, response;
    if (isResponseLike(msgOrErrOrResponse)) {
      response = msgOrErrOrResponse;
      message = "Server responded with " + msgOrErrOrResponse.status + ": " + msgOrErrOrResponse.statusText;
    } else if (msgOrErrOrResponse instanceof Error)
      message = msgOrErrOrResponse.message;
    else
      message = String(msgOrErrOrResponse);
    super(message);
    this.name = this.constructor.name;
    this.response = response;
  }
};
function isResponseLike(val) {
  return isObject(val) && typeof val["ok"] === "boolean" && typeof val["status"] === "number" && typeof val["statusText"] === "string";
}
async function connect(options) {
  const { signal, url, credentials, headers, body, referrer, referrerPolicy, fetchFn, onMessage } = options;
  const waiting = {};
  const queue = {};
  let res;
  try {
    res = await fetchFn(url, {
      signal,
      method: body ? "POST" : "GET",
      credentials,
      referrer,
      referrerPolicy,
      headers: {
        ...headers,
        accept: "text/event-stream"
      },
      body
    });
  } catch (err) {
    throw new NetworkError(err);
  }
  if (!res.ok)
    throw new NetworkError(res);
  if (!res.body)
    throw new Error("Missing response body");
  let error = null;
  let waitingForThrow;
  (async () => {
    var _a;
    try {
      const parse2 = createParser();
      for await (const chunk of toAsyncIterator(res.body)) {
        if (typeof chunk === "string")
          throw error = new Error(`Unexpected string chunk "${chunk}"`);
        let msgs;
        try {
          msgs = parse2(chunk);
        } catch (err) {
          throw error = err;
        }
        if (!msgs)
          continue;
        for (const msg of msgs) {
          try {
            onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg);
          } catch (err) {
            throw error = err;
          }
          const operationId = msg.data && "id" in msg.data ? msg.data.id : "";
          if (!(operationId in queue))
            queue[operationId] = [];
          switch (msg.event) {
            case "next":
              if (operationId)
                queue[operationId].push(msg.data.payload);
              else
                queue[operationId].push(msg.data);
              break;
            case "complete":
              queue[operationId].push("complete");
              break;
            default:
              throw error = new Error(`Unexpected message event "${msg.event}"`);
          }
          (_a = waiting[operationId]) === null || _a === void 0 ? void 0 : _a.proceed();
        }
      }
      if (Object.keys(waiting).length) {
        throw new Error("Connection closed while having active streams");
      }
    } catch (err) {
      if (!error && Object.keys(waiting).length) {
        error = new NetworkError(err);
      } else {
        error = err;
      }
      waitingForThrow === null || waitingForThrow === void 0 ? void 0 : waitingForThrow(error);
    } finally {
      Object.values(waiting).forEach(({ proceed }) => proceed());
    }
  })();
  return {
    url,
    headers,
    waitForThrow: () => new Promise((_, reject) => {
      if (error)
        return reject(error);
      waitingForThrow = reject;
    }),
    async *getResults(options2) {
      var _a;
      const { signal: signal2, operationId = "" } = options2 !== null && options2 !== void 0 ? options2 : {};
      try {
        for (; ; ) {
          while ((_a = queue[operationId]) === null || _a === void 0 ? void 0 : _a.length) {
            const result = queue[operationId].shift();
            if (result === "complete")
              return;
            yield result;
          }
          if (error)
            throw error;
          if (signal2 === null || signal2 === void 0 ? void 0 : signal2.aborted)
            throw new Error("Getting results aborted by the client");
          await new Promise((resolve) => {
            const proceed = () => {
              signal2 === null || signal2 === void 0 ? void 0 : signal2.removeEventListener("abort", proceed);
              delete waiting[operationId];
              resolve();
            };
            signal2 === null || signal2 === void 0 ? void 0 : signal2.addEventListener("abort", proceed);
            waiting[operationId] = { proceed };
          });
        }
      } finally {
        delete queue[operationId];
      }
    }
  };
}
function toAsyncIterator(val) {
  if (typeof Object(val)[Symbol.asyncIterator] === "function") {
    val = val;
    return val[Symbol.asyncIterator]();
  }
  return async function* () {
    const reader = val.getReader();
    let result;
    do {
      result = await reader.read();
      if (result.value !== void 0)
        yield result.value;
    } while (!result.done);
  }();
}

// ../node_modules/@redwoodjs/web/dist/apollo/sseLink.js
var mapCredentialsHeader = (httpLinkCredentials) => {
  if (!httpLinkCredentials) {
    return void 0;
  }
  switch (httpLinkCredentials) {
    case "omit":
    case "same-origin":
    case "include":
      return httpLinkCredentials;
    default:
      return void 0;
  }
};
var mapReferrerPolicyHeader = (referrerPolicy) => {
  if (!referrerPolicy) {
    return void 0;
  }
  switch (referrerPolicy) {
    case "no-referrer":
    case "no-referrer-when-downgrade":
    case "same-origin":
    case "origin":
    case "strict-origin":
    case "origin-when-cross-origin":
    case "strict-origin-when-cross-origin":
    case "unsafe-url":
      return referrerPolicy;
    default:
      return void 0;
  }
};
var hasTrustedDocument = (operation) => {
  var _a, _b;
  return (_b = (_a = operation.extensions) == null ? void 0 : _a.persistedQuery) == null ? void 0 : _b.sha256Hash;
};
var isSubscription = (definition) => {
  return definition.kind === Kind.OPERATION_DEFINITION && definition.operation === OperationTypeNode.SUBSCRIPTION;
};
var isLiveQuery = (definition) => {
  var _a;
  if (definition.kind !== Kind.OPERATION_DEFINITION || definition.operation !== OperationTypeNode.QUERY) {
    return false;
  }
  return !!((_a = definition.directives) == null ? void 0 : _a.find((d) => d.name.value === "live"));
};
var SSELink = class extends import_core.ApolloLink {
  constructor(options) {
    super();
    __publicField(this, "client");
    const { url, auth, headers, httpLinkConfig } = options;
    const { credentials, referrer, referrerPolicy } = (httpLinkConfig == null ? void 0 : httpLinkConfig.headers) || {};
    this.client = createClient({
      url,
      headers: async () => {
        const token = await auth.tokenFn();
        if (!token) {
          return { ...headers };
        }
        return {
          Authorization: `Bearer ${token}`,
          "auth-provider": auth.authProviderType,
          ...headers
        };
      },
      credentials: mapCredentialsHeader(credentials),
      referrer,
      referrerPolicy: mapReferrerPolicyHeader(referrerPolicy)
    });
  }
  request(operation) {
    return new import_utilities.Observable((sink) => {
      let request;
      if (hasTrustedDocument(operation)) {
        delete operation.query;
        request = { ...operation };
      } else {
        request = {
          ...operation,
          query: print(operation.query)
        };
      }
      return this.client.subscribe(request, {
        next: sink.next.bind(sink),
        complete: sink.complete.bind(sink),
        error: sink.error.bind(sink)
      });
    });
  }
};

// ../node_modules/@redwoodjs/web/dist/apollo/useCache.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);
var import_hooks = __toESM(require_hooks(), 1);
var useCache = () => {
  const client = (0, import_hooks.useApolloClient)();
  const cache = client.cache;
  const extract = (optimistic = false) => cache.extract(optimistic);
  const identify = (object) => {
    return { id: cache.identify(object) };
  };
  const modify = (object, fields) => {
    return cache.modify({ ...identify(object), fields });
  };
  const evict = (object) => {
    return cache.evict(identify(object));
  };
  const resetStore = () => {
    return client.resetStore();
  };
  const clearStore = () => {
    return client.clearStore();
  };
  return { cache, evict, extract, identify, modify, resetStore, clearStore };
};

// ../node_modules/@redwoodjs/web/dist/apollo/index.js
var { SSELink: SSELink2, isSubscription: isSubscription2, isLiveQuery: isLiveQuery2 } = sseLink_exports;
var ApolloProviderWithFetchConfig = ({ config, children, useAuth = useNoAuth, logLevel }) => {
  (0, import_core2.setLogVerbosity)(logLevel);
  const { getToken, type: authProviderType } = useAuth();
  const data = {
    mostRecentRequest: void 0,
    mostRecentResponse: void 0
  };
  const updateDataApolloLink = new ApolloLink((operation, forward) => {
    const { operationName, query, variables } = operation;
    data.mostRecentRequest = {};
    data.mostRecentRequest.operationName = operationName;
    data.mostRecentRequest.operationKind = query == null ? void 0 : query.kind.toString();
    data.mostRecentRequest.variables = variables;
    data.mostRecentRequest.query = query && (0, import_printer.print)(operation.query);
    return forward(operation).map((result) => {
      data.mostRecentResponse = result;
      return result;
    });
  });
  const withToken = (0, import_context.setContext)(async () => {
    const token = await getToken();
    return { token };
  });
  const { headers, uri } = useFetchConfig();
  const authMiddleware = new ApolloLink((operation, forward) => {
    const { token } = operation.getContext();
    const authHeaders = token ? {
      "auth-provider": authProviderType,
      authorization: `Bearer ${token}`
    } : {};
    operation.setContext(() => ({
      headers: {
        ...operation.getContext().headers,
        ...headers,
        // Duped auth headers, because we may remove the `FetchConfigProvider` at a later date.
        ...authHeaders
      }
    }));
    return forward(operation);
  });
  const { httpLinkConfig, link: redwoodApolloLink, ...rest } = config ?? {};
  const uploadLink = createUploadLink({
    uri,
    ...httpLinkConfig
    // The upload link types don't match the ApolloLink types, even though it comes from Apollo
    // because they use ESM imports and we're using the default ones.
  });
  const uploadOrSSELink = typeof SSELink2 !== "undefined" ? split(
    ({ query }) => {
      const definition = (0, import_utilities2.getMainDefinition)(query);
      return isSubscription2(definition) || isLiveQuery2(definition);
    },
    new SSELink2({
      url: uri,
      auth: { authProviderType, tokenFn: getToken },
      httpLinkConfig,
      headers
    }),
    uploadLink
  ) : uploadLink;
  const terminatingLink = split(
    ({ query }) => {
      var _a;
      const documentQuery = query;
      return ((_a = documentQuery == null ? void 0 : documentQuery["__meta__"]) == null ? void 0 : _a["hash"]) !== void 0;
    },
    (0, import_persisted_queries.createPersistedQueryLink)({
      generateHash: (document) => document["__meta__"]["hash"]
    }).concat(uploadOrSSELink),
    uploadOrSSELink
  );
  const redwoodApolloLinks = [
    { name: "withToken", link: withToken },
    { name: "authMiddleware", link: authMiddleware },
    { name: "updateDataApolloLink", link: updateDataApolloLink },
    { name: "httpLink", link: terminatingLink }
  ];
  let link = redwoodApolloLink;
  link ?? (link = ApolloLink.from(redwoodApolloLinks.map((l) => l.link)));
  if (typeof link === "function") {
    link = link(redwoodApolloLinks);
  }
  const client = new ApolloClient({
    // Default options for every Cell. Better to specify them here than in `beforeQuery` where it's too easy to overwrite them.
    // See https://www.apollographql.com/docs/react/api/core/ApolloClient/#example-defaultoptions-object.
    defaultOptions: {
      watchQuery: {
        // The `fetchPolicy` we expect:
        //
        // > Apollo Client executes the full query against both the cache and your GraphQL server.
        // > The query automatically updates if the result of the server-side query modifies cached fields.
        //
        // See https://www.apollographql.com/docs/react/data/queries/#cache-and-network.
        fetchPolicy: "cache-and-network",
        // So that Cells rerender when refetching.
        // See https://www.apollographql.com/docs/react/data/queries/#inspecting-loading-states.
        notifyOnNetworkStatusChange: true
      }
    },
    link,
    ...rest
  });
  const extendErrorAndRethrow = (error, _errorInfo) => {
    error["mostRecentRequest"] = data.mostRecentRequest;
    error["mostRecentResponse"] = data.mostRecentResponse;
    throw error;
  };
  return import_react.default.createElement(ApolloProvider, { client }, import_react.default.createElement(ErrorBoundary, { onError: extendErrorAndRethrow }, children));
};
var ErrorBoundary = class extends import_react.default.Component {
  componentDidCatch(...args) {
    this.setState({});
    this.props.onError(...args);
  }
  render() {
    return this.props.children;
  }
};
var RedwoodApolloProvider = ({
  graphQLClientConfig,
  fragments,
  useAuth = useNoAuth,
  logLevel = "debug",
  children
}) => {
  const { cacheConfig, ...config } = graphQLClientConfig ?? {};
  if (fragments) {
    fragmentRegistry.register(...fragments);
  }
  const cache = new InMemoryCache({
    fragments: fragmentRegistry,
    possibleTypes: cacheConfig == null ? void 0 : cacheConfig.possibleTypes,
    ...cacheConfig
  }).restore((globalThis == null ? void 0 : globalThis.__REDWOOD__APOLLO_STATE) ?? {});
  return import_react.default.createElement(FetchConfigProvider, { useAuth }, import_react.default.createElement(
    ApolloProviderWithFetchConfig,
    {
      config: { cache, ...config },
      useAuth,
      logLevel
    },
    import_react.default.createElement(
      GraphQLHooksProvider,
      {
        useQuery: import_hooks2.useQuery,
        useMutation: import_hooks2.useMutation,
        useSubscription: import_hooks2.useSubscription,
        useBackgroundQuery: import_hooks2.useBackgroundQuery,
        useReadQuery: import_hooks2.useReadQuery,
        useSuspenseQuery: import_hooks2.useSuspenseQuery
      },
      children
    )
  ));
};
export {
  RedwoodApolloProvider,
  fragmentRegistry,
  registerFragment,
  registerFragments,
  useCache
};
//# sourceMappingURL=@redwoodjs_web_apollo.js.map
