import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_react
} from "./chunk-ZILOSMTM.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-USKKUMLC.js";

// ../node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "../node_modules/source-map/lib/base64.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// ../node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "../node_modules/source-map/lib/base64-vlq.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// ../node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "../node_modules/source-map/lib/util.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// ../node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "../node_modules/source-map/lib/array-set.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// ../node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "../node_modules/source-map/lib/mapping-list.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// ../node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "../node_modules/source-map/lib/source-map-generator.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// ../node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "../node_modules/source-map/lib/binary-search.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// ../node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "../node_modules/source-map/lib/quick-sort.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// ../node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "../node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// ../node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "../node_modules/source-map/lib/source-node.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// ../node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "../node_modules/source-map/source-map.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// ../node_modules/get-source/impl/SyncPromise.js
var require_SyncPromise = __commonJS({
  "../node_modules/get-source/impl/SyncPromise.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports = class SyncPromise {
      constructor(fn) {
        try {
          fn(
            (x) => {
              this.setValue(x, false);
            },
            // resolve
            (x) => {
              this.setValue(x, true);
            }
            // reject
          );
        } catch (e) {
          this.setValue(e, true);
        }
      }
      setValue(x, rejected) {
        this.val = x instanceof SyncPromise ? x.val : x;
        this.rejected = rejected || (x instanceof SyncPromise ? x.rejected : false);
      }
      static valueFrom(x) {
        if (x instanceof SyncPromise) {
          if (x.rejected) throw x.val;
          else return x.val;
        } else {
          return x;
        }
      }
      then(fn) {
        try {
          if (!this.rejected) return SyncPromise.resolve(fn(this.val));
        } catch (e) {
          return SyncPromise.reject(e);
        }
        return this;
      }
      catch(fn) {
        try {
          if (this.rejected) return SyncPromise.resolve(fn(this.val));
        } catch (e) {
          return SyncPromise.reject(e);
        }
        return this;
      }
      static resolve(x) {
        return new SyncPromise((resolve) => {
          resolve(x);
        });
      }
      static reject(x) {
        return new SyncPromise((_, reject) => {
          reject(x);
        });
      }
    };
  }
});

// ../node_modules/get-source/impl/path.js
var require_path = __commonJS({
  "../node_modules/get-source/impl/path.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var isBrowser = typeof window !== "undefined" && window.window === window && window.navigator;
    var cwd = isBrowser ? window.location.href : process.cwd();
    var urlRegexp = new RegExp("^((https|http)://)?[a-z0-9A-Z]{3}.[a-z0-9A-Z][a-z0-9A-Z]{0,61}?[a-z0-9A-Z].com|net|cn|cc (:s[0-9]{1-4})?/$");
    var path = module.exports = {
      concat(a, b) {
        const a_endsWithSlash = a[a.length - 1] === "/", b_startsWithSlash = b[0] === "/";
        return a + (a_endsWithSlash || b_startsWithSlash ? "" : "/") + (a_endsWithSlash && b_startsWithSlash ? b.substring(1) : b);
      },
      resolve(x) {
        if (path.isAbsolute(x)) {
          return path.normalize(x);
        }
        return path.normalize(path.concat(cwd, x));
      },
      normalize(x) {
        let output = [], skip = 0;
        x.split("/").reverse().filter((x2) => x2 !== ".").forEach((x2) => {
          if (x2 === "..") {
            skip++;
          } else if (skip === 0) {
            output.push(x2);
          } else {
            skip--;
          }
        });
        const result = output.reverse().join("/");
        return (isBrowser && result[0] === "/" ? result[1] === "/" ? window.location.protocol : window.location.origin : "") + result;
      },
      isData: (x) => x.indexOf("data:") === 0,
      isURL: (x) => urlRegexp.test(x),
      isAbsolute: (x) => x[0] === "/" || /^[^\/]*:/.test(x),
      relativeToFile(a, b) {
        return path.isData(a) || path.isAbsolute(b) ? path.normalize(b) : path.normalize(path.concat(a.split("/").slice(0, -1).join("/"), b));
      }
    };
  }
});

// ../node_modules/data-uri-to-buffer/index.js
var require_data_uri_to_buffer = __commonJS({
  "../node_modules/data-uri-to-buffer/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports = dataUriToBuffer;
    function dataUriToBuffer(uri) {
      if (!/^data\:/i.test(uri)) {
        throw new TypeError(
          '`uri` does not appear to be a Data URI (must begin with "data:")'
        );
      }
      uri = uri.replace(/\r?\n/g, "");
      var firstComma = uri.indexOf(",");
      if (-1 === firstComma || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      var meta = uri.substring(5, firstComma).split(";");
      var type = meta[0] || "text/plain";
      var typeFull = type;
      var base64 = false;
      var charset = "";
      for (var i = 1; i < meta.length; i++) {
        if ("base64" == meta[i]) {
          base64 = true;
        } else {
          typeFull += ";" + meta[i];
          if (0 == meta[i].indexOf("charset=")) {
            charset = meta[i].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      var data = unescape(uri.substring(firstComma + 1));
      var encoding = base64 ? "base64" : "ascii";
      var buffer = Buffer.from ? Buffer.from(data, encoding) : new Buffer(data, encoding);
      buffer.type = type;
      buffer.typeFull = typeFull;
      buffer.charset = charset;
      return buffer;
    }
  }
});

// ../node_modules/get-source/get-source.js
var require_get_source = __commonJS({
  "../node_modules/get-source/get-source.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var { assign } = Object;
    var isBrowser = typeof window !== "undefined" && window.window === window && window.navigator;
    var SourceMapConsumer = require_source_map().SourceMapConsumer;
    var SyncPromise = require_SyncPromise();
    var path = require_path();
    var dataURIToBuffer = require_data_uri_to_buffer();
    var nodeRequire = isBrowser ? null : module.require;
    var memoize = (f) => {
      const m = (x) => x in m.cache ? m.cache[x] : m.cache[x] = f(x);
      m.forgetEverything = () => {
        m.cache = /* @__PURE__ */ Object.create(null);
      };
      m.cache = /* @__PURE__ */ Object.create(null);
      return m;
    };
    function impl(fetchFile, sync) {
      const PromiseImpl = sync ? SyncPromise : Promise;
      const SourceFileMemoized = memoize((path2) => SourceFile(path2, fetchFile(path2)));
      function SourceFile(srcPath, text) {
        if (text === void 0) return SourceFileMemoized(path.resolve(srcPath));
        return PromiseImpl.resolve(text).then((text2) => {
          let file;
          let lines;
          let resolver;
          let _resolve = (loc) => (resolver = resolver || SourceMapResolverFromFetchedFile(file))(loc);
          return file = {
            path: srcPath,
            text: text2,
            get lines() {
              return lines = lines || text2.split("\n");
            },
            resolve(loc) {
              const result = _resolve(loc);
              if (sync) {
                try {
                  return SyncPromise.valueFrom(result);
                } catch (e) {
                  return assign({}, loc, { error: e });
                }
              } else {
                return Promise.resolve(result);
              }
            },
            _resolve
          };
        });
      }
      function SourceMapResolverFromFetchedFile(file) {
        const re = /\u0023 sourceMappingURL=(.+)\n?/g;
        let lastMatch = void 0;
        while (true) {
          const match = re.exec(file.text);
          if (match) lastMatch = match;
          else break;
        }
        const url = lastMatch && lastMatch[1];
        const defaultResolver = (loc) => assign({}, loc, {
          sourceFile: file,
          sourceLine: file.lines[loc.line - 1] || ""
        });
        return url ? SourceMapResolver(file.path, url, defaultResolver) : defaultResolver;
      }
      function SourceMapResolver(originalFilePath, sourceMapPath, fallbackResolve) {
        const srcFile = sourceMapPath.startsWith("data:") ? SourceFile(originalFilePath, dataURIToBuffer(sourceMapPath).toString()) : SourceFile(path.relativeToFile(originalFilePath, sourceMapPath));
        const parsedMap = srcFile.then((f) => SourceMapConsumer(JSON.parse(f.text)));
        const sourceFor = memoize(function sourceFor2(filePath) {
          return srcFile.then((f) => {
            const fullPath = path.relativeToFile(f.path, filePath);
            return parsedMap.then((x) => SourceFile(
              fullPath,
              x.sourceContentFor(
                filePath,
                true
                /* return null on missing */
              ) || void 0
            ));
          });
        });
        return (loc) => parsedMap.then((x) => {
          const originalLoc = x.originalPositionFor(loc);
          return originalLoc.source ? sourceFor(originalLoc.source).then(
            (x2) => x2._resolve(assign({}, loc, {
              line: originalLoc.line,
              column: originalLoc.column + 1,
              name: originalLoc.name
            }))
          ) : fallbackResolve(loc);
        }).catch((e) => assign(fallbackResolve(loc), { sourceMapError: e }));
      }
      return assign(function getSource(path2) {
        const file = SourceFile(path2);
        if (sync) {
          try {
            return SyncPromise.valueFrom(file);
          } catch (e) {
            const noFile = {
              path: path2,
              text: "",
              lines: [],
              error: e,
              resolve(loc) {
                return assign({}, loc, { error: e, sourceLine: "", sourceFile: noFile });
              }
            };
            return noFile;
          }
        }
        return file;
      }, {
        resetCache: () => SourceFileMemoized.forgetEverything(),
        getCache: () => SourceFileMemoized.cache
      });
    }
    module.exports = impl(function fetchFileSync(path2) {
      return new SyncPromise((resolve) => {
        if (isBrowser) {
          let xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path2,
            false
            /* SYNCHRONOUS XHR FTW :) */
          );
          xhr.send(null);
          resolve(xhr.responseText);
        } else {
          resolve(nodeRequire("fs").readFileSync(path2, { encoding: "utf8" }));
        }
      });
    }, true);
    module.exports.async = impl(function fetchFileAsync(path2) {
      return new Promise((resolve, reject) => {
        if (isBrowser) {
          let xhr = new XMLHttpRequest();
          xhr.open("GET", path2);
          xhr.onreadystatechange = (event) => {
            if (xhr.readyState === 4) {
              if (xhr.status === 200) {
                resolve(xhr.responseText);
              } else {
                reject(new Error(xhr.statusText));
              }
            }
          };
          xhr.send(null);
        } else {
          nodeRequire("fs").readFile(path2, { encoding: "utf8" }, (e, x) => {
            e ? reject(e) : resolve(x);
          });
        }
      });
    });
  }
});

// ../node_modules/stacktracey/impl/partition.js
var require_partition = __commonJS({
  "../node_modules/stacktracey/impl/partition.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports = (arr_, pred) => {
      const arr = arr_ || [], spans = [];
      let span = {
        label: void 0,
        items: [arr.first]
      };
      arr.forEach((x) => {
        const label = pred(x);
        if (span.label !== label && span.items.length) {
          spans.push(span = { label, items: [x] });
        } else {
          span.items.push(x);
        }
      });
      return spans;
    };
  }
});

// ../node_modules/printable-characters/build/printable-characters.js
var require_printable_characters = __commonJS({
  "../node_modules/printable-characters/build/printable-characters.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var _slicedToArray = /* @__PURE__ */ function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var ansiEscapeCode = "[\x1B][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]";
    var zeroWidthCharacterExceptNewline = "\0-\b\v-\x1B­​\u2028\u2029\uFEFF︀-️";
    var zeroWidthCharacter = "\n" + zeroWidthCharacterExceptNewline;
    var zeroWidthCharactersExceptNewline = new RegExp("(?:" + ansiEscapeCode + ")|[" + zeroWidthCharacterExceptNewline + "]", "g");
    var zeroWidthCharacters = new RegExp("(?:" + ansiEscapeCode + ")|[" + zeroWidthCharacter + "]", "g");
    var partition = new RegExp("((?:" + ansiEscapeCode + ")|[	" + zeroWidthCharacter + "])?([^	" + zeroWidthCharacter + "]*)", "g");
    module.exports = {
      zeroWidthCharacters,
      ansiEscapeCodes: new RegExp(ansiEscapeCode, "g"),
      strlen: (s) => Array.from(s.replace(zeroWidthCharacters, "")).length,
      // Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two
      isBlank: (s) => s.replace(zeroWidthCharacters, "").replace(/\s/g, "").length === 0,
      blank: (s) => Array.from(s.replace(zeroWidthCharactersExceptNewline, "")).map((x) => x === "	" || x === "\n" ? x : " ").join(""),
      partition(s) {
        for (var m, spans = []; partition.lastIndex !== s.length && (m = partition.exec(s)); ) {
          spans.push([m[1] || "", m[2]]);
        }
        partition.lastIndex = 0;
        return spans;
      },
      first(s, n) {
        let result = "", length = 0;
        for (const _ref of module.exports.partition(s)) {
          var _ref2 = _slicedToArray(_ref, 2);
          const nonPrintable = _ref2[0];
          const printable = _ref2[1];
          const text = Array.from(printable).slice(0, n - length);
          result += nonPrintable + text.join("");
          length += text.length;
        }
        return result;
      }
    };
  }
});

// ../node_modules/as-table/build/as-table.js
var require_as_table = __commonJS({
  "../node_modules/as-table/build/as-table.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var O = Object;
    var _require = require_printable_characters();
    var first = _require.first;
    var strlen = _require.strlen;
    var limit = (s, n) => first(s, n - 1) + "…";
    var asColumns = (rows, cfg_) => {
      const zip = (arrs, f) => arrs.reduce((a, b) => b.map((b2, i) => [].concat(_toConsumableArray(a[i] || []), [b2])), []).map((args) => f.apply(void 0, _toConsumableArray(args))), cells = rows.map((r) => r.map((c) => c.replace(/\n/g, "\\n"))), cellWidths = cells.map((r) => r.map(strlen)), maxWidths = zip(cellWidths, Math.max), cfg = O.assign({
        delimiter: "  ",
        minColumnWidths: maxWidths.map((x) => 0),
        maxTotalWidth: 0
      }, cfg_), delimiterLength = strlen(cfg.delimiter), totalWidth = maxWidths.reduce((a, b) => a + b, 0), relativeWidths = maxWidths.map((w) => w / totalWidth), maxTotalWidth = cfg.maxTotalWidth - delimiterLength * (maxWidths.length - 1), excessWidth = Math.max(0, totalWidth - maxTotalWidth), computedWidths = zip([cfg.minColumnWidths, maxWidths, relativeWidths], (min, max, relative) => Math.max(min, Math.floor(max - excessWidth * relative))), restCellWidths = cellWidths.map((widths) => zip([computedWidths, widths], (a, b) => a - b));
      return zip([cells, restCellWidths], (a, b) => zip([a, b], (str, w) => w >= 0 ? cfg.right ? " ".repeat(w) + str : str + " ".repeat(w) : limit(str, strlen(str) + w)).join(cfg.delimiter));
    };
    var asTable = (cfg) => O.assign((arr) => {
      var _ref;
      if (arr[0] && Array.isArray(arr[0])) {
        return asColumns(arr.map((r) => r.map((c, i) => c === void 0 ? "" : cfg.print(c, i))), cfg).join("\n");
      }
      const colNames = [].concat(_toConsumableArray(new Set((_ref = []).concat.apply(_ref, _toConsumableArray(arr.map(O.keys)))))), columns = [colNames.map(cfg.title)].concat(_toConsumableArray(arr.map((o) => colNames.map((key) => o[key] === void 0 ? "" : cfg.print(o[key], key))))), lines = asColumns(columns, cfg);
      return (cfg.dash ? [lines[0], cfg.dash.repeat(strlen(lines[0]))].concat(_toConsumableArray(lines.slice(1))) : lines).join("\n");
    }, cfg, {
      configure: (newConfig) => asTable(O.assign({}, cfg, newConfig))
    });
    module.exports = asTable({
      maxTotalWidth: Number.MAX_SAFE_INTEGER,
      print: String,
      title: String,
      dash: "-",
      right: false
    });
  }
});

// ../node_modules/stacktracey/stacktracey.js
var require_stacktracey = __commonJS({
  "../node_modules/stacktracey/stacktracey.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var O = Object;
    var isBrowser = typeof window !== "undefined" && window.window === window && window.navigator;
    var nodeRequire = isBrowser ? null : module.require;
    var lastOf = (x) => x[x.length - 1];
    var getSource = require_get_source();
    var partition = require_partition();
    var asTable = require_as_table();
    var nixSlashes = (x) => x.replace(/\\/g, "/");
    var pathRoot = isBrowser ? window.location.href : nixSlashes(process.cwd()) + "/";
    var StackTracey2 = class _StackTracey {
      constructor(input, offset) {
        const originalInput = input, isParseableSyntaxError = input && (input instanceof SyntaxError && !isBrowser);
        if (!input) {
          input = new Error();
          offset = offset === void 0 ? 1 : offset;
        }
        if (input instanceof Error) {
          input = input.stack || "";
        }
        if (typeof input === "string") {
          input = this.rawParse(input).slice(offset).map((x) => this.extractEntryMetadata(x));
        }
        if (Array.isArray(input)) {
          if (isParseableSyntaxError) {
            const rawLines = nodeRequire("util").inspect(originalInput).split("\n"), fileLine = rawLines[0].split(":"), line = fileLine.pop(), file = fileLine.join(":");
            if (file) {
              input.unshift({
                file: nixSlashes(file),
                line,
                column: (rawLines[2] || "").indexOf("^") + 1,
                sourceLine: rawLines[1],
                callee: "(syntax error)",
                syntaxError: true
              });
            }
          }
          this.items = input;
        } else {
          this.items = [];
        }
      }
      extractEntryMetadata(e) {
        const decomposedPath = this.decomposePath(e.file || "");
        const fileRelative = decomposedPath[0];
        const externalDomain = decomposedPath[1];
        return O.assign(e, {
          calleeShort: e.calleeShort || lastOf((e.callee || "").split(".")),
          fileRelative,
          fileShort: this.shortenPath(fileRelative),
          fileName: lastOf((e.file || "").split("/")),
          thirdParty: this.isThirdParty(fileRelative, externalDomain) && !e.index,
          externalDomain
        });
      }
      shortenPath(relativePath) {
        return relativePath.replace(/^node_modules\//, "").replace(/^webpack\/bootstrap\//, "").replace(/^__parcel_source_root\//, "");
      }
      decomposePath(fullPath) {
        let result = fullPath;
        if (isBrowser) result = result.replace(pathRoot, "");
        const externalDomainMatch = result.match(/^(http|https)\:\/\/?([^\/]+)\/(.*)/);
        const externalDomain = externalDomainMatch ? externalDomainMatch[2] : void 0;
        result = externalDomainMatch ? externalDomainMatch[3] : result;
        if (!isBrowser) result = nodeRequire("path").relative(pathRoot, result);
        return [
          nixSlashes(result).replace(/^.*\:\/\/?\/?/, ""),
          // cut webpack:/// and webpack:/ things
          externalDomain
        ];
      }
      isThirdParty(relativePath, externalDomain) {
        return externalDomain || relativePath[0] === "~" || // webpack-specific heuristic
        relativePath[0] === "/" || // external source
        relativePath.indexOf("node_modules") === 0 || relativePath.indexOf("webpack/bootstrap") === 0;
      }
      rawParse(str) {
        const lines = (str || "").split("\n");
        const entries = lines.map((line) => {
          line = line.trim();
          let callee, fileLineColumn = [], native, planA, planB;
          if ((planA = line.match(/at (.+) \(eval at .+ \((.+)\), .+\)/)) || // eval calls
          (planA = line.match(/at (.+) \((.+)\)/)) || line.slice(0, 3) !== "at " && (planA = line.match(/(.*)@(.*)/))) {
            callee = planA[1];
            native = planA[2] === "native";
            fileLineColumn = (planA[2].match(/(.*):(\d+):(\d+)/) || planA[2].match(/(.*):(\d+)/) || []).slice(1);
          } else if (planB = line.match(/^(at\s+)*(.+):(\d+):(\d+)/)) {
            fileLineColumn = planB.slice(2);
          } else {
            return void 0;
          }
          if (callee && !fileLineColumn[0]) {
            const type = callee.split(".")[0];
            if (type === "Array") {
              native = true;
            }
          }
          return {
            beforeParse: line,
            callee: callee || "",
            index: isBrowser && fileLineColumn[0] === window.location.href,
            native: native || false,
            file: nixSlashes(fileLineColumn[0] || ""),
            line: parseInt(fileLineColumn[1] || "", 10) || void 0,
            column: parseInt(fileLineColumn[2] || "", 10) || void 0
          };
        });
        return entries.filter((x) => x !== void 0);
      }
      withSourceAt(i) {
        return this.items[i] && this.withSource(this.items[i]);
      }
      withSourceAsyncAt(i) {
        return this.items[i] && this.withSourceAsync(this.items[i]);
      }
      withSource(loc) {
        if (this.shouldSkipResolving(loc)) {
          return loc;
        } else {
          let resolved = getSource(loc.file || "").resolve(loc);
          if (!resolved.sourceFile) {
            return loc;
          }
          return this.withSourceResolved(loc, resolved);
        }
      }
      withSourceAsync(loc) {
        if (this.shouldSkipResolving(loc)) {
          return Promise.resolve(loc);
        } else {
          return getSource.async(loc.file || "").then((x) => x.resolve(loc)).then((resolved) => this.withSourceResolved(loc, resolved)).catch((e) => this.withSourceResolved(loc, { error: e, sourceLine: "" }));
        }
      }
      shouldSkipResolving(loc) {
        return loc.sourceFile || loc.error || loc.file && loc.file.indexOf("<") >= 0;
      }
      withSourceResolved(loc, resolved) {
        if (resolved.sourceFile && !resolved.sourceFile.error) {
          resolved.file = nixSlashes(resolved.sourceFile.path);
          resolved = this.extractEntryMetadata(resolved);
        }
        if (resolved.sourceLine.includes("// @hide")) {
          resolved.sourceLine = resolved.sourceLine.replace("// @hide", "");
          resolved.hide = true;
        }
        if (resolved.sourceLine.includes("__webpack_require__") || // webpack-specific heuristics
        resolved.sourceLine.includes("/******/ ({")) {
          resolved.thirdParty = true;
        }
        return O.assign({ sourceLine: "" }, loc, resolved);
      }
      withSources() {
        return this.map((x) => this.withSource(x));
      }
      withSourcesAsync() {
        return Promise.all(this.items.map((x) => this.withSourceAsync(x))).then((items) => new _StackTracey(items));
      }
      mergeRepeatedLines() {
        return new _StackTracey(
          partition(this.items, (e) => e.file + e.line).map(
            (group) => {
              return group.items.slice(1).reduce((memo, entry) => {
                memo.callee = (memo.callee || "<anonymous>") + " → " + (entry.callee || "<anonymous>");
                memo.calleeShort = (memo.calleeShort || "<anonymous>") + " → " + (entry.calleeShort || "<anonymous>");
                return memo;
              }, O.assign({}, group.items[0]));
            }
          )
        );
      }
      clean() {
        const s = this.withSources().mergeRepeatedLines();
        return s.filter(s.isClean.bind(s));
      }
      cleanAsync() {
        return this.withSourcesAsync().then((s) => {
          s = s.mergeRepeatedLines();
          return s.filter(s.isClean.bind(s));
        });
      }
      isClean(entry, index) {
        return index === 0 || !(entry.thirdParty || entry.hide || entry.native);
      }
      at(i) {
        return O.assign({
          beforeParse: "",
          callee: "<???>",
          index: false,
          native: false,
          file: "<???>",
          line: 0,
          column: 0
        }, this.items[i]);
      }
      asTable(opts) {
        const maxColumnWidths = opts && opts.maxColumnWidths || this.maxColumnWidths();
        const trimEnd = (s, n) => s && (s.length > n ? s.slice(0, n - 1) + "…" : s);
        const trimStart = (s, n) => s && (s.length > n ? "…" + s.slice(-(n - 1)) : s);
        const trimmed = this.map(
          (e) => [
            "at " + trimEnd(e.calleeShort, maxColumnWidths.callee),
            trimStart(e.fileShort && e.fileShort + ":" + e.line || "", maxColumnWidths.file),
            trimEnd((e.sourceLine || "").trim() || "", maxColumnWidths.sourceLine)
          ]
        );
        return asTable(trimmed.items);
      }
      maxColumnWidths() {
        return {
          callee: 30,
          file: 60,
          sourceLine: 80
        };
      }
      static resetCache() {
        getSource.resetCache();
        getSource.async.resetCache();
      }
      static locationsEqual(a, b) {
        return a.file === b.file && a.line === b.line && a.column === b.column;
      }
    };
    ["map", "filter", "slice", "concat"].forEach((method) => {
      StackTracey2.prototype[method] = function() {
        return new StackTracey2(this.items[method].apply(this.items, arguments));
      };
    });
    module.exports = StackTracey2;
  }
});

// ../node_modules/@redwoodjs/web/dist/components/DevFatalErrorPage.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var import_react = __toESM(require_react());
var import_stacktracey = __toESM(require_stacktracey());
var srcRoot = "";
if (typeof RWJS_DEBUG_ENV !== "undefined") {
  srcRoot = RWJS_DEBUG_ENV == null ? void 0 : RWJS_DEBUG_ENV.RWJS_SRC_ROOT;
}
var appRoot;
if (/^[A-Z]:\\/.test(srcRoot)) {
  appRoot = srcRoot.substring(3).replace(/\\/g, "/");
} else {
  appRoot = srcRoot.substring(1);
}
var DevFatalErrorPage = (props) => {
  var _a;
  if (!props.error) {
    return import_react.default.createElement("h3", null, "Could not render the error page due to a missing error, please see the console for more details.");
  }
  const err = props.error;
  const stack = new import_stacktracey.default(err).withSources();
  const typeName = String(
    err["type"] || ((_a = err.constructor) == null ? void 0 : _a.name) || typeof err
  );
  const msg = String(err && err.message);
  const FileRef = stack.items[0] ? import_react.default.createElement("a", { href: toVSCodeURL(stack.items[0]) }, stack.items[0].fileName) : null;
  return import_react.default.createElement("main", { className: "error-page" }, import_react.default.createElement(
    "style",
    {
      dangerouslySetInnerHTML: {
        __html: css
      }
    }
  ), import_react.default.createElement("nav", null, import_react.default.createElement("h1", null, "A fatal runtime error occurred when rendering ", FileRef), import_react.default.createElement("div", null, "Get help via ", import_react.default.createElement(Discord, null), " or ", import_react.default.createElement(Discourse, null))), import_react.default.createElement("section", { className: "panic-overlay" }, import_react.default.createElement("div", { className: "error" }, import_react.default.createElement("h3", { className: "error-title" }, import_react.default.createElement("span", { className: "error-type" }, typeName), import_react.default.createElement("span", { className: "error-message" }, prettyMessage(msg))), import_react.default.createElement("div", { className: "error-stack" }, stack.items.map((entry, i) => import_react.default.createElement(StackEntry, { key: i, entry, i, message: msg })))), import_react.default.createElement(ResponseRequest, { error: props.error })));
};
function hideStackLine(fileReference) {
  return fileReference.length === 1 || fileReference.includes("node_modules/react-dom");
}
function StackEntry({
  entry,
  i
}) {
  const { sourceFile = { lines: [] }, line, column, fileShort } = entry;
  const lineIndex = (line || 0) - 1;
  const maxLines = sourceFile.lines.length;
  const window2 = 4;
  let start = lineIndex - window2, end = lineIndex + window2 + 2;
  if (start < 0) {
    end = Math.min(end - start, maxLines);
    start = 0;
  }
  if (end > maxLines) {
    start = Math.max(0, start - (end - maxLines));
    end = maxLines;
  }
  const lines = sourceFile.lines.slice(start, end);
  const lineNumberWidth = String(start + lines.length).length;
  const highlightIndex = (line || 0) - start - 1;
  const onLastLine = highlightIndex === lines.length - 1;
  const shortestPath = (path) => path.replace(appRoot || "", "");
  const expanded = !shouldHideEntry(entry, i);
  const clickable = lines.length;
  const LinkToVSCode = (props) => clickable ? import_react.default.createElement("a", { href: toVSCodeURL(entry) }, props.children) : import_react.default.createElement(import_react.default.Fragment, null, props.children);
  const fileReference = !lines.length ? "[System]" : shortestPath(fileShort);
  const rootClasses = [
    "stack-entry",
    !fileReference.includes("node_modules") && "rwfw",
    i === 0 && " first",
    lines.length && "clickable"
  ].filter(Boolean);
  return hideStackLine(fileReference) ? import_react.default.createElement("div", null) : import_react.default.createElement(LinkToVSCode, null, import_react.default.createElement("div", { className: rootClasses.join(" ") }, import_react.default.createElement("div", { className: "file" }, fileReference + " in " + entry.callee), expanded && !!lines.length && import_react.default.createElement("div", { className: "lines" + (onLastLine ? ".no-fade" : "") }, lines.map((text, i2) => {
    return import_react.default.createElement(
      "div",
      {
        key: i2,
        className: "line" + (i2 === highlightIndex ? " line-hili" : "")
      },
      import_react.default.createElement("span", { className: "line-number" }, String(start + i2 + 1).padStart(lineNumberWidth, " ")),
      import_react.default.createElement("span", { className: "line-text" }, i2 === highlightIndex ? renderHighlightedLine(text, column || 0) : text)
    );
  }))));
  function renderHighlightedLine(text, column2) {
    const [before, after] = [text.slice(0, column2 - 1), text.slice(column2 - 1)];
    return import_react.default.createElement(import_react.default.Fragment, null, before, import_react.default.createElement("strong", null, after));
  }
  function shouldHideEntry(entry2, i2) {
    return (entry2.thirdParty || entry2["native"] || entry2.hide || entry2.fileShort.includes("node_modules")) && i2 !== 0;
  }
}
function toVSCodeURL(entry) {
  const scheme = RWJS_DEBUG_ENV.REDWOOD_ENV_EDITOR || "vscode";
  return `${scheme}://file/${entry.fileShort}:${entry.line}:${entry.column}`;
}
function prettyMessage(msg) {
  return msg.replace("is not a function.", "is not a function.\n\n");
}
function ResponseRequest(props) {
  var _a, _b;
  const [openQuery, setOpenQuery] = (0, import_react.useState)(false);
  const [openResponse, setOpenResponse] = (0, import_react.useState)(false);
  if (!props.error) {
    return null;
  }
  const mostRecentRequest = props.error.mostRecentRequest || ((_b = (_a = props.error.graphQLErrors) == null ? void 0 : _a.find((gqlErr) => gqlErr.__RedwoodEnhancedError)) == null ? void 0 : _b.__RedwoodEnhancedError);
  const mostRecentResponse = props.error.mostRecentResponse;
  return import_react.default.createElement("div", { className: "request-response" }, mostRecentRequest ? import_react.default.createElement("div", null, import_react.default.createElement("h4", null, "Request: ", mostRecentRequest.operationName), import_react.default.createElement("div", null, import_react.default.createElement("h5", null, "Variables:"), import_react.default.createElement("code", null, import_react.default.createElement("pre", null, JSON.stringify(mostRecentRequest.variables, null, "  ")))), import_react.default.createElement("div", null, import_react.default.createElement("h5", null, "Query:"), import_react.default.createElement("code", null, import_react.default.createElement(
    "pre",
    {
      onClick: () => setOpenQuery(!openQuery),
      className: openQuery ? "open" : "preview"
    },
    mostRecentRequest.query
  )))) : null, mostRecentResponse ? import_react.default.createElement("div", { className: "response" }, import_react.default.createElement("h4", null, "Response"), import_react.default.createElement("div", null, import_react.default.createElement("h5", null, "JSON:"), import_react.default.createElement("code", null, import_react.default.createElement(
    "pre",
    {
      onClick: () => setOpenResponse(!openResponse),
      className: openResponse ? "open" : "preview"
    },
    JSON.stringify(mostRecentResponse, null, "  ")
  )))) : null);
}
var css = `
body {
  background-color: rgb(253, 248, 246) !important;
  font-family: "Open Sans", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif  !important;
}

.panic-overlay {
  background-color: white;
  padding: 0 2.5em;
}

.panic-overlay strong {
  font-weight: bold;
}

main.error-page nav {
  display: flex;
  flex-direction: row;
  align: center;
  justify-content: space-between;
  padding: 1em 2.5em;
}

main.error-page  nav h1 {
  color: black;
  margin: 0;
  padding: 0;
  font-size: 1.2em;
  font-weight: 400;
  opacity: 1;
  color: rgb(191, 71, 34);
}

main.error-page nav h1 a {
  color: black;
  text-decoration: underline;
}

main.error-page nav div {
  display: flex;
  align-items: center;
  line-height: 2em;
}

main.error-page nav div a {
  display: flex;
  margin: 0 0.3em;
}

main.error-page nav svg {
  width: 24px;
  height: 24px;
  fill: rgb(191, 71, 34);
}

main.error-page nav svg.discourse {
  height: 20px;
  width: 20px;
}

main.error-page nav svg:hover {
  fill: rgb(200, 32, 32);
}

.request-response div div code,
.request-response div div pre {
  background-color: transparent !important;
}

.panic-overlay a {
  text-decoration: none;
}

.panic-overlay .error {
  padding: 3em 0;
}

.panic-overlay .error-title {
  display: flex;
  align-items: stretch;
}

.panic-overlay .error-type {
  min-height: 2.8em;
  display: flex !important;
  align-items: center;
  padding: 0 1em;
  background: rgb(195, 74, 37);
  color: white;
  margin-right: 2em;
  white-space: nowrap;
  text-align: center;
}
.panic-overlay .error-counter {
  color: white;
  opacity: 0.3;
  position: absolute;
  left: 0.8em;
}
.panic-overlay .error-message {
  display: flex !important;
  align-items: center;
  font-weight: 300;
  line-height: 1.1em;
  font-size: 2.8em;
  word-break: break-all;
  white-space: pre-wrap;
}
.panic-overlay .error-stack {
  margin-top: 2em;
  white-space: pre;
  padding-left: var(--left-pad);
}

.panic-overlay .stack-entry.clickable {
  cursor: pointer;
}

.panic-overlay .stack-entry {
  margin-left: 2.5em;
}

.panic-overlay .stack-entry.rwfw {
  font-weight: bold;
}

.panic-overlay .stack-entry .file {
  color: rgb(195, 74, 37, 0.8);
}

.panic-overlay .stack-entry.first .file {
  font-weight: bold;
  color: rgb(200, 47, 47);
}

.panic-overlay .file strong {
  font-weight: normal;
}
.panic-overlay .file:before,
.panic-overlay .more:before {
  content: "@ ";
  opacity: 0.5;
  margin-left: -1.25em;
}
.panic-overlay .more:before {
  content: "▷ ";
  opacity: 0.5;
}
.panic-overlay .more {
  opacity: 0.25;
  color: black;
  font-size: 0.835em;
  cursor: pointer;
  text-align: center;
  display: none;
}
.panic-overlay .more em {
  font-style: normal;
  font-weight: normal;
  border-bottom: 1px dashed black;
}
.panic-overlay .collapsed .panic-overlay .more {
  display: block;
}
.panic-overlay .lines, .request-response code {
  color: rgb(187, 165, 165);
  font-size: 0.835em;
  margin-bottom: 2.5em;
  padding: 2rem;
  font-family: Menlo, Monaco, "Courier New", Courier, monospace;
}
.panic-overlay .lines:not(.panic-overlay .no-fade) {
  -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
  mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
}
.panic-overlay .line-number {
  padding-right: 1.5em;
  opacity: 0.5;
}
.panic-overlay .line-hili {
  background: rgb(253, 248, 246);
  color: #5f4545;
}
.panic-overlay .stack-entry:first-child .panic-overlay .line-hili strong {
  text-decoration: underline wavy #ff0040;
}
.panic-overlay .line-hili em {
  font-style: italic;
  color: rgb(195, 74, 37);
  font-size: 0.75em;
  margin-left: 2em;
  opacity: 0.25;
  position: relative;
  top: -0.115em;
  white-space: nowrap;
}
.panic-overlay .line-hili em:before {
  content: "← ";
}
.panic-overlay .no-source {
  font-style: italic;
}

.panic-overlay .request-response {
  margin-top: 2rem;
  display: flex;
  flex-direction: row;
}

.panic-overlay .request-response > div {
  flex: 1;
}

.panic-overlay .request-response .response {
  margin-left: 2rem;
}

.panic-overlay .request-response h4 {
  background-color: rgb(195, 74, 37);
  color: white;
  font-size: 1.5rem;
  padding: 0.2rem 1rem;
}

.panic-overlay .request-response > div > div {
  margin: 1rem 1rem;
}

.panic-overlay .request-response pre {
  background-color: rgb(253, 248, 246);
  padding: 1rem 1rem;
  color: black;
}

.panic-overlay .request-response pre.open {
  max-height: auto;
}

.panic-overlay .request-response pre.preview {
  max-height: 13.5rem;
  overflow-y: auto;

  -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
  mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
}

@media only screen and (max-width: 640px) {
  .panic-overlay {
    font-size: 15px;
  }

  .panic-overlay h1 {
    margin: 40px 0;
  }
}
@media only screen and (max-width: 500px) {
  .panic-overlay {
    font-size: 14px;
  }

  .panic-overlay h1 {
    margin: 30px 0;
  }
}
`;
var Discourse = () => import_react.default.createElement(
  "a",
  {
    href: "https://community.redwoodjs.com",
    title: "Go to Redwood's Discourse server"
  },
  import_react.default.createElement(
    "svg",
    {
      className: "discourse",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32"
    },
    import_react.default.createElement("path", { d: "M16.1357143,0 C7.37857143,0 0,7.03571429 0,15.7214286 C0,16 0.00714285714,32 0.00714285714,32 L16.1357143,31.9857143 C24.9,31.9857143 32,24.6785714 32,15.9928571 C32,7.30714286 24.9,0 16.1357143,0 Z M16,25.1428571 C14.6142857,25.1428571 13.2928571,24.8357143 12.1142857,24.2785714 L6.32142857,25.7142857 L7.95714286,20.3571429 C7.25714286,19.0642857 6.85714286,17.5785714 6.85714286,16 C6.85714286,10.95 10.95,6.85714286 16,6.85714286 C21.05,6.85714286 25.1428571,10.95 25.1428571,16 C25.1428571,21.05 21.05,25.1428571 16,25.1428571 Z" })
  )
);
var Discord = () => import_react.default.createElement("a", { href: "https://discord.gg/redwoodjs", title: "Go to Redwood's Discord server" }, import_react.default.createElement("svg", { viewBox: "0 0 36 36", xmlns: "http://www.w3.org/2000/svg" }, import_react.default.createElement("path", { d: "M29.9699 7.7544C27.1043 5.44752 22.5705 5.05656 22.3761 5.04288C22.2284 5.03072 22.0806 5.0648 21.9531 5.1404C21.8257 5.216 21.7249 5.32937 21.6647 5.4648C21.5783 5.65936 21.5049 5.85949 21.4451 6.06384C23.3409 6.38424 25.6694 7.02864 27.7761 8.33616C27.8565 8.38604 27.9262 8.45126 27.9814 8.52809C28.0366 8.60493 28.0761 8.69187 28.0976 8.78397C28.1192 8.87607 28.1224 8.97151 28.1071 9.06485C28.0917 9.15819 28.0582 9.24759 28.0083 9.32796C27.9584 9.40833 27.8932 9.47809 27.8164 9.53325C27.7395 9.58842 27.6526 9.62791 27.5605 9.64947C27.4684 9.67103 27.373 9.67424 27.2796 9.65892C27.1863 9.6436 27.0969 9.61004 27.0165 9.56016C23.3949 7.3116 18.8719 7.2 17.9999 7.2C17.1287 7.2 12.6028 7.31232 8.98338 9.55944C8.90301 9.60932 8.81361 9.64288 8.72027 9.6582C8.62693 9.67352 8.53149 9.67031 8.43939 9.64875C8.25339 9.6052 8.09231 9.48955 7.99158 9.32724C7.89085 9.16493 7.85873 8.96925 7.90227 8.78325C7.94582 8.59725 8.06147 8.43617 8.22378 8.33544C10.3305 7.03152 12.659 6.38424 14.5547 6.06672C14.4453 5.7096 14.3459 5.48424 14.3387 5.4648C14.2788 5.32841 14.1776 5.2143 14.0493 5.13859C13.921 5.06288 13.7721 5.0294 13.6238 5.04288C13.4294 5.05728 8.89554 5.44752 5.99034 7.78536C4.47474 9.18792 1.43994 17.3894 1.43994 24.48C1.43994 24.6067 1.47378 24.7277 1.5357 24.8371C3.62802 28.5163 9.3405 29.4775 10.6423 29.52H10.6646C10.7782 29.5203 10.8903 29.4937 10.9916 29.4424C11.093 29.3911 11.1808 29.3165 11.2478 29.2248L12.5632 27.4133C9.01146 26.4967 7.19706 24.9386 7.09338 24.8458C6.95017 24.7194 6.86303 24.5412 6.85115 24.3506C6.83927 24.1599 6.90361 23.9723 7.03002 23.8291C7.15643 23.6859 7.33456 23.5988 7.52522 23.5869C7.71588 23.575 7.90345 23.6394 8.04666 23.7658C8.08842 23.8054 11.4299 26.64 17.9999 26.64C24.5807 26.64 27.9223 23.7938 27.9561 23.7658C28.0998 23.6403 28.2874 23.5769 28.4777 23.5896C28.668 23.6023 28.8456 23.69 28.9713 23.8334C29.0335 23.9042 29.0812 23.9864 29.1117 24.0756C29.1421 24.1647 29.1546 24.259 29.1486 24.353C29.1426 24.447 29.1181 24.5389 29.0766 24.6235C29.035 24.708 28.9772 24.7836 28.9065 24.8458C28.8028 24.9386 26.9884 26.4967 23.4367 27.4133L24.7528 29.2248C24.8198 29.3164 24.9074 29.3909 25.0087 29.4422C25.1099 29.4935 25.2218 29.5202 25.3353 29.52H25.3569C26.6601 29.4775 32.3719 28.5156 34.4649 24.8371C34.5261 24.7277 34.5599 24.6067 34.5599 24.48C34.5599 17.3894 31.5251 9.18864 29.9699 7.7544V7.7544ZM13.3199 21.6C11.9275 21.6 10.7999 20.3112 10.7999 18.72C10.7999 17.1288 11.9275 15.84 13.3199 15.84C14.7124 15.84 15.8399 17.1288 15.8399 18.72C15.8399 20.3112 14.7124 21.6 13.3199 21.6ZM22.6799 21.6C21.2875 21.6 20.1599 20.3112 20.1599 18.72C20.1599 17.1288 21.2875 15.84 22.6799 15.84C24.0724 15.84 25.1999 17.1288 25.1999 18.72C25.1999 20.3112 24.0724 21.6 22.6799 21.6Z" })));
export {
  DevFatalErrorPage
};
//# sourceMappingURL=@redwoodjs_web_dist_components_DevFatalErrorPage.js.map
