import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_react
} from "./chunk-52LGRYSO.js";
import {
  __publicField,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-QGZREBOA.js";

// ../node_modules/@redwoodjs/router/dist/history.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var createHistory = () => {
  const listeners = {};
  const blockers = [];
  let beforeUnloadListener = null;
  const history = {
    listen: (listener) => {
      const listenerId = "RW_HISTORY_LISTENER_ID_" + Date.now();
      listeners[listenerId] = listener;
      globalThis.addEventListener("popstate", listener);
      return listenerId;
    },
    navigate: (to, options) => {
      const performNavigation = () => {
        var _a, _b, _c, _d;
        const { pathname, search, hash } = new URL(
          ((_a = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _a.origin) + to
        );
        if (((_b = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _b.pathname) !== pathname || ((_c = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _c.search) !== search || ((_d = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _d.hash) !== hash) {
          if (options == null ? void 0 : options.replace) {
            globalThis.history.replaceState({}, "", to);
          } else {
            globalThis.history.pushState({}, "", to);
          }
        }
        for (const listener of Object.values(listeners)) {
          listener();
        }
      };
      if (blockers.length > 0) {
        processBlockers(0, performNavigation);
      } else {
        performNavigation();
      }
    },
    back: () => {
      const performBack = () => {
        globalThis.history.back();
        for (const listener of Object.values(listeners)) {
          listener();
        }
      };
      if (blockers.length > 0) {
        processBlockers(0, performBack);
      } else {
        performBack();
      }
    },
    remove: (listenerId) => {
      if (listeners[listenerId]) {
        const listener = listeners[listenerId];
        globalThis.removeEventListener("popstate", listener);
        delete listeners[listenerId];
      } else {
        console.warn(
          "History Listener with ID: " + listenerId + " does not exist."
        );
      }
    },
    block: (id, callback) => {
      const existingBlockerIndex = blockers.findIndex(
        (blocker) => blocker.id === id
      );
      if (existingBlockerIndex !== -1) {
        blockers[existingBlockerIndex] = { id, callback };
      } else {
        blockers.push({ id, callback });
        if (blockers.length === 1) {
          addBeforeUnloadListener();
        }
      }
    },
    unblock: (id) => {
      const index = blockers.findIndex((blocker) => blocker.id === id);
      if (index !== -1) {
        blockers.splice(index, 1);
        if (blockers.length === 0) {
          removeBeforeUnloadListener();
        }
      }
    }
  };
  const processBlockers = (index, navigate2) => {
    if (index < blockers.length) {
      blockers[index].callback({
        retry: () => processBlockers(index + 1, navigate2)
      });
    } else {
      navigate2();
    }
  };
  const addBeforeUnloadListener = () => {
    if (!beforeUnloadListener) {
      beforeUnloadListener = (event) => {
        if (blockers.length > 0) {
          event.preventDefault();
        }
      };
      globalThis.addEventListener("beforeunload", beforeUnloadListener);
    }
  };
  const removeBeforeUnloadListener = () => {
    if (beforeUnloadListener) {
      globalThis.removeEventListener("beforeunload", beforeUnloadListener);
      beforeUnloadListener = null;
    }
  };
  return history;
};
var gHistory = createHistory();
var { navigate, back, block, unblock } = gHistory;

// ../node_modules/@redwoodjs/router/dist/link.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var import_react = __toESM(require_react(), 1);
var Link = (0, import_react.forwardRef)(({ to, onClick, options, ...rest }, ref) => import_react.default.createElement(
  "a",
  {
    href: to,
    ref,
    ...rest,
    onClick: (event) => {
      if (event.button !== 0 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
        return;
      }
      event.preventDefault();
      if (onClick) {
        const result = onClick(event);
        if (typeof result !== "boolean" || result) {
          navigate(to, options);
        }
      } else {
        navigate(to, options);
      }
    }
  }
));

// ../node_modules/@redwoodjs/router/dist/location.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
var import_react3 = __toESM(require_react(), 1);

// ../node_modules/@redwoodjs/router/dist/createNamedContext.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
var import_react2 = __toESM(require_react(), 1);
function createNamedContext(name, defaultValue) {
  const Ctx = (0, import_react2.createContext)(defaultValue);
  Ctx.displayName = name;
  return Ctx;
}

// ../node_modules/@redwoodjs/router/dist/location.js
var LocationContext = createNamedContext("Location");
var LocationProvider = class extends import_react3.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "HISTORY_LISTENER_ID");
    __publicField(this, "state", {
      context: this.getContext()
    });
  }
  getContext() {
    let windowLocation;
    if (typeof window !== "undefined") {
      const { pathname } = window.location;
      switch (this.props.trailingSlashes) {
        case "never":
          if (pathname.endsWith("/")) {
            window.history.replaceState(
              {},
              "",
              pathname.substr(0, pathname.length - 1)
            );
          }
          break;
        case "always":
          if (!pathname.endsWith("/")) {
            window.history.replaceState({}, "", pathname + "/");
          }
          break;
        default:
          break;
      }
      windowLocation = new URL(window.location.href);
    }
    return this.props.location || this.context || windowLocation;
  }
  // componentDidMount() is not called during server rendering (aka SSR and
  // prerendering)
  componentDidMount() {
    this.HISTORY_LISTENER_ID = gHistory.listen(() => {
      const context = this.getContext();
      this.setState((lastState) => {
        var _a, _b;
        if ((context == null ? void 0 : context.pathname) !== ((_a = lastState == null ? void 0 : lastState.context) == null ? void 0 : _a.pathname) || (context == null ? void 0 : context.search) !== ((_b = lastState == null ? void 0 : lastState.context) == null ? void 0 : _b.search)) {
          globalThis == null ? void 0 : globalThis.scrollTo(0, 0);
        }
        return { context };
      });
    });
  }
  componentWillUnmount() {
    if (this.HISTORY_LISTENER_ID) {
      gHistory.remove(this.HISTORY_LISTENER_ID);
    }
  }
  render() {
    return import_react3.default.createElement(LocationContext.Provider, { value: this.state.context }, this.props.children);
  }
};
// When prerendering, there might be more than one level of location
// providers. Use the values from the one above.
// (this is basically the class component version of `useLocation()`)
__publicField(LocationProvider, "contextType", LocationContext);
var useLocation = () => {
  const location = import_react3.default.useContext(LocationContext);
  if (location === void 0) {
    throw new Error("useLocation must be used within a LocationProvider");
  }
  return location;
};

// ../node_modules/@redwoodjs/router/dist/util.js
var import_dist13 = __toESM(require_dist());
var import_dist14 = __toESM(require_dist2());
var import_dist15 = __toESM(require_dist3());
function paramsForRoute(route) {
  const params = [...route.matchAll(/\{([^}]+)\}/g)];
  return params.map((match) => match[1]).map((match) => {
    const parts = match.split(":");
    let name = parts[0];
    if (name.endsWith("...")) {
      name = name.slice(0, -3);
    }
    let type = parts[1];
    if (!type) {
      type = match.endsWith("...") ? "Glob" : "String";
    }
    return [name, type, `{${match}}`];
  });
}
var coreParamTypes = {
  String: {
    match: /[^/]+/
  },
  Int: {
    match: /\d+/,
    parse: Number
  },
  Float: {
    match: /[-+]?(?:\d*\.?\d+|\d+\.?\d*)(?:[eE][-+]?\d+)?/,
    parse: Number
  },
  Boolean: {
    match: /true|false/,
    parse: (boolAsString) => boolAsString === "true"
  },
  Glob: {
    match: /.*/
  }
};
function matchPath(routeDefinition, pathname, {
  userParamTypes,
  matchSubPaths
} = {
  userParamTypes: {},
  matchSubPaths: false
}) {
  const allParamTypes = { ...coreParamTypes, ...userParamTypes };
  const { matchRegex, routeParams: routeParamsDefinition } = getRouteRegexAndParams(routeDefinition, {
    matchSubPaths,
    allParamTypes
  });
  const matches = [...pathname.matchAll(matchRegex)];
  if (matches.length === 0) {
    return { match: false };
  }
  const providedParams = matches[0].slice(1);
  if (routeParamsDefinition.length > 0) {
    const params = providedParams.reduce(
      (acc, value, index) => {
        const [name, transformName] = routeParamsDefinition[index];
        const typeInfo = allParamTypes[transformName];
        let transformedValue = value;
        if (typeof (typeInfo == null ? void 0 : typeInfo.parse) === "function") {
          transformedValue = typeInfo.parse(value);
        }
        return {
          ...acc,
          [name]: transformedValue
        };
      },
      {}
    );
    return { match: true, params };
  }
  return { match: true };
}
function getRouteRegexAndParams(route, {
  matchSubPaths = false,
  allParamTypes = coreParamTypes
} = {}) {
  var _a;
  let typeMatchingRoute = route;
  const routeParams = paramsForRoute(route);
  for (const [_name, type, match] of routeParams) {
    const matcher = (_a = allParamTypes[type]) == null ? void 0 : _a.match;
    const typeRegexp = (matcher == null ? void 0 : matcher.source) || "[^/]+";
    typeMatchingRoute = typeMatchingRoute.replace(match, `(${typeRegexp})`);
  }
  const matchRegex = matchSubPaths ? new RegExp(`^${typeMatchingRoute}(?:/.*)?$`, "g") : new RegExp(`^${typeMatchingRoute}$`, "g");
  const matchRegexString = matchSubPaths ? `^${typeMatchingRoute}(?:/.*)?$` : `^${typeMatchingRoute}$`;
  return {
    matchRegex,
    routeParams,
    matchRegexString
  };
}
function parseSearch(search) {
  const searchParams = new URLSearchParams(search);
  return [...searchParams.keys()].reduce(
    (params, key) => ({
      ...params,
      [key]: searchParams.get(key)
    }),
    {}
  );
}
function replaceParams(route, args = {}) {
  const params = paramsForRoute(route);
  let path = route;
  params.forEach((param) => {
    const [name, _type, match] = param;
    const value = args[name];
    if (value !== void 0) {
      path = path.replace(match, value);
    } else {
      throw new Error(
        `Missing parameter '${name}' for route '${route}' when generating a navigation URL.`
      );
    }
  });
  const paramNames = params.map((param) => param[0]);
  const extraArgKeys = Object.keys(args).filter((x) => !paramNames.includes(x));
  const queryParams = [];
  extraArgKeys.forEach((key) => {
    queryParams.push(`${key}=${args[key]}`);
  });
  if (extraArgKeys.length) {
    const extraArgs = Object.fromEntries(
      extraArgKeys.map((key) => [key, `${args[key]}`])
    );
    path += `?${new URLSearchParams(extraArgs).toString()}`;
  }
  return path;
}
function flattenSearchParams(queryString) {
  const searchParams = [];
  for (const [key, value] of Object.entries(parseSearch(queryString))) {
    searchParams.push({ [key]: value });
  }
  return searchParams;
}

// ../node_modules/@redwoodjs/router/dist/useMatch.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);
var useMatch = (routePath, options) => {
  const location = useLocation();
  if (!location) {
    return { match: false };
  }
  if (options == null ? void 0 : options.searchParams) {
    const locationParams = new URLSearchParams(location.search);
    const hasUnmatched = options.searchParams.some((param) => {
      if (typeof param === "string") {
        return !locationParams.has(param);
      } else {
        return Object.keys(param).some(
          (key) => param[key] != locationParams.get(key)
        );
      }
    });
    if (hasUnmatched) {
      return { match: false };
    }
  }
  const matchInfo = matchPath(routePath, location.pathname, {
    matchSubPaths: options == null ? void 0 : options.matchSubPaths
  });
  if (!matchInfo.match) {
    return { match: false };
  }
  const routeParams = Object.entries((options == null ? void 0 : options.routeParams) || {});
  if (routeParams.length > 0) {
    if (!isMatchWithParams(matchInfo) || !matchInfo.params) {
      return { match: false };
    }
    const isParamMatch = routeParams.every(([key, value]) => {
      return matchInfo.params[key] === value;
    });
    if (!isParamMatch) {
      return { match: false };
    }
  }
  return matchInfo;
};
function isMatchWithParams(match) {
  return match !== null && typeof match === "object" && "params" in match;
}

// ../node_modules/@redwoodjs/router/dist/navLink.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
var import_react4 = __toESM(require_react(), 1);
var NavLink = (0, import_react4.forwardRef)(
  ({
    to,
    activeClassName,
    activeMatchParams,
    matchSubPaths,
    className,
    onClick,
    ...rest
  }, ref) => {
    const [pathname, queryString] = to.split("?");
    const searchParams = activeMatchParams || flattenSearchParams(queryString);
    const matchInfo = useMatch(pathname, {
      searchParams,
      matchSubPaths
    });
    return import_react4.default.createElement(
      Link,
      {
        ref,
        to,
        onClick,
        className: matchInfo.match ? activeClassName : className,
        ...rest
      }
    );
  }
);

// ../node_modules/@redwoodjs/router/dist/redirect.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);
var import_react5 = __toESM(require_react(), 1);
var Redirect = ({ to, options }) => {
  (0, import_react5.useEffect)(() => {
    navigate(to, options);
  }, [to, options]);
  return null;
};

// ../node_modules/@redwoodjs/router/dist/PageLoadingContext.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);
var import_react6 = __toESM(require_react(), 1);
var PageLoadingContext = createNamedContext("PageLoading");
var PageLoadingContextProvider = ({
  children,
  delay = 1e3
}) => {
  const [loading, setPageLoadingContext] = (0, import_react6.useState)(false);
  return import_react6.default.createElement(
    PageLoadingContext.Provider,
    {
      value: { loading, setPageLoadingContext, delay }
    },
    children
  );
};
var usePageLoadingContext = () => {
  const pageLoadingContext = (0, import_react6.useContext)(PageLoadingContext);
  if (!pageLoadingContext) {
    throw new Error(
      "usePageLoadingContext must be used within a PageLoadingContext provider"
    );
  }
  return pageLoadingContext;
};

// ../node_modules/@redwoodjs/router/dist/params.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);
var import_react7 = __toESM(require_react(), 1);
var ParamsContext = createNamedContext("Params");
var ParamsProvider = ({ allParams, children }) => {
  return import_react7.default.createElement(
    ParamsContext.Provider,
    {
      value: {
        params: {
          ...allParams
        }
      }
    },
    children
  );
};
var useParams = () => {
  const paramsContext = (0, import_react7.useContext)(ParamsContext);
  if (paramsContext === void 0) {
    throw new Error("useParams must be used within a ParamsProvider");
  }
  return paramsContext.params;
};

// ../node_modules/@redwoodjs/router/dist/Route.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
var import_react8 = __toESM(require_react(), 1);
function Route(_props) {
  return import_react8.default.createElement(import_react8.default.Fragment, null);
}

// ../node_modules/@redwoodjs/router/dist/route-validators.js
var import_dist34 = __toESM(require_dist());
var import_dist35 = __toESM(require_dist2());
var import_dist36 = __toESM(require_dist3());
var import_react9 = __toESM(require_react());
function isNodeTypeRoute(node) {
  return (0, import_react9.isValidElement)(node) && node.type === Route;
}
function isString(value) {
  return typeof value === "string";
}
function isValidRoute(node) {
  const isValidRouteElement = isNodeTypeRoute(node);
  if (isValidRouteElement) {
    const notFoundOrRedirect = node.props.notfound || node.props.redirect;
    const requiredKeys = [
      !node.props.notfound && "path",
      // redirects don't need an actual page, but notfound and standard do
      !node.props.redirect && "page",
      // Redirects can have names, but aren't required to
      !notFoundOrRedirect && "name"
    ].filter(isString);
    const missingKeys = requiredKeys.filter((key) => !(key in node.props));
    if (missingKeys.length > 0) {
      const stringToHelpIdentify = node.props.name || node.props.path ? `for "${node.props.name || node.props.path}" ` : "";
      throw new Error(
        `Route element ${stringToHelpIdentify}is missing required props: ` + missingKeys.join(", ")
      );
    }
  }
  return isValidRouteElement;
}

// ../node_modules/@redwoodjs/router/dist/Set.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);
var import_react10 = __toESM(require_react(), 1);
function Set(props) {
  return import_react10.default.createElement(import_react10.default.Fragment, null, props.children);
}
function Private(props) {
  return import_react10.default.createElement(import_react10.default.Fragment, null, props.children);
}
function PrivateSet(props) {
  return import_react10.default.createElement(import_react10.default.Fragment, null, props.children);
}
var isSetNode = (node) => {
  return import_react10.default.isValidElement(node) && (node.type === Set || node.type === PrivateSet || node.type === Private) && // Don't even bother including Sets without children. They're useless.
  node.props.children;
};
var isPrivateSetNode = (node) => {
  return import_react10.default.isValidElement(node) && node.type === PrivateSet;
};
var isPrivateNode = (node) => {
  return import_react10.default.isValidElement(node) && node.type === Private;
};

// ../node_modules/@redwoodjs/router/dist/route-announcement.js
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);
var import_react11 = __toESM(require_react(), 1);
var RouteAnnouncement = ({
  children,
  visuallyHidden = false,
  ...props
}) => {
  const hiddenStyle = {
    position: `absolute`,
    top: `0`,
    width: `1`,
    height: `1`,
    padding: `0`,
    overflow: `hidden`,
    clip: `rect(0, 0, 0, 0)`,
    whiteSpace: `nowrap`,
    border: `0`
  };
  return import_react11.default.createElement(
    "div",
    {
      ...props,
      "data-redwood-route-announcement": true,
      style: visuallyHidden ? hiddenStyle : {}
    },
    children
  );
};
var route_announcement_default = RouteAnnouncement;

// ../node_modules/@redwoodjs/router/dist/route-focus.js
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
var import_react12 = __toESM(require_react(), 1);
var RouteFocus = ({ children, ...props }) => import_react12.default.createElement("div", { ...props, "data-redwood-route-focus": true }, children);
var route_focus_default = RouteFocus;

// ../node_modules/@redwoodjs/router/dist/useRouteName.js
var import_dist88 = __toESM(require_dist(), 1);
var import_dist89 = __toESM(require_dist2(), 1);
var import_dist90 = __toESM(require_dist3(), 1);

// ../node_modules/@redwoodjs/router/dist/router-context.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);
var import_react13 = __toESM(require_react(), 1);
var RouterStateContext = (0, import_react13.createContext)(void 0);
var useRouterState = () => {
  const context = (0, import_react13.useContext)(RouterStateContext);
  if (context === void 0) {
    throw new Error(
      "useRouterState must be used within a RouterContextProvider"
    );
  }
  return context;
};

// ../node_modules/@redwoodjs/router/dist/index.js
var import_dist85 = __toESM(require_dist());
var import_dist86 = __toESM(require_dist2());
var import_dist87 = __toESM(require_dist3());

// ../node_modules/@redwoodjs/router/dist/router.js
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);
var import_react18 = __toESM(require_react(), 1);

// ../node_modules/@redwoodjs/router/dist/active-route-loader.js
var import_dist52 = __toESM(require_dist(), 1);
var import_dist53 = __toESM(require_dist2(), 1);
var import_dist54 = __toESM(require_dist3(), 1);
var import_react14 = __toESM(require_react(), 1);

// ../node_modules/@redwoodjs/router/dist/a11yUtils.js
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);

// ../node_modules/@redwoodjs/router/dist/active-route-loader.js
var isPrerendered = false;
if (typeof window !== "undefined") {
  const redwoodAppElement = document.getElementById("redwood-app");
  if (redwoodAppElement && redwoodAppElement.children.length > 0) {
    isPrerendered = true;
  }
}

// ../node_modules/@redwoodjs/router/dist/analyzeRoutes.js
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);
var import_react15 = __toESM(require_react(), 1);

// ../node_modules/@redwoodjs/router/dist/AuthenticatedRoute.js
var import_dist61 = __toESM(require_dist(), 1);
var import_dist62 = __toESM(require_dist2(), 1);
var import_dist63 = __toESM(require_dist3(), 1);
var import_react16 = __toESM(require_react(), 1);

// ../node_modules/@redwoodjs/router/dist/namedRoutes.js
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);
var namedRoutes = {};

// ../node_modules/@redwoodjs/router/dist/AuthenticatedRoute.js
var AuthenticatedRoute = ({
  unauthenticated,
  roles,
  whileLoadingAuth,
  children
}) => {
  const routerState = useRouterState();
  const {
    loading: authLoading,
    isAuthenticated,
    hasRole
  } = routerState.useAuth();
  const unauthorized = (0, import_react16.useCallback)(() => {
    return !(isAuthenticated && (!roles || hasRole(roles)));
  }, [isAuthenticated, roles, hasRole]);
  if (unauthorized()) {
    if (authLoading) {
      return (whileLoadingAuth == null ? void 0 : whileLoadingAuth()) || null;
    } else {
      const currentLocation = globalThis.location.pathname + encodeURIComponent(globalThis.location.search);
      const generatedRoutesMap = namedRoutes;
      if (!generatedRoutesMap[unauthenticated]) {
        throw new Error(`We could not find a route named ${unauthenticated}`);
      }
      let unauthenticatedPath;
      try {
        unauthenticatedPath = generatedRoutesMap[unauthenticated]();
      } catch (e) {
        if (e instanceof Error && /Missing parameter .* for route/.test(e.message)) {
          throw new Error(
            `Redirecting to route "${unauthenticated}" would require route parameters, which currently is not supported. Please choose a different route`
          );
        }
        throw new Error(
          `Could not redirect to the route named ${unauthenticated}`
        );
      }
      return import_react16.default.createElement(Redirect, { to: `${unauthenticatedPath}?redirectTo=${currentLocation}` });
    }
  }
  return import_react16.default.createElement(import_react16.default.Fragment, null, children);
};

// ../node_modules/@redwoodjs/router/dist/page.js
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);

// ../node_modules/@redwoodjs/router/dist/splash-page.js
var import_dist67 = __toESM(require_dist(), 1);
var import_dist68 = __toESM(require_dist2(), 1);
var import_dist69 = __toESM(require_dist3(), 1);
var import_react17 = __toESM(require_react(), 1);

// ../node_modules/@redwoodjs/router/dist/router.js
var WrappedPage = (0, import_react18.memo)(({ sets, children }) => {
  if (!sets || sets.length === 0) {
    return children;
  }
  return sets.reduceRight((acc, set) => {
    let wrapped = set.wrappers.reduceRight((acc2, Wrapper, index) => {
      return import_react18.default.createElement(
        Wrapper,
        { ...set.props, key: set.id + "-" + index },
        acc2
      );
    }, acc);
    if (set.isPrivate) {
      const unauthenticated = set.props.unauthenticated;
      if (!unauthenticated || typeof unauthenticated !== "string") {
        throw new Error(
          "You must specify an `unauthenticated` route when using PrivateSet"
        );
      }
      wrapped = import_react18.default.createElement(AuthenticatedRoute, { ...set.props, unauthenticated }, wrapped);
    }
    return wrapped;
  }, children);
});

// ../node_modules/@redwoodjs/router/dist/useRoutePaths.js
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);
function useRoutePaths() {
  const routerState = useRouterState();
  const routePaths = Object.values(routerState.routes.pathRouteMap).reduce((routePathsAcc, currRoute) => {
    if (currRoute.name) {
      routePathsAcc[currRoute.name] = currRoute.path;
    }
    return routePathsAcc;
  }, {});
  return routePaths;
}
function useRoutePath(routeName) {
  const currentRouteName = useRouteName();
  const routePaths = useRoutePaths();
  const name = routeName || currentRouteName;
  if (!name) {
    return void 0;
  }
  return routePaths[name];
}

// ../node_modules/@redwoodjs/router/dist/useBlocker.js
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);
var import_react19 = __toESM(require_react(), 1);
function useBlocker({ when }) {
  const [blockerState, setBlockerState] = (0, import_react19.useState)("IDLE");
  const [pendingNavigation, setPendingNavigation] = (0, import_react19.useState)(null);
  const blockerId = (0, import_react19.useId)();
  const blocker = (0, import_react19.useCallback)(
    ({ retry }) => {
      if (when) {
        setBlockerState("BLOCKED");
        setPendingNavigation(() => retry);
      } else {
        retry();
      }
    },
    [when]
  );
  (0, import_react19.useEffect)(() => {
    if (when) {
      block(blockerId, blocker);
    } else {
      unblock(blockerId);
    }
    return () => unblock(blockerId);
  }, [when, blocker, blockerId]);
  const confirm = (0, import_react19.useCallback)(() => {
    setBlockerState("IDLE");
    if (pendingNavigation) {
      pendingNavigation();
      setPendingNavigation(null);
    }
  }, [pendingNavigation]);
  const abort = (0, import_react19.useCallback)(() => {
    setBlockerState("IDLE");
    setPendingNavigation(null);
  }, []);
  return { state: blockerState, confirm, abort };
}

// ../node_modules/@redwoodjs/router/dist/skipNav.js
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);
var React15 = __toESM(require_react(), 1);
var defaultId = "reach-skip-nav";
var SkipNavLink = React15.forwardRef(function SkipNavLink2({ as: Comp = "a", children = "Skip to content", contentId, ...props }, forwardedRef) {
  const id = contentId || defaultId;
  return React15.createElement(
    Comp,
    {
      ...props,
      ref: forwardedRef,
      href: `#${id}`,
      "data-reach-skip-link": "",
      "data-reach-skip-nav-link": ""
    },
    children
  );
});
SkipNavLink.displayName = "SkipNavLink";
var SkipNavContent = React15.forwardRef(function SkipNavContent2({ as: Comp = "div", id: idProp, ...props }, forwardedRef) {
  const id = idProp || defaultId;
  return React15.createElement(
    Comp,
    {
      ...props,
      ref: forwardedRef,
      id,
      "data-reach-skip-nav-content": ""
    }
  );
});
SkipNavContent.displayName = "SkipNavContent";

// ../node_modules/@redwoodjs/router/dist/routeParamsTypes.js
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);

// ../node_modules/@redwoodjs/router/dist/useRouteName.js
function useRouteName() {
  const routerState = useRouterState();
  const routeName = routerState.activeRouteName;
  if (isAvailableRouteName(routeName)) {
    return routeName;
  }
  return void 0;
}
function isAvailableRouteName(name) {
  return typeof name === "string" && Object.keys(namedRoutes).includes(name);
}

export {
  navigate,
  back,
  Link,
  LocationProvider,
  useLocation,
  matchPath,
  getRouteRegexAndParams,
  parseSearch,
  replaceParams,
  useMatch,
  NavLink,
  Redirect,
  PageLoadingContextProvider,
  usePageLoadingContext,
  ParamsContext,
  ParamsProvider,
  useParams,
  Route,
  isValidRoute,
  Set,
  Private,
  PrivateSet,
  isSetNode,
  isPrivateSetNode,
  isPrivateNode,
  route_announcement_default,
  route_focus_default,
  useRouteName,
  useRoutePaths,
  useRoutePath,
  useBlocker,
  SkipNavLink,
  SkipNavContent
};
//# sourceMappingURL=chunk-7QZKDWBI.js.map
