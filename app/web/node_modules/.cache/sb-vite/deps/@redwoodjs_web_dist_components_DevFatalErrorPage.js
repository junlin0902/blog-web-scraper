import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_source_map
} from "./chunk-MFO3K2NQ.js";
import {
  require_react
} from "./chunk-52LGRYSO.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-QGZREBOA.js";

// ../node_modules/get-source/impl/SyncPromise.js
var require_SyncPromise = __commonJS({
  "../node_modules/get-source/impl/SyncPromise.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports = class SyncPromise {
      constructor(fn) {
        try {
          fn(
            (x) => {
              this.setValue(x, false);
            },
            // resolve
            (x) => {
              this.setValue(x, true);
            }
            // reject
          );
        } catch (e) {
          this.setValue(e, true);
        }
      }
      setValue(x, rejected) {
        this.val = x instanceof SyncPromise ? x.val : x;
        this.rejected = rejected || (x instanceof SyncPromise ? x.rejected : false);
      }
      static valueFrom(x) {
        if (x instanceof SyncPromise) {
          if (x.rejected) throw x.val;
          else return x.val;
        } else {
          return x;
        }
      }
      then(fn) {
        try {
          if (!this.rejected) return SyncPromise.resolve(fn(this.val));
        } catch (e) {
          return SyncPromise.reject(e);
        }
        return this;
      }
      catch(fn) {
        try {
          if (this.rejected) return SyncPromise.resolve(fn(this.val));
        } catch (e) {
          return SyncPromise.reject(e);
        }
        return this;
      }
      static resolve(x) {
        return new SyncPromise((resolve) => {
          resolve(x);
        });
      }
      static reject(x) {
        return new SyncPromise((_, reject) => {
          reject(x);
        });
      }
    };
  }
});

// ../node_modules/get-source/impl/path.js
var require_path = __commonJS({
  "../node_modules/get-source/impl/path.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var isBrowser = typeof window !== "undefined" && window.window === window && window.navigator;
    var cwd = isBrowser ? window.location.href : process.cwd();
    var urlRegexp = new RegExp("^((https|http)://)?[a-z0-9A-Z]{3}.[a-z0-9A-Z][a-z0-9A-Z]{0,61}?[a-z0-9A-Z].com|net|cn|cc (:s[0-9]{1-4})?/$");
    var path = module.exports = {
      concat(a, b) {
        const a_endsWithSlash = a[a.length - 1] === "/", b_startsWithSlash = b[0] === "/";
        return a + (a_endsWithSlash || b_startsWithSlash ? "" : "/") + (a_endsWithSlash && b_startsWithSlash ? b.substring(1) : b);
      },
      resolve(x) {
        if (path.isAbsolute(x)) {
          return path.normalize(x);
        }
        return path.normalize(path.concat(cwd, x));
      },
      normalize(x) {
        let output = [], skip = 0;
        x.split("/").reverse().filter((x2) => x2 !== ".").forEach((x2) => {
          if (x2 === "..") {
            skip++;
          } else if (skip === 0) {
            output.push(x2);
          } else {
            skip--;
          }
        });
        const result = output.reverse().join("/");
        return (isBrowser && result[0] === "/" ? result[1] === "/" ? window.location.protocol : window.location.origin : "") + result;
      },
      isData: (x) => x.indexOf("data:") === 0,
      isURL: (x) => urlRegexp.test(x),
      isAbsolute: (x) => x[0] === "/" || /^[^\/]*:/.test(x),
      relativeToFile(a, b) {
        return path.isData(a) || path.isAbsolute(b) ? path.normalize(b) : path.normalize(path.concat(a.split("/").slice(0, -1).join("/"), b));
      }
    };
  }
});

// ../node_modules/data-uri-to-buffer/index.js
var require_data_uri_to_buffer = __commonJS({
  "../node_modules/data-uri-to-buffer/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports = dataUriToBuffer;
    function dataUriToBuffer(uri) {
      if (!/^data\:/i.test(uri)) {
        throw new TypeError(
          '`uri` does not appear to be a Data URI (must begin with "data:")'
        );
      }
      uri = uri.replace(/\r?\n/g, "");
      var firstComma = uri.indexOf(",");
      if (-1 === firstComma || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      var meta = uri.substring(5, firstComma).split(";");
      var type = meta[0] || "text/plain";
      var typeFull = type;
      var base64 = false;
      var charset = "";
      for (var i = 1; i < meta.length; i++) {
        if ("base64" == meta[i]) {
          base64 = true;
        } else {
          typeFull += ";" + meta[i];
          if (0 == meta[i].indexOf("charset=")) {
            charset = meta[i].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      var data = unescape(uri.substring(firstComma + 1));
      var encoding = base64 ? "base64" : "ascii";
      var buffer = Buffer.from ? Buffer.from(data, encoding) : new Buffer(data, encoding);
      buffer.type = type;
      buffer.typeFull = typeFull;
      buffer.charset = charset;
      return buffer;
    }
  }
});

// ../node_modules/get-source/get-source.js
var require_get_source = __commonJS({
  "../node_modules/get-source/get-source.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var { assign } = Object;
    var isBrowser = typeof window !== "undefined" && window.window === window && window.navigator;
    var SourceMapConsumer = require_source_map().SourceMapConsumer;
    var SyncPromise = require_SyncPromise();
    var path = require_path();
    var dataURIToBuffer = require_data_uri_to_buffer();
    var nodeRequire = isBrowser ? null : module.require;
    var memoize = (f) => {
      const m = (x) => x in m.cache ? m.cache[x] : m.cache[x] = f(x);
      m.forgetEverything = () => {
        m.cache = /* @__PURE__ */ Object.create(null);
      };
      m.cache = /* @__PURE__ */ Object.create(null);
      return m;
    };
    function impl(fetchFile, sync) {
      const PromiseImpl = sync ? SyncPromise : Promise;
      const SourceFileMemoized = memoize((path2) => SourceFile(path2, fetchFile(path2)));
      function SourceFile(srcPath, text) {
        if (text === void 0) return SourceFileMemoized(path.resolve(srcPath));
        return PromiseImpl.resolve(text).then((text2) => {
          let file;
          let lines;
          let resolver;
          let _resolve = (loc) => (resolver = resolver || SourceMapResolverFromFetchedFile(file))(loc);
          return file = {
            path: srcPath,
            text: text2,
            get lines() {
              return lines = lines || text2.split("\n");
            },
            resolve(loc) {
              const result = _resolve(loc);
              if (sync) {
                try {
                  return SyncPromise.valueFrom(result);
                } catch (e) {
                  return assign({}, loc, { error: e });
                }
              } else {
                return Promise.resolve(result);
              }
            },
            _resolve
          };
        });
      }
      function SourceMapResolverFromFetchedFile(file) {
        const re = /\u0023 sourceMappingURL=(.+)\n?/g;
        let lastMatch = void 0;
        while (true) {
          const match = re.exec(file.text);
          if (match) lastMatch = match;
          else break;
        }
        const url = lastMatch && lastMatch[1];
        const defaultResolver = (loc) => assign({}, loc, {
          sourceFile: file,
          sourceLine: file.lines[loc.line - 1] || ""
        });
        return url ? SourceMapResolver(file.path, url, defaultResolver) : defaultResolver;
      }
      function SourceMapResolver(originalFilePath, sourceMapPath, fallbackResolve) {
        const srcFile = sourceMapPath.startsWith("data:") ? SourceFile(originalFilePath, dataURIToBuffer(sourceMapPath).toString()) : SourceFile(path.relativeToFile(originalFilePath, sourceMapPath));
        const parsedMap = srcFile.then((f) => SourceMapConsumer(JSON.parse(f.text)));
        const sourceFor = memoize(function sourceFor2(filePath) {
          return srcFile.then((f) => {
            const fullPath = path.relativeToFile(f.path, filePath);
            return parsedMap.then((x) => SourceFile(
              fullPath,
              x.sourceContentFor(
                filePath,
                true
                /* return null on missing */
              ) || void 0
            ));
          });
        });
        return (loc) => parsedMap.then((x) => {
          const originalLoc = x.originalPositionFor(loc);
          return originalLoc.source ? sourceFor(originalLoc.source).then(
            (x2) => x2._resolve(assign({}, loc, {
              line: originalLoc.line,
              column: originalLoc.column + 1,
              name: originalLoc.name
            }))
          ) : fallbackResolve(loc);
        }).catch((e) => assign(fallbackResolve(loc), { sourceMapError: e }));
      }
      return assign(function getSource(path2) {
        const file = SourceFile(path2);
        if (sync) {
          try {
            return SyncPromise.valueFrom(file);
          } catch (e) {
            const noFile = {
              path: path2,
              text: "",
              lines: [],
              error: e,
              resolve(loc) {
                return assign({}, loc, { error: e, sourceLine: "", sourceFile: noFile });
              }
            };
            return noFile;
          }
        }
        return file;
      }, {
        resetCache: () => SourceFileMemoized.forgetEverything(),
        getCache: () => SourceFileMemoized.cache
      });
    }
    module.exports = impl(function fetchFileSync(path2) {
      return new SyncPromise((resolve) => {
        if (isBrowser) {
          let xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path2,
            false
            /* SYNCHRONOUS XHR FTW :) */
          );
          xhr.send(null);
          resolve(xhr.responseText);
        } else {
          resolve(nodeRequire("fs").readFileSync(path2, { encoding: "utf8" }));
        }
      });
    }, true);
    module.exports.async = impl(function fetchFileAsync(path2) {
      return new Promise((resolve, reject) => {
        if (isBrowser) {
          let xhr = new XMLHttpRequest();
          xhr.open("GET", path2);
          xhr.onreadystatechange = (event) => {
            if (xhr.readyState === 4) {
              if (xhr.status === 200) {
                resolve(xhr.responseText);
              } else {
                reject(new Error(xhr.statusText));
              }
            }
          };
          xhr.send(null);
        } else {
          nodeRequire("fs").readFile(path2, { encoding: "utf8" }, (e, x) => {
            e ? reject(e) : resolve(x);
          });
        }
      });
    });
  }
});

// ../node_modules/stacktracey/impl/partition.js
var require_partition = __commonJS({
  "../node_modules/stacktracey/impl/partition.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports = (arr_, pred) => {
      const arr = arr_ || [], spans = [];
      let span = {
        label: void 0,
        items: [arr.first]
      };
      arr.forEach((x) => {
        const label = pred(x);
        if (span.label !== label && span.items.length) {
          spans.push(span = { label, items: [x] });
        } else {
          span.items.push(x);
        }
      });
      return spans;
    };
  }
});

// ../node_modules/printable-characters/build/printable-characters.js
var require_printable_characters = __commonJS({
  "../node_modules/printable-characters/build/printable-characters.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var _slicedToArray = /* @__PURE__ */ function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var ansiEscapeCode = "[\x1B][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]";
    var zeroWidthCharacterExceptNewline = "\0-\b\v-\x1B­​\u2028\u2029\uFEFF︀-️";
    var zeroWidthCharacter = "\n" + zeroWidthCharacterExceptNewline;
    var zeroWidthCharactersExceptNewline = new RegExp("(?:" + ansiEscapeCode + ")|[" + zeroWidthCharacterExceptNewline + "]", "g");
    var zeroWidthCharacters = new RegExp("(?:" + ansiEscapeCode + ")|[" + zeroWidthCharacter + "]", "g");
    var partition = new RegExp("((?:" + ansiEscapeCode + ")|[	" + zeroWidthCharacter + "])?([^	" + zeroWidthCharacter + "]*)", "g");
    module.exports = {
      zeroWidthCharacters,
      ansiEscapeCodes: new RegExp(ansiEscapeCode, "g"),
      strlen: (s) => Array.from(s.replace(zeroWidthCharacters, "")).length,
      // Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two
      isBlank: (s) => s.replace(zeroWidthCharacters, "").replace(/\s/g, "").length === 0,
      blank: (s) => Array.from(s.replace(zeroWidthCharactersExceptNewline, "")).map((x) => x === "	" || x === "\n" ? x : " ").join(""),
      partition(s) {
        for (var m, spans = []; partition.lastIndex !== s.length && (m = partition.exec(s)); ) {
          spans.push([m[1] || "", m[2]]);
        }
        partition.lastIndex = 0;
        return spans;
      },
      first(s, n) {
        let result = "", length = 0;
        for (const _ref of module.exports.partition(s)) {
          var _ref2 = _slicedToArray(_ref, 2);
          const nonPrintable = _ref2[0];
          const printable = _ref2[1];
          const text = Array.from(printable).slice(0, n - length);
          result += nonPrintable + text.join("");
          length += text.length;
        }
        return result;
      }
    };
  }
});

// ../node_modules/as-table/build/as-table.js
var require_as_table = __commonJS({
  "../node_modules/as-table/build/as-table.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var O = Object;
    var _require = require_printable_characters();
    var first = _require.first;
    var strlen = _require.strlen;
    var limit = (s, n) => first(s, n - 1) + "…";
    var asColumns = (rows, cfg_) => {
      const zip = (arrs, f) => arrs.reduce((a, b) => b.map((b2, i) => [].concat(_toConsumableArray(a[i] || []), [b2])), []).map((args) => f.apply(void 0, _toConsumableArray(args))), cells = rows.map((r) => r.map((c) => c.replace(/\n/g, "\\n"))), cellWidths = cells.map((r) => r.map(strlen)), maxWidths = zip(cellWidths, Math.max), cfg = O.assign({
        delimiter: "  ",
        minColumnWidths: maxWidths.map((x) => 0),
        maxTotalWidth: 0
      }, cfg_), delimiterLength = strlen(cfg.delimiter), totalWidth = maxWidths.reduce((a, b) => a + b, 0), relativeWidths = maxWidths.map((w) => w / totalWidth), maxTotalWidth = cfg.maxTotalWidth - delimiterLength * (maxWidths.length - 1), excessWidth = Math.max(0, totalWidth - maxTotalWidth), computedWidths = zip([cfg.minColumnWidths, maxWidths, relativeWidths], (min, max, relative) => Math.max(min, Math.floor(max - excessWidth * relative))), restCellWidths = cellWidths.map((widths) => zip([computedWidths, widths], (a, b) => a - b));
      return zip([cells, restCellWidths], (a, b) => zip([a, b], (str, w) => w >= 0 ? cfg.right ? " ".repeat(w) + str : str + " ".repeat(w) : limit(str, strlen(str) + w)).join(cfg.delimiter));
    };
    var asTable = (cfg) => O.assign((arr) => {
      var _ref;
      if (arr[0] && Array.isArray(arr[0])) {
        return asColumns(arr.map((r) => r.map((c, i) => c === void 0 ? "" : cfg.print(c, i))), cfg).join("\n");
      }
      const colNames = [].concat(_toConsumableArray(new Set((_ref = []).concat.apply(_ref, _toConsumableArray(arr.map(O.keys)))))), columns = [colNames.map(cfg.title)].concat(_toConsumableArray(arr.map((o) => colNames.map((key) => o[key] === void 0 ? "" : cfg.print(o[key], key))))), lines = asColumns(columns, cfg);
      return (cfg.dash ? [lines[0], cfg.dash.repeat(strlen(lines[0]))].concat(_toConsumableArray(lines.slice(1))) : lines).join("\n");
    }, cfg, {
      configure: (newConfig) => asTable(O.assign({}, cfg, newConfig))
    });
    module.exports = asTable({
      maxTotalWidth: Number.MAX_SAFE_INTEGER,
      print: String,
      title: String,
      dash: "-",
      right: false
    });
  }
});

// ../node_modules/stacktracey/stacktracey.js
var require_stacktracey = __commonJS({
  "../node_modules/stacktracey/stacktracey.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var O = Object;
    var isBrowser = typeof window !== "undefined" && window.window === window && window.navigator;
    var nodeRequire = isBrowser ? null : module.require;
    var lastOf = (x) => x[x.length - 1];
    var getSource = require_get_source();
    var partition = require_partition();
    var asTable = require_as_table();
    var nixSlashes = (x) => x.replace(/\\/g, "/");
    var pathRoot = isBrowser ? window.location.href : nixSlashes(process.cwd()) + "/";
    var StackTracey2 = class _StackTracey {
      constructor(input, offset) {
        const originalInput = input, isParseableSyntaxError = input && (input instanceof SyntaxError && !isBrowser);
        if (!input) {
          input = new Error();
          offset = offset === void 0 ? 1 : offset;
        }
        if (input instanceof Error) {
          input = input.stack || "";
        }
        if (typeof input === "string") {
          input = this.rawParse(input).slice(offset).map((x) => this.extractEntryMetadata(x));
        }
        if (Array.isArray(input)) {
          if (isParseableSyntaxError) {
            const rawLines = nodeRequire("util").inspect(originalInput).split("\n"), fileLine = rawLines[0].split(":"), line = fileLine.pop(), file = fileLine.join(":");
            if (file) {
              input.unshift({
                file: nixSlashes(file),
                line,
                column: (rawLines[2] || "").indexOf("^") + 1,
                sourceLine: rawLines[1],
                callee: "(syntax error)",
                syntaxError: true
              });
            }
          }
          this.items = input;
        } else {
          this.items = [];
        }
      }
      extractEntryMetadata(e) {
        const decomposedPath = this.decomposePath(e.file || "");
        const fileRelative = decomposedPath[0];
        const externalDomain = decomposedPath[1];
        return O.assign(e, {
          calleeShort: e.calleeShort || lastOf((e.callee || "").split(".")),
          fileRelative,
          fileShort: this.shortenPath(fileRelative),
          fileName: lastOf((e.file || "").split("/")),
          thirdParty: this.isThirdParty(fileRelative, externalDomain) && !e.index,
          externalDomain
        });
      }
      shortenPath(relativePath) {
        return relativePath.replace(/^node_modules\//, "").replace(/^webpack\/bootstrap\//, "").replace(/^__parcel_source_root\//, "");
      }
      decomposePath(fullPath) {
        let result = fullPath;
        if (isBrowser) result = result.replace(pathRoot, "");
        const externalDomainMatch = result.match(/^(http|https)\:\/\/?([^\/]+)\/(.*)/);
        const externalDomain = externalDomainMatch ? externalDomainMatch[2] : void 0;
        result = externalDomainMatch ? externalDomainMatch[3] : result;
        if (!isBrowser) result = nodeRequire("path").relative(pathRoot, result);
        return [
          nixSlashes(result).replace(/^.*\:\/\/?\/?/, ""),
          // cut webpack:/// and webpack:/ things
          externalDomain
        ];
      }
      isThirdParty(relativePath, externalDomain) {
        return externalDomain || relativePath[0] === "~" || // webpack-specific heuristic
        relativePath[0] === "/" || // external source
        relativePath.indexOf("node_modules") === 0 || relativePath.indexOf("webpack/bootstrap") === 0;
      }
      rawParse(str) {
        const lines = (str || "").split("\n");
        const entries = lines.map((line) => {
          line = line.trim();
          let callee, fileLineColumn = [], native, planA, planB;
          if ((planA = line.match(/at (.+) \(eval at .+ \((.+)\), .+\)/)) || // eval calls
          (planA = line.match(/at (.+) \((.+)\)/)) || line.slice(0, 3) !== "at " && (planA = line.match(/(.*)@(.*)/))) {
            callee = planA[1];
            native = planA[2] === "native";
            fileLineColumn = (planA[2].match(/(.*):(\d+):(\d+)/) || planA[2].match(/(.*):(\d+)/) || []).slice(1);
          } else if (planB = line.match(/^(at\s+)*(.+):(\d+):(\d+)/)) {
            fileLineColumn = planB.slice(2);
          } else {
            return void 0;
          }
          if (callee && !fileLineColumn[0]) {
            const type = callee.split(".")[0];
            if (type === "Array") {
              native = true;
            }
          }
          return {
            beforeParse: line,
            callee: callee || "",
            index: isBrowser && fileLineColumn[0] === window.location.href,
            native: native || false,
            file: nixSlashes(fileLineColumn[0] || ""),
            line: parseInt(fileLineColumn[1] || "", 10) || void 0,
            column: parseInt(fileLineColumn[2] || "", 10) || void 0
          };
        });
        return entries.filter((x) => x !== void 0);
      }
      withSourceAt(i) {
        return this.items[i] && this.withSource(this.items[i]);
      }
      withSourceAsyncAt(i) {
        return this.items[i] && this.withSourceAsync(this.items[i]);
      }
      withSource(loc) {
        if (this.shouldSkipResolving(loc)) {
          return loc;
        } else {
          let resolved = getSource(loc.file || "").resolve(loc);
          if (!resolved.sourceFile) {
            return loc;
          }
          return this.withSourceResolved(loc, resolved);
        }
      }
      withSourceAsync(loc) {
        if (this.shouldSkipResolving(loc)) {
          return Promise.resolve(loc);
        } else {
          return getSource.async(loc.file || "").then((x) => x.resolve(loc)).then((resolved) => this.withSourceResolved(loc, resolved)).catch((e) => this.withSourceResolved(loc, { error: e, sourceLine: "" }));
        }
      }
      shouldSkipResolving(loc) {
        return loc.sourceFile || loc.error || loc.file && loc.file.indexOf("<") >= 0;
      }
      withSourceResolved(loc, resolved) {
        if (resolved.sourceFile && !resolved.sourceFile.error) {
          resolved.file = nixSlashes(resolved.sourceFile.path);
          resolved = this.extractEntryMetadata(resolved);
        }
        if (resolved.sourceLine.includes("// @hide")) {
          resolved.sourceLine = resolved.sourceLine.replace("// @hide", "");
          resolved.hide = true;
        }
        if (resolved.sourceLine.includes("__webpack_require__") || // webpack-specific heuristics
        resolved.sourceLine.includes("/******/ ({")) {
          resolved.thirdParty = true;
        }
        return O.assign({ sourceLine: "" }, loc, resolved);
      }
      withSources() {
        return this.map((x) => this.withSource(x));
      }
      withSourcesAsync() {
        return Promise.all(this.items.map((x) => this.withSourceAsync(x))).then((items) => new _StackTracey(items));
      }
      mergeRepeatedLines() {
        return new _StackTracey(
          partition(this.items, (e) => e.file + e.line).map(
            (group) => {
              return group.items.slice(1).reduce((memo, entry) => {
                memo.callee = (memo.callee || "<anonymous>") + " → " + (entry.callee || "<anonymous>");
                memo.calleeShort = (memo.calleeShort || "<anonymous>") + " → " + (entry.calleeShort || "<anonymous>");
                return memo;
              }, O.assign({}, group.items[0]));
            }
          )
        );
      }
      clean() {
        const s = this.withSources().mergeRepeatedLines();
        return s.filter(s.isClean.bind(s));
      }
      cleanAsync() {
        return this.withSourcesAsync().then((s) => {
          s = s.mergeRepeatedLines();
          return s.filter(s.isClean.bind(s));
        });
      }
      isClean(entry, index) {
        return index === 0 || !(entry.thirdParty || entry.hide || entry.native);
      }
      at(i) {
        return O.assign({
          beforeParse: "",
          callee: "<???>",
          index: false,
          native: false,
          file: "<???>",
          line: 0,
          column: 0
        }, this.items[i]);
      }
      asTable(opts) {
        const maxColumnWidths = opts && opts.maxColumnWidths || this.maxColumnWidths();
        const trimEnd = (s, n) => s && (s.length > n ? s.slice(0, n - 1) + "…" : s);
        const trimStart = (s, n) => s && (s.length > n ? "…" + s.slice(-(n - 1)) : s);
        const trimmed = this.map(
          (e) => [
            "at " + trimEnd(e.calleeShort, maxColumnWidths.callee),
            trimStart(e.fileShort && e.fileShort + ":" + e.line || "", maxColumnWidths.file),
            trimEnd((e.sourceLine || "").trim() || "", maxColumnWidths.sourceLine)
          ]
        );
        return asTable(trimmed.items);
      }
      maxColumnWidths() {
        return {
          callee: 30,
          file: 60,
          sourceLine: 80
        };
      }
      static resetCache() {
        getSource.resetCache();
        getSource.async.resetCache();
      }
      static locationsEqual(a, b) {
        return a.file === b.file && a.line === b.line && a.column === b.column;
      }
    };
    ["map", "filter", "slice", "concat"].forEach((method) => {
      StackTracey2.prototype[method] = function() {
        return new StackTracey2(this.items[method].apply(this.items, arguments));
      };
    });
    module.exports = StackTracey2;
  }
});

// ../node_modules/@redwoodjs/web/dist/components/DevFatalErrorPage.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var import_react = __toESM(require_react());
var import_stacktracey = __toESM(require_stacktracey());
var srcRoot = "";
if (typeof RWJS_DEBUG_ENV !== "undefined") {
  srcRoot = RWJS_DEBUG_ENV == null ? void 0 : RWJS_DEBUG_ENV.RWJS_SRC_ROOT;
}
var appRoot;
if (/^[A-Z]:\\/.test(srcRoot)) {
  appRoot = srcRoot.substring(3).replace(/\\/g, "/");
} else {
  appRoot = srcRoot.substring(1);
}
var DevFatalErrorPage = (props) => {
  var _a;
  if (!props.error) {
    return import_react.default.createElement("h3", null, "Could not render the error page due to a missing error, please see the console for more details.");
  }
  const err = props.error;
  const stack = new import_stacktracey.default(err).withSources();
  const typeName = String(
    err["type"] || ((_a = err.constructor) == null ? void 0 : _a.name) || typeof err
  );
  const msg = String(err && err.message);
  const FileRef = stack.items[0] ? import_react.default.createElement("a", { href: toVSCodeURL(stack.items[0]) }, stack.items[0].fileName) : null;
  return import_react.default.createElement("main", { className: "error-page" }, import_react.default.createElement(
    "style",
    {
      dangerouslySetInnerHTML: {
        __html: css
      }
    }
  ), import_react.default.createElement("nav", null, import_react.default.createElement("h1", null, "A fatal runtime error occurred when rendering ", FileRef), import_react.default.createElement("div", null, "Get help via ", import_react.default.createElement(Discord, null), " or ", import_react.default.createElement(Discourse, null))), import_react.default.createElement("section", { className: "panic-overlay" }, import_react.default.createElement("div", { className: "error" }, import_react.default.createElement("h3", { className: "error-title" }, import_react.default.createElement("span", { className: "error-type" }, typeName), import_react.default.createElement("span", { className: "error-message" }, prettyMessage(msg))), import_react.default.createElement("div", { className: "error-stack" }, stack.items.map((entry, i) => import_react.default.createElement(StackEntry, { key: i, entry, i, message: msg })))), import_react.default.createElement(ResponseRequest, { error: props.error })));
};
function hideStackLine(fileReference) {
  return fileReference.length === 1 || fileReference.includes("node_modules/react-dom");
}
function StackEntry({
  entry,
  i
}) {
  const { sourceFile = { lines: [] }, line, column, fileShort } = entry;
  const lineIndex = (line || 0) - 1;
  const maxLines = sourceFile.lines.length;
  const window2 = 4;
  let start = lineIndex - window2, end = lineIndex + window2 + 2;
  if (start < 0) {
    end = Math.min(end - start, maxLines);
    start = 0;
  }
  if (end > maxLines) {
    start = Math.max(0, start - (end - maxLines));
    end = maxLines;
  }
  const lines = sourceFile.lines.slice(start, end);
  const lineNumberWidth = String(start + lines.length).length;
  const highlightIndex = (line || 0) - start - 1;
  const onLastLine = highlightIndex === lines.length - 1;
  const shortestPath = (path) => path.replace(appRoot || "", "");
  const expanded = !shouldHideEntry(entry, i);
  const clickable = lines.length;
  const LinkToVSCode = (props) => clickable ? import_react.default.createElement("a", { href: toVSCodeURL(entry) }, props.children) : import_react.default.createElement(import_react.default.Fragment, null, props.children);
  const fileReference = !lines.length ? "[System]" : shortestPath(fileShort);
  const rootClasses = [
    "stack-entry",
    !fileReference.includes("node_modules") && "rwfw",
    i === 0 && " first",
    lines.length && "clickable"
  ].filter(Boolean);
  return hideStackLine(fileReference) ? import_react.default.createElement("div", null) : import_react.default.createElement(LinkToVSCode, null, import_react.default.createElement("div", { className: rootClasses.join(" ") }, import_react.default.createElement("div", { className: "file" }, fileReference + " in " + entry.callee), expanded && !!lines.length && import_react.default.createElement("div", { className: "lines" + (onLastLine ? ".no-fade" : "") }, lines.map((text, i2) => {
    return import_react.default.createElement(
      "div",
      {
        key: i2,
        className: "line" + (i2 === highlightIndex ? " line-hili" : "")
      },
      import_react.default.createElement("span", { className: "line-number" }, String(start + i2 + 1).padStart(lineNumberWidth, " ")),
      import_react.default.createElement("span", { className: "line-text" }, i2 === highlightIndex ? renderHighlightedLine(text, column || 0) : text)
    );
  }))));
  function renderHighlightedLine(text, column2) {
    const [before, after] = [text.slice(0, column2 - 1), text.slice(column2 - 1)];
    return import_react.default.createElement(import_react.default.Fragment, null, before, import_react.default.createElement("strong", null, after));
  }
  function shouldHideEntry(entry2, i2) {
    return (entry2.thirdParty || entry2["native"] || entry2.hide || entry2.fileShort.includes("node_modules")) && i2 !== 0;
  }
}
function toVSCodeURL(entry) {
  const scheme = RWJS_DEBUG_ENV.REDWOOD_ENV_EDITOR || "vscode";
  return `${scheme}://file/${entry.fileShort}:${entry.line}:${entry.column}`;
}
function prettyMessage(msg) {
  return msg.replace("is not a function.", "is not a function.\n\n");
}
function ResponseRequest(props) {
  var _a, _b;
  const [openQuery, setOpenQuery] = (0, import_react.useState)(false);
  const [openResponse, setOpenResponse] = (0, import_react.useState)(false);
  if (!props.error) {
    return null;
  }
  const mostRecentRequest = props.error.mostRecentRequest || ((_b = (_a = props.error.graphQLErrors) == null ? void 0 : _a.find((gqlErr) => gqlErr.__RedwoodEnhancedError)) == null ? void 0 : _b.__RedwoodEnhancedError);
  const mostRecentResponse = props.error.mostRecentResponse;
  return import_react.default.createElement("div", { className: "request-response" }, mostRecentRequest ? import_react.default.createElement("div", null, import_react.default.createElement("h4", null, "Request: ", mostRecentRequest.operationName), import_react.default.createElement("div", null, import_react.default.createElement("h5", null, "Variables:"), import_react.default.createElement("code", null, import_react.default.createElement("pre", null, JSON.stringify(mostRecentRequest.variables, null, "  ")))), import_react.default.createElement("div", null, import_react.default.createElement("h5", null, "Query:"), import_react.default.createElement("code", null, import_react.default.createElement(
    "pre",
    {
      onClick: () => setOpenQuery(!openQuery),
      className: openQuery ? "open" : "preview"
    },
    mostRecentRequest.query
  )))) : null, mostRecentResponse ? import_react.default.createElement("div", { className: "response" }, import_react.default.createElement("h4", null, "Response"), import_react.default.createElement("div", null, import_react.default.createElement("h5", null, "JSON:"), import_react.default.createElement("code", null, import_react.default.createElement(
    "pre",
    {
      onClick: () => setOpenResponse(!openResponse),
      className: openResponse ? "open" : "preview"
    },
    JSON.stringify(mostRecentResponse, null, "  ")
  )))) : null);
}
var css = `
body {
  background-color: rgb(253, 248, 246) !important;
  font-family: "Open Sans", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif  !important;
}

.panic-overlay {
  background-color: white;
  padding: 0 2.5em;
}

.panic-overlay strong {
  font-weight: bold;
}

main.error-page nav {
  display: flex;
  flex-direction: row;
  align: center;
  justify-content: space-between;
  padding: 1em 2.5em;
}

main.error-page  nav h1 {
  color: black;
  margin: 0;
  padding: 0;
  font-size: 1.2em;
  font-weight: 400;
  opacity: 1;
  color: rgb(191, 71, 34);
}

main.error-page nav h1 a {
  color: black;
  text-decoration: underline;
}

main.error-page nav div {
  display: flex;
  align-items: center;
  line-height: 2em;
}

main.error-page nav div a {
  display: flex;
  margin: 0 0.3em;
}

main.error-page nav svg {
  width: 24px;
  height: 24px;
  fill: rgb(191, 71, 34);
}

main.error-page nav svg.discourse {
  height: 20px;
  width: 20px;
}

main.error-page nav svg:hover {
  fill: rgb(200, 32, 32);
}

.request-response div div code,
.request-response div div pre {
  background-color: transparent !important;
}

.panic-overlay a {
  text-decoration: none;
}

.panic-overlay .error {
  padding: 3em 0;
}

.panic-overlay .error-title {
  display: flex;
  align-items: stretch;
}

.panic-overlay .error-type {
  min-height: 2.8em;
  display: flex !important;
  align-items: center;
  padding: 0 1em;
  background: rgb(195, 74, 37);
  color: white;
  margin-right: 2em;
  white-space: nowrap;
  text-align: center;
}
.panic-overlay .error-counter {
  color: white;
  opacity: 0.3;
  position: absolute;
  left: 0.8em;
}
.panic-overlay .error-message {
  display: flex !important;
  align-items: center;
  font-weight: 300;
  line-height: 1.1em;
  font-size: 2.8em;
  word-break: break-all;
  white-space: pre-wrap;
}
.panic-overlay .error-stack {
  margin-top: 2em;
  white-space: pre;
  padding-left: var(--left-pad);
}

.panic-overlay .stack-entry.clickable {
  cursor: pointer;
}

.panic-overlay .stack-entry {
  margin-left: 2.5em;
}

.panic-overlay .stack-entry.rwfw {
  font-weight: bold;
}

.panic-overlay .stack-entry .file {
  color: rgb(195, 74, 37, 0.8);
}

.panic-overlay .stack-entry.first .file {
  font-weight: bold;
  color: rgb(200, 47, 47);
}

.panic-overlay .file strong {
  font-weight: normal;
}
.panic-overlay .file:before,
.panic-overlay .more:before {
  content: "@ ";
  opacity: 0.5;
  margin-left: -1.25em;
}
.panic-overlay .more:before {
  content: "▷ ";
  opacity: 0.5;
}
.panic-overlay .more {
  opacity: 0.25;
  color: black;
  font-size: 0.835em;
  cursor: pointer;
  text-align: center;
  display: none;
}
.panic-overlay .more em {
  font-style: normal;
  font-weight: normal;
  border-bottom: 1px dashed black;
}
.panic-overlay .collapsed .panic-overlay .more {
  display: block;
}
.panic-overlay .lines, .request-response code {
  color: rgb(187, 165, 165);
  font-size: 0.835em;
  margin-bottom: 2.5em;
  padding: 2rem;
  font-family: Menlo, Monaco, "Courier New", Courier, monospace;
}
.panic-overlay .lines:not(.panic-overlay .no-fade) {
  -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
  mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
}
.panic-overlay .line-number {
  padding-right: 1.5em;
  opacity: 0.5;
}
.panic-overlay .line-hili {
  background: rgb(253, 248, 246);
  color: #5f4545;
}
.panic-overlay .stack-entry:first-child .panic-overlay .line-hili strong {
  text-decoration: underline wavy #ff0040;
}
.panic-overlay .line-hili em {
  font-style: italic;
  color: rgb(195, 74, 37);
  font-size: 0.75em;
  margin-left: 2em;
  opacity: 0.25;
  position: relative;
  top: -0.115em;
  white-space: nowrap;
}
.panic-overlay .line-hili em:before {
  content: "← ";
}
.panic-overlay .no-source {
  font-style: italic;
}

.panic-overlay .request-response {
  margin-top: 2rem;
  display: flex;
  flex-direction: row;
}

.panic-overlay .request-response > div {
  flex: 1;
}

.panic-overlay .request-response .response {
  margin-left: 2rem;
}

.panic-overlay .request-response h4 {
  background-color: rgb(195, 74, 37);
  color: white;
  font-size: 1.5rem;
  padding: 0.2rem 1rem;
}

.panic-overlay .request-response > div > div {
  margin: 1rem 1rem;
}

.panic-overlay .request-response pre {
  background-color: rgb(253, 248, 246);
  padding: 1rem 1rem;
  color: black;
}

.panic-overlay .request-response pre.open {
  max-height: auto;
}

.panic-overlay .request-response pre.preview {
  max-height: 13.5rem;
  overflow-y: auto;

  -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
  mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
}

@media only screen and (max-width: 640px) {
  .panic-overlay {
    font-size: 15px;
  }

  .panic-overlay h1 {
    margin: 40px 0;
  }
}
@media only screen and (max-width: 500px) {
  .panic-overlay {
    font-size: 14px;
  }

  .panic-overlay h1 {
    margin: 30px 0;
  }
}
`;
var Discourse = () => import_react.default.createElement(
  "a",
  {
    href: "https://community.redwoodjs.com",
    title: "Go to Redwood's Discourse server"
  },
  import_react.default.createElement(
    "svg",
    {
      className: "discourse",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32"
    },
    import_react.default.createElement("path", { d: "M16.1357143,0 C7.37857143,0 0,7.03571429 0,15.7214286 C0,16 0.00714285714,32 0.00714285714,32 L16.1357143,31.9857143 C24.9,31.9857143 32,24.6785714 32,15.9928571 C32,7.30714286 24.9,0 16.1357143,0 Z M16,25.1428571 C14.6142857,25.1428571 13.2928571,24.8357143 12.1142857,24.2785714 L6.32142857,25.7142857 L7.95714286,20.3571429 C7.25714286,19.0642857 6.85714286,17.5785714 6.85714286,16 C6.85714286,10.95 10.95,6.85714286 16,6.85714286 C21.05,6.85714286 25.1428571,10.95 25.1428571,16 C25.1428571,21.05 21.05,25.1428571 16,25.1428571 Z" })
  )
);
var Discord = () => import_react.default.createElement("a", { href: "https://discord.gg/redwoodjs", title: "Go to Redwood's Discord server" }, import_react.default.createElement("svg", { viewBox: "0 0 36 36", xmlns: "http://www.w3.org/2000/svg" }, import_react.default.createElement("path", { d: "M29.9699 7.7544C27.1043 5.44752 22.5705 5.05656 22.3761 5.04288C22.2284 5.03072 22.0806 5.0648 21.9531 5.1404C21.8257 5.216 21.7249 5.32937 21.6647 5.4648C21.5783 5.65936 21.5049 5.85949 21.4451 6.06384C23.3409 6.38424 25.6694 7.02864 27.7761 8.33616C27.8565 8.38604 27.9262 8.45126 27.9814 8.52809C28.0366 8.60493 28.0761 8.69187 28.0976 8.78397C28.1192 8.87607 28.1224 8.97151 28.1071 9.06485C28.0917 9.15819 28.0582 9.24759 28.0083 9.32796C27.9584 9.40833 27.8932 9.47809 27.8164 9.53325C27.7395 9.58842 27.6526 9.62791 27.5605 9.64947C27.4684 9.67103 27.373 9.67424 27.2796 9.65892C27.1863 9.6436 27.0969 9.61004 27.0165 9.56016C23.3949 7.3116 18.8719 7.2 17.9999 7.2C17.1287 7.2 12.6028 7.31232 8.98338 9.55944C8.90301 9.60932 8.81361 9.64288 8.72027 9.6582C8.62693 9.67352 8.53149 9.67031 8.43939 9.64875C8.25339 9.6052 8.09231 9.48955 7.99158 9.32724C7.89085 9.16493 7.85873 8.96925 7.90227 8.78325C7.94582 8.59725 8.06147 8.43617 8.22378 8.33544C10.3305 7.03152 12.659 6.38424 14.5547 6.06672C14.4453 5.7096 14.3459 5.48424 14.3387 5.4648C14.2788 5.32841 14.1776 5.2143 14.0493 5.13859C13.921 5.06288 13.7721 5.0294 13.6238 5.04288C13.4294 5.05728 8.89554 5.44752 5.99034 7.78536C4.47474 9.18792 1.43994 17.3894 1.43994 24.48C1.43994 24.6067 1.47378 24.7277 1.5357 24.8371C3.62802 28.5163 9.3405 29.4775 10.6423 29.52H10.6646C10.7782 29.5203 10.8903 29.4937 10.9916 29.4424C11.093 29.3911 11.1808 29.3165 11.2478 29.2248L12.5632 27.4133C9.01146 26.4967 7.19706 24.9386 7.09338 24.8458C6.95017 24.7194 6.86303 24.5412 6.85115 24.3506C6.83927 24.1599 6.90361 23.9723 7.03002 23.8291C7.15643 23.6859 7.33456 23.5988 7.52522 23.5869C7.71588 23.575 7.90345 23.6394 8.04666 23.7658C8.08842 23.8054 11.4299 26.64 17.9999 26.64C24.5807 26.64 27.9223 23.7938 27.9561 23.7658C28.0998 23.6403 28.2874 23.5769 28.4777 23.5896C28.668 23.6023 28.8456 23.69 28.9713 23.8334C29.0335 23.9042 29.0812 23.9864 29.1117 24.0756C29.1421 24.1647 29.1546 24.259 29.1486 24.353C29.1426 24.447 29.1181 24.5389 29.0766 24.6235C29.035 24.708 28.9772 24.7836 28.9065 24.8458C28.8028 24.9386 26.9884 26.4967 23.4367 27.4133L24.7528 29.2248C24.8198 29.3164 24.9074 29.3909 25.0087 29.4422C25.1099 29.4935 25.2218 29.5202 25.3353 29.52H25.3569C26.6601 29.4775 32.3719 28.5156 34.4649 24.8371C34.5261 24.7277 34.5599 24.6067 34.5599 24.48C34.5599 17.3894 31.5251 9.18864 29.9699 7.7544V7.7544ZM13.3199 21.6C11.9275 21.6 10.7999 20.3112 10.7999 18.72C10.7999 17.1288 11.9275 15.84 13.3199 15.84C14.7124 15.84 15.8399 17.1288 15.8399 18.72C15.8399 20.3112 14.7124 21.6 13.3199 21.6ZM22.6799 21.6C21.2875 21.6 20.1599 20.3112 20.1599 18.72C20.1599 17.1288 21.2875 15.84 22.6799 15.84C24.0724 15.84 25.1999 17.1288 25.1999 18.72C25.1999 20.3112 24.0724 21.6 22.6799 21.6Z" })));
export {
  DevFatalErrorPage
};
//# sourceMappingURL=@redwoodjs_web_dist_components_DevFatalErrorPage.js.map
