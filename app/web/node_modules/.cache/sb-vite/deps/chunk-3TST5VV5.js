import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_react
} from "./chunk-52LGRYSO.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-QGZREBOA.js";

// ../node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result2 = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result2 === void 0) continue;
      if (result2 === null || typeof result2 !== "object") throw new TypeError("Object expected");
      if (_ = accept(result2.get)) descriptor.get = _;
      if (_ = accept(result2.set)) descriptor.set = _;
      if (_ = accept(result2.init)) initializers.unshift(_);
    } else if (_ = accept(result2)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result2 = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result2, mod, k);
  }
  __setModuleDefault(result2, mod);
  return result2;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result2 = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result2).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
var import_dist, import_dist2, import_dist3, extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "../node_modules/tslib/tslib.es6.mjs"() {
    import_dist = __toESM(require_dist(), 1);
    import_dist2 = __toESM(require_dist2(), 1);
    import_dist3 = __toESM(require_dist3(), 1);
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// ../node_modules/ts-invariant/lib/invariant.js
var invariant_exports = {};
__export(invariant_exports, {
  InvariantError: () => InvariantError,
  default: () => invariant_default,
  invariant: () => invariant,
  setVerbosity: () => setVerbosity
});
function invariant(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
function wrapConsoleMethod(name) {
  return function() {
    if (verbosityLevels.indexOf(name) >= verbosityLevel) {
      var method = console[name] || console.log;
      return method.apply(console, arguments);
    }
  };
}
function setVerbosity(level) {
  var old = verbosityLevels[verbosityLevel];
  verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
  return old;
}
var import_dist4, import_dist5, import_dist6, genericMessage, _a, setPrototypeOf, InvariantError, verbosityLevels, verbosityLevel, invariant_default;
var init_invariant = __esm({
  "../node_modules/ts-invariant/lib/invariant.js"() {
    import_dist4 = __toESM(require_dist());
    import_dist5 = __toESM(require_dist2());
    import_dist6 = __toESM(require_dist3());
    init_tslib_es6();
    genericMessage = "Invariant Violation";
    _a = Object.setPrototypeOf;
    setPrototypeOf = _a === void 0 ? function(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    } : _a;
    InvariantError = /** @class */
    function(_super) {
      __extends(InvariantError2, _super);
      function InvariantError2(message) {
        if (message === void 0) {
          message = genericMessage;
        }
        var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError2.prototype);
        return _this;
      }
      return InvariantError2;
    }(Error);
    verbosityLevels = ["debug", "log", "warn", "error", "silent"];
    verbosityLevel = verbosityLevels.indexOf("log");
    (function(invariant5) {
      invariant5.debug = wrapConsoleMethod("debug");
      invariant5.log = wrapConsoleMethod("log");
      invariant5.warn = wrapConsoleMethod("warn");
      invariant5.error = wrapConsoleMethod("error");
    })(invariant || (invariant = {}));
    invariant_default = invariant;
  }
});

// ../node_modules/@apollo/client/version.js
var import_dist7, import_dist8, import_dist9, version;
var init_version = __esm({
  "../node_modules/@apollo/client/version.js"() {
    import_dist7 = __toESM(require_dist(), 1);
    import_dist8 = __toESM(require_dist2(), 1);
    import_dist9 = __toESM(require_dist3(), 1);
    version = "3.11.1";
  }
});

// ../node_modules/@apollo/client/utilities/globals/maybe.js
function maybe(thunk) {
  try {
    return thunk();
  } catch (_a2) {
  }
}
var import_dist10, import_dist11, import_dist12;
var init_maybe = __esm({
  "../node_modules/@apollo/client/utilities/globals/maybe.js"() {
    import_dist10 = __toESM(require_dist(), 1);
    import_dist11 = __toESM(require_dist2(), 1);
    import_dist12 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/utilities/globals/global.js
var import_dist13, import_dist14, import_dist15, global_default;
var init_global = __esm({
  "../node_modules/@apollo/client/utilities/globals/global.js"() {
    import_dist13 = __toESM(require_dist(), 1);
    import_dist14 = __toESM(require_dist2(), 1);
    import_dist15 = __toESM(require_dist3(), 1);
    init_maybe();
    global_default = maybe(function() {
      return globalThis;
    }) || maybe(function() {
      return window;
    }) || maybe(function() {
      return self;
    }) || maybe(function() {
      return global;
    }) || // We don't expect the Function constructor ever to be invoked at runtime, as
    // long as at least one of globalThis, window, self, or global is defined, so
    // we are under no obligation to make it easy for static analysis tools to
    // detect syntactic usage of the Function constructor. If you think you can
    // improve your static analysis to detect this obfuscation, think again. This
    // is an arms race you cannot win, at least not in JavaScript.
    maybe(function() {
      return maybe.constructor("return this")();
    });
  }
});

// ../node_modules/@apollo/client/utilities/common/makeUniqueId.js
function makeUniqueId(prefix) {
  var count = prefixCounts.get(prefix) || 1;
  prefixCounts.set(prefix, count + 1);
  return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
}
var import_dist16, import_dist17, import_dist18, prefixCounts;
var init_makeUniqueId = __esm({
  "../node_modules/@apollo/client/utilities/common/makeUniqueId.js"() {
    import_dist16 = __toESM(require_dist(), 1);
    import_dist17 = __toESM(require_dist2(), 1);
    import_dist18 = __toESM(require_dist3(), 1);
    prefixCounts = /* @__PURE__ */ new Map();
  }
});

// ../node_modules/@apollo/client/utilities/common/stringifyForDisplay.js
function stringifyForDisplay(value, space) {
  if (space === void 0) {
    space = 0;
  }
  var undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, function(key, value2) {
    return value2 === void 0 ? undefId : value2;
  }, space).split(JSON.stringify(undefId)).join("<undefined>");
}
var import_dist19, import_dist20, import_dist21;
var init_stringifyForDisplay = __esm({
  "../node_modules/@apollo/client/utilities/common/stringifyForDisplay.js"() {
    import_dist19 = __toESM(require_dist(), 1);
    import_dist20 = __toESM(require_dist2(), 1);
    import_dist21 = __toESM(require_dist3(), 1);
    init_makeUniqueId();
  }
});

// ../node_modules/@apollo/client/utilities/globals/invariantWrappers.js
function wrap(fn) {
  return function(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof message === "number") {
      var arg0 = message;
      message = getHandledErrorMsg(arg0);
      if (!message) {
        message = getFallbackErrorMsg(arg0, args);
        args = [];
      }
    }
    fn.apply(void 0, [message].concat(args));
  };
}
function newInvariantError(message) {
  var optionalParams = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    optionalParams[_i - 1] = arguments[_i];
  }
  return new InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
}
function stringify(arg) {
  if (typeof arg == "string") {
    return arg;
  }
  try {
    return stringifyForDisplay(arg, 2).slice(0, 1e3);
  } catch (_a2) {
    return "<non-serializable>";
  }
}
function getHandledErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return global_default[ApolloErrorMessageHandler] && global_default[ApolloErrorMessageHandler](message, messageArgs.map(stringify));
}
function getFallbackErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
    version,
    message,
    args: messageArgs.map(stringify)
  })));
}
var import_dist22, import_dist23, import_dist24, invariant2, ApolloErrorMessageHandler;
var init_invariantWrappers = __esm({
  "../node_modules/@apollo/client/utilities/globals/invariantWrappers.js"() {
    import_dist22 = __toESM(require_dist(), 1);
    import_dist23 = __toESM(require_dist2(), 1);
    import_dist24 = __toESM(require_dist3(), 1);
    init_invariant();
    init_version();
    init_global();
    init_stringifyForDisplay();
    invariant2 = Object.assign(function invariant3(condition, message) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (!condition) {
        invariant(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));
      }
    }, {
      debug: wrap(invariant.debug),
      log: wrap(invariant.log),
      warn: wrap(invariant.warn),
      error: wrap(invariant.error)
    });
    ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version);
  }
});

// ../node_modules/@apollo/client/utilities/globals/index.js
var import_dist25, import_dist26, import_dist27, DEV;
var init_globals = __esm({
  "../node_modules/@apollo/client/utilities/globals/index.js"() {
    import_dist25 = __toESM(require_dist(), 1);
    import_dist26 = __toESM(require_dist2(), 1);
    import_dist27 = __toESM(require_dist3(), 1);
    init_invariantWrappers();
    init_maybe();
    init_global();
    DEV = globalThis.__DEV__ !== false;
  }
});

// ../node_modules/graphql/version.mjs
var import_dist28, import_dist29, import_dist30, version2, versionInfo;
var init_version2 = __esm({
  "../node_modules/graphql/version.mjs"() {
    import_dist28 = __toESM(require_dist(), 1);
    import_dist29 = __toESM(require_dist2(), 1);
    import_dist30 = __toESM(require_dist3(), 1);
    version2 = "16.9.0";
    versionInfo = Object.freeze({
      major: 16,
      minor: 9,
      patch: 0,
      preReleaseTag: null
    });
  }
});

// ../node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
var import_dist31, import_dist32, import_dist33;
var init_devAssert = __esm({
  "../node_modules/graphql/jsutils/devAssert.mjs"() {
    import_dist31 = __toESM(require_dist(), 1);
    import_dist32 = __toESM(require_dist2(), 1);
    import_dist33 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/isPromise.mjs
function isPromise(value) {
  return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
}
var import_dist34, import_dist35, import_dist36;
var init_isPromise = __esm({
  "../node_modules/graphql/jsutils/isPromise.mjs"() {
    import_dist34 = __toESM(require_dist(), 1);
    import_dist35 = __toESM(require_dist2(), 1);
    import_dist36 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
var import_dist37, import_dist38, import_dist39;
var init_isObjectLike = __esm({
  "../node_modules/graphql/jsutils/isObjectLike.mjs"() {
    import_dist37 = __toESM(require_dist(), 1);
    import_dist38 = __toESM(require_dist2(), 1);
    import_dist39 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/invariant.mjs
function invariant4(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}
var import_dist40, import_dist41, import_dist42;
var init_invariant2 = __esm({
  "../node_modules/graphql/jsutils/invariant.mjs"() {
    import_dist40 = __toESM(require_dist(), 1);
    import_dist41 = __toESM(require_dist2(), 1);
    import_dist42 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant4(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var import_dist43, import_dist44, import_dist45, LineRegExp;
var init_location = __esm({
  "../node_modules/graphql/language/location.mjs"() {
    import_dist43 = __toESM(require_dist(), 1);
    import_dist44 = __toESM(require_dist2(), 1);
    import_dist45 = __toESM(require_dist3(), 1);
    init_invariant2();
    LineRegExp = /\r\n|[\n\r]/g;
  }
});

// ../node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}
var import_dist46, import_dist47, import_dist48;
var init_printLocation = __esm({
  "../node_modules/graphql/language/printLocation.mjs"() {
    import_dist46 = __toESM(require_dist(), 1);
    import_dist47 = __toESM(require_dist2(), 1);
    import_dist48 = __toESM(require_dist3(), 1);
    init_location();
  }
});

// ../node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function printError(error) {
  return error.toString();
}
function formatError(error) {
  return error.toJSON();
}
var import_dist49, import_dist50, import_dist51, GraphQLError;
var init_GraphQLError = __esm({
  "../node_modules/graphql/error/GraphQLError.mjs"() {
    import_dist49 = __toESM(require_dist(), 1);
    import_dist50 = __toESM(require_dist2(), 1);
    import_dist51 = __toESM(require_dist3(), 1);
    init_isObjectLike();
    init_location();
    init_printLocation();
    GraphQLError = class _GraphQLError extends Error {
      /**
       * An array of `{ line, column }` locations within the source GraphQL document
       * which correspond to this error.
       *
       * Errors during validation often contain multiple locations, for example to
       * point out two things with the same name. Errors during execution include a
       * single location, the field which produced the error.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array describing the JSON-path into the execution response which
       * corresponds to this error. Only included for errors during execution.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array of GraphQL AST Nodes corresponding to this error.
       */
      /**
       * The source GraphQL document for the first location of this error.
       *
       * Note that if this Error represents more than one node, the source may not
       * represent nodes after the first node.
       */
      /**
       * An array of character offsets within the source GraphQL document
       * which correspond to this error.
       */
      /**
       * The original error thrown from a field resolver during execution.
       */
      /**
       * Extension fields to add to the formatted error.
       */
      /**
       * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
       */
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(
          Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
        );
        const nodeLocations = undefinedIfEmpty(
          (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
        );
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
        const originalExtensions = isObjectLike(
          originalError === null || originalError === void 0 ? void 0 : originalError.extensions
        ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _GraphQLError);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + printLocation(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + printSourceLocation(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
  }
});

// ../node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}
var import_dist52, import_dist53, import_dist54;
var init_syntaxError = __esm({
  "../node_modules/graphql/error/syntaxError.mjs"() {
    import_dist52 = __toESM(require_dist(), 1);
    import_dist53 = __toESM(require_dist2(), 1);
    import_dist54 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var import_dist55, import_dist56, import_dist57, Location, Token, QueryDocumentKeys, kindValues, OperationTypeNode;
var init_ast = __esm({
  "../node_modules/graphql/language/ast.mjs"() {
    import_dist55 = __toESM(require_dist(), 1);
    import_dist56 = __toESM(require_dist2(), 1);
    import_dist57 = __toESM(require_dist3(), 1);
    Location = class {
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The Token at which this Node begins.
       */
      /**
       * The Token at which this Node ends.
       */
      /**
       * The Source document the AST represents.
       */
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    Token = class {
      /**
       * The kind of Token.
       */
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The 1-indexed line number on which this Token appears.
       */
      /**
       * The 1-indexed column number at which this Token begins.
       */
      /**
       * For non-punctuation tokens, represents the interpreted value of the token.
       *
       * Note: is undefined for punctuation tokens, but typed as string for
       * convenience in the parser.
       */
      /**
       * Tokens exist as nodes in a double-linked-list amongst all tokens
       * including ignored tokens. <SOF> is always the first node and <EOF>
       * the last.
       */
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        // Note: fragment variable definitions are deprecated and will removed in v17.0.0
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    kindValues = new Set(Object.keys(QueryDocumentKeys));
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (OperationTypeNode = {}));
  }
});

// ../node_modules/graphql/language/directiveLocation.mjs
var import_dist58, import_dist59, import_dist60, DirectiveLocation;
var init_directiveLocation = __esm({
  "../node_modules/graphql/language/directiveLocation.mjs"() {
    import_dist58 = __toESM(require_dist(), 1);
    import_dist59 = __toESM(require_dist2(), 1);
    import_dist60 = __toESM(require_dist3(), 1);
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (DirectiveLocation = {}));
  }
});

// ../node_modules/graphql/language/kinds.mjs
var import_dist61, import_dist62, import_dist63, Kind;
var init_kinds = __esm({
  "../node_modules/graphql/language/kinds.mjs"() {
    import_dist61 = __toESM(require_dist(), 1);
    import_dist62 = __toESM(require_dist2(), 1);
    import_dist63 = __toESM(require_dist3(), 1);
    (function(Kind2) {
      Kind2["NAME"] = "Name";
      Kind2["DOCUMENT"] = "Document";
      Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind2["SELECTION_SET"] = "SelectionSet";
      Kind2["FIELD"] = "Field";
      Kind2["ARGUMENT"] = "Argument";
      Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind2["INLINE_FRAGMENT"] = "InlineFragment";
      Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind2["VARIABLE"] = "Variable";
      Kind2["INT"] = "IntValue";
      Kind2["FLOAT"] = "FloatValue";
      Kind2["STRING"] = "StringValue";
      Kind2["BOOLEAN"] = "BooleanValue";
      Kind2["NULL"] = "NullValue";
      Kind2["ENUM"] = "EnumValue";
      Kind2["LIST"] = "ListValue";
      Kind2["OBJECT"] = "ObjectValue";
      Kind2["OBJECT_FIELD"] = "ObjectField";
      Kind2["DIRECTIVE"] = "Directive";
      Kind2["NAMED_TYPE"] = "NamedType";
      Kind2["LIST_TYPE"] = "ListType";
      Kind2["NON_NULL_TYPE"] = "NonNullType";
      Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind2["FIELD_DEFINITION"] = "FieldDefinition";
      Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind || (Kind = {}));
  }
});

// ../node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}
var import_dist64, import_dist65, import_dist66;
var init_characterClasses = __esm({
  "../node_modules/graphql/language/characterClasses.mjs"() {
    import_dist64 = __toESM(require_dist(), 1);
    import_dist65 = __toESM(require_dist2(), 1);
    import_dist66 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0; i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result2 = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result2 += "\n";
  }
  result2 += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result2 += "\n";
  }
  return '"""' + result2 + '"""';
}
var import_dist67, import_dist68, import_dist69;
var init_blockString = __esm({
  "../node_modules/graphql/language/blockString.mjs"() {
    import_dist67 = __toESM(require_dist(), 1);
    import_dist68 = __toESM(require_dist2(), 1);
    import_dist69 = __toESM(require_dist3(), 1);
    init_characterClasses();
  }
});

// ../node_modules/graphql/language/tokenKind.mjs
var import_dist70, import_dist71, import_dist72, TokenKind;
var init_tokenKind = __esm({
  "../node_modules/graphql/language/tokenKind.mjs"() {
    import_dist70 = __toESM(require_dist(), 1);
    import_dist71 = __toESM(require_dist2(), 1);
    import_dist72 = __toESM(require_dist3(), 1);
    (function(TokenKind2) {
      TokenKind2["SOF"] = "<SOF>";
      TokenKind2["EOF"] = "<EOF>";
      TokenKind2["BANG"] = "!";
      TokenKind2["DOLLAR"] = "$";
      TokenKind2["AMP"] = "&";
      TokenKind2["PAREN_L"] = "(";
      TokenKind2["PAREN_R"] = ")";
      TokenKind2["SPREAD"] = "...";
      TokenKind2["COLON"] = ":";
      TokenKind2["EQUALS"] = "=";
      TokenKind2["AT"] = "@";
      TokenKind2["BRACKET_L"] = "[";
      TokenKind2["BRACKET_R"] = "]";
      TokenKind2["BRACE_L"] = "{";
      TokenKind2["PIPE"] = "|";
      TokenKind2["BRACE_R"] = "}";
      TokenKind2["NAME"] = "Name";
      TokenKind2["INT"] = "Int";
      TokenKind2["FLOAT"] = "Float";
      TokenKind2["STRING"] = "String";
      TokenKind2["BLOCK_STRING"] = "BlockString";
      TokenKind2["COMMENT"] = "Comment";
    })(TokenKind || (TokenKind = {}));
  }
});

// ../node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape.value;
      position += escape.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}
var import_dist73, import_dist74, import_dist75, Lexer;
var init_lexer = __esm({
  "../node_modules/graphql/language/lexer.mjs"() {
    import_dist73 = __toESM(require_dist(), 1);
    import_dist74 = __toESM(require_dist2(), 1);
    import_dist75 = __toESM(require_dist3(), 1);
    init_syntaxError();
    init_ast();
    init_blockString();
    init_characterClasses();
    init_tokenKind();
    Lexer = class {
      /**
       * The previously focused non-ignored token.
       */
      /**
       * The currently focused non-ignored token.
       */
      /**
       * The (1-indexed) line containing the current token.
       */
      /**
       * The character offset at which the current line begins.
       */
      constructor(source) {
        const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      /**
       * Advances the token stream to the next non-ignored token.
       */
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      /**
       * Looks ahead and returns the next non-ignored token, but does not change
       * the state of Lexer.
       */
      lookahead() {
        let token = this.token;
        if (token.kind !== TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === TokenKind.COMMENT);
        }
        return token;
      }
    };
  }
});

// ../node_modules/graphql/jsutils/inspect.mjs
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
var import_dist76, import_dist77, import_dist78, MAX_ARRAY_LENGTH, MAX_RECURSIVE_DEPTH;
var init_inspect = __esm({
  "../node_modules/graphql/jsutils/inspect.mjs"() {
    import_dist76 = __toESM(require_dist(), 1);
    import_dist77 = __toESM(require_dist2(), 1);
    import_dist78 = __toESM(require_dist3(), 1);
    MAX_ARRAY_LENGTH = 10;
    MAX_RECURSIVE_DEPTH = 2;
  }
});

// ../node_modules/graphql/jsutils/instanceOf.mjs
var import_dist79, import_dist80, import_dist81, isProduction, instanceOf;
var init_instanceOf = __esm({
  "../node_modules/graphql/jsutils/instanceOf.mjs"() {
    import_dist79 = __toESM(require_dist(), 1);
    import_dist80 = __toESM(require_dist2(), 1);
    import_dist81 = __toESM(require_dist3(), 1);
    init_inspect();
    isProduction = globalThis.process && // eslint-disable-next-line no-undef
    process.env.NODE_ENV === "production";
    instanceOf = /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    isProduction ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
        );
        if (className === valueClassName) {
          const stringifiedValue = inspect(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    };
  }
});

// ../node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}
var import_dist82, import_dist83, import_dist84, Source;
var init_source = __esm({
  "../node_modules/graphql/language/source.mjs"() {
    import_dist82 = __toESM(require_dist(), 1);
    import_dist83 = __toESM(require_dist2(), 1);
    import_dist84 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_inspect();
    init_instanceOf();
    Source = class {
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || devAssert(
          false,
          "line in locationOffset is 1-indexed and must be positive."
        );
        this.locationOffset.column > 0 || devAssert(
          false,
          "column in locationOffset is 1-indexed and must be positive."
        );
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
  }
});

// ../node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser2 = new Parser(source, options);
  return parser2.parseDocument();
}
function parseValue(source, options) {
  const parser2 = new Parser(source, options);
  parser2.expectToken(TokenKind.SOF);
  const value = parser2.parseValueLiteral(false);
  parser2.expectToken(TokenKind.EOF);
  return value;
}
function parseConstValue(source, options) {
  const parser2 = new Parser(source, options);
  parser2.expectToken(TokenKind.SOF);
  const value = parser2.parseConstValueLiteral();
  parser2.expectToken(TokenKind.EOF);
  return value;
}
function parseType(source, options) {
  const parser2 = new Parser(source, options);
  parser2.expectToken(TokenKind.SOF);
  const type = parser2.parseTypeReference();
  parser2.expectToken(TokenKind.EOF);
  return type;
}
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}
var import_dist85, import_dist86, import_dist87, Parser;
var init_parser = __esm({
  "../node_modules/graphql/language/parser.mjs"() {
    import_dist85 = __toESM(require_dist(), 1);
    import_dist86 = __toESM(require_dist2(), 1);
    import_dist87 = __toESM(require_dist3(), 1);
    init_syntaxError();
    init_ast();
    init_directiveLocation();
    init_kinds();
    init_lexer();
    init_source();
    init_tokenKind();
    Parser = class {
      constructor(source, options = {}) {
        const sourceObj = isSource(source) ? source : new Source(source);
        this._lexer = new Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
      }
      /**
       * Converts a name lex token into a name parse node.
       */
      parseName() {
        const token = this.expectToken(TokenKind.NAME);
        return this.node(token, {
          kind: Kind.NAME,
          value: token.value
        });
      }
      // Implements the parsing rules in the Document section.
      /**
       * Document : Definition+
       */
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: Kind.DOCUMENT,
          definitions: this.many(
            TokenKind.SOF,
            this.parseDefinition,
            TokenKind.EOF
          )
        });
      }
      /**
       * Definition :
       *   - ExecutableDefinition
       *   - TypeSystemDefinition
       *   - TypeSystemExtension
       *
       * ExecutableDefinition :
       *   - OperationDefinition
       *   - FragmentDefinition
       *
       * TypeSystemDefinition :
       *   - SchemaDefinition
       *   - TypeDefinition
       *   - DirectiveDefinition
       *
       * TypeDefinition :
       *   - ScalarTypeDefinition
       *   - ObjectTypeDefinition
       *   - InterfaceTypeDefinition
       *   - UnionTypeDefinition
       *   - EnumTypeDefinition
       *   - InputObjectTypeDefinition
       */
      parseDefinition() {
        if (this.peek(TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw syntaxError(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      // Implements the parsing rules in the Operations section.
      /**
       * OperationDefinition :
       *  - SelectionSet
       *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
       */
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: Kind.OPERATION_DEFINITION,
            operation: OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * OperationType : one of query mutation subscription
       */
      parseOperationType() {
        const operationToken = this.expectToken(TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return OperationTypeNode.QUERY;
          case "mutation":
            return OperationTypeNode.MUTATION;
          case "subscription":
            return OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      /**
       * VariableDefinitions : ( VariableDefinition+ )
       */
      parseVariableDefinitions() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseVariableDefinition,
          TokenKind.PAREN_R
        );
      }
      /**
       * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
       */
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      /**
       * Variable : $ Name
       */
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.DOLLAR);
        return this.node(start, {
          kind: Kind.VARIABLE,
          name: this.parseName()
        });
      }
      /**
       * ```
       * SelectionSet : { Selection+ }
       * ```
       */
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: Kind.SELECTION_SET,
          selections: this.many(
            TokenKind.BRACE_L,
            this.parseSelection,
            TokenKind.BRACE_R
          )
        });
      }
      /**
       * Selection :
       *   - Field
       *   - FragmentSpread
       *   - InlineFragment
       */
      parseSelection() {
        return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      /**
       * Field : Alias? Name Arguments? Directives? SelectionSet?
       *
       * Alias : Name :
       */
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      /**
       * Arguments[Const] : ( Argument[?Const]+ )
       */
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
      }
      /**
       * Argument[Const] : Name : Value[?Const]
       */
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      // Implements the parsing rules in the Fragments section.
      /**
       * Corresponds to both FragmentSpread and InlineFragment in the spec.
       *
       * FragmentSpread : ... FragmentName Directives?
       *
       * InlineFragment : ... TypeCondition? Directives? SelectionSet
       */
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
          return this.node(start, {
            kind: Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentDefinition :
       *   - fragment FragmentName on TypeCondition Directives? SelectionSet
       *
       * TypeCondition : NamedType
       */
      parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(start, {
            kind: Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentName : Name but not `on`
       */
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      // Implements the parsing rules in the Values section.
      /**
       * Value[Const] :
       *   - [~Const] Variable
       *   - IntValue
       *   - FloatValue
       *   - StringValue
       *   - BooleanValue
       *   - NullValue
       *   - EnumValue
       *   - ListValue[?Const]
       *   - ObjectValue[?Const]
       *
       * BooleanValue : one of `true` `false`
       *
       * NullValue : `null`
       *
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case TokenKind.INT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.INT,
              value: token.value
            });
          case TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.FLOAT,
              value: token.value
            });
          case TokenKind.STRING:
          case TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case TokenKind.NAME:
            this.advanceLexer();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: Kind.ENUM,
                  value: token.value
                });
            }
          case TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(TokenKind.DOLLAR);
              if (this._lexer.token.kind === TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw syntaxError(
                  this._lexer.source,
                  token.start,
                  `Unexpected variable "$${varName}" in constant value.`
                );
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.STRING,
          value: token.value,
          block: token.kind === TokenKind.BLOCK_STRING
        });
      }
      /**
       * ListValue[Const] :
       *   - [ ]
       *   - [ Value[?Const]+ ]
       */
      parseList(isConst) {
        const item = () => this.parseValueLiteral(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.LIST,
          values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
        });
      }
      /**
       * ```
       * ObjectValue[Const] :
       *   - { }
       *   - { ObjectField[?Const]+ }
       * ```
       */
      parseObject(isConst) {
        const item = () => this.parseObjectField(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.OBJECT,
          fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
        });
      }
      /**
       * ObjectField[Const] : Name : Value[?Const]
       */
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      // Implements the parsing rules in the Directives section.
      /**
       * Directives[Const] : Directive[?Const]+
       */
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      /**
       * ```
       * Directive[Const] : @ Name Arguments[?Const]?
       * ```
       */
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(TokenKind.AT);
        return this.node(start, {
          kind: Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      // Implements the parsing rules in the Types section.
      /**
       * Type :
       *   - NamedType
       *   - ListType
       *   - NonNullType
       */
      parseTypeReference() {
        const start = this._lexer.token;
        let type;
        if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(TokenKind.BRACKET_R);
          type = this.node(start, {
            kind: Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(TokenKind.BANG)) {
          return this.node(start, {
            kind: Kind.NON_NULL_TYPE,
            type
          });
        }
        return type;
      }
      /**
       * NamedType : Name
       */
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      // Implements the parsing rules in the Type Definition section.
      peekDescription() {
        return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
      }
      /**
       * Description : StringValue
       */
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      /**
       * ```
       * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
       * ```
       */
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        return this.node(start, {
          kind: Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      /**
       * OperationTypeDefinition : OperationType : NamedType
       */
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(TokenKind.COLON);
        const type = this.parseNamedType();
        return this.node(start, {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type
        });
      }
      /**
       * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
       */
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * ObjectTypeDefinition :
       *   Description?
       *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
       */
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * ImplementsInterfaces :
       *   - implements `&`? NamedType
       *   - ImplementsInterfaces & NamedType
       */
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
      }
      /**
       * ```
       * FieldsDefinition : { FieldDefinition+ }
       * ```
       */
      parseFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseFieldDefinition,
          TokenKind.BRACE_R
        );
      }
      /**
       * FieldDefinition :
       *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
       */
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives
        });
      }
      /**
       * ArgumentsDefinition : ( InputValueDefinition+ )
       */
      parseArgumentDefs() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseInputValueDef,
          TokenKind.PAREN_R
        );
      }
      /**
       * InputValueDefinition :
       *   - Description? Name : Type DefaultValue? Directives[Const]?
       */
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives
        });
      }
      /**
       * InterfaceTypeDefinition :
       *   - Description? interface Name Directives[Const]? FieldsDefinition?
       */
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeDefinition :
       *   - Description? union Name Directives[Const]? UnionMemberTypes?
       */
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types
        });
      }
      /**
       * UnionMemberTypes :
       *   - = `|`? NamedType
       *   - UnionMemberTypes | NamedType
       */
      parseUnionMemberTypes() {
        return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
      }
      /**
       * EnumTypeDefinition :
       *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
       */
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      /**
       * ```
       * EnumValuesDefinition : { EnumValueDefinition+ }
       * ```
       */
      parseEnumValuesDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          TokenKind.BRACE_R
        );
      }
      /**
       * EnumValueDefinition : Description? EnumValue Directives[Const]?
       */
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(
              this._lexer.token
            )} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      /**
       * InputObjectTypeDefinition :
       *   - Description? input Name Directives[Const]? InputFieldsDefinition?
       */
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * InputFieldsDefinition : { InputValueDefinition+ }
       * ```
       */
      parseInputFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseInputValueDef,
          TokenKind.BRACE_R
        );
      }
      /**
       * TypeSystemExtension :
       *   - SchemaExtension
       *   - TypeExtension
       *
       * TypeExtension :
       *   - ScalarTypeExtension
       *   - ObjectTypeExtension
       *   - InterfaceTypeExtension
       *   - UnionTypeExtension
       *   - EnumTypeExtension
       *   - InputObjectTypeDefinition
       */
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      /**
       * ```
       * SchemaExtension :
       *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
       *  - extend schema Directives[Const]
       * ```
       */
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      /**
       * ScalarTypeExtension :
       *   - extend scalar Name Directives[Const]
       */
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      /**
       * ObjectTypeExtension :
       *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend type Name ImplementsInterfaces? Directives[Const]
       *  - extend type Name ImplementsInterfaces
       */
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * InterfaceTypeExtension :
       *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend interface Name ImplementsInterfaces? Directives[Const]
       *  - extend interface Name ImplementsInterfaces
       */
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeExtension :
       *   - extend union Name Directives[Const]? UnionMemberTypes
       *   - extend union Name Directives[Const]
       */
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types
        });
      }
      /**
       * EnumTypeExtension :
       *   - extend enum Name Directives[Const]? EnumValuesDefinition
       *   - extend enum Name Directives[Const]
       */
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      /**
       * InputObjectTypeExtension :
       *   - extend input Name Directives[Const]? InputFieldsDefinition
       *   - extend input Name Directives[Const]
       */
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * DirectiveDefinition :
       *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
       * ```
       */
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      /**
       * DirectiveLocations :
       *   - `|`? DirectiveLocation
       *   - DirectiveLocations | DirectiveLocation
       */
      parseDirectiveLocations() {
        return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
      }
      /*
       * DirectiveLocation :
       *   - ExecutableDirectiveLocation
       *   - TypeSystemDirectiveLocation
       *
       * ExecutableDirectiveLocation : one of
       *   `QUERY`
       *   `MUTATION`
       *   `SUBSCRIPTION`
       *   `FIELD`
       *   `FRAGMENT_DEFINITION`
       *   `FRAGMENT_SPREAD`
       *   `INLINE_FRAGMENT`
       *
       * TypeSystemDirectiveLocation : one of
       *   `SCHEMA`
       *   `SCALAR`
       *   `OBJECT`
       *   `FIELD_DEFINITION`
       *   `ARGUMENT_DEFINITION`
       *   `INTERFACE`
       *   `UNION`
       *   `ENUM`
       *   `ENUM_VALUE`
       *   `INPUT_OBJECT`
       *   `INPUT_FIELD_DEFINITION`
       */
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
          return name;
        }
        throw this.unexpected(start);
      }
      // Core parsing utility functions
      /**
       * Returns a node that, if configured to do so, sets a "loc" field as a
       * location object, used to identify the place in the source that created a
       * given parsed object.
       */
      node(startToken, node) {
        if (this._options.noLocation !== true) {
          node.loc = new Location(
            startToken,
            this._lexer.lastToken,
            this._lexer.source
          );
        }
        return node;
      }
      /**
       * Determines if the next token is of a given kind
       */
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      /**
       * If the next token is of the given kind, return that token after advancing the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return token;
        }
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
        );
      }
      /**
       * If the next token is of the given kind, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * If the next token is a given keyword, advance the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
        } else {
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Expected "${value}", found ${getTokenDesc(token)}.`
          );
        }
      }
      /**
       * If the next token is a given keyword, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * Helper function for creating an error when an unexpected lexed token is encountered.
       */
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return syntaxError(
          this._lexer.source,
          token.start,
          `Unexpected ${getTokenDesc(token)}.`
        );
      }
      /**
       * Returns a possibly empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      /**
       * Returns a list of parse nodes, determined by the parseFn.
       * It can be empty only if open token is missing otherwise it will always return non-empty list
       * that begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
       * Advances the parser to the next lex token after last item in the list.
       */
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
      advanceLexer() {
        const { maxTokens } = this._options;
        const token = this._lexer.advance();
        if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
          ++this._tokenCounter;
          if (this._tokenCounter > maxTokens) {
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Document contains more that ${maxTokens} tokens. Parsing aborted.`
            );
          }
        }
      }
    };
  }
});

// ../node_modules/graphql/jsutils/didYouMean.mjs
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var import_dist88, import_dist89, import_dist90, MAX_SUGGESTIONS;
var init_didYouMean = __esm({
  "../node_modules/graphql/jsutils/didYouMean.mjs"() {
    import_dist88 = __toESM(require_dist(), 1);
    import_dist89 = __toESM(require_dist2(), 1);
    import_dist90 = __toESM(require_dist3(), 1);
    MAX_SUGGESTIONS = 5;
  }
});

// ../node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}
var import_dist91, import_dist92, import_dist93;
var init_identityFunc = __esm({
  "../node_modules/graphql/jsutils/identityFunc.mjs"() {
    import_dist91 = __toESM(require_dist(), 1);
    import_dist92 = __toESM(require_dist2(), 1);
    import_dist93 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result2 = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result2[keyFn(item)] = item;
  }
  return result2;
}
var import_dist94, import_dist95, import_dist96;
var init_keyMap = __esm({
  "../node_modules/graphql/jsutils/keyMap.mjs"() {
    import_dist94 = __toESM(require_dist(), 1);
    import_dist95 = __toESM(require_dist2(), 1);
    import_dist96 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result2 = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result2[keyFn(item)] = valFn(item);
  }
  return result2;
}
var import_dist97, import_dist98, import_dist99;
var init_keyValMap = __esm({
  "../node_modules/graphql/jsutils/keyValMap.mjs"() {
    import_dist97 = __toESM(require_dist(), 1);
    import_dist98 = __toESM(require_dist2(), 1);
    import_dist99 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result2 = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result2[key] = fn(map[key], key);
  }
  return result2;
}
var import_dist100, import_dist101, import_dist102;
var init_mapValue = __esm({
  "../node_modules/graphql/jsutils/mapValue.mjs"() {
    import_dist100 = __toESM(require_dist(), 1);
    import_dist101 = __toESM(require_dist2(), 1);
    import_dist102 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}
var import_dist103, import_dist104, import_dist105, DIGIT_0, DIGIT_9;
var init_naturalCompare = __esm({
  "../node_modules/graphql/jsutils/naturalCompare.mjs"() {
    import_dist103 = __toESM(require_dist(), 1);
    import_dist104 = __toESM(require_dist2(), 1);
    import_dist105 = __toESM(require_dist3(), 1);
    DIGIT_0 = 48;
    DIGIT_9 = 57;
  }
});

// ../node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
var import_dist106, import_dist107, import_dist108, LexicalDistance;
var init_suggestionList = __esm({
  "../node_modules/graphql/jsutils/suggestionList.mjs"() {
    import_dist106 = __toESM(require_dist(), 1);
    import_dist107 = __toESM(require_dist2(), 1);
    import_dist108 = __toESM(require_dist3(), 1);
    init_naturalCompare();
    LexicalDistance = class {
      constructor(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0)
        ];
      }
      measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        const optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b = this._inputArray;
        if (a.length < b.length) {
          const tmp = a;
          a = b;
          b = tmp;
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        const rows = this._rows;
        for (let j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (let i = 1; i <= aLength; i++) {
          const upRow = rows[(i - 1) % 3];
          const currentRow = rows[i % 3];
          let smallestCell = currentRow[0] = i;
          for (let j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            let currentCell = Math.min(
              upRow[j] + 1,
              // delete
              currentRow[j - 1] + 1,
              // insert
              upRow[j - 1] + cost
              // substitute
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      }
    };
  }
});

// ../node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}
var import_dist109, import_dist110, import_dist111;
var init_toObjMap = __esm({
  "../node_modules/graphql/jsutils/toObjMap.mjs"() {
    import_dist109 = __toESM(require_dist(), 1);
    import_dist110 = __toESM(require_dist2(), 1);
    import_dist111 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var import_dist112, import_dist113, import_dist114, escapedRegExp, escapeSequences;
var init_printString = __esm({
  "../node_modules/graphql/language/printString.mjs"() {
    import_dist112 = __toESM(require_dist(), 1);
    import_dist113 = __toESM(require_dist2(), 1);
    import_dist114 = __toESM(require_dist3(), 1);
    escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 2F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 3F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 4F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      // 5F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 6F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// ../node_modules/graphql/language/visitor.mjs
function visit(root2, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys = [root2];
  let index = -1;
  let edits = [];
  let node = root2;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result2;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result2 = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result2 === BREAK) {
        break;
      }
      if (result2 === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result2 !== void 0) {
        edits.push([key, result2]);
        if (!isLeaving) {
          if (isNode(result2)) {
            node = result2;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result2 === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = /* @__PURE__ */ Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(void 0);
    const leaveList = new Array(visitors.length).fill(void 0);
    for (let i = 0; i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result2 = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
            if (result2 === false) {
              skipping[i] = node;
            } else if (result2 === BREAK) {
              skipping[i] = BREAK;
            } else if (result2 !== void 0) {
              return result2;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result2 = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
            if (result2 === BREAK) {
              skipping[i] = BREAK;
            } else if (result2 !== void 0 && result2 !== false) {
              return result2;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function getVisitFn(visitor, kind, isLeaving) {
  const { enter, leave } = getEnterLeaveForKind(visitor, kind);
  return isLeaving ? leave : enter;
}
var import_dist115, import_dist116, import_dist117, BREAK;
var init_visitor = __esm({
  "../node_modules/graphql/language/visitor.mjs"() {
    import_dist115 = __toESM(require_dist(), 1);
    import_dist116 = __toESM(require_dist2(), 1);
    import_dist117 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_inspect();
    init_ast();
    init_kinds();
    BREAK = Object.freeze({});
  }
});

// ../node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap2("{\n", indent(join(array, "\n")), "\n}");
}
function wrap2(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap2("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
var import_dist118, import_dist119, import_dist120, MAX_LINE_LENGTH, printDocASTReducer;
var init_printer = __esm({
  "../node_modules/graphql/language/printer.mjs"() {
    import_dist118 = __toESM(require_dist(), 1);
    import_dist119 = __toESM(require_dist2(), 1);
    import_dist120 = __toESM(require_dist3(), 1);
    init_blockString();
    init_printString();
    init_visitor();
    MAX_LINE_LENGTH = 80;
    printDocASTReducer = {
      Name: {
        leave: (node) => node.value
      },
      Variable: {
        leave: (node) => "$" + node.name
      },
      // Document
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap2("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join(
            [
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join(directives, " "))
      },
      SelectionSet: {
        leave: ({ selections }) => block(selections)
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap2("", alias, ": ") + name;
          let argsLine = prefix + wrap2("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap2("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap2(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(
          [
            "...",
            wrap2("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ],
          " "
        )
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // or removed in the future.
          `fragment ${name}${wrap2("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: {
        leave: ({ value }) => value
      },
      FloatValue: {
        leave: ({ value }) => value
      },
      StringValue: {
        leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
      },
      BooleanValue: {
        leave: ({ value }) => value ? "true" : "false"
      },
      NullValue: {
        leave: () => "null"
      },
      EnumValue: {
        leave: ({ value }) => value
      },
      ListValue: {
        leave: ({ values }) => "[" + join(values, ", ") + "]"
      },
      ObjectValue: {
        leave: ({ fields }) => "{" + join(fields, ", ") + "}"
      },
      ObjectField: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join(args, ", "), ")")
      },
      // Type
      NamedType: {
        leave: ({ name }) => name
      },
      ListType: {
        leave: ({ type }) => "[" + type + "]"
      },
      NonNullType: {
        leave: ({ type }) => type + "!"
      },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ description, directives, operationTypes }) => wrap2("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ description, name, directives }) => wrap2("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join(
          [
            "type",
            name,
            wrap2("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      FieldDefinition: {
        leave: ({ description, name, arguments: args, type, directives }) => wrap2("", description, "\n") + name + (hasMultilineItems(args) ? wrap2("(\n", indent(join(args, "\n")), "\n)") : wrap2("(", join(args, ", "), ")")) + ": " + type + wrap2(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ description, name, type, defaultValue, directives }) => wrap2("", description, "\n") + join(
          [name + ": " + type, wrap2("= ", defaultValue), join(directives, " ")],
          " "
        )
      },
      InterfaceTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join(
          [
            "interface",
            name,
            wrap2("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeDefinition: {
        leave: ({ description, name, directives, types }) => wrap2("", description, "\n") + join(
          ["union", name, join(directives, " "), wrap2("= ", join(types, " | "))],
          " "
        )
      },
      EnumTypeDefinition: {
        leave: ({ description, name, directives, values }) => wrap2("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ description, name, directives }) => wrap2("", description, "\n") + join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ description, name, directives, fields }) => wrap2("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ description, name, arguments: args, repeatable, locations }) => wrap2("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap2("(\n", indent(join(args, "\n")), "\n)") : wrap2("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(
          ["extend schema", join(directives, " "), block(operationTypes)],
          " "
        )
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend type",
            name,
            wrap2("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend interface",
            name,
            wrap2("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(
          [
            "extend union",
            name,
            join(directives, " "),
            wrap2("= ", join(types, " | "))
          ],
          " "
        )
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
  }
});

// ../node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}
var import_dist121, import_dist122, import_dist123;
var init_valueFromASTUntyped = __esm({
  "../node_modules/graphql/utilities/valueFromASTUntyped.mjs"() {
    import_dist121 = __toESM(require_dist(), 1);
    import_dist122 = __toESM(require_dist2(), 1);
    import_dist123 = __toESM(require_dist3(), 1);
    init_keyValMap();
    init_kinds();
  }
});

// ../node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1; i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}
var import_dist124, import_dist125, import_dist126;
var init_assertName = __esm({
  "../node_modules/graphql/type/assertName.mjs"() {
    import_dist124 = __toESM(require_dist(), 1);
    import_dist125 = __toESM(require_dist2(), 1);
    import_dist126 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_GraphQLError();
    init_characterClasses();
  }
});

// ../node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function assertType(type) {
  if (!isType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);
  }
  return type;
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function assertScalarType(type) {
  if (!isScalarType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);
  }
  return type;
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function assertObjectType(type) {
  if (!isObjectType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);
  }
  return type;
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function assertInterfaceType(type) {
  if (!isInterfaceType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL Interface type.`
    );
  }
  return type;
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function assertUnionType(type) {
  if (!isUnionType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);
  }
  return type;
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function assertEnumType(type) {
  if (!isEnumType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);
  }
  return type;
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function assertInputObjectType(type) {
  if (!isInputObjectType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL Input Object type.`
    );
  }
  return type;
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function assertListType(type) {
  if (!isListType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);
  }
  return type;
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function assertNonNullType(type) {
  if (!isNonNullType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);
  }
  return type;
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function assertInputType(type) {
  if (!isInputType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);
  }
  return type;
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function assertOutputType(type) {
  if (!isOutputType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);
  }
  return type;
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function assertLeafType(type) {
  if (!isLeafType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);
  }
  return type;
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function assertCompositeType(type) {
  if (!isCompositeType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL composite type.`
    );
  }
  return type;
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function assertAbstractType(type) {
  if (!isAbstractType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);
  }
  return type;
}
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function assertWrappingType(type) {
  if (!isWrappingType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);
  }
  return type;
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function assertNullableType(type) {
  if (!isNullableType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);
  }
  return type;
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function assertNamedType(type) {
  if (!isNamedType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);
  }
  return type;
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}
var import_dist127, import_dist128, import_dist129, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType;
var init_definition = __esm({
  "../node_modules/graphql/type/definition.mjs"() {
    import_dist127 = __toESM(require_dist(), 1);
    import_dist128 = __toESM(require_dist2(), 1);
    import_dist129 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_didYouMean();
    init_identityFunc();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_keyMap();
    init_keyValMap();
    init_mapValue();
    init_suggestionList();
    init_toObjMap();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_valueFromASTUntyped();
    init_assertName();
    GraphQLList = class {
      constructor(ofType) {
        isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLNonNull = class {
      constructor(ofType) {
        isNullableType(ofType) || devAssert(
          false,
          `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLScalarType = class {
      constructor(config) {
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
        this.name = assertName(config.name);
        this.description = config.description;
        this.specifiedByURL = config.specifiedByURL;
        this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
        this.parseValue = parseValue2;
        this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
          false,
          `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
        );
        config.serialize == null || typeof config.serialize === "function" || devAssert(
          false,
          `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
        );
        if (config.parseLiteral) {
          typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
            false,
            `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
          );
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLObjectType = class {
      constructor(config) {
        var _config$extensionASTN2;
        this.name = assertName(config.name);
        this.description = config.description;
        this.isTypeOf = config.isTypeOf;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = () => defineFieldMap(config);
        this._interfaces = () => defineInterfaces(config);
        config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
          false,
          `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLInterfaceType = class {
      constructor(config) {
        var _config$extensionASTN3;
        this.name = assertName(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        config.resolveType == null || typeof config.resolveType === "function" || devAssert(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLUnionType = class {
      constructor(config) {
        var _config$extensionASTN4;
        this.name = assertName(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(void 0, config);
        config.resolveType == null || typeof config.resolveType === "function" || devAssert(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLEnumType = class {
      /* <T> */
      constructor(config) {
        var _config$extensionASTN5;
        this.name = assertName(config.name);
        this.description = config.description;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
        this._valueLookup = null;
        this._nameLookup = null;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        if (typeof this._values === "function") {
          this._values = defineEnumValues(this.name, this._values());
        }
        return this._values;
      }
      getValue(name) {
        if (this._nameLookup === null) {
          this._nameLookup = keyMap(this.getValues(), (value) => value.name);
        }
        return this._nameLookup[name];
      }
      serialize(outputValue) {
        if (this._valueLookup === null) {
          this._valueLookup = new Map(
            this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
          );
        }
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
          );
        }
        return enumValue.name;
      }
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          const valueStr = inspect(inputValue);
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
          );
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new GraphQLError(
            `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
          );
        }
        return enumValue.value;
      }
      parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== Kind.ENUM) {
          const valueStr = print(valueNode);
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          const valueStr = print(valueNode);
          throw new GraphQLError(
            `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        return enumValue.value;
      }
      toConfig() {
        const values = keyValMap(
          this.getValues(),
          (value) => value.name,
          (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          })
        );
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLInputObjectType = class {
      constructor(config) {
        var _config$extensionASTN6, _config$isOneOf;
        this.name = assertName(config.name);
        this.description = config.description;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
        this._fields = defineInputFieldMap.bind(void 0, config);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const fields = mapValue(this.getFields(), (field) => ({
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          isOneOf: this.isOneOf
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
  }
});

// ../node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}
var import_dist130, import_dist131, import_dist132;
var init_typeComparators = __esm({
  "../node_modules/graphql/utilities/typeComparators.mjs"() {
    import_dist130 = __toESM(require_dist(), 1);
    import_dist131 = __toESM(require_dist2(), 1);
    import_dist132 = __toESM(require_dist3(), 1);
    init_definition();
  }
});

// ../node_modules/graphql/type/scalars.mjs
function isSpecifiedScalarType(type) {
  return specifiedScalarTypes.some(({ name }) => type.name === name);
}
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
var import_dist133, import_dist134, import_dist135, GRAPHQL_MAX_INT, GRAPHQL_MIN_INT, GraphQLInt, GraphQLFloat, GraphQLString, GraphQLBoolean, GraphQLID, specifiedScalarTypes;
var init_scalars = __esm({
  "../node_modules/graphql/type/scalars.mjs"() {
    import_dist133 = __toESM(require_dist(), 1);
    import_dist134 = __toESM(require_dist2(), 1);
    import_dist135 = __toESM(require_dist3(), 1);
    init_inspect();
    init_isObjectLike();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    GRAPHQL_MAX_INT = 2147483647;
    GRAPHQL_MIN_INT = -2147483648;
    GraphQLInt = new GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${inspect(coercedValue)}`
          );
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${inspect(inputValue)}`
          );
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${inputValue}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
            {
              nodes: valueNode
            }
          );
        }
        return num;
      }
    });
    GraphQLFloat = new GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${inspect(coercedValue)}`
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${print(valueNode)}`,
            valueNode
          );
        }
        return parseFloat(valueNode.value);
      }
    });
    GraphQLString = new GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
          return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
          return coercedValue.toString();
        }
        throw new GraphQLError(
          `String cannot represent value: ${inspect(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          throw new GraphQLError(
            `String cannot represent a non string value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.STRING) {
          throw new GraphQLError(
            `String cannot represent a non string value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    GraphQLBoolean = new GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
          return coercedValue !== 0;
        }
        throw new GraphQLError(
          `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "boolean") {
          throw new GraphQLError(
            `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.BOOLEAN) {
          throw new GraphQLError(
            `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    GraphQLID = new GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
          return String(coercedValue);
        }
        throw new GraphQLError(
          `ID cannot represent value: ${inspect(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue === "string") {
          return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
          return inputValue.toString();
        }
        throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            "ID cannot represent a non-string and non-integer value: " + print(valueNode),
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    specifiedScalarTypes = Object.freeze([
      GraphQLString,
      GraphQLInt,
      GraphQLFloat,
      GraphQLBoolean,
      GraphQLID
    ]);
  }
});

// ../node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function assertDirective(directive) {
  if (!isDirective(directive)) {
    throw new Error(
      `Expected ${inspect(directive)} to be a GraphQL directive.`
    );
  }
  return directive;
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}
var import_dist136, import_dist137, import_dist138, GraphQLDirective, GraphQLIncludeDirective, GraphQLSkipDirective, DEFAULT_DEPRECATION_REASON, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective, GraphQLOneOfDirective, specifiedDirectives;
var init_directives = __esm({
  "../node_modules/graphql/type/directives.mjs"() {
    import_dist136 = __toESM(require_dist(), 1);
    import_dist137 = __toESM(require_dist2(), 1);
    import_dist138 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_toObjMap();
    init_directiveLocation();
    init_assertName();
    init_definition();
    init_scalars();
    GraphQLDirective = class {
      constructor(config) {
        var _config$isRepeatable, _config$args;
        this.name = assertName(config.name);
        this.description = config.description;
        this.locations = config.locations;
        this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
        const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
        isObjectLike(args) && !Array.isArray(args) || devAssert(
          false,
          `@${config.name} args must be an object with argument names as keys.`
        );
        this.args = defineArguments(args);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: argsToArgsConfig(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLIncludeDirective = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [
        DirectiveLocation.FIELD,
        DirectiveLocation.FRAGMENT_SPREAD,
        DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    GraphQLSkipDirective = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [
        DirectiveLocation.FIELD,
        DirectiveLocation.FRAGMENT_SPREAD,
        DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    DEFAULT_DEPRECATION_REASON = "No longer supported";
    GraphQLDeprecatedDirective = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        DirectiveLocation.FIELD_DEFINITION,
        DirectiveLocation.ARGUMENT_DEFINITION,
        DirectiveLocation.INPUT_FIELD_DEFINITION,
        DirectiveLocation.ENUM_VALUE
      ],
      args: {
        reason: {
          type: GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    GraphQLSpecifiedByDirective = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new GraphQLNonNull(GraphQLString),
          description: "The URL that specifies the behavior of this scalar."
        }
      }
    });
    GraphQLOneOfDirective = new GraphQLDirective({
      name: "oneOf",
      description: "Indicates exactly one field must be supplied and this field must not be `null`.",
      locations: [DirectiveLocation.INPUT_OBJECT],
      args: {}
    });
    specifiedDirectives = Object.freeze([
      GraphQLIncludeDirective,
      GraphQLSkipDirective,
      GraphQLDeprecatedDirective,
      GraphQLSpecifiedByDirective,
      GraphQLOneOfDirective
    ]);
  }
});

// ../node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}
var import_dist139, import_dist140, import_dist141;
var init_isIterableObject = __esm({
  "../node_modules/graphql/jsutils/isIterableObject.mjs"() {
    import_dist139 = __toESM(require_dist(), 1);
    import_dist140 = __toESM(require_dist2(), 1);
    import_dist141 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant4(false, "Unexpected input type: " + inspect(type));
}
var import_dist142, import_dist143, import_dist144, integerStringRegExp;
var init_astFromValue = __esm({
  "../node_modules/graphql/utilities/astFromValue.mjs"() {
    import_dist142 = __toESM(require_dist(), 1);
    import_dist143 = __toESM(require_dist2(), 1);
    import_dist144 = __toESM(require_dist3(), 1);
    init_inspect();
    init_invariant2();
    init_isIterableObject();
    init_isObjectLike();
    init_kinds();
    init_definition();
    init_scalars();
    integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// ../node_modules/graphql/type/introspection.mjs
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}
var import_dist145, import_dist146, import_dist147, __Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, TypeKind, __TypeKind, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, introspectionTypes;
var init_introspection = __esm({
  "../node_modules/graphql/type/introspection.mjs"() {
    import_dist145 = __toESM(require_dist(), 1);
    import_dist146 = __toESM(require_dist2(), 1);
    import_dist147 = __toESM(require_dist3(), 1);
    init_inspect();
    init_invariant2();
    init_directiveLocation();
    init_printer();
    init_astFromValue();
    init_definition();
    init_scalars();
    __Schema = new GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: () => ({
        description: {
          type: GraphQLString,
          resolve: (schema) => schema.description
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
          resolve(schema) {
            return Object.values(schema.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new GraphQLNonNull(__Type),
          resolve: (schema) => schema.getQueryType()
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getMutationType()
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getSubscriptionType()
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__Directive))
          ),
          resolve: (schema) => schema.getDirectives()
        }
      })
    });
    __Directive = new GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (directive) => directive.name
        },
        description: {
          type: GraphQLString,
          resolve: (directive) => directive.description
        },
        isRepeatable: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (directive) => directive.isRepeatable
        },
        locations: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
          ),
          resolve: (directive) => directive.locations
        },
        args: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__InputValue))
          ),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        }
      })
    });
    __DirectiveLocation = new GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    __Type = new GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: () => ({
        kind: {
          type: new GraphQLNonNull(__TypeKind),
          resolve(type) {
            if (isScalarType(type)) {
              return TypeKind.SCALAR;
            }
            if (isObjectType(type)) {
              return TypeKind.OBJECT;
            }
            if (isInterfaceType(type)) {
              return TypeKind.INTERFACE;
            }
            if (isUnionType(type)) {
              return TypeKind.UNION;
            }
            if (isEnumType(type)) {
              return TypeKind.ENUM;
            }
            if (isInputObjectType(type)) {
              return TypeKind.INPUT_OBJECT;
            }
            if (isListType(type)) {
              return TypeKind.LIST;
            }
            if (isNonNullType(type)) {
              return TypeKind.NON_NULL;
            }
            invariant4(false, `Unexpected type: "${inspect(type)}".`);
          }
        },
        name: {
          type: GraphQLString,
          resolve: (type) => "name" in type ? type.name : void 0
        },
        description: {
          type: GraphQLString,
          resolve: (type) => (
            /* c8 ignore next */
            "description" in type ? type.description : void 0
          )
        },
        specifiedByURL: {
          type: GraphQLString,
          resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
        },
        fields: {
          type: new GraphQLList(new GraphQLNonNull(__Field)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isObjectType(type) || isInterfaceType(type)) {
              const fields = Object.values(type.getFields());
              return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
            }
          }
        },
        interfaces: {
          type: new GraphQLList(new GraphQLNonNull(__Type)),
          resolve(type) {
            if (isObjectType(type) || isInterfaceType(type)) {
              return type.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new GraphQLList(new GraphQLNonNull(__Type)),
          resolve(type, _args, _context, { schema }) {
            if (isAbstractType(type)) {
              return schema.getPossibleTypes(type);
            }
          }
        },
        enumValues: {
          type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isEnumType(type)) {
              const values = type.getValues();
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        inputFields: {
          type: new GraphQLList(new GraphQLNonNull(__InputValue)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isInputObjectType(type)) {
              const values = Object.values(type.getFields());
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: (type) => "ofType" in type ? type.ofType : void 0
        },
        isOneOf: {
          type: GraphQLBoolean,
          resolve: (type) => {
            if (isInputObjectType(type)) {
              return type.isOneOf;
            }
          }
        }
      })
    });
    __Field = new GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (field) => field.name
        },
        description: {
          type: GraphQLString,
          resolve: (field) => field.description
        },
        args: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__InputValue))
          ),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        },
        type: {
          type: new GraphQLNonNull(__Type),
          resolve: (field) => field.type
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (field) => field.deprecationReason
        }
      })
    });
    __InputValue = new GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (inputValue) => inputValue.name
        },
        description: {
          type: GraphQLString,
          resolve: (inputValue) => inputValue.description
        },
        type: {
          type: new GraphQLNonNull(__Type),
          resolve: (inputValue) => inputValue.type
        },
        defaultValue: {
          type: GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(inputValue) {
            const { type, defaultValue } = inputValue;
            const valueAST = astFromValue(defaultValue, type);
            return valueAST ? print(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (obj) => obj.deprecationReason
        }
      })
    });
    __EnumValue = new GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (enumValue) => enumValue.name
        },
        description: {
          type: GraphQLString,
          resolve: (enumValue) => enumValue.description
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (enumValue) => enumValue.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (enumValue) => enumValue.deprecationReason
        }
      })
    });
    (function(TypeKind2) {
      TypeKind2["SCALAR"] = "SCALAR";
      TypeKind2["OBJECT"] = "OBJECT";
      TypeKind2["INTERFACE"] = "INTERFACE";
      TypeKind2["UNION"] = "UNION";
      TypeKind2["ENUM"] = "ENUM";
      TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
      TypeKind2["LIST"] = "LIST";
      TypeKind2["NON_NULL"] = "NON_NULL";
    })(TypeKind || (TypeKind = {}));
    __TypeKind = new GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    SchemaMetaFieldDef = {
      name: "__schema",
      type: new GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: (_source, _args, _context, { schema }) => schema,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: void 0,
          type: new GraphQLNonNull(GraphQLString),
          defaultValue: void 0,
          deprecationReason: void 0,
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: void 0
        }
      ],
      resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    TypeNameMetaFieldDef = {
      name: "__typename",
      type: new GraphQLNonNull(GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: (_source, _args, _context, { parentType }) => parentType.name,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    introspectionTypes = Object.freeze([
      __Schema,
      __Directive,
      __DirectiveLocation,
      __Type,
      __Field,
      __InputValue,
      __EnumValue,
      __TypeKind
    ]);
  }
});

// ../node_modules/graphql/type/schema.mjs
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
function collectReferencedTypes(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
}
var import_dist148, import_dist149, import_dist150, GraphQLSchema;
var init_schema = __esm({
  "../node_modules/graphql/type/schema.mjs"() {
    import_dist148 = __toESM(require_dist(), 1);
    import_dist149 = __toESM(require_dist2(), 1);
    import_dist150 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_toObjMap();
    init_ast();
    init_definition();
    init_directives();
    init_introspection();
    GraphQLSchema = class {
      // Used as a cache for validateSchema().
      constructor(config) {
        var _config$extensionASTN, _config$directives;
        this.__validationErrors = config.assumeValid === true ? [] : void 0;
        isObjectLike(config) || devAssert(false, "Must provide configuration object.");
        !config.types || Array.isArray(config.types) || devAssert(
          false,
          `"types" must be Array if provided but got: ${inspect(config.types)}.`
        );
        !config.directives || Array.isArray(config.directives) || devAssert(
          false,
          `"directives" must be Array if provided but got: ${inspect(config.directives)}.`
        );
        this.description = config.description;
        this.extensions = toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config.query;
        this._mutationType = config.mutation;
        this._subscriptionType = config.subscription;
        this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
        const allReferencedTypes = new Set(config.types);
        if (config.types != null) {
          for (const type of config.types) {
            allReferencedTypes.delete(type);
            collectReferencedTypes(type, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives) {
          if (isDirective(directive)) {
            for (const arg of directive.args) {
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (const namedType of allReferencedTypes) {
          if (namedType == null) {
            continue;
          }
          const typeName = namedType.name;
          typeName || devAssert(
            false,
            "One of the provided types for building the Schema is missing a name."
          );
          if (this._typeMap[typeName] !== void 0) {
            throw new Error(
              `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
            );
          }
          this._typeMap[typeName] = namedType;
          if (isInterfaceType(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if (isInterfaceType(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if (isObjectType(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if (isInterfaceType(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(operation) {
        switch (operation) {
          case OperationTypeNode.QUERY:
            return this.getQueryType();
          case OperationTypeNode.MUTATION:
            return this.getMutationType();
          case OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(name) {
        return this.getTypeMap()[name];
      }
      getPossibleTypes(abstractType) {
        return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      }
      getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      }
      isSubType(abstractType, maybeSubType) {
        let map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = /* @__PURE__ */ Object.create(null);
          if (isUnionType(abstractType)) {
            for (const type of abstractType.getTypes()) {
              map[type.name] = true;
            }
          } else {
            const implementations = this.getImplementations(abstractType);
            for (const type of implementations.objects) {
              map[type.name] = true;
            }
            for (const type of implementations.interfaces) {
              map[type.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(name) {
        return this.getDirectives().find((directive) => directive.name === name);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== void 0
        };
      }
    };
  }
});

// ../node_modules/graphql/type/validate.mjs
function validateSchema(schema) {
  assertSchema(schema);
  if (schema.__validationErrors) {
    return schema.__validationErrors;
  }
  const context = new SchemaValidationContext(schema);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema) {
  const errors = validateSchema(schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function validateRootTypes(context) {
  const schema = context.schema;
  const queryType = schema.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(
      `Query root type must be Object type, it cannot be ${inspect(
        queryType
      )}.`,
      (_getOperationTypeNode = getOperationTypeNode(
        schema,
        OperationTypeNode.QUERY
      )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
    );
  }
  const mutationType = schema.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError(
      `Mutation root type must be Object type if provided, it cannot be ${inspect(mutationType)}.`,
      (_getOperationTypeNode2 = getOperationTypeNode(
        schema,
        OperationTypeNode.MUTATION
      )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
    );
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError(
      `Subscription root type must be Object type if provided, it cannot be ${inspect(subscriptionType)}.`,
      (_getOperationTypeNode3 = getOperationTypeNode(
        schema,
        OperationTypeNode.SUBSCRIPTION
      )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
    );
  }
}
function getOperationTypeNode(schema, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    (schemaNode) => {
      var _schemaNode$operation;
      return (
        /* c8 ignore next */
        (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
      );
    }
  ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
}
function validateDirectives(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(
        `Expected directive but got: ${inspect(directive)}.`,
        directive === null || directive === void 0 ? void 0 : directive.astNode
      );
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(
          `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect(arg.type)}.`,
          arg.astNode
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(
          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
          ]
        );
      }
    }
  }
}
function validateName(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(
      `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      node.astNode
    );
  }
}
function validateTypes(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context.reportError(
        `Expected GraphQL named type but got: ${inspect(type)}.`,
        type.astNode
      );
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context, type);
    }
    if (isObjectType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isInterfaceType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context, type);
      validateInputObjectCircularRefs(type);
    }
  }
}
function validateFields(context, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(
        `The type of ${type.name}.${field.name} must be Output Type but got: ${inspect(field.type)}.`,
        (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
      );
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(
          `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect(arg.type)}.`,
          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(
          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
          ]
        );
      }
    }
  }
}
function validateInterfaces(context, type) {
  const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(
        `Type ${inspect(type)} must only implement Interface types, it cannot implement ${inspect(iface)}.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (type === iface) {
      context.reportError(
        `Type ${type.name} cannot implement itself because it would create a circular reference.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(
        `Type ${type.name} can only implement ${iface.name} once.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type, iface);
    validateTypeImplementsInterface(context, type, iface);
  }
}
function validateTypeImplementsInterface(context, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
      );
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expects type ${inspect(ifaceField.type)} but ${type.name}.${fieldName} is type ${inspect(typeField.type)}.`,
        [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
        ]
      );
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
          [ifaceArg.astNode, typeField.astNode]
        );
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${inspect(typeArg.type)}.`,
          [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
          ]
        );
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(
          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
          [typeArg.astNode, ifaceField.astNode]
        );
      }
    }
  }
}
function validateTypeImplementsAncestors(context, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(
        transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
        [
          ...getAllImplementsInterfaceNodes(iface, transitive),
          ...getAllImplementsInterfaceNodes(type, iface)
        ]
      );
    }
  }
}
function validateUnionMembers(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(
      `Union type ${union.name} must define one or more member types.`,
      [union.astNode, ...union.extensionASTNodes]
    );
  }
  const includedTypeNames = /* @__PURE__ */ Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(
        `Union type ${union.name} can only include type ${memberType.name} once.`,
        getUnionMemberTypeNodes(union, memberType.name)
      );
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(
        `Union type ${union.name} can only include Object types, it cannot include ${inspect(memberType)}.`,
        getUnionMemberTypeNodes(union, String(memberType))
      );
    }
  }
}
function validateEnumValues(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(
      `Enum type ${enumType.name} must define one or more values.`,
      [enumType.astNode, ...enumType.extensionASTNodes]
    );
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
}
function validateInputFields(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(
      `Input Object type ${inputObj.name} must define one or more fields.`,
      [inputObj.astNode, ...inputObj.extensionASTNodes]
    );
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(
        `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect(field.type)}.`,
        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
      );
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(
        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
        [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
        ]
      );
    }
    if (inputObj.isOneOf) {
      validateOneOfInputObjectField(inputObj, field, context);
    }
  }
}
function validateOneOfInputObjectField(type, field, context) {
  if (isNonNullType(field.type)) {
    var _field$astNode4;
    context.reportError(
      `OneOf input field ${type.name}.${field.name} must be nullable.`,
      (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0 ? void 0 : _field$astNode4.type
    );
  }
  if (field.defaultValue !== void 0) {
    context.reportError(
      `OneOf input field ${type.name}.${field.name} cannot have a default value.`,
      field.astNode
    );
  }
}
function createInputObjectCircularRefsValidator(context) {
  const visitedTypes = /* @__PURE__ */ Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(
            `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
            cyclePath.map((fieldObj) => fieldObj.astNode)
          );
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllImplementsInterfaceNodes(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (
      /* c8 ignore next */
      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
    );
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
}
function getUnionMemberTypeNodes(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (
      /* c8 ignore next */
      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
    );
  }).filter((typeNode) => typeNode.name.value === typeName);
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
    (node) => node.name.value === GraphQLDeprecatedDirective.name
  );
}
var import_dist151, import_dist152, import_dist153, SchemaValidationContext;
var init_validate = __esm({
  "../node_modules/graphql/type/validate.mjs"() {
    import_dist151 = __toESM(require_dist(), 1);
    import_dist152 = __toESM(require_dist2(), 1);
    import_dist153 = __toESM(require_dist3(), 1);
    init_inspect();
    init_GraphQLError();
    init_ast();
    init_typeComparators();
    init_definition();
    init_directives();
    init_introspection();
    init_schema();
    SchemaValidationContext = class {
      constructor(schema) {
        this._errors = [];
        this.schema = schema;
      }
      reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(
          new GraphQLError(message, {
            nodes: _nodes
          })
        );
      }
      getErrors() {
        return this._errors;
      }
    };
  }
});

// ../node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}
var import_dist154, import_dist155, import_dist156;
var init_typeFromAST = __esm({
  "../node_modules/graphql/utilities/typeFromAST.mjs"() {
    import_dist154 = __toESM(require_dist(), 1);
    import_dist155 = __toESM(require_dist2(), 1);
    import_dist156 = __toESM(require_dist3(), 1);
    init_kinds();
    init_definition();
  }
});

// ../node_modules/graphql/utilities/TypeInfo.mjs
function getFieldDef(schema, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor, node.kind).enter;
      if (fn) {
        const result2 = fn.apply(visitor, args);
        if (result2 !== void 0) {
          typeInfo.leave(node);
          if (isNode(result2)) {
            typeInfo.enter(result2);
          }
        }
        return result2;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor, node.kind).leave;
      let result2;
      if (fn) {
        result2 = fn.apply(visitor, args);
      }
      typeInfo.leave(node);
      return result2;
    }
  };
}
var import_dist157, import_dist158, import_dist159, TypeInfo;
var init_TypeInfo = __esm({
  "../node_modules/graphql/utilities/TypeInfo.mjs"() {
    import_dist157 = __toESM(require_dist(), 1);
    import_dist158 = __toESM(require_dist2(), 1);
    import_dist159 = __toESM(require_dist3(), 1);
    init_ast();
    init_kinds();
    init_visitor();
    init_definition();
    init_introspection();
    init_typeFromAST();
    TypeInfo = class {
      constructor(schema, initialType, getFieldDefFn) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if (isInputType(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if (isCompositeType(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if (isOutputType(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(node) {
        const schema = this._schema;
        switch (node.kind) {
          case Kind.SELECTION_SET: {
            const namedType = getNamedType(this.getType());
            this._parentTypeStack.push(
              isCompositeType(namedType) ? namedType : void 0
            );
            break;
          }
          case Kind.FIELD: {
            const parentType = this.getParentType();
            let fieldDef;
            let fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
            break;
          }
          case Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case Kind.OPERATION_DEFINITION: {
            const rootType = schema.getRootType(node.operation);
            this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
            break;
          }
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION: {
            const typeConditionAST = node.typeCondition;
            const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
            this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
            break;
          }
          case Kind.VARIABLE_DEFINITION: {
            const inputType = typeFromAST(schema, node.type);
            this._inputTypeStack.push(
              isInputType(inputType) ? inputType : void 0
            );
            break;
          }
          case Kind.ARGUMENT: {
            var _this$getDirective;
            let argDef;
            let argType;
            const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = fieldOrDirective.args.find(
                (arg) => arg.name === node.name.value
              );
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
            break;
          }
          case Kind.LIST: {
            const listType = getNullableType(this.getInputType());
            const itemType = isListType(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
            break;
          }
          case Kind.OBJECT_FIELD: {
            const objectType = getNamedType(this.getInputType());
            let inputFieldType;
            let inputField;
            if (isInputObjectType(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(
              inputField ? inputField.defaultValue : void 0
            );
            this._inputTypeStack.push(
              isInputType(inputFieldType) ? inputFieldType : void 0
            );
            break;
          }
          case Kind.ENUM: {
            const enumType = getNamedType(this.getInputType());
            let enumValue;
            if (isEnumType(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
          default:
        }
      }
      leave(node) {
        switch (node.kind) {
          case Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case Kind.DIRECTIVE:
            this._directive = null;
            break;
          case Kind.OPERATION_DEFINITION:
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.LIST:
          case Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    };
  }
});

// ../node_modules/graphql/language/predicates.mjs
function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;
}
function isValueNode(node) {
  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;
}
function isConstValueNode(node) {
  return isValueNode(node) && (node.kind === Kind.LIST ? node.values.some(isConstValueNode) : node.kind === Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== Kind.VARIABLE);
}
function isTypeNode(node) {
  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}
var import_dist160, import_dist161, import_dist162;
var init_predicates = __esm({
  "../node_modules/graphql/language/predicates.mjs"() {
    import_dist160 = __toESM(require_dist(), 1);
    import_dist161 = __toESM(require_dist2(), 1);
    import_dist162 = __toESM(require_dist3(), 1);
    init_kinds();
  }
});

// ../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}
var import_dist163, import_dist164, import_dist165;
var init_ExecutableDefinitionsRule = __esm({
  "../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs"() {
    import_dist163 = __toESM(require_dist(), 1);
    import_dist164 = __toESM(require_dist2(), 1);
    import_dist165 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_kinds();
    init_predicates();
  }
});

// ../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}
var import_dist166, import_dist167, import_dist168;
var init_FieldsOnCorrectTypeRule = __esm({
  "../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"() {
    import_dist166 = __toESM(require_dist(), 1);
    import_dist167 = __toESM(require_dist2(), 1);
    import_dist168 = __toESM(require_dist3(), 1);
    init_didYouMean();
    init_naturalCompare();
    init_suggestionList();
    init_GraphQLError();
    init_definition();
  }
});

// ../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}
var import_dist169, import_dist170, import_dist171;
var init_FragmentsOnCompositeTypesRule = __esm({
  "../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs"() {
    import_dist169 = __toESM(require_dist(), 1);
    import_dist170 = __toESM(require_dist2(), 1);
    import_dist171 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});

// ../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}
var import_dist172, import_dist173, import_dist174;
var init_KnownArgumentNamesRule = __esm({
  "../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs"() {
    import_dist172 = __toESM(require_dist(), 1);
    import_dist173 = __toESM(require_dist2(), 1);
    import_dist174 = __toESM(require_dist3(), 1);
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_directives();
  }
});

// ../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant4(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant4(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant4(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}
var import_dist175, import_dist176, import_dist177;
var init_KnownDirectivesRule = __esm({
  "../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs"() {
    import_dist175 = __toESM(require_dist(), 1);
    import_dist176 = __toESM(require_dist2(), 1);
    import_dist177 = __toESM(require_dist3(), 1);
    init_inspect();
    init_invariant2();
    init_GraphQLError();
    init_ast();
    init_directiveLocation();
    init_kinds();
    init_directives();
  }
});

// ../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}
var import_dist178, import_dist179, import_dist180;
var init_KnownFragmentNamesRule = __esm({
  "../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs"() {
    import_dist178 = __toESM(require_dist(), 1);
    import_dist179 = __toESM(require_dist2(), 1);
    import_dist180 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}
var import_dist181, import_dist182, import_dist183, standardTypeNames;
var init_KnownTypeNamesRule = __esm({
  "../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"() {
    import_dist181 = __toESM(require_dist(), 1);
    import_dist182 = __toESM(require_dist2(), 1);
    import_dist183 = __toESM(require_dist3(), 1);
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_predicates();
    init_introspection();
    init_scalars();
    standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
      (type) => type.name
    );
  }
});

// ../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var import_dist184, import_dist185, import_dist186;
var init_LoneAnonymousOperationRule = __esm({
  "../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs"() {
    import_dist184 = __toESM(require_dist(), 1);
    import_dist185 = __toESM(require_dist2(), 1);
    import_dist186 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_kinds();
  }
});

// ../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}
var import_dist187, import_dist188, import_dist189;
var init_LoneSchemaDefinitionRule = __esm({
  "../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs"() {
    import_dist187 = __toESM(require_dist(), 1);
    import_dist188 = __toESM(require_dist2(), 1);
    import_dist189 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node.kind === Kind.FIELD && // check all introspection lists
    (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node]
            })
          );
          return false;
        }
      }
    }
  };
}
var import_dist190, import_dist191, import_dist192, MAX_LISTS_DEPTH;
var init_MaxIntrospectionDepthRule = __esm({
  "../node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs"() {
    import_dist190 = __toESM(require_dist(), 1);
    import_dist191 = __toESM(require_dist2(), 1);
    import_dist192 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_kinds();
    MAX_LISTS_DEPTH = 3;
  }
});

// ../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}
var import_dist193, import_dist194, import_dist195;
var init_NoFragmentCyclesRule = __esm({
  "../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"() {
    import_dist193 = __toESM(require_dist(), 1);
    import_dist194 = __toESM(require_dist2(), 1);
    import_dist195 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}
var import_dist196, import_dist197, import_dist198;
var init_NoUndefinedVariablesRule = __esm({
  "../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs"() {
    import_dist196 = __toESM(require_dist(), 1);
    import_dist197 = __toESM(require_dist2(), 1);
    import_dist198 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}
var import_dist199, import_dist200, import_dist201;
var init_NoUnusedFragmentsRule = __esm({
  "../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs"() {
    import_dist199 = __toESM(require_dist(), 1);
    import_dist200 = __toESM(require_dist2(), 1);
    import_dist201 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}
var import_dist202, import_dist203, import_dist204;
var init_NoUnusedVariablesRule = __esm({
  "../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs"() {
    import_dist202 = __toESM(require_dist(), 1);
    import_dist203 = __toESM(require_dist2(), 1);
    import_dist204 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}
var import_dist205, import_dist206, import_dist207;
var init_sortValueNode = __esm({
  "../node_modules/graphql/utilities/sortValueNode.mjs"() {
    import_dist205 = __toESM(require_dist(), 1);
    import_dist206 = __toESM(require_dist2(), 1);
    import_dist207 = __toESM(require_dist3(), 1);
    init_naturalCompare();
    init_kinds();
  }
});

// ../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i]
      );
      for (let j = i + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0; i < fields.length; i++) {
        for (let j = i + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value) {
  return print(sortValueNode(value));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result2 = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result2);
  return result2;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var import_dist208, import_dist209, import_dist210, PairSet;
var init_OverlappingFieldsCanBeMergedRule = __esm({
  "../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"() {
    import_dist208 = __toESM(require_dist(), 1);
    import_dist209 = __toESM(require_dist2(), 1);
    import_dist210 = __toESM(require_dist3(), 1);
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_sortValueNode();
    init_typeFromAST();
    PairSet = class {
      constructor() {
        this._data = /* @__PURE__ */ new Map();
      }
      has(a, b, areMutuallyExclusive) {
        var _this$_data$get;
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const result2 = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
        if (result2 === void 0) {
          return false;
        }
        return areMutuallyExclusive ? true : areMutuallyExclusive === result2;
      }
      add(a, b, areMutuallyExclusive) {
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const map = this._data.get(key1);
        if (map === void 0) {
          this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
        } else {
          map.set(key2, areMutuallyExclusive);
        }
      }
    };
  }
});

// ../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}
var import_dist211, import_dist212, import_dist213;
var init_PossibleFragmentSpreadsRule = __esm({
  "../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"() {
    import_dist211 = __toESM(require_dist(), 1);
    import_dist212 = __toESM(require_dist2(), 1);
    import_dist213 = __toESM(require_dist3(), 1);
    init_inspect();
    init_GraphQLError();
    init_definition();
    init_typeComparators();
    init_typeFromAST();
  }
});

// ../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant4(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant4(false, "Unexpected kind: " + inspect(kind));
  }
}
var import_dist214, import_dist215, import_dist216, defKindToExtKind;
var init_PossibleTypeExtensionsRule = __esm({
  "../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"() {
    import_dist214 = __toESM(require_dist(), 1);
    import_dist215 = __toESM(require_dist2(), 1);
    import_dist216 = __toESM(require_dist3(), 1);
    init_didYouMean();
    init_inspect();
    init_invariant2();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_definition();
    defKindToExtKind = {
      [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
      [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
      [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
      [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
      [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
      [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
  }
});

// ../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}
var import_dist217, import_dist218, import_dist219;
var init_ProvidedRequiredArgumentsRule = __esm({
  "../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs"() {
    import_dist217 = __toESM(require_dist(), 1);
    import_dist218 = __toESM(require_dist2(), 1);
    import_dist219 = __toESM(require_dist3(), 1);
    init_inspect();
    init_keyMap();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_directives();
  }
});

// ../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
var import_dist220, import_dist221, import_dist222;
var init_ScalarLeafsRule = __esm({
  "../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs"() {
    import_dist220 = __toESM(require_dist(), 1);
    import_dist221 = __toESM(require_dist2(), 1);
    import_dist222 = __toESM(require_dist3(), 1);
    init_inspect();
    init_GraphQLError();
    init_definition();
  }
});

// ../node_modules/graphql/jsutils/printPathArray.mjs
function printPathArray(path) {
  return path.map(
    (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
  ).join("");
}
var import_dist223, import_dist224, import_dist225;
var init_printPathArray = __esm({
  "../node_modules/graphql/jsutils/printPathArray.mjs"() {
    import_dist223 = __toESM(require_dist(), 1);
    import_dist224 = __toESM(require_dist2(), 1);
    import_dist225 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/Path.mjs
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
var import_dist226, import_dist227, import_dist228;
var init_Path = __esm({
  "../node_modules/graphql/jsutils/Path.mjs"() {
    import_dist226 = __toESM(require_dist(), 1);
    import_dist227 = __toESM(require_dist2(), 1);
    import_dist228 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, void 0);
}
function defaultOnError(path, invalidValue, error) {
  let errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix + ": " + error.message;
  throw error;
}
function coerceInputValueImpl(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(
      pathToArray(path),
      inputValue,
      new GraphQLError(
        `Expected non-nullable type "${inspect(type)}" not to be null.`
      )
    );
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, void 0);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}" to be an object.`)
      );
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === void 0) {
        if (field.defaultValue !== void 0) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(
            pathToArray(path),
            inputValue,
            new GraphQLError(
              `Field "${field.name}" of required type "${typeStr}" was not provided.`
            )
          );
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(
        fieldValue,
        field.type,
        onError,
        addPath(path, field.name, type.name)
      );
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(
          fieldName,
          Object.keys(type.getFields())
        );
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(
            `Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)
          )
        );
      }
    }
    if (type.isOneOf) {
      const keys = Object.keys(coercedValue);
      if (keys.length !== 1) {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(
            `Exactly one key must be specified for OneOf type "${type.name}".`
          )
        );
      }
      const key = keys[0];
      const value = coercedValue[key];
      if (value === null) {
        onError(
          pathToArray(path).concat(key),
          value,
          new GraphQLError(`Field "${key}" must be non-null.`)
        );
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(`Expected type "${type.name}". ` + error.message, {
            originalError: error
          })
        );
      }
      return;
    }
    if (parseResult === void 0) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}".`)
      );
    }
    return parseResult;
  }
  invariant4(false, "Unexpected input type: " + inspect(type));
}
var import_dist229, import_dist230, import_dist231;
var init_coerceInputValue = __esm({
  "../node_modules/graphql/utilities/coerceInputValue.mjs"() {
    import_dist229 = __toESM(require_dist(), 1);
    import_dist230 = __toESM(require_dist2(), 1);
    import_dist231 = __toESM(require_dist3(), 1);
    init_didYouMean();
    init_inspect();
    init_invariant2();
    init_isIterableObject();
    init_isObjectLike();
    init_Path();
    init_printPathArray();
    init_suggestionList();
    init_GraphQLError();
    init_definition();
  }
});

// ../node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result2;
    try {
      result2 = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result2 === void 0) {
      return;
    }
    return result2;
  }
  invariant4(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}
var import_dist232, import_dist233, import_dist234;
var init_valueFromAST = __esm({
  "../node_modules/graphql/utilities/valueFromAST.mjs"() {
    import_dist232 = __toESM(require_dist(), 1);
    import_dist233 = __toESM(require_dist2(), 1);
    import_dist234 = __toESM(require_dist3(), 1);
    init_inspect();
    init_invariant2();
    init_keyMap();
    init_kinds();
    init_definition();
  }
});

// ../node_modules/graphql/execution/values.mjs
function getVariableValues(schema, varDefNodes, inputs, options) {
  const errors = [];
  const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
  try {
    const coerced = coerceVariableValues(
      schema,
      varDefNodes,
      inputs,
      (error) => {
        if (maxErrors != null && errors.length >= maxErrors) {
          throw new GraphQLError(
            "Too many errors processing variables, error limit reached. Execution aborted."
          );
        }
        errors.push(error);
      }
    );
    if (errors.length === 0) {
      return {
        coerced
      };
    }
  } catch (error) {
    errors.push(error);
  }
  return {
    errors
  };
}
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(
        new GraphQLError(
          `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
          {
            nodes: varDefNode.type
          }
        )
      );
      continue;
    }
    if (!hasOwnProperty(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect(varType);
        onError(
          new GraphQLError(
            `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
            {
              nodes: varDefNode
            }
          )
        );
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect(varType);
      onError(
        new GraphQLError(
          `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
          {
            nodes: varDefNode
          }
        )
      );
      continue;
    }
    coercedValues[varName] = coerceInputValue(
      value,
      varType,
      (path, invalidValue, error) => {
        let prefix = `Variable "$${varName}" got invalid value ` + inspect(invalidValue);
        if (path.length > 0) {
          prefix += ` at "${varName}${printPathArray(path)}"`;
        }
        onError(
          new GraphQLError(prefix + "; " + error.message, {
            nodes: varDefNode,
            originalError: error
          })
        );
      }
    );
  }
  return coercedValues;
}
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var import_dist235, import_dist236, import_dist237;
var init_values = __esm({
  "../node_modules/graphql/execution/values.mjs"() {
    import_dist235 = __toESM(require_dist(), 1);
    import_dist236 = __toESM(require_dist2(), 1);
    import_dist237 = __toESM(require_dist3(), 1);
    init_inspect();
    init_keyMap();
    init_printPathArray();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_coerceInputValue();
    init_typeFromAST();
    init_valueFromAST();
  }
});

// ../node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
var import_dist238, import_dist239, import_dist240;
var init_collectFields = __esm({
  "../node_modules/graphql/execution/collectFields.mjs"() {
    import_dist238 = __toESM(require_dist(), 1);
    import_dist239 = __toESM(require_dist2(), 1);
    import_dist240 = __toESM(require_dist3(), 1);
    init_kinds();
    init_definition();
    init_directives();
    init_typeFromAST();
    init_values();
  }
});

// ../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName2 = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName2 != null ? `Subscription "${operationName2}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName2 != null ? `Subscription "${operationName2}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
var import_dist241, import_dist242, import_dist243;
var init_SingleFieldSubscriptionsRule = __esm({
  "../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs"() {
    import_dist241 = __toESM(require_dist(), 1);
    import_dist242 = __toESM(require_dist2(), 1);
    import_dist243 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_kinds();
    init_collectFields();
  }
});

// ../node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result2 = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result2.get(key);
    if (group === void 0) {
      result2.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result2;
}
var import_dist244, import_dist245, import_dist246;
var init_groupBy = __esm({
  "../node_modules/graphql/jsutils/groupBy.mjs"() {
    import_dist244 = __toESM(require_dist(), 1);
    import_dist245 = __toESM(require_dist2(), 1);
    import_dist246 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}
var import_dist247, import_dist248, import_dist249;
var init_UniqueArgumentDefinitionNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs"() {
    import_dist247 = __toESM(require_dist(), 1);
    import_dist248 = __toESM(require_dist2(), 1);
    import_dist249 = __toESM(require_dist3(), 1);
    init_groupBy();
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}
var import_dist250, import_dist251, import_dist252;
var init_UniqueArgumentNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs"() {
    import_dist250 = __toESM(require_dist(), 1);
    import_dist251 = __toESM(require_dist2(), 1);
    import_dist252 = __toESM(require_dist3(), 1);
    init_groupBy();
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}
var import_dist253, import_dist254, import_dist255;
var init_UniqueDirectiveNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs"() {
    import_dist253 = __toESM(require_dist(), 1);
    import_dist254 = __toESM(require_dist2(), 1);
    import_dist255 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}
var import_dist256, import_dist257, import_dist258;
var init_UniqueDirectivesPerLocationRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"() {
    import_dist256 = __toESM(require_dist(), 1);
    import_dist257 = __toESM(require_dist2(), 1);
    import_dist258 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_directives();
  }
});

// ../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}
var import_dist259, import_dist260, import_dist261;
var init_UniqueEnumValueNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs"() {
    import_dist259 = __toESM(require_dist(), 1);
    import_dist260 = __toESM(require_dist2(), 1);
    import_dist261 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_definition();
  }
});

// ../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}
var import_dist262, import_dist263, import_dist264;
var init_UniqueFieldDefinitionNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs"() {
    import_dist262 = __toESM(require_dist(), 1);
    import_dist263 = __toESM(require_dist2(), 1);
    import_dist264 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_definition();
  }
});

// ../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}
var import_dist265, import_dist266, import_dist267;
var init_UniqueFragmentNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs"() {
    import_dist265 = __toESM(require_dist(), 1);
    import_dist266 = __toESM(require_dist2(), 1);
    import_dist267 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant4(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}
var import_dist268, import_dist269, import_dist270;
var init_UniqueInputFieldNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs"() {
    import_dist268 = __toESM(require_dist(), 1);
    import_dist269 = __toESM(require_dist2(), 1);
    import_dist270 = __toESM(require_dist3(), 1);
    init_invariant2();
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName2 = node.name;
      if (operationName2) {
        if (knownOperationNames[operationName2.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName2.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName2.value],
                  operationName2
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName2.value] = operationName2;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}
var import_dist271, import_dist272, import_dist273;
var init_UniqueOperationNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs"() {
    import_dist271 = __toESM(require_dist(), 1);
    import_dist272 = __toESM(require_dist2(), 1);
    import_dist273 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}
var import_dist274, import_dist275, import_dist276;
var init_UniqueOperationTypesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs"() {
    import_dist274 = __toESM(require_dist(), 1);
    import_dist275 = __toESM(require_dist2(), 1);
    import_dist276 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}
var import_dist277, import_dist278, import_dist279;
var init_UniqueTypeNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs"() {
    import_dist277 = __toESM(require_dist(), 1);
    import_dist278 = __toESM(require_dist2(), 1);
    import_dist279 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}
var import_dist280, import_dist281, import_dist282;
var init_UniqueVariableNamesRule = __esm({
  "../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs"() {
    import_dist280 = __toESM(require_dist(), 1);
    import_dist281 = __toESM(require_dist2(), 1);
    import_dist282 = __toESM(require_dist3(), 1);
    init_groupBy();
    init_GraphQLError();
  }
});

// ../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions = {};
      }
    },
    VariableDefinition(definition) {
      variableDefinitions[definition.variable.name.value] = definition;
    },
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
      if (type.isOneOf) {
        validateOneOfInputObject(
          context,
          node,
          type,
          fieldNodeMap,
          variableDefinitions
        );
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context, node, type, fieldNodeMap, variableDefinitions) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(
      new GraphQLError(
        `OneOf Input Object "${type.name}" must specify exactly one key.`,
        {
          nodes: [node]
        }
      )
    );
    return;
  }
  const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value || value.kind === Kind.NULL;
  const isVariable2 = (value === null || value === void 0 ? void 0 : value.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(
      new GraphQLError(`Field "${type.name}.${keys[0]}" must be non-null.`, {
        nodes: [node]
      })
    );
    return;
  }
  if (isVariable2) {
    const variableName = value.name.value;
    const definition = variableDefinitions[variableName];
    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type.name}".`,
          {
            nodes: [node]
          }
        )
      );
    }
  }
}
var import_dist283, import_dist284, import_dist285;
var init_ValuesOfCorrectTypeRule = __esm({
  "../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs"() {
    import_dist283 = __toESM(require_dist(), 1);
    import_dist284 = __toESM(require_dist2(), 1);
    import_dist285 = __toESM(require_dist3(), 1);
    init_didYouMean();
    init_inspect();
    init_keyMap();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
  }
});

// ../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}
var import_dist286, import_dist287, import_dist288;
var init_VariablesAreInputTypesRule = __esm({
  "../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs"() {
    import_dist286 = __toESM(require_dist(), 1);
    import_dist287 = __toESM(require_dist2(), 1);
    import_dist288 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});

// ../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}
var import_dist289, import_dist290, import_dist291;
var init_VariablesInAllowedPositionRule = __esm({
  "../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs"() {
    import_dist289 = __toESM(require_dist(), 1);
    import_dist290 = __toESM(require_dist2(), 1);
    import_dist291 = __toESM(require_dist3(), 1);
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_definition();
    init_typeComparators();
    init_typeFromAST();
  }
});

// ../node_modules/graphql/validation/specifiedRules.mjs
var import_dist292, import_dist293, import_dist294, recommendedRules, specifiedRules, specifiedSDLRules;
var init_specifiedRules = __esm({
  "../node_modules/graphql/validation/specifiedRules.mjs"() {
    import_dist292 = __toESM(require_dist(), 1);
    import_dist293 = __toESM(require_dist2(), 1);
    import_dist294 = __toESM(require_dist3(), 1);
    init_ExecutableDefinitionsRule();
    init_FieldsOnCorrectTypeRule();
    init_FragmentsOnCompositeTypesRule();
    init_KnownArgumentNamesRule();
    init_KnownDirectivesRule();
    init_KnownFragmentNamesRule();
    init_KnownTypeNamesRule();
    init_LoneAnonymousOperationRule();
    init_LoneSchemaDefinitionRule();
    init_MaxIntrospectionDepthRule();
    init_NoFragmentCyclesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedFragmentsRule();
    init_NoUnusedVariablesRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_PossibleFragmentSpreadsRule();
    init_PossibleTypeExtensionsRule();
    init_ProvidedRequiredArgumentsRule();
    init_ScalarLeafsRule();
    init_SingleFieldSubscriptionsRule();
    init_UniqueArgumentDefinitionNamesRule();
    init_UniqueArgumentNamesRule();
    init_UniqueDirectiveNamesRule();
    init_UniqueDirectivesPerLocationRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueFragmentNamesRule();
    init_UniqueInputFieldNamesRule();
    init_UniqueOperationNamesRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueVariableNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_VariablesAreInputTypesRule();
    init_VariablesInAllowedPositionRule();
    recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
    specifiedRules = Object.freeze([
      ExecutableDefinitionsRule,
      UniqueOperationNamesRule,
      LoneAnonymousOperationRule,
      SingleFieldSubscriptionsRule,
      KnownTypeNamesRule,
      FragmentsOnCompositeTypesRule,
      VariablesAreInputTypesRule,
      ScalarLeafsRule,
      FieldsOnCorrectTypeRule,
      UniqueFragmentNamesRule,
      KnownFragmentNamesRule,
      NoUnusedFragmentsRule,
      PossibleFragmentSpreadsRule,
      NoFragmentCyclesRule,
      UniqueVariableNamesRule,
      NoUndefinedVariablesRule,
      NoUnusedVariablesRule,
      KnownDirectivesRule,
      UniqueDirectivesPerLocationRule,
      KnownArgumentNamesRule,
      UniqueArgumentNamesRule,
      ValuesOfCorrectTypeRule,
      ProvidedRequiredArgumentsRule,
      VariablesInAllowedPositionRule,
      OverlappingFieldsCanBeMergedRule,
      UniqueInputFieldNamesRule,
      ...recommendedRules
    ]);
    specifiedSDLRules = Object.freeze([
      LoneSchemaDefinitionRule,
      UniqueOperationTypesRule,
      UniqueTypeNamesRule,
      UniqueEnumValueNamesRule,
      UniqueFieldDefinitionNamesRule,
      UniqueArgumentDefinitionNamesRule,
      UniqueDirectiveNamesRule,
      KnownTypeNamesRule,
      KnownDirectivesRule,
      UniqueDirectivesPerLocationRule,
      PossibleTypeExtensionsRule,
      KnownArgumentNamesOnDirectivesRule,
      UniqueArgumentNamesRule,
      UniqueInputFieldNamesRule,
      ProvidedRequiredArgumentsOnDirectivesRule
    ]);
  }
});

// ../node_modules/graphql/validation/ValidationContext.mjs
var import_dist295, import_dist296, import_dist297, ASTValidationContext, SDLValidationContext, ValidationContext;
var init_ValidationContext = __esm({
  "../node_modules/graphql/validation/ValidationContext.mjs"() {
    import_dist295 = __toESM(require_dist(), 1);
    import_dist296 = __toESM(require_dist2(), 1);
    import_dist297 = __toESM(require_dist3(), 1);
    init_kinds();
    init_visitor();
    init_TypeInfo();
    ASTValidationContext = class {
      constructor(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(error) {
        this._onError(error);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(name) {
        let fragments;
        if (this._fragments) {
          fragments = this._fragments;
        } else {
          fragments = /* @__PURE__ */ Object.create(null);
          for (const defNode of this.getDocument().definitions) {
            if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[defNode.name.value] = defNode;
            }
          }
          this._fragments = fragments;
        }
        return fragments[name];
      }
      getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          const setsToVisit = [node];
          let set;
          while (set = setsToVisit.pop()) {
            for (const selection of set.selections) {
              if (selection.kind === Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      }
      getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          const collectedNames = /* @__PURE__ */ Object.create(null);
          const nodesToVisit = [operation.selectionSet];
          let node;
          while (node = nodesToVisit.pop()) {
            for (const spread of this.getFragmentSpreads(node)) {
              const fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                const fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      }
    };
    SDLValidationContext = class extends ASTValidationContext {
      constructor(ast, schema, onError) {
        super(ast, onError);
        this._schema = schema;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    };
    ValidationContext = class extends ASTValidationContext {
      constructor(schema, ast, typeInfo, onError) {
        super(ast, onError);
        this._schema = schema;
        this._typeInfo = typeInfo;
        this._variableUsages = /* @__PURE__ */ new Map();
        this._recursiveVariableUsages = /* @__PURE__ */ new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
          const newUsages = [];
          const typeInfo = new TypeInfo(this._schema);
          visit(
            node,
            visitWithTypeInfo(typeInfo, {
              VariableDefinition: () => false,
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue()
                });
              }
            })
          );
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      }
      getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (const frag of this.getRecursivelyReferencedFragments(operation)) {
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    };
  }
});

// ../node_modules/graphql/validation/validate.mjs
function validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(
    schema,
    documentAST,
    typeInfo,
    (error) => {
      if (errors.length >= maxErrors) {
        errors.push(
          new GraphQLError(
            "Too many validation errors, error limit reached. Validation aborted."
          )
        );
        throw abortObj;
      }
      errors.push(error);
    }
  );
  const visitor = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}
function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
  const errors = [];
  const context = new SDLValidationContext(
    documentAST,
    schemaToExtend,
    (error) => {
      errors.push(error);
    }
  );
  const visitors = rules.map((rule) => rule(context));
  visit(documentAST, visitInParallel(visitors));
  return errors;
}
function assertValidSDL(documentAST) {
  const errors = validateSDL(documentAST);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema) {
  const errors = validateSDL(documentAST, schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
var import_dist298, import_dist299, import_dist300;
var init_validate2 = __esm({
  "../node_modules/graphql/validation/validate.mjs"() {
    import_dist298 = __toESM(require_dist(), 1);
    import_dist299 = __toESM(require_dist2(), 1);
    import_dist300 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_GraphQLError();
    init_visitor();
    init_validate();
    init_TypeInfo();
    init_specifiedRules();
    init_ValidationContext();
  }
});

// ../node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}
var import_dist301, import_dist302, import_dist303;
var init_memoize3 = __esm({
  "../node_modules/graphql/jsutils/memoize3.mjs"() {
    import_dist301 = __toESM(require_dist(), 1);
    import_dist302 = __toESM(require_dist2(), 1);
    import_dist303 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/promiseForObject.mjs
function promiseForObject(object) {
  return Promise.all(Object.values(object)).then((resolvedValues) => {
    const resolvedObject = /* @__PURE__ */ Object.create(null);
    for (const [i, key] of Object.keys(object).entries()) {
      resolvedObject[key] = resolvedValues[i];
    }
    return resolvedObject;
  });
}
var import_dist304, import_dist305, import_dist306;
var init_promiseForObject = __esm({
  "../node_modules/graphql/jsutils/promiseForObject.mjs"() {
    import_dist304 = __toESM(require_dist(), 1);
    import_dist305 = __toESM(require_dist2(), 1);
    import_dist306 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/jsutils/promiseReduce.mjs
function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values) {
    accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
var import_dist307, import_dist308, import_dist309;
var init_promiseReduce = __esm({
  "../node_modules/graphql/jsutils/promiseReduce.mjs"() {
    import_dist307 = __toESM(require_dist(), 1);
    import_dist308 = __toESM(require_dist2(), 1);
    import_dist309 = __toESM(require_dist3(), 1);
    init_isPromise();
  }
});

// ../node_modules/graphql/jsutils/toError.mjs
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}
var import_dist310, import_dist311, import_dist312, NonErrorThrown;
var init_toError = __esm({
  "../node_modules/graphql/jsutils/toError.mjs"() {
    import_dist310 = __toESM(require_dist(), 1);
    import_dist311 = __toESM(require_dist2(), 1);
    import_dist312 = __toESM(require_dist3(), 1);
    init_inspect();
    NonErrorThrown = class extends Error {
      constructor(thrownValue) {
        super("Unexpected error value: " + inspect(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
      }
    };
  }
});

// ../node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
function isLocatedGraphQLError(error) {
  return Array.isArray(error.path);
}
var import_dist313, import_dist314, import_dist315;
var init_locatedError = __esm({
  "../node_modules/graphql/error/locatedError.mjs"() {
    import_dist313 = __toESM(require_dist(), 1);
    import_dist314 = __toESM(require_dist2(), 1);
    import_dist315 = __toESM(require_dist3(), 1);
    init_toError();
    init_GraphQLError();
  }
});

// ../node_modules/graphql/execution/execute.mjs
function execute(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const { schema, document, variableValues, rootValue } = args;
  assertValidExecutionArguments(schema, document, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const { operation } = exeContext;
    const result2 = executeOperation(exeContext, operation, rootValue);
    if (isPromise(result2)) {
      return result2.then(
        (data) => buildResponse(data, exeContext.errors),
        (error) => {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        }
      );
    }
    return buildResponse(result2, exeContext.errors);
  } catch (error) {
    exeContext.errors.push(error);
    return buildResponse(null, exeContext.errors);
  }
}
function executeSync(args) {
  const result2 = execute(args);
  if (isPromise(result2)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result2;
}
function buildResponse(data, errors) {
  return errors.length === 0 ? {
    data
  } : {
    errors,
    data
  };
}
function assertValidExecutionArguments(schema, document, rawVariableValues) {
  document || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(
    false,
    "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
  );
}
function buildExecutionContext(args) {
  var _definition$name, _operation$variableDe;
  const {
    schema,
    document,
    rootValue,
    contextValue,
    variableValues: rawVariableValues,
    operationName: operationName2,
    fieldResolver,
    typeResolver,
    subscribeFieldResolver
  } = args;
  let operation;
  const fragments = /* @__PURE__ */ Object.create(null);
  for (const definition of document.definitions) {
    switch (definition.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName2 == null) {
          if (operation !== void 0) {
            return [
              new GraphQLError(
                "Must provide operation name if query contains multiple operations."
              )
            ];
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName2) {
          operation = definition;
        }
        break;
      case Kind.FRAGMENT_DEFINITION:
        fragments[definition.name.value] = definition;
        break;
      default:
    }
  }
  if (!operation) {
    if (operationName2 != null) {
      return [new GraphQLError(`Unknown operation named "${operationName2}".`)];
    }
    return [new GraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
  const coercedVariableValues = getVariableValues(
    schema,
    variableDefinitions,
    rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
    {
      maxErrors: 50
    }
  );
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
    errors: []
  };
}
function executeOperation(exeContext, operation, rootValue) {
  const rootType = exeContext.schema.getRootType(operation.operation);
  if (rootType == null) {
    throw new GraphQLError(
      `Schema is not configured to execute ${operation.operation} operation.`,
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    rootType,
    operation.selectionSet
  );
  const path = void 0;
  switch (operation.operation) {
    case OperationTypeNode.QUERY:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
    case OperationTypeNode.MUTATION:
      return executeFieldsSerially(
        exeContext,
        rootType,
        rootValue,
        path,
        rootFields
      );
    case OperationTypeNode.SUBSCRIPTION:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
  return promiseReduce(
    fields.entries(),
    (results, [responseName, fieldNodes]) => {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result2 = executeField(
        exeContext,
        parentType,
        sourceValue,
        fieldNodes,
        fieldPath
      );
      if (result2 === void 0) {
        return results;
      }
      if (isPromise(result2)) {
        return result2.then((resolvedResult) => {
          results[responseName] = resolvedResult;
          return results;
        });
      }
      results[responseName] = result2;
      return results;
    },
    /* @__PURE__ */ Object.create(null)
  );
}
function executeFields(exeContext, parentType, sourceValue, path, fields) {
  const results = /* @__PURE__ */ Object.create(null);
  let containsPromise = false;
  try {
    for (const [responseName, fieldNodes] of fields.entries()) {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result2 = executeField(
        exeContext,
        parentType,
        sourceValue,
        fieldNodes,
        fieldPath
      );
      if (result2 !== void 0) {
        results[responseName] = result2;
        if (isPromise(result2)) {
          containsPromise = true;
        }
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results);
}
function executeField(exeContext, parentType, source, fieldNodes, path) {
  var _fieldDef$resolve;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    parentType,
    path
  );
  try {
    const args = getArgumentValues(
      fieldDef,
      fieldNodes[0],
      exeContext.variableValues
    );
    const contextValue = exeContext.contextValue;
    const result2 = resolveFn(source, args, contextValue, info);
    let completed;
    if (isPromise(result2)) {
      completed = result2.then(
        (resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved)
      );
    } else {
      completed = completeValue(
        exeContext,
        returnType,
        fieldNodes,
        info,
        path,
        result2
      );
    }
    if (isPromise(completed)) {
      return completed.then(void 0, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray(path));
        return handleFieldError(error, returnType, exeContext);
      });
    }
    return completed;
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray(path));
    return handleFieldError(error, returnType, exeContext);
  }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
function handleFieldError(error, returnType, exeContext) {
  if (isNonNullType(returnType)) {
    throw error;
  }
  exeContext.errors.push(error);
  return null;
}
function completeValue(exeContext, returnType, fieldNodes, info, path, result2) {
  if (result2 instanceof Error) {
    throw result2;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(
      exeContext,
      returnType.ofType,
      fieldNodes,
      info,
      path,
      result2
    );
    if (completed === null) {
      throw new Error(
        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
      );
    }
    return completed;
  }
  if (result2 == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result2
    );
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result2);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result2
    );
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result2
    );
  }
  invariant4(
    false,
    "Cannot complete value of unexpected output type: " + inspect(returnType)
  );
}
function completeListValue(exeContext, returnType, fieldNodes, info, path, result2) {
  if (!isIterableObject(result2)) {
    throw new GraphQLError(
      `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
    );
  }
  const itemType = returnType.ofType;
  let containsPromise = false;
  const completedResults = Array.from(result2, (item, index) => {
    const itemPath = addPath(path, index, void 0);
    try {
      let completedItem;
      if (isPromise(item)) {
        completedItem = item.then(
          (resolved) => completeValue(
            exeContext,
            itemType,
            fieldNodes,
            info,
            itemPath,
            resolved
          )
        );
      } else {
        completedItem = completeValue(
          exeContext,
          itemType,
          fieldNodes,
          info,
          itemPath,
          item
        );
      }
      if (isPromise(completedItem)) {
        containsPromise = true;
        return completedItem.then(void 0, (rawError) => {
          const error = locatedError(
            rawError,
            fieldNodes,
            pathToArray(itemPath)
          );
          return handleFieldError(error, itemType, exeContext);
        });
      }
      return completedItem;
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));
      return handleFieldError(error, itemType, exeContext);
    }
  });
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeLeafValue(returnType, result2) {
  const serializedResult = returnType.serialize(result2);
  if (serializedResult == null) {
    throw new Error(
      `Expected \`${inspect(returnType)}.serialize(${inspect(result2)})\` to return non-nullable value, returned: ${inspect(serializedResult)}`
    );
  }
  return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result2) {
  var _returnType$resolveTy;
  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result2, contextValue, info, returnType);
  if (isPromise(runtimeType)) {
    return runtimeType.then(
      (resolvedRuntimeType) => completeObjectValue(
        exeContext,
        ensureValidRuntimeType(
          resolvedRuntimeType,
          exeContext,
          returnType,
          fieldNodes,
          info,
          result2
        ),
        fieldNodes,
        info,
        path,
        result2
      )
    );
  }
  return completeObjectValue(
    exeContext,
    ensureValidRuntimeType(
      runtimeType,
      exeContext,
      returnType,
      fieldNodes,
      info,
      result2
    ),
    fieldNodes,
    info,
    path,
    result2
  );
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result2) {
  if (runtimeTypeName == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
      fieldNodes
    );
  }
  if (isObjectType(runtimeTypeName)) {
    throw new GraphQLError(
      "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
    );
  }
  if (typeof runtimeTypeName !== "string") {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${inspect(result2)}, received "${inspect(runtimeTypeName)}".`
    );
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!isObjectType(runtimeType)) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw new GraphQLError(
      `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result2) {
  const subFieldNodes = collectSubfields2(exeContext, returnType, fieldNodes);
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result2, exeContext.contextValue, info);
    if (isPromise(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result2, fieldNodes);
        }
        return executeFields(
          exeContext,
          returnType,
          result2,
          path,
          subFieldNodes
        );
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result2, fieldNodes);
    }
  }
  return executeFields(exeContext, returnType, result2, path, subFieldNodes);
}
function invalidReturnTypeError(returnType, result2, fieldNodes) {
  return new GraphQLError(
    `Expected value of type "${returnType.name}" but got: ${inspect(result2)}.`,
    {
      nodes: fieldNodes
    }
  );
}
function getFieldDef2(schema, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var import_dist316, import_dist317, import_dist318, collectSubfields2, defaultTypeResolver, defaultFieldResolver;
var init_execute = __esm({
  "../node_modules/graphql/execution/execute.mjs"() {
    import_dist316 = __toESM(require_dist(), 1);
    import_dist317 = __toESM(require_dist2(), 1);
    import_dist318 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_inspect();
    init_invariant2();
    init_isIterableObject();
    init_isObjectLike();
    init_isPromise();
    init_memoize3();
    init_Path();
    init_promiseForObject();
    init_promiseReduce();
    init_GraphQLError();
    init_locatedError();
    init_ast();
    init_kinds();
    init_definition();
    init_introspection();
    init_validate();
    init_collectFields();
    init_values();
    collectSubfields2 = memoize3(
      (exeContext, returnType, fieldNodes) => collectSubfields(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        returnType,
        fieldNodes
      )
    );
    defaultTypeResolver = function(value, contextValue, info, abstractType) {
      if (isObjectLike(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      const possibleTypes = info.schema.getPossibleTypes(abstractType);
      const promisedIsTypeOfResults = [];
      for (let i = 0; i < possibleTypes.length; i++) {
        const type = possibleTypes[i];
        if (type.isTypeOf) {
          const isTypeOfResult = type.isTypeOf(value, contextValue, info);
          if (isPromise(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
          for (let i = 0; i < isTypeOfResults.length; i++) {
            if (isTypeOfResults[i]) {
              return possibleTypes[i].name;
            }
          }
        });
      }
    };
    defaultFieldResolver = function(source, args, contextValue, info) {
      if (isObjectLike(source) || typeof source === "function") {
        const property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    };
  }
});

// ../node_modules/graphql/graphql.mjs
function graphql(args) {
  return new Promise((resolve) => resolve(graphqlImpl(args)));
}
function graphqlSync(args) {
  const result2 = graphqlImpl(args);
  if (isPromise(result2)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result2;
}
function graphqlImpl(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const {
    schema,
    source,
    rootValue,
    contextValue,
    variableValues,
    operationName: operationName2,
    fieldResolver,
    typeResolver
  } = args;
  const schemaValidationErrors = validateSchema(schema);
  if (schemaValidationErrors.length > 0) {
    return {
      errors: schemaValidationErrors
    };
  }
  let document;
  try {
    document = parse(source);
  } catch (syntaxError2) {
    return {
      errors: [syntaxError2]
    };
  }
  const validationErrors = validate(schema, document);
  if (validationErrors.length > 0) {
    return {
      errors: validationErrors
    };
  }
  return execute({
    schema,
    document,
    rootValue,
    contextValue,
    variableValues,
    operationName: operationName2,
    fieldResolver,
    typeResolver
  });
}
var import_dist319, import_dist320, import_dist321;
var init_graphql = __esm({
  "../node_modules/graphql/graphql.mjs"() {
    import_dist319 = __toESM(require_dist(), 1);
    import_dist320 = __toESM(require_dist2(), 1);
    import_dist321 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_isPromise();
    init_parser();
    init_validate();
    init_validate2();
    init_execute();
  }
});

// ../node_modules/graphql/type/index.mjs
var import_dist322, import_dist323, import_dist324;
var init_type = __esm({
  "../node_modules/graphql/type/index.mjs"() {
    import_dist322 = __toESM(require_dist(), 1);
    import_dist323 = __toESM(require_dist2(), 1);
    import_dist324 = __toESM(require_dist3(), 1);
    init_schema();
    init_definition();
    init_directives();
    init_scalars();
    init_introspection();
    init_validate();
    init_assertName();
  }
});

// ../node_modules/graphql/language/index.mjs
var import_dist325, import_dist326, import_dist327;
var init_language = __esm({
  "../node_modules/graphql/language/index.mjs"() {
    import_dist325 = __toESM(require_dist(), 1);
    import_dist326 = __toESM(require_dist2(), 1);
    import_dist327 = __toESM(require_dist3(), 1);
    init_source();
    init_location();
    init_printLocation();
    init_kinds();
    init_tokenKind();
    init_lexer();
    init_parser();
    init_printer();
    init_visitor();
    init_ast();
    init_predicates();
    init_directiveLocation();
  }
});

// ../node_modules/graphql/jsutils/isAsyncIterable.mjs
function isAsyncIterable(maybeAsyncIterable) {
  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
}
var import_dist328, import_dist329, import_dist330;
var init_isAsyncIterable = __esm({
  "../node_modules/graphql/jsutils/isAsyncIterable.mjs"() {
    import_dist328 = __toESM(require_dist(), 1);
    import_dist329 = __toESM(require_dist2(), 1);
    import_dist330 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/execution/mapAsyncIterator.mjs
function mapAsyncIterator(iterable, callback) {
  const iterator = iterable[Symbol.asyncIterator]();
  async function mapResult(result2) {
    if (result2.done) {
      return result2;
    }
    try {
      return {
        value: await callback(result2.value),
        done: false
      };
    } catch (error) {
      if (typeof iterator.return === "function") {
        try {
          await iterator.return();
        } catch (_e) {
        }
      }
      throw error;
    }
  }
  return {
    async next() {
      return mapResult(await iterator.next());
    },
    async return() {
      return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
        value: void 0,
        done: true
      };
    },
    async throw(error) {
      if (typeof iterator.throw === "function") {
        return mapResult(await iterator.throw(error));
      }
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var import_dist331, import_dist332, import_dist333;
var init_mapAsyncIterator = __esm({
  "../node_modules/graphql/execution/mapAsyncIterator.mjs"() {
    import_dist331 = __toESM(require_dist(), 1);
    import_dist332 = __toESM(require_dist2(), 1);
    import_dist333 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/execution/subscribe.mjs
async function subscribe(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const resultOrStream = await createSourceEventStream(args);
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  const mapSourceToResponse = (payload) => execute({ ...args, rootValue: payload });
  return mapAsyncIterator(resultOrStream, mapSourceToResponse);
}
function toNormalizedArgs(args) {
  const firstArg = args[0];
  if (firstArg && "document" in firstArg) {
    return firstArg;
  }
  return {
    schema: firstArg,
    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    subscribeFieldResolver: args[6]
  };
}
async function createSourceEventStream(...rawArgs) {
  const args = toNormalizedArgs(rawArgs);
  const { schema, document, variableValues } = args;
  assertValidExecutionArguments(schema, document, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const eventStream = await executeSubscription(exeContext);
    if (!isAsyncIterable(eventStream)) {
      throw new Error(
        `Subscription field must return Async Iterable. Received: ${inspect(eventStream)}.`
      );
    }
    return eventStream;
  } catch (error) {
    if (error instanceof GraphQLError) {
      return {
        errors: [error]
      };
    }
    throw error;
  }
}
async function executeSubscription(exeContext) {
  const { schema, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema.getSubscriptionType();
  if (rootType == null) {
    throw new GraphQLError(
      "Schema is not configured to execute subscription operation.",
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    schema,
    fragments,
    variableValues,
    rootType,
    operation.selectionSet
  );
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldDef = getFieldDef2(schema, rootType, fieldNodes[0]);
  if (!fieldDef) {
    const fieldName = fieldNodes[0].name.value;
    throw new GraphQLError(
      `The subscription field "${fieldName}" is not defined.`,
      {
        nodes: fieldNodes
      }
    );
  }
  const path = addPath(void 0, responseName, rootType.name);
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    rootType,
    path
  );
  try {
    var _fieldDef$subscribe;
    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
    const eventStream = await resolveFn(rootValue, args, contextValue, info);
    if (eventStream instanceof Error) {
      throw eventStream;
    }
    return eventStream;
  } catch (error) {
    throw locatedError(error, fieldNodes, pathToArray(path));
  }
}
var import_dist334, import_dist335, import_dist336;
var init_subscribe = __esm({
  "../node_modules/graphql/execution/subscribe.mjs"() {
    import_dist334 = __toESM(require_dist(), 1);
    import_dist335 = __toESM(require_dist2(), 1);
    import_dist336 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_inspect();
    init_isAsyncIterable();
    init_Path();
    init_GraphQLError();
    init_locatedError();
    init_collectFields();
    init_execute();
    init_mapAsyncIterator();
    init_values();
  }
});

// ../node_modules/graphql/execution/index.mjs
var import_dist337, import_dist338, import_dist339;
var init_execution = __esm({
  "../node_modules/graphql/execution/index.mjs"() {
    import_dist337 = __toESM(require_dist(), 1);
    import_dist338 = __toESM(require_dist2(), 1);
    import_dist339 = __toESM(require_dist3(), 1);
    init_Path();
    init_execute();
    init_subscribe();
    init_values();
  }
});

// ../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs
function NoDeprecatedCustomRule(context) {
  return {
    Field(node) {
      const fieldDef = context.getFieldDef();
      const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
      if (fieldDef && deprecationReason != null) {
        const parentType = context.getParentType();
        parentType != null || invariant4(false);
        context.reportError(
          new GraphQLError(
            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    },
    Argument(node) {
      const argDef = context.getArgument();
      const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
      if (argDef && deprecationReason != null) {
        const directiveDef = context.getDirective();
        if (directiveDef != null) {
          context.reportError(
            new GraphQLError(
              `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        } else {
          const parentType = context.getParentType();
          const fieldDef = context.getFieldDef();
          parentType != null && fieldDef != null || invariant4(false);
          context.reportError(
            new GraphQLError(
              `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const inputObjectDef = getNamedType(context.getParentInputType());
      if (isInputObjectType(inputObjectDef)) {
        const inputFieldDef = inputObjectDef.getFields()[node.name.value];
        const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
        if (deprecationReason != null) {
          context.reportError(
            new GraphQLError(
              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    EnumValue(node) {
      const enumValueDef = context.getEnumValue();
      const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
      if (enumValueDef && deprecationReason != null) {
        const enumTypeDef = getNamedType(context.getInputType());
        enumTypeDef != null || invariant4(false);
        context.reportError(
          new GraphQLError(
            `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var import_dist340, import_dist341, import_dist342;
var init_NoDeprecatedCustomRule = __esm({
  "../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs"() {
    import_dist340 = __toESM(require_dist(), 1);
    import_dist341 = __toESM(require_dist2(), 1);
    import_dist342 = __toESM(require_dist3(), 1);
    init_invariant2();
    init_GraphQLError();
    init_definition();
  }
});

// ../node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs
function NoSchemaIntrospectionCustomRule(context) {
  return {
    Field(node) {
      const type = getNamedType(context.getType());
      if (type && isIntrospectionType(type)) {
        context.reportError(
          new GraphQLError(
            `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var import_dist343, import_dist344, import_dist345;
var init_NoSchemaIntrospectionCustomRule = __esm({
  "../node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs"() {
    import_dist343 = __toESM(require_dist(), 1);
    import_dist344 = __toESM(require_dist2(), 1);
    import_dist345 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_definition();
    init_introspection();
  }
});

// ../node_modules/graphql/validation/index.mjs
var import_dist346, import_dist347, import_dist348;
var init_validation = __esm({
  "../node_modules/graphql/validation/index.mjs"() {
    import_dist346 = __toESM(require_dist(), 1);
    import_dist347 = __toESM(require_dist2(), 1);
    import_dist348 = __toESM(require_dist3(), 1);
    init_validate2();
    init_ValidationContext();
    init_specifiedRules();
    init_ExecutableDefinitionsRule();
    init_FieldsOnCorrectTypeRule();
    init_FragmentsOnCompositeTypesRule();
    init_KnownArgumentNamesRule();
    init_KnownDirectivesRule();
    init_KnownFragmentNamesRule();
    init_KnownTypeNamesRule();
    init_LoneAnonymousOperationRule();
    init_NoFragmentCyclesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedFragmentsRule();
    init_NoUnusedVariablesRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_PossibleFragmentSpreadsRule();
    init_ProvidedRequiredArgumentsRule();
    init_ScalarLeafsRule();
    init_SingleFieldSubscriptionsRule();
    init_UniqueArgumentNamesRule();
    init_UniqueDirectivesPerLocationRule();
    init_UniqueFragmentNamesRule();
    init_UniqueInputFieldNamesRule();
    init_UniqueOperationNamesRule();
    init_UniqueVariableNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_VariablesAreInputTypesRule();
    init_VariablesInAllowedPositionRule();
    init_MaxIntrospectionDepthRule();
    init_LoneSchemaDefinitionRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueArgumentDefinitionNamesRule();
    init_UniqueDirectiveNamesRule();
    init_PossibleTypeExtensionsRule();
    init_NoDeprecatedCustomRule();
    init_NoSchemaIntrospectionCustomRule();
  }
});

// ../node_modules/graphql/error/index.mjs
var import_dist349, import_dist350, import_dist351;
var init_error = __esm({
  "../node_modules/graphql/error/index.mjs"() {
    import_dist349 = __toESM(require_dist(), 1);
    import_dist350 = __toESM(require_dist2(), 1);
    import_dist351 = __toESM(require_dist3(), 1);
    init_GraphQLError();
    init_syntaxError();
    init_locatedError();
  }
});

// ../node_modules/graphql/utilities/getIntrospectionQuery.mjs
function getIntrospectionQuery(options) {
  const optionsWithDefault = {
    descriptions: true,
    specifiedByUrl: false,
    directiveIsRepeatable: false,
    schemaDescription: false,
    inputValueDeprecation: false,
    oneOf: false,
    ...options
  };
  const descriptions = optionsWithDefault.descriptions ? "description" : "";
  const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
  const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
  function inputDeprecation(str) {
    return optionsWithDefault.inputValueDeprecation ? str : "";
  }
  const oneOf = optionsWithDefault.oneOf ? "isOneOf" : "";
  return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      ${oneOf}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
}
var import_dist352, import_dist353, import_dist354;
var init_getIntrospectionQuery = __esm({
  "../node_modules/graphql/utilities/getIntrospectionQuery.mjs"() {
    import_dist352 = __toESM(require_dist(), 1);
    import_dist353 = __toESM(require_dist2(), 1);
    import_dist354 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql/utilities/getOperationAST.mjs
function getOperationAST(documentAST, operationName2) {
  let operation = null;
  for (const definition of documentAST.definitions) {
    if (definition.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName2 == null) {
        if (operation) {
          return null;
        }
        operation = definition;
      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName2) {
        return definition;
      }
    }
  }
  return operation;
}
var import_dist355, import_dist356, import_dist357;
var init_getOperationAST = __esm({
  "../node_modules/graphql/utilities/getOperationAST.mjs"() {
    import_dist355 = __toESM(require_dist(), 1);
    import_dist356 = __toESM(require_dist2(), 1);
    import_dist357 = __toESM(require_dist3(), 1);
    init_kinds();
  }
});

// ../node_modules/graphql/utilities/getOperationRootType.mjs
function getOperationRootType(schema, operation) {
  if (operation.operation === "query") {
    const queryType = schema.getQueryType();
    if (!queryType) {
      throw new GraphQLError(
        "Schema does not define the required query root type.",
        {
          nodes: operation
        }
      );
    }
    return queryType;
  }
  if (operation.operation === "mutation") {
    const mutationType = schema.getMutationType();
    if (!mutationType) {
      throw new GraphQLError("Schema is not configured for mutations.", {
        nodes: operation
      });
    }
    return mutationType;
  }
  if (operation.operation === "subscription") {
    const subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
      throw new GraphQLError("Schema is not configured for subscriptions.", {
        nodes: operation
      });
    }
    return subscriptionType;
  }
  throw new GraphQLError(
    "Can only have query, mutation and subscription operations.",
    {
      nodes: operation
    }
  );
}
var import_dist358, import_dist359, import_dist360;
var init_getOperationRootType = __esm({
  "../node_modules/graphql/utilities/getOperationRootType.mjs"() {
    import_dist358 = __toESM(require_dist(), 1);
    import_dist359 = __toESM(require_dist2(), 1);
    import_dist360 = __toESM(require_dist3(), 1);
    init_GraphQLError();
  }
});

// ../node_modules/graphql/utilities/introspectionFromSchema.mjs
function introspectionFromSchema(schema, options) {
  const optionsWithDefaults = {
    specifiedByUrl: true,
    directiveIsRepeatable: true,
    schemaDescription: true,
    inputValueDeprecation: true,
    oneOf: true,
    ...options
  };
  const document = parse(getIntrospectionQuery(optionsWithDefaults));
  const result2 = executeSync({
    schema,
    document
  });
  !result2.errors && result2.data || invariant4(false);
  return result2.data;
}
var import_dist361, import_dist362, import_dist363;
var init_introspectionFromSchema = __esm({
  "../node_modules/graphql/utilities/introspectionFromSchema.mjs"() {
    import_dist361 = __toESM(require_dist(), 1);
    import_dist362 = __toESM(require_dist2(), 1);
    import_dist363 = __toESM(require_dist3(), 1);
    init_invariant2();
    init_parser();
    init_execute();
    init_getIntrospectionQuery();
  }
});

// ../node_modules/graphql/utilities/buildClientSchema.mjs
function buildClientSchema(introspection, options) {
  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(
    false,
    `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect(
      introspection
    )}.`
  );
  const schemaIntrospection = introspection.__schema;
  const typeMap = keyValMap(
    schemaIntrospection.types,
    (typeIntrospection) => typeIntrospection.name,
    (typeIntrospection) => buildType(typeIntrospection)
  );
  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {
    if (typeMap[stdType.name]) {
      typeMap[stdType.name] = stdType;
    }
  }
  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
  return new GraphQLSchema({
    description: schemaIntrospection.description,
    query: queryType,
    mutation: mutationType,
    subscription: subscriptionType,
    types: Object.values(typeMap),
    directives,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
  function getType(typeRef) {
    if (typeRef.kind === TypeKind.LIST) {
      const itemRef = typeRef.ofType;
      if (!itemRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      return new GraphQLList(getType(itemRef));
    }
    if (typeRef.kind === TypeKind.NON_NULL) {
      const nullableRef = typeRef.ofType;
      if (!nullableRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      const nullableType = getType(nullableRef);
      return new GraphQLNonNull(assertNullableType(nullableType));
    }
    return getNamedType2(typeRef);
  }
  function getNamedType2(typeRef) {
    const typeName = typeRef.name;
    if (!typeName) {
      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);
    }
    const type = typeMap[typeName];
    if (!type) {
      throw new Error(
        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
      );
    }
    return type;
  }
  function getObjectType(typeRef) {
    return assertObjectType(getNamedType2(typeRef));
  }
  function getInterfaceType(typeRef) {
    return assertInterfaceType(getNamedType2(typeRef));
  }
  function buildType(type) {
    if (type != null && type.name != null && type.kind != null) {
      switch (type.kind) {
        case TypeKind.SCALAR:
          return buildScalarDef(type);
        case TypeKind.OBJECT:
          return buildObjectDef(type);
        case TypeKind.INTERFACE:
          return buildInterfaceDef(type);
        case TypeKind.UNION:
          return buildUnionDef(type);
        case TypeKind.ENUM:
          return buildEnumDef(type);
        case TypeKind.INPUT_OBJECT:
          return buildInputObjectDef(type);
      }
    }
    const typeStr = inspect(type);
    throw new Error(
      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
    );
  }
  function buildScalarDef(scalarIntrospection) {
    return new GraphQLScalarType({
      name: scalarIntrospection.name,
      description: scalarIntrospection.description,
      specifiedByURL: scalarIntrospection.specifiedByURL
    });
  }
  function buildImplementationsList(implementingIntrospection) {
    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
      return [];
    }
    if (!implementingIntrospection.interfaces) {
      const implementingIntrospectionStr = inspect(implementingIntrospection);
      throw new Error(
        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
      );
    }
    return implementingIntrospection.interfaces.map(getInterfaceType);
  }
  function buildObjectDef(objectIntrospection) {
    return new GraphQLObjectType({
      name: objectIntrospection.name,
      description: objectIntrospection.description,
      interfaces: () => buildImplementationsList(objectIntrospection),
      fields: () => buildFieldDefMap(objectIntrospection)
    });
  }
  function buildInterfaceDef(interfaceIntrospection) {
    return new GraphQLInterfaceType({
      name: interfaceIntrospection.name,
      description: interfaceIntrospection.description,
      interfaces: () => buildImplementationsList(interfaceIntrospection),
      fields: () => buildFieldDefMap(interfaceIntrospection)
    });
  }
  function buildUnionDef(unionIntrospection) {
    if (!unionIntrospection.possibleTypes) {
      const unionIntrospectionStr = inspect(unionIntrospection);
      throw new Error(
        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
      );
    }
    return new GraphQLUnionType({
      name: unionIntrospection.name,
      description: unionIntrospection.description,
      types: () => unionIntrospection.possibleTypes.map(getObjectType)
    });
  }
  function buildEnumDef(enumIntrospection) {
    if (!enumIntrospection.enumValues) {
      const enumIntrospectionStr = inspect(enumIntrospection);
      throw new Error(
        `Introspection result missing enumValues: ${enumIntrospectionStr}.`
      );
    }
    return new GraphQLEnumType({
      name: enumIntrospection.name,
      description: enumIntrospection.description,
      values: keyValMap(
        enumIntrospection.enumValues,
        (valueIntrospection) => valueIntrospection.name,
        (valueIntrospection) => ({
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        })
      )
    });
  }
  function buildInputObjectDef(inputObjectIntrospection) {
    if (!inputObjectIntrospection.inputFields) {
      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);
      throw new Error(
        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
      );
    }
    return new GraphQLInputObjectType({
      name: inputObjectIntrospection.name,
      description: inputObjectIntrospection.description,
      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),
      isOneOf: inputObjectIntrospection.isOneOf
    });
  }
  function buildFieldDefMap(typeIntrospection) {
    if (!typeIntrospection.fields) {
      throw new Error(
        `Introspection result missing fields: ${inspect(typeIntrospection)}.`
      );
    }
    return keyValMap(
      typeIntrospection.fields,
      (fieldIntrospection) => fieldIntrospection.name,
      buildField
    );
  }
  function buildField(fieldIntrospection) {
    const type = getType(fieldIntrospection.type);
    if (!isOutputType(type)) {
      const typeStr = inspect(type);
      throw new Error(
        `Introspection must provide output type for fields, but received: ${typeStr}.`
      );
    }
    if (!fieldIntrospection.args) {
      const fieldIntrospectionStr = inspect(fieldIntrospection);
      throw new Error(
        `Introspection result missing field args: ${fieldIntrospectionStr}.`
      );
    }
    return {
      description: fieldIntrospection.description,
      deprecationReason: fieldIntrospection.deprecationReason,
      type,
      args: buildInputValueDefMap(fieldIntrospection.args)
    };
  }
  function buildInputValueDefMap(inputValueIntrospections) {
    return keyValMap(
      inputValueIntrospections,
      (inputValue) => inputValue.name,
      buildInputValue
    );
  }
  function buildInputValue(inputValueIntrospection) {
    const type = getType(inputValueIntrospection.type);
    if (!isInputType(type)) {
      const typeStr = inspect(type);
      throw new Error(
        `Introspection must provide input type for arguments, but received: ${typeStr}.`
      );
    }
    const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : void 0;
    return {
      description: inputValueIntrospection.description,
      type,
      defaultValue,
      deprecationReason: inputValueIntrospection.deprecationReason
    };
  }
  function buildDirective(directiveIntrospection) {
    if (!directiveIntrospection.args) {
      const directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive args: ${directiveIntrospectionStr}.`
      );
    }
    if (!directiveIntrospection.locations) {
      const directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
      );
    }
    return new GraphQLDirective({
      name: directiveIntrospection.name,
      description: directiveIntrospection.description,
      isRepeatable: directiveIntrospection.isRepeatable,
      locations: directiveIntrospection.locations.slice(),
      args: buildInputValueDefMap(directiveIntrospection.args)
    });
  }
}
var import_dist364, import_dist365, import_dist366;
var init_buildClientSchema = __esm({
  "../node_modules/graphql/utilities/buildClientSchema.mjs"() {
    import_dist364 = __toESM(require_dist(), 1);
    import_dist365 = __toESM(require_dist2(), 1);
    import_dist366 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_inspect();
    init_isObjectLike();
    init_keyValMap();
    init_parser();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_schema();
    init_valueFromAST();
  }
});

// ../node_modules/graphql/utilities/extendSchema.mjs
function extendSchema(schema, documentAST, options) {
  assertSchema(schema);
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDLExtension(documentAST, schema);
  }
  const schemaConfig = schema.toConfig();
  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  const typeDefs = [];
  const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
  const directiveDefs = [];
  let schemaDef;
  const schemaExtensions = [];
  for (const def of documentAST.definitions) {
    if (def.kind === Kind.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      const extendedTypeName = def.name.value;
      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  const typeMap = /* @__PURE__ */ Object.create(null);
  for (const existingType of schemaConfig.types) {
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (const typeNode of typeDefs) {
    var _stdTypeMap$name;
    const name = typeNode.name.value;
    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
  }
  const operationTypes = {
    // Get the extended root operation types.
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
    // Then, incorporate schema definition and all schema extensions.
    ...schemaDef && getOperationTypes([schemaDef]),
    ...getOperationTypes(schemaExtensions)
  };
  return {
    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
    ...operationTypes,
    types: Object.values(typeMap),
    directives: [
      ...schemaConfig.directives.map(replaceDirective),
      ...directiveDefs.map(buildDirective)
    ],
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
  };
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    }
    if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      args: mapValue(config.args, extendArg)
    });
  }
  function extendNamedType(type) {
    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
      return type;
    }
    if (isScalarType(type)) {
      return extendScalarType(type);
    }
    if (isObjectType(type)) {
      return extendObjectType(type);
    }
    if (isInterfaceType(type)) {
      return extendInterfaceType(type);
    }
    if (isUnionType(type)) {
      return extendUnionType(type);
    }
    if (isEnumType(type)) {
      return extendEnumType(type);
    }
    if (isInputObjectType(type)) {
      return extendInputObjectType(type);
    }
    invariant4(false, "Unexpected type: " + inspect(type));
  }
  function extendInputObjectType(type) {
    var _typeExtensionsMap$co;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType({
      ...config,
      fields: () => ({
        ...mapValue(config.fields, (field) => ({
          ...field,
          type: replaceType(field.type)
        })),
        ...buildInputFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendEnumType(type) {
    var _typeExtensionsMap$ty;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType({
      ...config,
      values: { ...config.values, ...buildEnumValueMap(extensions) },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendScalarType(type) {
    var _typeExtensionsMap$co2;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
    let specifiedByURL = config.specifiedByURL;
    for (const extensionNode of extensions) {
      var _getSpecifiedByURL;
      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
    }
    return new GraphQLScalarType({
      ...config,
      specifiedByURL,
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendObjectType(type) {
    var _typeExtensionsMap$co3;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendInterfaceType(type) {
    var _typeExtensionsMap$co4;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendUnionType(type) {
    var _typeExtensionsMap$co5;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType({
      ...config,
      types: () => [
        ...type.getTypes().map(replaceNamedType),
        ...buildUnionTypes(extensions)
      ],
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendField(field) {
    return {
      ...field,
      type: replaceType(field.type),
      args: field.args && mapValue(field.args, extendArg)
    };
  }
  function extendArg(arg) {
    return { ...arg, type: replaceType(arg.type) };
  }
  function getOperationTypes(nodes) {
    const opTypes = {};
    for (const node of nodes) {
      var _node$operationTypes;
      const operationTypesNodes = (
        /* c8 ignore next */
        (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
      );
      for (const operationType of operationTypesNodes) {
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    const name = node.name.value;
    const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
    if (type === void 0) {
      throw new Error(`Unknown type: "${name}".`);
    }
    return type;
  }
  function getWrappedType(node) {
    if (node.kind === Kind.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var _node$description;
    return new GraphQLDirective({
      name: node.name.value,
      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
      // @ts-expect-error
      locations: node.locations.map(({ value }) => value),
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    const fieldConfigMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields;
      const nodeFields = (
        /* c8 ignore next */
        (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
      );
      for (const field of nodeFields) {
        var _field$description;
        fieldConfigMap[field.name.value] = {
          // Note: While this could make assertions to get the correctly typed
          // value, that would throw immediately while type system validation
          // with validateSchema() will produce more actionable results.
          type: getWrappedType(field.type),
          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args) {
    const argsNodes = (
      /* c8 ignore next */
      args !== null && args !== void 0 ? args : []
    );
    const argConfigMap = /* @__PURE__ */ Object.create(null);
    for (const arg of argsNodes) {
      var _arg$description;
      const type = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type,
        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
        defaultValue: valueFromAST(arg.defaultValue, type),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    const inputFieldMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields2;
      const fieldsNodes = (
        /* c8 ignore next */
        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
      );
      for (const field of fieldsNodes) {
        var _field$description2;
        const type = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type,
          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
          defaultValue: valueFromAST(field.defaultValue, type),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    const enumValueMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$values;
      const valuesNodes = (
        /* c8 ignore next */
        (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
      );
      for (const value of valuesNodes) {
        var _value$description;
        enumValueMap[value.name.value] = {
          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
          deprecationReason: getDeprecationReason(value),
          astNode: value
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$interfaces$map, _node$interfaces;
        return (
          /* c8 ignore next */
          (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
        );
      }
    );
  }
  function buildUnionTypes(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$types$map, _node$types;
        return (
          /* c8 ignore next */
          (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : []
        );
      }
    );
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    const name = astNode.name.value;
    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var _astNode$description;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLObjectType({
          name,
          description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _astNode$description2;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInterfaceType({
          name,
          description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _astNode$description3;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLEnumType({
          name,
          description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
          values: buildEnumValueMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _astNode$description4;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLUnionType({
          name,
          description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
          types: () => buildUnionTypes(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.SCALAR_TYPE_DEFINITION: {
        var _astNode$description5;
        return new GraphQLScalarType({
          name,
          description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
          specifiedByURL: getSpecifiedByURL(astNode),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _astNode$description6;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInputObjectType({
          name,
          description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
          fields: () => buildInputFieldMap(allNodes),
          astNode,
          extensionASTNodes,
          isOneOf: isOneOf(astNode)
        });
      }
    }
  }
}
function getDeprecationReason(node) {
  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
function getSpecifiedByURL(node) {
  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}
function isOneOf(node) {
  return Boolean(getDirectiveValues(GraphQLOneOfDirective, node));
}
var import_dist367, import_dist368, import_dist369, stdTypeMap;
var init_extendSchema = __esm({
  "../node_modules/graphql/utilities/extendSchema.mjs"() {
    import_dist367 = __toESM(require_dist(), 1);
    import_dist368 = __toESM(require_dist2(), 1);
    import_dist369 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_inspect();
    init_invariant2();
    init_keyMap();
    init_mapValue();
    init_kinds();
    init_predicates();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_schema();
    init_validate2();
    init_values();
    init_valueFromAST();
    stdTypeMap = keyMap(
      [...specifiedScalarTypes, ...introspectionTypes],
      (type) => type.name
    );
  }
});

// ../node_modules/graphql/utilities/buildASTSchema.mjs
function buildASTSchema(documentAST, options) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  const emptySchemaConfig = {
    description: void 0,
    types: [],
    directives: [],
    extensions: /* @__PURE__ */ Object.create(null),
    extensionASTNodes: [],
    assumeValid: false
  };
  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);
  if (config.astNode == null) {
    for (const type of config.types) {
      switch (type.name) {
        case "Query":
          config.query = type;
          break;
        case "Mutation":
          config.mutation = type;
          break;
        case "Subscription":
          config.subscription = type;
          break;
      }
    }
  }
  const directives = [
    ...config.directives,
    // If specified directives were not explicitly declared, add them.
    ...specifiedDirectives.filter(
      (stdDirective) => config.directives.every(
        (directive) => directive.name !== stdDirective.name
      )
    )
  ];
  return new GraphQLSchema({ ...config, directives });
}
function buildSchema(source, options) {
  const document = parse(source, {
    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
    allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
  });
  return buildASTSchema(document, {
    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
}
var import_dist370, import_dist371, import_dist372;
var init_buildASTSchema = __esm({
  "../node_modules/graphql/utilities/buildASTSchema.mjs"() {
    import_dist370 = __toESM(require_dist(), 1);
    import_dist371 = __toESM(require_dist2(), 1);
    import_dist372 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_kinds();
    init_parser();
    init_directives();
    init_schema();
    init_validate2();
    init_extendSchema();
  }
});

// ../node_modules/graphql/utilities/lexicographicSortSchema.mjs
function lexicographicSortSchema(schema) {
  const schemaConfig = schema.toConfig();
  const typeMap = keyValMap(
    sortByName(schemaConfig.types),
    (type) => type.name,
    sortNamedType
  );
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x) => x),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config = type.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type)) {
      const config = type.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type)) {
      const config = type.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant4(false, "Unexpected type: " + inspect(type));
  }
}
function sortObjMap(map, sortValueFn) {
  const sortedMap = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
}
function sortByName(array) {
  return sortBy(array, (obj) => obj.name);
}
function sortBy(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
}
var import_dist373, import_dist374, import_dist375;
var init_lexicographicSortSchema = __esm({
  "../node_modules/graphql/utilities/lexicographicSortSchema.mjs"() {
    import_dist373 = __toESM(require_dist(), 1);
    import_dist374 = __toESM(require_dist2(), 1);
    import_dist375 = __toESM(require_dist3(), 1);
    init_inspect();
    init_invariant2();
    init_keyValMap();
    init_naturalCompare();
    init_definition();
    init_directives();
    init_introspection();
    init_schema();
  }
});

// ../node_modules/graphql/utilities/printSchema.mjs
function printSchema(schema) {
  return printFilteredSchema(
    schema,
    (n) => !isSpecifiedDirective(n),
    isDefinedType
  );
}
function printIntrospectionSchema(schema) {
  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);
}
function isDefinedType(type) {
  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
}
function printFilteredSchema(schema, directiveFilter, typeFilter) {
  const directives = schema.getDirectives().filter(directiveFilter);
  const types = Object.values(schema.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema),
    ...directives.map((directive) => printDirective(directive)),
    ...types.map((type) => printType(type))
  ].filter(Boolean).join("\n\n");
}
function printSchemaDefinition(schema) {
  if (schema.description == null && isSchemaOfCommonNames(schema)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
}
function isSchemaOfCommonNames(schema) {
  const queryType = schema.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
}
function printType(type) {
  if (isScalarType(type)) {
    return printScalar(type);
  }
  if (isObjectType(type)) {
    return printObject(type);
  }
  if (isInterfaceType(type)) {
    return printInterface(type);
  }
  if (isUnionType(type)) {
    return printUnion(type);
  }
  if (isEnumType(type)) {
    return printEnum(type);
  }
  if (isInputObjectType(type)) {
    return printInputObject(type);
  }
  invariant4(false, "Unexpected type: " + inspect(type));
}
function printScalar(type) {
  return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
}
function printImplementedInterfaces(type) {
  const interfaces = type.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
}
function printObject(type) {
  return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printInterface(type) {
  return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printUnion(type) {
  const types = type.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type) + "union " + type.name + possibleTypes;
}
function printEnum(type) {
  const values = type.getValues().map(
    (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
  );
  return printDescription(type) + `enum ${type.name}` + printBlock(values);
}
function printInputObject(type) {
  const fields = Object.values(type.getFields()).map(
    (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
  );
  return printDescription(type) + `input ${type.name}` + (type.isOneOf ? " @oneOf" : "") + printBlock(fields);
}
function printFields(type) {
  const fields = Object.values(type.getFields()).map(
    (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
  );
  return printBlock(fields);
}
function printBlock(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
}
function printArgs(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map(
    (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
  ).join("\n") + "\n" + indentation + ")";
}
function printInputValue(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
}
function printDirective(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
}
function printDeprecated(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
}
function printSpecifiedByURL(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
}
function printDescription(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString = print({
    kind: Kind.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
}
var import_dist376, import_dist377, import_dist378;
var init_printSchema = __esm({
  "../node_modules/graphql/utilities/printSchema.mjs"() {
    import_dist376 = __toESM(require_dist(), 1);
    import_dist377 = __toESM(require_dist2(), 1);
    import_dist378 = __toESM(require_dist3(), 1);
    init_inspect();
    init_invariant2();
    init_blockString();
    init_kinds();
    init_printer();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_astFromValue();
  }
});

// ../node_modules/graphql/utilities/concatAST.mjs
function concatAST(documents) {
  const definitions = [];
  for (const doc of documents) {
    definitions.push(...doc.definitions);
  }
  return {
    kind: Kind.DOCUMENT,
    definitions
  };
}
var import_dist379, import_dist380, import_dist381;
var init_concatAST = __esm({
  "../node_modules/graphql/utilities/concatAST.mjs"() {
    import_dist379 = __toESM(require_dist(), 1);
    import_dist380 = __toESM(require_dist2(), 1);
    import_dist381 = __toESM(require_dist3(), 1);
    init_kinds();
  }
});

// ../node_modules/graphql/utilities/separateOperations.mjs
function separateOperations(documentAST) {
  const operations = [];
  const depGraph = /* @__PURE__ */ Object.create(null);
  for (const definitionNode of documentAST.definitions) {
    switch (definitionNode.kind) {
      case Kind.OPERATION_DEFINITION:
        operations.push(definitionNode);
        break;
      case Kind.FRAGMENT_DEFINITION:
        depGraph[definitionNode.name.value] = collectDependencies(
          definitionNode.selectionSet
        );
        break;
      default:
    }
  }
  const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
  for (const operation of operations) {
    const dependencies = /* @__PURE__ */ new Set();
    for (const fragmentName of collectDependencies(operation.selectionSet)) {
      collectTransitiveDependencies(dependencies, depGraph, fragmentName);
    }
    const operationName2 = operation.name ? operation.name.value : "";
    separatedDocumentASTs[operationName2] = {
      kind: Kind.DOCUMENT,
      definitions: documentAST.definitions.filter(
        (node) => node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
      )
    };
  }
  return separatedDocumentASTs;
}
function collectTransitiveDependencies(collected, depGraph, fromName) {
  if (!collected.has(fromName)) {
    collected.add(fromName);
    const immediateDeps = depGraph[fromName];
    if (immediateDeps !== void 0) {
      for (const toName of immediateDeps) {
        collectTransitiveDependencies(collected, depGraph, toName);
      }
    }
  }
}
function collectDependencies(selectionSet) {
  const dependencies = [];
  visit(selectionSet, {
    FragmentSpread(node) {
      dependencies.push(node.name.value);
    }
  });
  return dependencies;
}
var import_dist382, import_dist383, import_dist384;
var init_separateOperations = __esm({
  "../node_modules/graphql/utilities/separateOperations.mjs"() {
    import_dist382 = __toESM(require_dist(), 1);
    import_dist383 = __toESM(require_dist2(), 1);
    import_dist384 = __toESM(require_dist3(), 1);
    init_kinds();
    init_visitor();
  }
});

// ../node_modules/graphql/utilities/stripIgnoredCharacters.mjs
function stripIgnoredCharacters(source) {
  const sourceObj = isSource(source) ? source : new Source(source);
  const body = sourceObj.body;
  const lexer = new Lexer(sourceObj);
  let strippedBody = "";
  let wasLastAddedTokenNonPunctuator = false;
  while (lexer.advance().kind !== TokenKind.EOF) {
    const currentToken = lexer.token;
    const tokenKind = currentToken.kind;
    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);
    if (wasLastAddedTokenNonPunctuator) {
      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {
        strippedBody += " ";
      }
    }
    const tokenBody = body.slice(currentToken.start, currentToken.end);
    if (tokenKind === TokenKind.BLOCK_STRING) {
      strippedBody += printBlockString(currentToken.value, {
        minimize: true
      });
    } else {
      strippedBody += tokenBody;
    }
    wasLastAddedTokenNonPunctuator = isNonPunctuator;
  }
  return strippedBody;
}
var import_dist385, import_dist386, import_dist387;
var init_stripIgnoredCharacters = __esm({
  "../node_modules/graphql/utilities/stripIgnoredCharacters.mjs"() {
    import_dist385 = __toESM(require_dist(), 1);
    import_dist386 = __toESM(require_dist2(), 1);
    import_dist387 = __toESM(require_dist3(), 1);
    init_blockString();
    init_lexer();
    init_source();
    init_tokenKind();
  }
});

// ../node_modules/graphql/utilities/assertValidName.mjs
function assertValidName(name) {
  const error = isValidNameError(name);
  if (error) {
    throw error;
  }
  return name;
}
function isValidNameError(name) {
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.startsWith("__")) {
    return new GraphQLError(
      `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
    );
  }
  try {
    assertName(name);
  } catch (error) {
    return error;
  }
}
var import_dist388, import_dist389, import_dist390;
var init_assertValidName = __esm({
  "../node_modules/graphql/utilities/assertValidName.mjs"() {
    import_dist388 = __toESM(require_dist(), 1);
    import_dist389 = __toESM(require_dist2(), 1);
    import_dist390 = __toESM(require_dist3(), 1);
    init_devAssert();
    init_GraphQLError();
    init_assertName();
  }
});

// ../node_modules/graphql/utilities/findBreakingChanges.mjs
function findBreakingChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in BreakingChangeType
  );
}
function findDangerousChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in DangerousChangeType
  );
}
function findSchemaChanges(oldSchema, newSchema) {
  return [
    ...findTypeChanges(oldSchema, newSchema),
    ...findDirectiveChanges(oldSchema, newSchema)
  ];
}
function findDirectiveChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const directivesDiff = diff(
    oldSchema.getDirectives(),
    newSchema.getDirectives()
  );
  for (const oldDirective of directivesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.DIRECTIVE_REMOVED,
      description: `${oldDirective.name} was removed.`
    });
  }
  for (const [oldDirective, newDirective] of directivesDiff.persisted) {
    const argsDiff = diff(oldDirective.args, newDirective.args);
    for (const newArg of argsDiff.added) {
      if (isRequiredArgument(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
        });
      }
    }
    for (const oldArg of argsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
        description: `${oldArg.name} was removed from ${oldDirective.name}.`
      });
    }
    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
        description: `Repeatable flag was removed from ${oldDirective.name}.`
      });
    }
    for (const location of oldDirective.locations) {
      if (!newDirective.locations.includes(location)) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
          description: `${location} was removed from ${oldDirective.name}.`
        });
      }
    }
  }
  return schemaChanges;
}
function findTypeChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const typesDiff = diff(
    Object.values(oldSchema.getTypeMap()),
    Object.values(newSchema.getTypeMap())
  );
  for (const oldType of typesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED,
      description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
    });
  }
  for (const [oldType, newType] of typesDiff.persisted) {
    if (isEnumType(oldType) && isEnumType(newType)) {
      schemaChanges.push(...findEnumTypeChanges(oldType, newType));
    } else if (isUnionType(oldType) && isUnionType(newType)) {
      schemaChanges.push(...findUnionTypeChanges(oldType, newType));
    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {
      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
    } else if (isObjectType(oldType) && isObjectType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (oldType.constructor !== newType.constructor) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_CHANGED_KIND,
        description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
      });
    }
  }
  return schemaChanges;
}
function findInputObjectTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const newField of fieldsDiff.added) {
    if (isRequiredInputField(newField)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
        description: `A required field ${newField.name} on input type ${oldType.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
      });
    }
  }
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findUnionTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
  for (const newPossibleType of possibleTypesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.TYPE_ADDED_TO_UNION,
      description: `${newPossibleType.name} was added to union type ${oldType.name}.`
    });
  }
  for (const oldPossibleType of possibleTypesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findEnumTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const valuesDiff = diff(oldType.getValues(), newType.getValues());
  for (const newValue of valuesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
      description: `${newValue.name} was added to enum type ${oldType.name}.`
    });
  }
  for (const oldValue of valuesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
      description: `${oldValue.name} was removed from enum type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findImplementedInterfacesChanges(oldType, newType) {
  const schemaChanges = [];
  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
  for (const newInterface of interfacesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
    });
  }
  for (const oldInterface of interfacesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
    });
  }
  return schemaChanges;
}
function findFieldChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    schemaChanges.push(...findArgChanges(oldType, oldField, newField));
    const isSafe = isChangeSafeForObjectOrInterfaceField(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findArgChanges(oldType, oldField, newField) {
  const schemaChanges = [];
  const argsDiff = diff(oldField.args, newField.args);
  for (const oldArg of argsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.ARG_REMOVED,
      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
    });
  }
  for (const [oldArg, newArg] of argsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldArg.type,
      newArg.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
      });
    } else if (oldArg.defaultValue !== void 0) {
      if (newArg.defaultValue === void 0) {
        schemaChanges.push({
          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
        });
      } else {
        const oldValueStr = stringifyValue2(oldArg.defaultValue, oldArg.type);
        const newValueStr = stringifyValue2(newArg.defaultValue, newArg.type);
        if (oldValueStr !== newValueStr) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
          });
        }
      }
    }
  }
  for (const newArg of argsDiff.added) {
    if (isRequiredArgument(newArg)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_ARG_ADDED,
        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_ARG_ADDED,
        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    }
  }
  return schemaChanges;
}
function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
  if (isListType(oldType)) {
    return (
      // if they're both lists, make sure the underlying types are compatible
      isListType(newType) && isChangeSafeForObjectOrInterfaceField(
        oldType.ofType,
        newType.ofType
      ) || // moving from nullable to non-null of the same underlying type is safe
      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
    );
  }
  if (isNonNullType(oldType)) {
    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
  }
  return (
    // if they're both named types, see if their names are equivalent
    isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
  );
}
function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
  if (isListType(oldType)) {
    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    return (
      // if they're both non-null, make sure the underlying types are
      // compatible
      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
        oldType.ofType,
        newType.ofType
      ) || // moving from non-null to nullable of the same underlying type is safe
      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
    );
  }
  return isNamedType(newType) && oldType.name === newType.name;
}
function typeKindName(type) {
  if (isScalarType(type)) {
    return "a Scalar type";
  }
  if (isObjectType(type)) {
    return "an Object type";
  }
  if (isInterfaceType(type)) {
    return "an Interface type";
  }
  if (isUnionType(type)) {
    return "a Union type";
  }
  if (isEnumType(type)) {
    return "an Enum type";
  }
  if (isInputObjectType(type)) {
    return "an Input type";
  }
  invariant4(false, "Unexpected type: " + inspect(type));
}
function stringifyValue2(value, type) {
  const ast = astFromValue(value, type);
  ast != null || invariant4(false);
  return print(sortValueNode(ast));
}
function diff(oldArray, newArray) {
  const added = [];
  const removed = [];
  const persisted = [];
  const oldMap = keyMap(oldArray, ({ name }) => name);
  const newMap = keyMap(newArray, ({ name }) => name);
  for (const oldItem of oldArray) {
    const newItem = newMap[oldItem.name];
    if (newItem === void 0) {
      removed.push(oldItem);
    } else {
      persisted.push([oldItem, newItem]);
    }
  }
  for (const newItem of newArray) {
    if (oldMap[newItem.name] === void 0) {
      added.push(newItem);
    }
  }
  return {
    added,
    persisted,
    removed
  };
}
var import_dist391, import_dist392, import_dist393, BreakingChangeType, DangerousChangeType;
var init_findBreakingChanges = __esm({
  "../node_modules/graphql/utilities/findBreakingChanges.mjs"() {
    import_dist391 = __toESM(require_dist(), 1);
    import_dist392 = __toESM(require_dist2(), 1);
    import_dist393 = __toESM(require_dist3(), 1);
    init_inspect();
    init_invariant2();
    init_keyMap();
    init_printer();
    init_definition();
    init_scalars();
    init_astFromValue();
    init_sortValueNode();
    (function(BreakingChangeType2) {
      BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
      BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
      BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
      BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(BreakingChangeType || (BreakingChangeType = {}));
    (function(DangerousChangeType2) {
      DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(DangerousChangeType || (DangerousChangeType = {}));
  }
});

// ../node_modules/graphql/utilities/index.mjs
var import_dist394, import_dist395, import_dist396;
var init_utilities = __esm({
  "../node_modules/graphql/utilities/index.mjs"() {
    import_dist394 = __toESM(require_dist(), 1);
    import_dist395 = __toESM(require_dist2(), 1);
    import_dist396 = __toESM(require_dist3(), 1);
    init_getIntrospectionQuery();
    init_getOperationAST();
    init_getOperationRootType();
    init_introspectionFromSchema();
    init_buildClientSchema();
    init_buildASTSchema();
    init_extendSchema();
    init_lexicographicSortSchema();
    init_printSchema();
    init_typeFromAST();
    init_valueFromAST();
    init_valueFromASTUntyped();
    init_astFromValue();
    init_TypeInfo();
    init_coerceInputValue();
    init_concatAST();
    init_separateOperations();
    init_stripIgnoredCharacters();
    init_typeComparators();
    init_assertValidName();
    init_findBreakingChanges();
  }
});

// ../node_modules/graphql/index.mjs
var graphql_exports = {};
__export(graphql_exports, {
  BREAK: () => BREAK,
  BreakingChangeType: () => BreakingChangeType,
  DEFAULT_DEPRECATION_REASON: () => DEFAULT_DEPRECATION_REASON,
  DangerousChangeType: () => DangerousChangeType,
  DirectiveLocation: () => DirectiveLocation,
  ExecutableDefinitionsRule: () => ExecutableDefinitionsRule,
  FieldsOnCorrectTypeRule: () => FieldsOnCorrectTypeRule,
  FragmentsOnCompositeTypesRule: () => FragmentsOnCompositeTypesRule,
  GRAPHQL_MAX_INT: () => GRAPHQL_MAX_INT,
  GRAPHQL_MIN_INT: () => GRAPHQL_MIN_INT,
  GraphQLBoolean: () => GraphQLBoolean,
  GraphQLDeprecatedDirective: () => GraphQLDeprecatedDirective,
  GraphQLDirective: () => GraphQLDirective,
  GraphQLEnumType: () => GraphQLEnumType,
  GraphQLError: () => GraphQLError,
  GraphQLFloat: () => GraphQLFloat,
  GraphQLID: () => GraphQLID,
  GraphQLIncludeDirective: () => GraphQLIncludeDirective,
  GraphQLInputObjectType: () => GraphQLInputObjectType,
  GraphQLInt: () => GraphQLInt,
  GraphQLInterfaceType: () => GraphQLInterfaceType,
  GraphQLList: () => GraphQLList,
  GraphQLNonNull: () => GraphQLNonNull,
  GraphQLObjectType: () => GraphQLObjectType,
  GraphQLOneOfDirective: () => GraphQLOneOfDirective,
  GraphQLScalarType: () => GraphQLScalarType,
  GraphQLSchema: () => GraphQLSchema,
  GraphQLSkipDirective: () => GraphQLSkipDirective,
  GraphQLSpecifiedByDirective: () => GraphQLSpecifiedByDirective,
  GraphQLString: () => GraphQLString,
  GraphQLUnionType: () => GraphQLUnionType,
  Kind: () => Kind,
  KnownArgumentNamesRule: () => KnownArgumentNamesRule,
  KnownDirectivesRule: () => KnownDirectivesRule,
  KnownFragmentNamesRule: () => KnownFragmentNamesRule,
  KnownTypeNamesRule: () => KnownTypeNamesRule,
  Lexer: () => Lexer,
  Location: () => Location,
  LoneAnonymousOperationRule: () => LoneAnonymousOperationRule,
  LoneSchemaDefinitionRule: () => LoneSchemaDefinitionRule,
  MaxIntrospectionDepthRule: () => MaxIntrospectionDepthRule,
  NoDeprecatedCustomRule: () => NoDeprecatedCustomRule,
  NoFragmentCyclesRule: () => NoFragmentCyclesRule,
  NoSchemaIntrospectionCustomRule: () => NoSchemaIntrospectionCustomRule,
  NoUndefinedVariablesRule: () => NoUndefinedVariablesRule,
  NoUnusedFragmentsRule: () => NoUnusedFragmentsRule,
  NoUnusedVariablesRule: () => NoUnusedVariablesRule,
  OperationTypeNode: () => OperationTypeNode,
  OverlappingFieldsCanBeMergedRule: () => OverlappingFieldsCanBeMergedRule,
  PossibleFragmentSpreadsRule: () => PossibleFragmentSpreadsRule,
  PossibleTypeExtensionsRule: () => PossibleTypeExtensionsRule,
  ProvidedRequiredArgumentsRule: () => ProvidedRequiredArgumentsRule,
  ScalarLeafsRule: () => ScalarLeafsRule,
  SchemaMetaFieldDef: () => SchemaMetaFieldDef,
  SingleFieldSubscriptionsRule: () => SingleFieldSubscriptionsRule,
  Source: () => Source,
  Token: () => Token,
  TokenKind: () => TokenKind,
  TypeInfo: () => TypeInfo,
  TypeKind: () => TypeKind,
  TypeMetaFieldDef: () => TypeMetaFieldDef,
  TypeNameMetaFieldDef: () => TypeNameMetaFieldDef,
  UniqueArgumentDefinitionNamesRule: () => UniqueArgumentDefinitionNamesRule,
  UniqueArgumentNamesRule: () => UniqueArgumentNamesRule,
  UniqueDirectiveNamesRule: () => UniqueDirectiveNamesRule,
  UniqueDirectivesPerLocationRule: () => UniqueDirectivesPerLocationRule,
  UniqueEnumValueNamesRule: () => UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule: () => UniqueFieldDefinitionNamesRule,
  UniqueFragmentNamesRule: () => UniqueFragmentNamesRule,
  UniqueInputFieldNamesRule: () => UniqueInputFieldNamesRule,
  UniqueOperationNamesRule: () => UniqueOperationNamesRule,
  UniqueOperationTypesRule: () => UniqueOperationTypesRule,
  UniqueTypeNamesRule: () => UniqueTypeNamesRule,
  UniqueVariableNamesRule: () => UniqueVariableNamesRule,
  ValidationContext: () => ValidationContext,
  ValuesOfCorrectTypeRule: () => ValuesOfCorrectTypeRule,
  VariablesAreInputTypesRule: () => VariablesAreInputTypesRule,
  VariablesInAllowedPositionRule: () => VariablesInAllowedPositionRule,
  __Directive: () => __Directive,
  __DirectiveLocation: () => __DirectiveLocation,
  __EnumValue: () => __EnumValue,
  __Field: () => __Field,
  __InputValue: () => __InputValue,
  __Schema: () => __Schema,
  __Type: () => __Type,
  __TypeKind: () => __TypeKind,
  assertAbstractType: () => assertAbstractType,
  assertCompositeType: () => assertCompositeType,
  assertDirective: () => assertDirective,
  assertEnumType: () => assertEnumType,
  assertEnumValueName: () => assertEnumValueName,
  assertInputObjectType: () => assertInputObjectType,
  assertInputType: () => assertInputType,
  assertInterfaceType: () => assertInterfaceType,
  assertLeafType: () => assertLeafType,
  assertListType: () => assertListType,
  assertName: () => assertName,
  assertNamedType: () => assertNamedType,
  assertNonNullType: () => assertNonNullType,
  assertNullableType: () => assertNullableType,
  assertObjectType: () => assertObjectType,
  assertOutputType: () => assertOutputType,
  assertScalarType: () => assertScalarType,
  assertSchema: () => assertSchema,
  assertType: () => assertType,
  assertUnionType: () => assertUnionType,
  assertValidName: () => assertValidName,
  assertValidSchema: () => assertValidSchema,
  assertWrappingType: () => assertWrappingType,
  astFromValue: () => astFromValue,
  buildASTSchema: () => buildASTSchema,
  buildClientSchema: () => buildClientSchema,
  buildSchema: () => buildSchema,
  coerceInputValue: () => coerceInputValue,
  concatAST: () => concatAST,
  createSourceEventStream: () => createSourceEventStream,
  defaultFieldResolver: () => defaultFieldResolver,
  defaultTypeResolver: () => defaultTypeResolver,
  doTypesOverlap: () => doTypesOverlap,
  execute: () => execute,
  executeSync: () => executeSync,
  extendSchema: () => extendSchema,
  findBreakingChanges: () => findBreakingChanges,
  findDangerousChanges: () => findDangerousChanges,
  formatError: () => formatError,
  getArgumentValues: () => getArgumentValues,
  getDirectiveValues: () => getDirectiveValues,
  getEnterLeaveForKind: () => getEnterLeaveForKind,
  getIntrospectionQuery: () => getIntrospectionQuery,
  getLocation: () => getLocation,
  getNamedType: () => getNamedType,
  getNullableType: () => getNullableType,
  getOperationAST: () => getOperationAST,
  getOperationRootType: () => getOperationRootType,
  getVariableValues: () => getVariableValues,
  getVisitFn: () => getVisitFn,
  graphql: () => graphql,
  graphqlSync: () => graphqlSync,
  introspectionFromSchema: () => introspectionFromSchema,
  introspectionTypes: () => introspectionTypes,
  isAbstractType: () => isAbstractType,
  isCompositeType: () => isCompositeType,
  isConstValueNode: () => isConstValueNode,
  isDefinitionNode: () => isDefinitionNode,
  isDirective: () => isDirective,
  isEnumType: () => isEnumType,
  isEqualType: () => isEqualType,
  isExecutableDefinitionNode: () => isExecutableDefinitionNode,
  isInputObjectType: () => isInputObjectType,
  isInputType: () => isInputType,
  isInterfaceType: () => isInterfaceType,
  isIntrospectionType: () => isIntrospectionType,
  isLeafType: () => isLeafType,
  isListType: () => isListType,
  isNamedType: () => isNamedType,
  isNonNullType: () => isNonNullType,
  isNullableType: () => isNullableType,
  isObjectType: () => isObjectType,
  isOutputType: () => isOutputType,
  isRequiredArgument: () => isRequiredArgument,
  isRequiredInputField: () => isRequiredInputField,
  isScalarType: () => isScalarType,
  isSchema: () => isSchema,
  isSelectionNode: () => isSelectionNode,
  isSpecifiedDirective: () => isSpecifiedDirective,
  isSpecifiedScalarType: () => isSpecifiedScalarType,
  isType: () => isType,
  isTypeDefinitionNode: () => isTypeDefinitionNode,
  isTypeExtensionNode: () => isTypeExtensionNode,
  isTypeNode: () => isTypeNode,
  isTypeSubTypeOf: () => isTypeSubTypeOf,
  isTypeSystemDefinitionNode: () => isTypeSystemDefinitionNode,
  isTypeSystemExtensionNode: () => isTypeSystemExtensionNode,
  isUnionType: () => isUnionType,
  isValidNameError: () => isValidNameError,
  isValueNode: () => isValueNode,
  isWrappingType: () => isWrappingType,
  lexicographicSortSchema: () => lexicographicSortSchema,
  locatedError: () => locatedError,
  parse: () => parse,
  parseConstValue: () => parseConstValue,
  parseType: () => parseType,
  parseValue: () => parseValue,
  print: () => print,
  printError: () => printError,
  printIntrospectionSchema: () => printIntrospectionSchema,
  printLocation: () => printLocation,
  printSchema: () => printSchema,
  printSourceLocation: () => printSourceLocation,
  printType: () => printType,
  recommendedRules: () => recommendedRules,
  resolveObjMapThunk: () => resolveObjMapThunk,
  resolveReadonlyArrayThunk: () => resolveReadonlyArrayThunk,
  responsePathAsArray: () => pathToArray,
  separateOperations: () => separateOperations,
  specifiedDirectives: () => specifiedDirectives,
  specifiedRules: () => specifiedRules,
  specifiedScalarTypes: () => specifiedScalarTypes,
  stripIgnoredCharacters: () => stripIgnoredCharacters,
  subscribe: () => subscribe,
  syntaxError: () => syntaxError,
  typeFromAST: () => typeFromAST,
  validate: () => validate,
  validateSchema: () => validateSchema,
  valueFromAST: () => valueFromAST,
  valueFromASTUntyped: () => valueFromASTUntyped,
  version: () => version2,
  versionInfo: () => versionInfo,
  visit: () => visit,
  visitInParallel: () => visitInParallel,
  visitWithTypeInfo: () => visitWithTypeInfo
});
var import_dist397, import_dist398, import_dist399;
var init_graphql2 = __esm({
  "../node_modules/graphql/index.mjs"() {
    import_dist397 = __toESM(require_dist(), 1);
    import_dist398 = __toESM(require_dist2(), 1);
    import_dist399 = __toESM(require_dist3(), 1);
    init_version2();
    init_graphql();
    init_type();
    init_language();
    init_execution();
    init_validation();
    init_error();
    init_utilities();
  }
});

// ../node_modules/@apollo/client/utilities/graphql/directives.js
function shouldInclude(_a2, variables) {
  var directives = _a2.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a3) {
    var directive = _a3.directive, ifArgument = _a3.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      invariant2(evaledValue !== void 0, 69, directive.name.value);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function hasDirectives(names, root2, all) {
  var nameSet = new Set(names);
  var uniqueCount = nameSet.size;
  visit(root2, {
    Directive: function(node) {
      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
        return BREAK;
      }
    }
  });
  return all ? !nameSet.size : nameSet.size < uniqueCount;
}
function hasClientExports(document) {
  return document && hasDirectives(["client", "export"], document, true);
}
function isInclusionDirective(_a2) {
  var value = _a2.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result2 = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      invariant2(directiveArguments && directiveArguments.length === 1, 70, directiveName);
      var ifArgument = directiveArguments[0];
      invariant2(ifArgument.name && ifArgument.name.value === "if", 71, directiveName);
      var ifValue = ifArgument.value;
      invariant2(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 72, directiveName);
      result2.push({ directive, ifArgument });
    });
  }
  return result2;
}
var import_dist400, import_dist401, import_dist402;
var init_directives2 = __esm({
  "../node_modules/@apollo/client/utilities/graphql/directives.js"() {
    import_dist400 = __toESM(require_dist(), 1);
    import_dist401 = __toESM(require_dist2(), 1);
    import_dist402 = __toESM(require_dist3(), 1);
    init_globals();
    init_graphql2();
  }
});

// ../node_modules/@wry/trie/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  Trie: () => Trie
});
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
var import_dist403, import_dist404, import_dist405, defaultMakeData, forEach, slice, hasOwnProperty2, Trie;
var init_lib = __esm({
  "../node_modules/@wry/trie/lib/index.js"() {
    import_dist403 = __toESM(require_dist());
    import_dist404 = __toESM(require_dist2());
    import_dist405 = __toESM(require_dist3());
    defaultMakeData = () => /* @__PURE__ */ Object.create(null);
    ({ forEach, slice } = Array.prototype);
    ({ hasOwnProperty: hasOwnProperty2 } = Object.prototype);
    Trie = class _Trie {
      constructor(weakness = true, makeData = defaultMakeData) {
        this.weakness = weakness;
        this.makeData = makeData;
      }
      lookup() {
        return this.lookupArray(arguments);
      }
      lookupArray(array) {
        let node = this;
        forEach.call(array, (key) => node = node.getChildTrie(key));
        return hasOwnProperty2.call(node, "data") ? node.data : node.data = this.makeData(slice.call(array));
      }
      peek() {
        return this.peekArray(arguments);
      }
      peekArray(array) {
        let node = this;
        for (let i = 0, len = array.length; node && i < len; ++i) {
          const map = node.mapFor(array[i], false);
          node = map && map.get(array[i]);
        }
        return node && node.data;
      }
      remove() {
        return this.removeArray(arguments);
      }
      removeArray(array) {
        let data;
        if (array.length) {
          const head = array[0];
          const map = this.mapFor(head, false);
          const child = map && map.get(head);
          if (child) {
            data = child.removeArray(slice.call(array, 1));
            if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
              map.delete(head);
            }
          }
        } else {
          data = this.data;
          delete this.data;
        }
        return data;
      }
      getChildTrie(key) {
        const map = this.mapFor(key, true);
        let child = map.get(key);
        if (!child)
          map.set(key, child = new _Trie(this.weakness, this.makeData));
        return child;
      }
      mapFor(key, create) {
        return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (create ? this.strong = /* @__PURE__ */ new Map() : void 0);
      }
    };
  }
});

// ../node_modules/@apollo/client/utilities/common/canUse.js
var import_dist406, import_dist407, import_dist408, isReactNative, canUseWeakMap, canUseWeakSet, canUseSymbol, canUseAsyncIteratorSymbol, canUseDOM, usingJSDOM, canUseLayoutEffect;
var init_canUse = __esm({
  "../node_modules/@apollo/client/utilities/common/canUse.js"() {
    import_dist406 = __toESM(require_dist(), 1);
    import_dist407 = __toESM(require_dist2(), 1);
    import_dist408 = __toESM(require_dist3(), 1);
    init_globals();
    isReactNative = maybe(function() {
      return navigator.product;
    }) == "ReactNative";
    canUseWeakMap = typeof WeakMap === "function" && !(isReactNative && !global.HermesInternal);
    canUseWeakSet = typeof WeakSet === "function";
    canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
    canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
    canUseDOM = typeof maybe(function() {
      return window.document.createElement;
    }) === "function";
    usingJSDOM = // Following advice found in this comment from @domenic (maintainer of jsdom):
    // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327
    //
    // Since we control the version of Jest and jsdom used when running Apollo
    // Client tests, and that version is recent enought to include " jsdom/x.y.z"
    // at the end of the user agent string, I believe this case is all we need to
    // check. Testing for "Node.js" was recommended for backwards compatibility
    // with older version of jsdom, but we don't have that problem.
    maybe(function() {
      return navigator.userAgent.indexOf("jsdom") >= 0;
    }) || false;
    canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;
  }
});

// ../node_modules/@apollo/client/utilities/common/objects.js
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}
var import_dist409, import_dist410, import_dist411;
var init_objects = __esm({
  "../node_modules/@apollo/client/utilities/common/objects.js"() {
    import_dist409 = __toESM(require_dist(), 1);
    import_dist410 = __toESM(require_dist2(), 1);
    import_dist411 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/utilities/graphql/fragments.js
function getFragmentQueryDocument(document, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw newInvariantError(
        73,
        definition.operation,
        definition.name ? " named '".concat(definition.name.value, "'") : ""
      );
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    invariant2(fragments.length === 1, 74, fragments.length);
    actualFragmentName = fragments[0].name.value;
  }
  var query = __assign(__assign({}, document), { definitions: __spreadArray([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document.definitions, true) });
  return query;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      var fragment = fragmentMap && fragmentMap[fragmentName];
      invariant2(fragment, 75, fragmentName);
      return fragment || null;
    }
    default:
      return null;
  }
}
var import_dist412, import_dist413, import_dist414;
var init_fragments = __esm({
  "../node_modules/@apollo/client/utilities/graphql/fragments.js"() {
    import_dist412 = __toESM(require_dist(), 1);
    import_dist413 = __toESM(require_dist2(), 1);
    import_dist414 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
  }
});

// ../node_modules/@wry/caches/lib/strong.js
function defaultDispose() {
}
var import_dist415, import_dist416, import_dist417, StrongCache;
var init_strong = __esm({
  "../node_modules/@wry/caches/lib/strong.js"() {
    import_dist415 = __toESM(require_dist(), 1);
    import_dist416 = __toESM(require_dist2(), 1);
    import_dist417 = __toESM(require_dist3(), 1);
    StrongCache = class {
      constructor(max = Infinity, dispose = defaultDispose) {
        this.max = max;
        this.dispose = dispose;
        this.map = /* @__PURE__ */ new Map();
        this.newest = null;
        this.oldest = null;
      }
      has(key) {
        return this.map.has(key);
      }
      get(key) {
        const node = this.getNode(key);
        return node && node.value;
      }
      get size() {
        return this.map.size;
      }
      getNode(key) {
        const node = this.map.get(key);
        if (node && node !== this.newest) {
          const { older, newer } = node;
          if (newer) {
            newer.older = older;
          }
          if (older) {
            older.newer = newer;
          }
          node.older = this.newest;
          node.older.newer = node;
          node.newer = null;
          this.newest = node;
          if (node === this.oldest) {
            this.oldest = newer;
          }
        }
        return node;
      }
      set(key, value) {
        let node = this.getNode(key);
        if (node) {
          return node.value = value;
        }
        node = {
          key,
          value,
          newer: null,
          older: this.newest
        };
        if (this.newest) {
          this.newest.newer = node;
        }
        this.newest = node;
        this.oldest = this.oldest || node;
        this.map.set(key, node);
        return node.value;
      }
      clean() {
        while (this.oldest && this.map.size > this.max) {
          this.delete(this.oldest.key);
        }
      }
      delete(key) {
        const node = this.map.get(key);
        if (node) {
          if (node === this.newest) {
            this.newest = node.older;
          }
          if (node === this.oldest) {
            this.oldest = node.newer;
          }
          if (node.newer) {
            node.newer.older = node.older;
          }
          if (node.older) {
            node.older.newer = node.newer;
          }
          this.map.delete(key);
          this.dispose(node.value, key);
          return true;
        }
        return false;
      }
    };
  }
});

// ../node_modules/@wry/caches/lib/weak.js
function noop() {
}
var import_dist418, import_dist419, import_dist420, defaultDispose2, _WeakRef, _WeakMap, _FinalizationRegistry, finalizationBatchSize, WeakCache;
var init_weak = __esm({
  "../node_modules/@wry/caches/lib/weak.js"() {
    import_dist418 = __toESM(require_dist(), 1);
    import_dist419 = __toESM(require_dist2(), 1);
    import_dist420 = __toESM(require_dist3(), 1);
    defaultDispose2 = noop;
    _WeakRef = typeof WeakRef !== "undefined" ? WeakRef : function(value) {
      return { deref: () => value };
    };
    _WeakMap = typeof WeakMap !== "undefined" ? WeakMap : Map;
    _FinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : function() {
      return {
        register: noop,
        unregister: noop
      };
    };
    finalizationBatchSize = 10024;
    WeakCache = class {
      constructor(max = Infinity, dispose = defaultDispose2) {
        this.max = max;
        this.dispose = dispose;
        this.map = new _WeakMap();
        this.newest = null;
        this.oldest = null;
        this.unfinalizedNodes = /* @__PURE__ */ new Set();
        this.finalizationScheduled = false;
        this.size = 0;
        this.finalize = () => {
          const iterator = this.unfinalizedNodes.values();
          for (let i = 0; i < finalizationBatchSize; i++) {
            const node = iterator.next().value;
            if (!node)
              break;
            this.unfinalizedNodes.delete(node);
            const key = node.key;
            delete node.key;
            node.keyRef = new _WeakRef(key);
            this.registry.register(key, node, node);
          }
          if (this.unfinalizedNodes.size > 0) {
            queueMicrotask(this.finalize);
          } else {
            this.finalizationScheduled = false;
          }
        };
        this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));
      }
      has(key) {
        return this.map.has(key);
      }
      get(key) {
        const node = this.getNode(key);
        return node && node.value;
      }
      getNode(key) {
        const node = this.map.get(key);
        if (node && node !== this.newest) {
          const { older, newer } = node;
          if (newer) {
            newer.older = older;
          }
          if (older) {
            older.newer = newer;
          }
          node.older = this.newest;
          node.older.newer = node;
          node.newer = null;
          this.newest = node;
          if (node === this.oldest) {
            this.oldest = newer;
          }
        }
        return node;
      }
      set(key, value) {
        let node = this.getNode(key);
        if (node) {
          return node.value = value;
        }
        node = {
          key,
          value,
          newer: null,
          older: this.newest
        };
        if (this.newest) {
          this.newest.newer = node;
        }
        this.newest = node;
        this.oldest = this.oldest || node;
        this.scheduleFinalization(node);
        this.map.set(key, node);
        this.size++;
        return node.value;
      }
      clean() {
        while (this.oldest && this.size > this.max) {
          this.deleteNode(this.oldest);
        }
      }
      deleteNode(node) {
        if (node === this.newest) {
          this.newest = node.older;
        }
        if (node === this.oldest) {
          this.oldest = node.newer;
        }
        if (node.newer) {
          node.newer.older = node.older;
        }
        if (node.older) {
          node.older.newer = node.newer;
        }
        this.size--;
        const key = node.key || node.keyRef && node.keyRef.deref();
        this.dispose(node.value, key);
        if (!node.keyRef) {
          this.unfinalizedNodes.delete(node);
        } else {
          this.registry.unregister(node);
        }
        if (key)
          this.map.delete(key);
      }
      delete(key) {
        const node = this.map.get(key);
        if (node) {
          this.deleteNode(node);
          return true;
        }
        return false;
      }
      scheduleFinalization(node) {
        this.unfinalizedNodes.add(node);
        if (!this.finalizationScheduled) {
          this.finalizationScheduled = true;
          queueMicrotask(this.finalize);
        }
      }
    };
  }
});

// ../node_modules/@wry/caches/lib/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  StrongCache: () => StrongCache,
  WeakCache: () => WeakCache
});
var import_dist421, import_dist422, import_dist423;
var init_lib2 = __esm({
  "../node_modules/@wry/caches/lib/index.js"() {
    import_dist421 = __toESM(require_dist());
    import_dist422 = __toESM(require_dist2());
    import_dist423 = __toESM(require_dist3());
    init_strong();
    init_weak();
  }
});

// ../node_modules/@apollo/client/utilities/caching/caches.js
function schedule(cache2) {
  if (cache2.size <= (cache2.max || -1)) {
    return;
  }
  if (!scheduledCleanup.has(cache2)) {
    scheduledCleanup.add(cache2);
    setTimeout(function() {
      cache2.clean();
      scheduledCleanup.delete(cache2);
    }, 100);
  }
}
var import_dist424, import_dist425, import_dist426, scheduledCleanup, AutoCleanedWeakCache, AutoCleanedStrongCache;
var init_caches = __esm({
  "../node_modules/@apollo/client/utilities/caching/caches.js"() {
    import_dist424 = __toESM(require_dist(), 1);
    import_dist425 = __toESM(require_dist2(), 1);
    import_dist426 = __toESM(require_dist3(), 1);
    init_lib2();
    scheduledCleanup = /* @__PURE__ */ new WeakSet();
    AutoCleanedWeakCache = function(max, dispose) {
      var cache2 = new WeakCache(max, dispose);
      cache2.set = function(key, value) {
        var ret = WeakCache.prototype.set.call(this, key, value);
        schedule(this);
        return ret;
      };
      return cache2;
    };
    AutoCleanedStrongCache = function(max, dispose) {
      var cache2 = new StrongCache(max, dispose);
      cache2.set = function(key, value) {
        var ret = StrongCache.prototype.set.call(this, key, value);
        schedule(this);
        return ret;
      };
      return cache2;
    };
  }
});

// ../node_modules/@apollo/client/utilities/caching/sizes.js
var import_dist427, import_dist428, import_dist429, cacheSizeSymbol, cacheSizes;
var init_sizes = __esm({
  "../node_modules/@apollo/client/utilities/caching/sizes.js"() {
    import_dist427 = __toESM(require_dist(), 1);
    import_dist428 = __toESM(require_dist2(), 1);
    import_dist429 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    cacheSizeSymbol = Symbol.for("apollo.cacheSize");
    cacheSizes = __assign({}, global_default[cacheSizeSymbol]);
  }
});

// ../node_modules/@apollo/client/utilities/caching/index.js
var import_dist430, import_dist431, import_dist432;
var init_caching = __esm({
  "../node_modules/@apollo/client/utilities/caching/index.js"() {
    import_dist430 = __toESM(require_dist(), 1);
    import_dist431 = __toESM(require_dist2(), 1);
    import_dist432 = __toESM(require_dist3(), 1);
    init_caches();
    init_sizes();
  }
});

// ../node_modules/@apollo/client/utilities/caching/getMemoryInternals.js
function registerGlobalCache(name, getSize) {
  globalCaches[name] = getSize;
}
function getCurrentCacheSizes() {
  var defaults = {
    parser: 1e3,
    canonicalStringify: 1e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(defaults).map(function(_a2) {
    var k = _a2[0], v = _a2[1];
    return [
      k,
      cacheSizes[k] || v
    ];
  }));
}
function _getApolloClientMemoryInternals() {
  var _a2, _b, _c, _d, _e;
  if (!(globalThis.__DEV__ !== false))
    throw new Error("only supported in development mode");
  return {
    limits: getCurrentCacheSizes(),
    sizes: __assign({ print: (_a2 = globalCaches.print) === null || _a2 === void 0 ? void 0 : _a2.call(globalCaches), parser: (_b = globalCaches.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches), canonicalStringify: (_c = globalCaches.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches), links: linkInfo(this.link), queryManager: {
      getDocumentInfo: this["queryManager"]["transformCache"].size,
      documentTransforms: transformInfo(this["queryManager"].documentTransform)
    } }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))
  };
}
function _getApolloCacheMemoryInternals() {
  return {
    cache: {
      fragmentQueryDocuments: getWrapperInformation(this["getFragmentDoc"])
    }
  };
}
function _getInMemoryCacheMemoryInternals() {
  var fragments = this.config.fragments;
  return __assign(__assign({}, _getApolloCacheMemoryInternals.apply(this)), { addTypenameDocumentTransform: transformInfo(this["addTypenameTransform"]), inMemoryCache: {
    executeSelectionSet: getWrapperInformation(this["storeReader"]["executeSelectionSet"]),
    executeSubSelectedArray: getWrapperInformation(this["storeReader"]["executeSubSelectedArray"]),
    maybeBroadcastWatch: getWrapperInformation(this["maybeBroadcastWatch"])
  }, fragmentRegistry: {
    findFragmentSpreads: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
    lookup: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
    transform: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
  } });
}
function isWrapper(f) {
  return !!f && "dirtyKey" in f;
}
function getWrapperInformation(f) {
  return isWrapper(f) ? f.size : void 0;
}
function isDefined(value) {
  return value != null;
}
function transformInfo(transform) {
  return recurseTransformInfo(transform).map(function(cache2) {
    return { cache: cache2 };
  });
}
function recurseTransformInfo(transform) {
  return transform ? __spreadArray(__spreadArray([
    getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform["performWork"])
  ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined) : [];
}
function linkInfo(link) {
  var _a2;
  return link ? __spreadArray(__spreadArray([
    (_a2 = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a2 === void 0 ? void 0 : _a2.call(link)
  ], linkInfo(link === null || link === void 0 ? void 0 : link.left), true), linkInfo(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined) : [];
}
var import_dist433, import_dist434, import_dist435, globalCaches, getApolloClientMemoryInternals, getInMemoryCacheMemoryInternals, getApolloCacheMemoryInternals;
var init_getMemoryInternals = __esm({
  "../node_modules/@apollo/client/utilities/caching/getMemoryInternals.js"() {
    import_dist433 = __toESM(require_dist(), 1);
    import_dist434 = __toESM(require_dist2(), 1);
    import_dist435 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_sizes();
    globalCaches = {};
    getApolloClientMemoryInternals = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals : void 0;
    getInMemoryCacheMemoryInternals = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals : void 0;
    getApolloCacheMemoryInternals = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals : void 0;
  }
});

// ../node_modules/@apollo/client/utilities/common/canonicalStringify.js
function stableObjectReplacer(key, value) {
  if (value && typeof value === "object") {
    var proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
      var keys = Object.keys(value);
      if (keys.every(everyKeyInOrder))
        return value;
      var unsortedKey = JSON.stringify(keys);
      var sortedKeys = sortingMap.get(unsortedKey);
      if (!sortedKeys) {
        keys.sort();
        var sortedKey = JSON.stringify(keys);
        sortedKeys = sortingMap.get(sortedKey) || keys;
        sortingMap.set(unsortedKey, sortedKeys);
        sortingMap.set(sortedKey, sortedKeys);
      }
      var sortedObject_1 = Object.create(proto);
      sortedKeys.forEach(function(key2) {
        sortedObject_1[key2] = value[key2];
      });
      return sortedObject_1;
    }
  }
  return value;
}
function everyKeyInOrder(key, i, keys) {
  return i === 0 || keys[i - 1] <= key;
}
var import_dist436, import_dist437, import_dist438, canonicalStringify, sortingMap;
var init_canonicalStringify = __esm({
  "../node_modules/@apollo/client/utilities/common/canonicalStringify.js"() {
    import_dist436 = __toESM(require_dist(), 1);
    import_dist437 = __toESM(require_dist2(), 1);
    import_dist438 = __toESM(require_dist3(), 1);
    init_caching();
    init_getMemoryInternals();
    canonicalStringify = Object.assign(function canonicalStringify2(value) {
      return JSON.stringify(value, stableObjectReplacer);
    }, {
      reset: function() {
        sortingMap = new AutoCleanedStrongCache(
          cacheSizes.canonicalStringify || 1e3
          /* defaultCacheSizes.canonicalStringify */
        );
      }
    });
    if (globalThis.__DEV__ !== false) {
      registerGlobalCache("canonicalStringify", function() {
        return sortingMap.size;
      });
    }
    canonicalStringify.reset();
  }
});

// ../node_modules/@apollo/client/utilities/graphql/storeUtils.js
function makeReference(id) {
  return { __ref: String(id) };
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw newInvariantError(84, name.value, value.kind);
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a2) {
          var name = _a2.name, value = _a2.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result2, selectionSet, fragmentMap) {
  var fragments;
  for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
    var selection = _a2[_i];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result2[resultKeyNameFromField(selection)];
      }
    } else if (fragments) {
      fragments.push(selection);
    } else {
      fragments = [selection];
    }
  }
  if (typeof result2.__typename === "string") {
    return result2.__typename;
  }
  if (fragments) {
    for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
      var selection = fragments_1[_b];
      var typename = getTypenameFromResult(result2, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}
var import_dist439, import_dist440, import_dist441, KNOWN_DIRECTIVES, storeKeyNameStringify, getStoreKeyName;
var init_storeUtils = __esm({
  "../node_modules/@apollo/client/utilities/graphql/storeUtils.js"() {
    import_dist439 = __toESM(require_dist(), 1);
    import_dist440 = __toESM(require_dist2(), 1);
    import_dist441 = __toESM(require_dist3(), 1);
    init_globals();
    init_objects();
    init_fragments();
    init_canonicalStringify();
    KNOWN_DIRECTIVES = [
      "connection",
      "include",
      "skip",
      "client",
      "rest",
      "export",
      "nonreactive"
    ];
    storeKeyNameStringify = canonicalStringify;
    getStoreKeyName = Object.assign(function(fieldName, args, directives) {
      if (args && directives && directives["connection"] && directives["connection"]["key"]) {
        if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
          var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
          filterKeys.sort();
          var filteredArgs_1 = {};
          filterKeys.forEach(function(key) {
            filteredArgs_1[key] = args[key];
          });
          return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify(filteredArgs_1), ")");
        } else {
          return directives["connection"]["key"];
        }
      }
      var completeFieldName = fieldName;
      if (args) {
        var stringifiedArgs = storeKeyNameStringify(args);
        completeFieldName += "(".concat(stringifiedArgs, ")");
      }
      if (directives) {
        Object.keys(directives).forEach(function(key) {
          if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
            return;
          if (directives[key] && Object.keys(directives[key]).length) {
            completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify(directives[key]), ")");
          } else {
            completeFieldName += "@".concat(key);
          }
        });
      }
      return completeFieldName;
    }, {
      setStringify: function(s) {
        var previous = storeKeyNameStringify;
        storeKeyNameStringify = s;
        return previous;
      }
    });
  }
});

// ../node_modules/@apollo/client/utilities/graphql/getFromAST.js
function checkDocument(doc) {
  invariant2(doc && doc.kind === "Document", 76);
  var operations = doc.definitions.filter(function(d) {
    return d.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw newInvariantError(77, definition.kind);
    }
    return definition;
  });
  invariant2(operations.length <= 1, 78, operations.length);
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && !!definition.name;
  }).map(function(x) {
    return x.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  invariant2(queryDef && queryDef.operation === "query", 79);
  return queryDef;
}
function getFragmentDefinition(doc) {
  invariant2(doc.kind === "Document", 80);
  invariant2(doc.definitions.length <= 1, 81);
  var fragmentDef = doc.definitions[0];
  invariant2(fragmentDef.kind === "FragmentDefinition", 82);
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
    var definition = _a2[_i];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw newInvariantError(83);
}
function getDefaultValues(definition) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}
var import_dist442, import_dist443, import_dist444;
var init_getFromAST = __esm({
  "../node_modules/@apollo/client/utilities/graphql/getFromAST.js"() {
    import_dist442 = __toESM(require_dist(), 1);
    import_dist443 = __toESM(require_dist2(), 1);
    import_dist444 = __toESM(require_dist3(), 1);
    init_globals();
    init_storeUtils();
  }
});

// ../node_modules/optimism/node_modules/@wry/trie/lib/index.js
function isObjRef2(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
var import_dist445, import_dist446, import_dist447, defaultMakeData2, forEach2, slice2, hasOwnProperty3, Trie2;
var init_lib3 = __esm({
  "../node_modules/optimism/node_modules/@wry/trie/lib/index.js"() {
    import_dist445 = __toESM(require_dist());
    import_dist446 = __toESM(require_dist2());
    import_dist447 = __toESM(require_dist3());
    defaultMakeData2 = () => /* @__PURE__ */ Object.create(null);
    ({ forEach: forEach2, slice: slice2 } = Array.prototype);
    ({ hasOwnProperty: hasOwnProperty3 } = Object.prototype);
    Trie2 = class _Trie {
      constructor(weakness = true, makeData = defaultMakeData2) {
        this.weakness = weakness;
        this.makeData = makeData;
      }
      lookup(...array) {
        return this.lookupArray(array);
      }
      lookupArray(array) {
        let node = this;
        forEach2.call(array, (key) => node = node.getChildTrie(key));
        return hasOwnProperty3.call(node, "data") ? node.data : node.data = this.makeData(slice2.call(array));
      }
      peek(...array) {
        return this.peekArray(array);
      }
      peekArray(array) {
        let node = this;
        for (let i = 0, len = array.length; node && i < len; ++i) {
          const map = this.weakness && isObjRef2(array[i]) ? node.weak : node.strong;
          node = map && map.get(array[i]);
        }
        return node && node.data;
      }
      getChildTrie(key) {
        const map = this.weakness && isObjRef2(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
        let child = map.get(key);
        if (!child)
          map.set(key, child = new _Trie(this.weakness, this.makeData));
        return child;
      }
    };
  }
});

// ../node_modules/@wry/context/lib/slot.js
function maybe2(fn) {
  try {
    return fn();
  } catch (ignored) {
  }
}
var import_dist448, import_dist449, import_dist450, currentContext, MISSING_VALUE, idCounter, makeSlotClass, globalKey, host, globalHost, Slot;
var init_slot = __esm({
  "../node_modules/@wry/context/lib/slot.js"() {
    import_dist448 = __toESM(require_dist(), 1);
    import_dist449 = __toESM(require_dist2(), 1);
    import_dist450 = __toESM(require_dist3(), 1);
    currentContext = null;
    MISSING_VALUE = {};
    idCounter = 1;
    makeSlotClass = () => class Slot {
      constructor() {
        this.id = [
          "slot",
          idCounter++,
          Date.now(),
          Math.random().toString(36).slice(2)
        ].join(":");
      }
      hasValue() {
        for (let context = currentContext; context; context = context.parent) {
          if (this.id in context.slots) {
            const value = context.slots[this.id];
            if (value === MISSING_VALUE)
              break;
            if (context !== currentContext) {
              currentContext.slots[this.id] = value;
            }
            return true;
          }
        }
        if (currentContext) {
          currentContext.slots[this.id] = MISSING_VALUE;
        }
        return false;
      }
      getValue() {
        if (this.hasValue()) {
          return currentContext.slots[this.id];
        }
      }
      withValue(value, callback, args, thisArg) {
        const slots = {
          __proto__: null,
          [this.id]: value
        };
        const parent = currentContext;
        currentContext = { parent, slots };
        try {
          return callback.apply(thisArg, args);
        } finally {
          currentContext = parent;
        }
      }
      // Capture the current context and wrap a callback function so that it
      // reestablishes the captured context when called.
      static bind(callback) {
        const context = currentContext;
        return function() {
          const saved = currentContext;
          try {
            currentContext = context;
            return callback.apply(this, arguments);
          } finally {
            currentContext = saved;
          }
        };
      }
      // Immediately run a callback function without any captured context.
      static noContext(callback, args, thisArg) {
        if (currentContext) {
          const saved = currentContext;
          try {
            currentContext = null;
            return callback.apply(thisArg, args);
          } finally {
            currentContext = saved;
          }
        } else {
          return callback.apply(thisArg, args);
        }
      }
    };
    globalKey = "@wry/context:Slot";
    host = // Prefer globalThis when available.
    // https://github.com/benjamn/wryware/issues/347
    maybe2(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
    // bundlers to the appropriate identifier (window, self, ...) depending on the
    // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
    maybe2(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
    // back to using the Array constructor as a namespace, but that was flagged in
    // https://github.com/benjamn/wryware/issues/347, and can be avoided.
    /* @__PURE__ */ Object.create(null);
    globalHost = host;
    Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
    // constructor, so we check there as well, to prevent Slot class duplication.
    Array[globalKey] || function(Slot2) {
      try {
        Object.defineProperty(globalHost, globalKey, {
          value: Slot2,
          enumerable: false,
          writable: false,
          // When it was possible for globalHost to be the Array constructor (a
          // legacy Slot dedup strategy), it was important for the property to be
          // configurable:true so it could be deleted. That does not seem to be as
          // important when globalHost is the global object, but I don't want to
          // cause similar problems again, and configurable:true seems safest.
          // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
          configurable: true
        });
      } finally {
        return Slot2;
      }
    }(makeSlotClass());
  }
});

// ../node_modules/@wry/context/lib/index.js
function setTimeoutWithContext(callback, delay) {
  return setTimeout(bind(callback), delay);
}
function asyncFromGen(genFn) {
  return function() {
    const gen = genFn.apply(this, arguments);
    const boundNext = bind(gen.next);
    const boundThrow = bind(gen.throw);
    return new Promise((resolve, reject) => {
      function invoke(method, argument) {
        try {
          var result2 = method.call(gen, argument);
        } catch (error) {
          return reject(error);
        }
        const next = result2.done ? resolve : invokeNext;
        if (isPromiseLike(result2.value)) {
          result2.value.then(next, result2.done ? reject : invokeThrow);
        } else {
          next(result2.value);
        }
      }
      const invokeNext = (value) => invoke(boundNext, value);
      const invokeThrow = (error) => invoke(boundThrow, error);
      invokeNext();
    });
  };
}
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var import_dist451, import_dist452, import_dist453, bind, noContext;
var init_lib4 = __esm({
  "../node_modules/@wry/context/lib/index.js"() {
    import_dist451 = __toESM(require_dist());
    import_dist452 = __toESM(require_dist2());
    import_dist453 = __toESM(require_dist3());
    init_slot();
    ({ bind, noContext } = Slot);
  }
});

// ../node_modules/optimism/lib/context.js
function nonReactive(fn) {
  return parentEntrySlot.withValue(void 0, fn);
}
var import_dist454, import_dist455, import_dist456, parentEntrySlot;
var init_context = __esm({
  "../node_modules/optimism/lib/context.js"() {
    import_dist454 = __toESM(require_dist(), 1);
    import_dist455 = __toESM(require_dist2(), 1);
    import_dist456 = __toESM(require_dist3(), 1);
    init_lib4();
    init_lib4();
    parentEntrySlot = new Slot();
  }
});

// ../node_modules/optimism/lib/helpers.js
function maybeUnsubscribe(entryOrDep) {
  const { unsubscribe } = entryOrDep;
  if (typeof unsubscribe === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe();
  }
}
var import_dist457, import_dist458, import_dist459, hasOwnProperty4, arrayFromSet;
var init_helpers = __esm({
  "../node_modules/optimism/lib/helpers.js"() {
    import_dist457 = __toESM(require_dist(), 1);
    import_dist458 = __toESM(require_dist2(), 1);
    import_dist459 = __toESM(require_dist3(), 1);
    ({ hasOwnProperty: hasOwnProperty4 } = Object.prototype);
    arrayFromSet = Array.from || function(set) {
      const array = [];
      set.forEach((item) => array.push(item));
      return array;
    };
  }
});

// ../node_modules/optimism/lib/entry.js
function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a, b) {
  const len = a.length;
  return (
    // Unknown values are not equal to each other.
    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    len === b.length && // The underlying value or exception must be the same.
    a[len - 1] === b[len - 1]
  );
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
function rememberParent(child) {
  const parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  const { normalizeResult } = entry;
  let oldValueCopy;
  if (normalizeResult && entry.value.length === 1) {
    oldValueCopy = valueCopy(entry.value);
  }
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
    if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
      try {
        entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
      } catch (_a2) {
      }
    }
  } catch (e) {
    entry.value[1] = e;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  eachParent(child, reportDirtyChild);
}
function reportClean(child) {
  eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
  const parentCount = child.parents.size;
  if (parentCount) {
    const parents = arrayFromSet(child.parents);
    for (let i = 0; i < parentCount; ++i) {
      callback(parents[i], child);
    }
  }
}
function reportDirtyChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(mightBeDirty(child));
  const parentWasClean = !mightBeDirty(parent);
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  if (parentWasClean) {
    reportDirty(parent);
  }
}
function reportCleanChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(!mightBeDirty(child));
  const childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  const dc = parent.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      parent.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent) {
  if (parent.childValues.size > 0) {
    parent.childValues.forEach((_value, child) => {
      forgetChild(parent, child);
    });
  }
  parent.forgetDeps();
  assert(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
var import_dist460, import_dist461, import_dist462, emptySetPool, POOL_TARGET_SIZE, Entry;
var init_entry = __esm({
  "../node_modules/optimism/lib/entry.js"() {
    import_dist460 = __toESM(require_dist(), 1);
    import_dist461 = __toESM(require_dist2(), 1);
    import_dist462 = __toESM(require_dist3(), 1);
    init_context();
    init_helpers();
    emptySetPool = [];
    POOL_TARGET_SIZE = 100;
    Entry = class _Entry {
      constructor(fn) {
        this.fn = fn;
        this.parents = /* @__PURE__ */ new Set();
        this.childValues = /* @__PURE__ */ new Map();
        this.dirtyChildren = null;
        this.dirty = true;
        this.recomputing = false;
        this.value = [];
        this.deps = null;
        ++_Entry.count;
      }
      peek() {
        if (this.value.length === 1 && !mightBeDirty(this)) {
          rememberParent(this);
          return this.value[0];
        }
      }
      // This is the most important method of the Entry API, because it
      // determines whether the cached this.value can be returned immediately,
      // or must be recomputed. The overall performance of the caching system
      // depends on the truth of the following observations: (1) this.dirty is
      // usually false, (2) this.dirtyChildren is usually null/empty, and thus
      // (3) valueGet(this.value) is usually returned without recomputation.
      recompute(args) {
        assert(!this.recomputing, "already recomputing");
        rememberParent(this);
        return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
      }
      setDirty() {
        if (this.dirty)
          return;
        this.dirty = true;
        reportDirty(this);
        maybeUnsubscribe(this);
      }
      dispose() {
        this.setDirty();
        forgetChildren(this);
        eachParent(this, (parent, child) => {
          parent.setDirty();
          forgetChild(parent, this);
        });
      }
      forget() {
        this.dispose();
      }
      dependOn(dep2) {
        dep2.add(this);
        if (!this.deps) {
          this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
        }
        this.deps.add(dep2);
      }
      forgetDeps() {
        if (this.deps) {
          arrayFromSet(this.deps).forEach((dep2) => dep2.delete(this));
          this.deps.clear();
          emptySetPool.push(this.deps);
          this.deps = null;
        }
      }
    };
    Entry.count = 0;
  }
});

// ../node_modules/optimism/lib/dep.js
function dep(options) {
  const depsByKey = /* @__PURE__ */ new Map();
  const subscribe2 = options && options.subscribe;
  function depend(key) {
    const parent = parentEntrySlot.getValue();
    if (parent) {
      let dep2 = depsByKey.get(key);
      if (!dep2) {
        depsByKey.set(key, dep2 = /* @__PURE__ */ new Set());
      }
      parent.dependOn(dep2);
      if (typeof subscribe2 === "function") {
        maybeUnsubscribe(dep2);
        dep2.unsubscribe = subscribe2(key);
      }
    }
  }
  depend.dirty = function dirty(key, entryMethodName) {
    const dep2 = depsByKey.get(key);
    if (dep2) {
      const m = entryMethodName && hasOwnProperty4.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
      arrayFromSet(dep2).forEach((entry) => entry[m]());
      depsByKey.delete(key);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}
var import_dist463, import_dist464, import_dist465, EntryMethods;
var init_dep = __esm({
  "../node_modules/optimism/lib/dep.js"() {
    import_dist463 = __toESM(require_dist(), 1);
    import_dist464 = __toESM(require_dist2(), 1);
    import_dist465 = __toESM(require_dist3(), 1);
    init_context();
    init_helpers();
    EntryMethods = {
      setDirty: true,
      dispose: true,
      forget: true
      // Fully remove parent Entry from LRU cache and computation graph
    };
  }
});

// ../node_modules/optimism/lib/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  KeyTrie: () => Trie2,
  Slot: () => Slot,
  asyncFromGen: () => asyncFromGen,
  bindContext: () => bind,
  defaultMakeCacheKey: () => defaultMakeCacheKey,
  dep: () => dep,
  noContext: () => noContext,
  nonReactive: () => nonReactive,
  setTimeout: () => setTimeoutWithContext,
  wrap: () => wrap3
});
function defaultMakeCacheKey(...args) {
  const trie = defaultKeyTrie || (defaultKeyTrie = new Trie2(typeof WeakMap === "function"));
  return trie.lookupArray(args);
}
function wrap3(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe: subscribe2, cache: cacheOption = StrongCache } = /* @__PURE__ */ Object.create(null)) {
  const cache2 = typeof cacheOption === "function" ? new cacheOption(max, (entry) => entry.dispose()) : cacheOption;
  const optimistic = function() {
    const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    let entry = cache2.get(key);
    if (!entry) {
      cache2.set(key, entry = new Entry(originalFunction));
      entry.normalizeResult = normalizeResult;
      entry.subscribe = subscribe2;
      entry.forget = () => cache2.delete(key);
    }
    const value = entry.recompute(Array.prototype.slice.call(arguments));
    cache2.set(key, entry);
    caches.add(cache2);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach((cache3) => cache3.clean());
      caches.clear();
    }
    return value;
  };
  Object.defineProperty(optimistic, "size", {
    get: () => cache2.size,
    configurable: false,
    enumerable: false
  });
  Object.freeze(optimistic.options = {
    max,
    keyArgs,
    makeCacheKey,
    normalizeResult,
    subscribe: subscribe2,
    cache: cache2
  });
  function dirtyKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      entry.setDirty();
    }
  }
  optimistic.dirtyKey = dirtyKey;
  optimistic.dirty = function dirty() {
    dirtyKey(makeCacheKey.apply(null, arguments));
  };
  function peekKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      return entry.peek();
    }
  }
  optimistic.peekKey = peekKey;
  optimistic.peek = function peek() {
    return peekKey(makeCacheKey.apply(null, arguments));
  };
  function forgetKey(key) {
    return key ? cache2.delete(key) : false;
  }
  optimistic.forgetKey = forgetKey;
  optimistic.forget = function forget() {
    return forgetKey(makeCacheKey.apply(null, arguments));
  };
  optimistic.makeCacheKey = makeCacheKey;
  optimistic.getKey = keyArgs ? function getKey() {
    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
  } : makeCacheKey;
  return Object.freeze(optimistic);
}
var import_dist466, import_dist467, import_dist468, defaultKeyTrie, caches;
var init_lib5 = __esm({
  "../node_modules/optimism/lib/index.js"() {
    import_dist466 = __toESM(require_dist());
    import_dist467 = __toESM(require_dist2());
    import_dist468 = __toESM(require_dist3());
    init_lib3();
    init_lib2();
    init_entry();
    init_context();
    init_context();
    init_dep();
    caches = /* @__PURE__ */ new Set();
  }
});

// ../node_modules/@apollo/client/utilities/graphql/DocumentTransform.js
function identity(document) {
  return document;
}
var import_dist469, import_dist470, import_dist471, DocumentTransform;
var init_DocumentTransform = __esm({
  "../node_modules/@apollo/client/utilities/graphql/DocumentTransform.js"() {
    import_dist469 = __toESM(require_dist(), 1);
    import_dist470 = __toESM(require_dist2(), 1);
    import_dist471 = __toESM(require_dist3(), 1);
    init_lib();
    init_canUse();
    init_getFromAST();
    init_globals();
    init_lib2();
    init_lib5();
    init_caching();
    DocumentTransform = /** @class */
    function() {
      function DocumentTransform2(transform, options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        this.resultCache = canUseWeakSet ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
        this.transform = transform;
        if (options.getCacheKey) {
          this.getCacheKey = options.getCacheKey;
        }
        this.cached = options.cache !== false;
        this.resetCache();
      }
      DocumentTransform2.prototype.getCacheKey = function(document) {
        return [document];
      };
      DocumentTransform2.identity = function() {
        return new DocumentTransform2(identity, { cache: false });
      };
      DocumentTransform2.split = function(predicate, left, right) {
        if (right === void 0) {
          right = DocumentTransform2.identity();
        }
        return Object.assign(new DocumentTransform2(
          function(document) {
            var documentTransform = predicate(document) ? left : right;
            return documentTransform.transformDocument(document);
          },
          // Reasonably assume both `left` and `right` transforms handle their own caching
          { cache: false }
        ), { left, right });
      };
      DocumentTransform2.prototype.resetCache = function() {
        var _this = this;
        if (this.cached) {
          var stableCacheKeys_1 = new Trie(canUseWeakMap);
          this.performWork = wrap3(DocumentTransform2.prototype.performWork.bind(this), {
            makeCacheKey: function(document) {
              var cacheKeys = _this.getCacheKey(document);
              if (cacheKeys) {
                invariant2(Array.isArray(cacheKeys), 68);
                return stableCacheKeys_1.lookupArray(cacheKeys);
              }
            },
            max: cacheSizes["documentTransform.cache"],
            cache: WeakCache
          });
        }
      };
      DocumentTransform2.prototype.performWork = function(document) {
        checkDocument(document);
        return this.transform(document);
      };
      DocumentTransform2.prototype.transformDocument = function(document) {
        if (this.resultCache.has(document)) {
          return document;
        }
        var transformedDocument = this.performWork(document);
        this.resultCache.add(transformedDocument);
        return transformedDocument;
      };
      DocumentTransform2.prototype.concat = function(otherTransform) {
        var _this = this;
        return Object.assign(new DocumentTransform2(
          function(document) {
            return otherTransform.transformDocument(_this.transformDocument(document));
          },
          // Reasonably assume both transforms handle their own caching
          { cache: false }
        ), {
          left: this,
          right: otherTransform
        });
      };
      return DocumentTransform2;
    }();
  }
});

// ../node_modules/@apollo/client/utilities/graphql/print.js
var import_dist472, import_dist473, import_dist474, printCache, print2;
var init_print = __esm({
  "../node_modules/@apollo/client/utilities/graphql/print.js"() {
    import_dist472 = __toESM(require_dist(), 1);
    import_dist473 = __toESM(require_dist2(), 1);
    import_dist474 = __toESM(require_dist3(), 1);
    init_graphql2();
    init_caching();
    init_getMemoryInternals();
    print2 = Object.assign(function(ast) {
      var result2 = printCache.get(ast);
      if (!result2) {
        result2 = print(ast);
        printCache.set(ast, result2);
      }
      return result2;
    }, {
      reset: function() {
        printCache = new AutoCleanedWeakCache(
          cacheSizes.print || 2e3
          /* defaultCacheSizes.print */
        );
      }
    });
    print2.reset();
    if (globalThis.__DEV__ !== false) {
      registerGlobalCache("print", function() {
        return printCache ? printCache.size : 0;
      });
    }
  }
});

// ../node_modules/@apollo/client/utilities/common/arrays.js
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
var import_dist475, import_dist476, import_dist477, isArray;
var init_arrays = __esm({
  "../node_modules/@apollo/client/utilities/common/arrays.js"() {
    import_dist475 = __toESM(require_dist(), 1);
    import_dist476 = __toESM(require_dist2(), 1);
    import_dist477 = __toESM(require_dist3(), 1);
    isArray = Array.isArray;
  }
});

// ../node_modules/@apollo/client/utilities/graphql/transform.js
function isEmpty(op, fragmentMap) {
  return !op || op.selectionSet.selections.every(function(selection) {
    return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(configs) {
  var names = /* @__PURE__ */ new Map();
  var tests = /* @__PURE__ */ new Map();
  configs.forEach(function(directive) {
    if (directive) {
      if (directive.name) {
        names.set(directive.name, directive);
      } else if (directive.test) {
        tests.set(directive.test, directive);
      }
    }
  });
  return function(directive) {
    var config = names.get(directive.name.value);
    if (!config && tests.size) {
      tests.forEach(function(testConfig, test) {
        if (test(directive)) {
          config = testConfig;
        }
      });
    }
    return config;
  };
}
function makeInUseGetterFunction(defaultKey) {
  var map = /* @__PURE__ */ new Map();
  return function inUseGetterFunction(key) {
    if (key === void 0) {
      key = defaultKey;
    }
    var inUse = map.get(key);
    if (!inUse) {
      map.set(key, inUse = {
        // Variable and fragment spread names used directly within this
        // operation or fragment definition, as identified by key. These sets
        // will be populated during the first traversal of the document in
        // removeDirectivesFromDocument below.
        variables: /* @__PURE__ */ new Set(),
        fragmentSpreads: /* @__PURE__ */ new Set()
      });
    }
    return inUse;
  };
}
function removeDirectivesFromDocument(directives, doc) {
  checkDocument(doc);
  var getInUseByOperationName = makeInUseGetterFunction("");
  var getInUseByFragmentName = makeInUseGetterFunction("");
  var getInUse = function(ancestors) {
    for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
      if (isArray(ancestor))
        continue;
      if (ancestor.kind === Kind.OPERATION_DEFINITION) {
        return getInUseByOperationName(ancestor.name && ancestor.name.value);
      }
      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {
        return getInUseByFragmentName(ancestor.name.value);
      }
    }
    globalThis.__DEV__ !== false && invariant2.error(85);
    return null;
  };
  var operationCount = 0;
  for (var i = doc.definitions.length - 1; i >= 0; --i) {
    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {
      ++operationCount;
    }
  }
  var directiveMatcher = getDirectiveMatcher(directives);
  var shouldRemoveField = function(nodeDirectives) {
    return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
      return config && config.remove;
    });
  };
  var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
  var firstVisitMadeChanges = false;
  var fieldOrInlineFragmentVisitor = {
    enter: function(node) {
      if (shouldRemoveField(node.directives)) {
        firstVisitMadeChanges = true;
        return null;
      }
    }
  };
  var docWithoutDirectiveSubtrees = visit(doc, {
    // These two AST node types share the same implementation, defined above.
    Field: fieldOrInlineFragmentVisitor,
    InlineFragment: fieldOrInlineFragmentVisitor,
    VariableDefinition: {
      enter: function() {
        return false;
      }
    },
    Variable: {
      enter: function(node, _key, _parent, _path, ancestors) {
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.variables.add(node.name.value);
        }
      }
    },
    FragmentSpread: {
      enter: function(node, _key, _parent, _path, ancestors) {
        if (shouldRemoveField(node.directives)) {
          firstVisitMadeChanges = true;
          return null;
        }
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.fragmentSpreads.add(node.name.value);
        }
      }
    },
    FragmentDefinition: {
      enter: function(node, _key, _parent, path) {
        originalFragmentDefsByPath.set(JSON.stringify(path), node);
      },
      leave: function(node, _key, _parent, path) {
        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
        if (node === originalNode) {
          return node;
        }
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          operationCount > 0 && node.selectionSet.selections.every(function(selection) {
            return selection.kind === Kind.FIELD && selection.name.value === "__typename";
          })
        ) {
          getInUseByFragmentName(node.name.value).removed = true;
          firstVisitMadeChanges = true;
          return null;
        }
      }
    },
    Directive: {
      leave: function(node) {
        if (directiveMatcher(node)) {
          firstVisitMadeChanges = true;
          return null;
        }
      }
    }
  });
  if (!firstVisitMadeChanges) {
    return doc;
  }
  var populateTransitiveVars = function(inUse) {
    if (!inUse.transitiveVars) {
      inUse.transitiveVars = new Set(inUse.variables);
      if (!inUse.removed) {
        inUse.fragmentSpreads.forEach(function(childFragmentName) {
          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
            inUse.transitiveVars.add(varName);
          });
        });
      }
    }
    return inUse;
  };
  var allFragmentNamesUsed = /* @__PURE__ */ new Set();
  docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
    if (def.kind === Kind.OPERATION_DEFINITION) {
      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
        allFragmentNamesUsed.add(childFragmentName);
      });
    } else if (def.kind === Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
      allFragmentNamesUsed.add(def.name.value);
    }
  });
  allFragmentNamesUsed.forEach(function(fragmentName) {
    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
      allFragmentNamesUsed.add(childFragmentName);
    });
  });
  var fragmentWillBeRemoved = function(fragmentName) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
  };
  var enterVisitor = {
    enter: function(node) {
      if (fragmentWillBeRemoved(node.name.value)) {
        return null;
      }
    }
  };
  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: enterVisitor,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: enterVisitor,
    OperationDefinition: {
      leave: function(node) {
        if (node.variableDefinitions) {
          var usedVariableNames_1 = populateTransitiveVars(
            // If an operation is anonymous, we use the empty string as its key.
            getInUseByOperationName(node.name && node.name.value)
          ).transitiveVars;
          if (usedVariableNames_1.size < node.variableDefinitions.length) {
            return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
              return usedVariableNames_1.has(varDef.variable.name.value);
            }) });
          }
        }
      }
    }
  }));
}
function buildQueryFromSelectionSet(document) {
  var definition = getMainDefinition(document);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document;
  }
  var modifiedDoc = visit(document, {
    OperationDefinition: {
      enter: function(node) {
        return __assign(__assign({}, node), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document) {
  checkDocument(document);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document);
  return modifiedDoc;
}
var import_dist478, import_dist479, import_dist480, TYPENAME_FIELD, addTypenameToDocument;
var init_transform = __esm({
  "../node_modules/@apollo/client/utilities/graphql/transform.js"() {
    import_dist478 = __toESM(require_dist(), 1);
    import_dist479 = __toESM(require_dist2(), 1);
    import_dist480 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_graphql2();
    init_getFromAST();
    init_storeUtils();
    init_fragments();
    init_arrays();
    TYPENAME_FIELD = {
      kind: Kind.FIELD,
      name: {
        kind: Kind.NAME,
        value: "__typename"
      }
    };
    addTypenameToDocument = Object.assign(function(doc) {
      return visit(doc, {
        SelectionSet: {
          enter: function(node, _key, parent) {
            if (parent && parent.kind === Kind.OPERATION_DEFINITION) {
              return;
            }
            var selections = node.selections;
            if (!selections) {
              return;
            }
            var skip = selections.some(function(selection) {
              return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
            });
            if (skip) {
              return;
            }
            var field = parent;
            if (isField(field) && field.directives && field.directives.some(function(d) {
              return d.name.value === "export";
            })) {
              return;
            }
            return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
          }
        }
      });
    }, {
      added: function(field) {
        return field === TYPENAME_FIELD;
      }
    });
  }
});

// ../node_modules/@apollo/client/utilities/graphql/operations.js
var import_dist481, import_dist482, import_dist483;
var init_operations = __esm({
  "../node_modules/@apollo/client/utilities/graphql/operations.js"() {
    import_dist481 = __toESM(require_dist(), 1);
    import_dist482 = __toESM(require_dist2(), 1);
    import_dist483 = __toESM(require_dist3(), 1);
    init_getFromAST();
  }
});

// ../node_modules/@apollo/client/utilities/common/mergeDeep.js
function mergeDeep() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count = sources.length;
  if (count > 1) {
    var merger = new DeepMerger();
    for (var i = 1; i < count; ++i) {
      target = merger.merge(target, sources[i]);
    }
  }
  return target;
}
var import_dist484, import_dist485, import_dist486, hasOwnProperty5, defaultReconciler, DeepMerger;
var init_mergeDeep = __esm({
  "../node_modules/@apollo/client/utilities/common/mergeDeep.js"() {
    import_dist484 = __toESM(require_dist(), 1);
    import_dist485 = __toESM(require_dist2(), 1);
    import_dist486 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_objects();
    hasOwnProperty5 = Object.prototype.hasOwnProperty;
    defaultReconciler = function(target, source, property) {
      return this.merge(target[property], source[property]);
    };
    DeepMerger = /** @class */
    function() {
      function DeepMerger2(reconciler) {
        if (reconciler === void 0) {
          reconciler = defaultReconciler;
        }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject;
        this.pastCopies = /* @__PURE__ */ new Set();
      }
      DeepMerger2.prototype.merge = function(target, source) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject(source) && isNonNullObject(target)) {
          Object.keys(source).forEach(function(sourceKey) {
            if (hasOwnProperty5.call(target, sourceKey)) {
              var targetValue = target[sourceKey];
              if (source[sourceKey] !== targetValue) {
                var result2 = _this.reconciler.apply(_this, __spreadArray([
                  target,
                  source,
                  sourceKey
                ], context, false));
                if (result2 !== targetValue) {
                  target = _this.shallowCopyForMerge(target);
                  target[sourceKey] = result2;
                }
              }
            } else {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = source[sourceKey];
            }
          });
          return target;
        }
        return source;
      };
      DeepMerger2.prototype.shallowCopyForMerge = function(value) {
        if (isNonNullObject(value)) {
          if (!this.pastCopies.has(value)) {
            if (Array.isArray(value)) {
              value = value.slice(0);
            } else {
              value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);
            }
            this.pastCopies.add(value);
          }
        }
        return value;
      };
      return DeepMerger2;
    }();
  }
});

// ../node_modules/@apollo/client/utilities/policies/pagination.js
var import_dist487, import_dist488, import_dist489;
var init_pagination = __esm({
  "../node_modules/@apollo/client/utilities/policies/pagination.js"() {
    import_dist487 = __toESM(require_dist(), 1);
    import_dist488 = __toESM(require_dist2(), 1);
    import_dist489 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_tslib_es6();
    init_mergeDeep();
  }
});

// ../node_modules/zen-observable-ts/module.js
var module_exports = {};
__export(module_exports, {
  Observable: () => Observable
});
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function getMethod(obj, key) {
  var value = obj[key];
  if (value == null) return void 0;
  if (typeof value !== "function") throw new TypeError(value + " is not a function");
  return value;
}
function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x) {
  return x instanceof Observable;
}
function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function() {
      throw e;
    });
  }
}
function enqueue(fn) {
  Promise.resolve().then(function() {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}
function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === void 0) return;
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, "unsubscribe");
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === "closed") break;
  }
}
function notifySubscription(subscription, type, value) {
  subscription._state = "running";
  var observer = subscription._observer;
  try {
    var m = getMethod(observer, type);
    switch (type) {
      case "next":
        if (m) m.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m) m.call(observer, value);
        else throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }
  if (subscription._state === "closed") cleanupSubscription(subscription);
  else if (subscription._state === "running") subscription._state = "ready";
}
function onNotify(subscription, type, value) {
  if (subscription._state === "closed") return;
  if (subscription._state === "buffering") {
    subscription._queue.push({
      type,
      value
    });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{
      type,
      value
    }];
    enqueue(function() {
      return flushSubscription(subscription);
    });
    return;
  }
  notifySubscription(subscription, type, value);
}
var import_dist490, import_dist491, import_dist492, hasSymbols, hasSymbol, getSymbol, SymbolIterator, SymbolObservable, SymbolSpecies, Subscription, SubscriptionObserver, Observable;
var init_module = __esm({
  "../node_modules/zen-observable-ts/module.js"() {
    import_dist490 = __toESM(require_dist());
    import_dist491 = __toESM(require_dist2());
    import_dist492 = __toESM(require_dist3());
    hasSymbols = function() {
      return typeof Symbol === "function";
    };
    hasSymbol = function(name) {
      return hasSymbols() && Boolean(Symbol[name]);
    };
    getSymbol = function(name) {
      return hasSymbol(name) ? Symbol[name] : "@@" + name;
    };
    if (hasSymbols() && !hasSymbol("observable")) {
      Symbol.observable = Symbol("observable");
    }
    SymbolIterator = getSymbol("iterator");
    SymbolObservable = getSymbol("observable");
    SymbolSpecies = getSymbol("species");
    Subscription = function() {
      function Subscription2(observer, subscriber) {
        this._cleanup = void 0;
        this._observer = observer;
        this._queue = void 0;
        this._state = "initializing";
        var subscriptionObserver = new SubscriptionObserver(this);
        try {
          this._cleanup = subscriber.call(void 0, subscriptionObserver);
        } catch (e) {
          subscriptionObserver.error(e);
        }
        if (this._state === "initializing") this._state = "ready";
      }
      var _proto = Subscription2.prototype;
      _proto.unsubscribe = function unsubscribe() {
        if (this._state !== "closed") {
          closeSubscription(this);
          cleanupSubscription(this);
        }
      };
      _createClass(Subscription2, [{
        key: "closed",
        get: function() {
          return this._state === "closed";
        }
      }]);
      return Subscription2;
    }();
    SubscriptionObserver = function() {
      function SubscriptionObserver2(subscription) {
        this._subscription = subscription;
      }
      var _proto2 = SubscriptionObserver2.prototype;
      _proto2.next = function next(value) {
        onNotify(this._subscription, "next", value);
      };
      _proto2.error = function error(value) {
        onNotify(this._subscription, "error", value);
      };
      _proto2.complete = function complete() {
        onNotify(this._subscription, "complete");
      };
      _createClass(SubscriptionObserver2, [{
        key: "closed",
        get: function() {
          return this._subscription._state === "closed";
        }
      }]);
      return SubscriptionObserver2;
    }();
    Observable = function() {
      function Observable2(subscriber) {
        if (!(this instanceof Observable2)) throw new TypeError("Observable cannot be called as a function");
        if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");
        this._subscriber = subscriber;
      }
      var _proto3 = Observable2.prototype;
      _proto3.subscribe = function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          observer = {
            next: observer,
            error: arguments[1],
            complete: arguments[2]
          };
        }
        return new Subscription(observer, this._subscriber);
      };
      _proto3.forEach = function forEach3(fn) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          if (typeof fn !== "function") {
            reject(new TypeError(fn + " is not a function"));
            return;
          }
          function done() {
            subscription.unsubscribe();
            resolve();
          }
          var subscription = _this.subscribe({
            next: function(value) {
              try {
                fn(value, done);
              } catch (e) {
                reject(e);
                subscription.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
        });
      };
      _proto3.map = function map(fn) {
        var _this2 = this;
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        var C = getSpecies(this);
        return new C(function(observer) {
          return _this2.subscribe({
            next: function(value) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
              observer.next(value);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              observer.complete();
            }
          });
        });
      };
      _proto3.filter = function filter(fn) {
        var _this3 = this;
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        var C = getSpecies(this);
        return new C(function(observer) {
          return _this3.subscribe({
            next: function(value) {
              try {
                if (!fn(value)) return;
              } catch (e) {
                return observer.error(e);
              }
              observer.next(value);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              observer.complete();
            }
          });
        });
      };
      _proto3.reduce = function reduce(fn) {
        var _this4 = this;
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        var C = getSpecies(this);
        var hasSeed = arguments.length > 1;
        var hasValue = false;
        var seed = arguments[1];
        var acc = seed;
        return new C(function(observer) {
          return _this4.subscribe({
            next: function(value) {
              var first = !hasValue;
              hasValue = true;
              if (!first || hasSeed) {
                try {
                  acc = fn(acc, value);
                } catch (e) {
                  return observer.error(e);
                }
              } else {
                acc = value;
              }
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              if (!hasValue && !hasSeed) return observer.error(new TypeError("Cannot reduce an empty sequence"));
              observer.next(acc);
              observer.complete();
            }
          });
        });
      };
      _proto3.concat = function concat2() {
        var _this5 = this;
        for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
          sources[_key] = arguments[_key];
        }
        var C = getSpecies(this);
        return new C(function(observer) {
          var subscription;
          var index = 0;
          function startNext(next) {
            subscription = next.subscribe({
              next: function(v) {
                observer.next(v);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                if (index === sources.length) {
                  subscription = void 0;
                  observer.complete();
                } else {
                  startNext(C.from(sources[index++]));
                }
              }
            });
          }
          startNext(_this5);
          return function() {
            if (subscription) {
              subscription.unsubscribe();
              subscription = void 0;
            }
          };
        });
      };
      _proto3.flatMap = function flatMap(fn) {
        var _this6 = this;
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        var C = getSpecies(this);
        return new C(function(observer) {
          var subscriptions = [];
          var outer = _this6.subscribe({
            next: function(value) {
              if (fn) {
                try {
                  value = fn(value);
                } catch (e) {
                  return observer.error(e);
                }
              }
              var inner = C.from(value).subscribe({
                next: function(value2) {
                  observer.next(value2);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  var i = subscriptions.indexOf(inner);
                  if (i >= 0) subscriptions.splice(i, 1);
                  completeIfDone();
                }
              });
              subscriptions.push(inner);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              completeIfDone();
            }
          });
          function completeIfDone() {
            if (outer.closed && subscriptions.length === 0) observer.complete();
          }
          return function() {
            subscriptions.forEach(function(s) {
              return s.unsubscribe();
            });
            outer.unsubscribe();
          };
        });
      };
      _proto3[SymbolObservable] = function() {
        return this;
      };
      Observable2.from = function from2(x) {
        var C = typeof this === "function" ? this : Observable2;
        if (x == null) throw new TypeError(x + " is not an object");
        var method = getMethod(x, SymbolObservable);
        if (method) {
          var observable = method.call(x);
          if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
          if (isObservable(observable) && observable.constructor === C) return observable;
          return new C(function(observer) {
            return observable.subscribe(observer);
          });
        }
        if (hasSymbol("iterator")) {
          method = getMethod(x, SymbolIterator);
          if (method) {
            return new C(function(observer) {
              enqueue(function() {
                if (observer.closed) return;
                for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done; ) {
                  var item = _step.value;
                  observer.next(item);
                  if (observer.closed) return;
                }
                observer.complete();
              });
            });
          }
        }
        if (Array.isArray(x)) {
          return new C(function(observer) {
            enqueue(function() {
              if (observer.closed) return;
              for (var i = 0; i < x.length; ++i) {
                observer.next(x[i]);
                if (observer.closed) return;
              }
              observer.complete();
            });
          });
        }
        throw new TypeError(x + " is not observable");
      };
      Observable2.of = function of() {
        for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          items[_key2] = arguments[_key2];
        }
        var C = typeof this === "function" ? this : Observable2;
        return new C(function(observer) {
          enqueue(function() {
            if (observer.closed) return;
            for (var i = 0; i < items.length; ++i) {
              observer.next(items[i]);
              if (observer.closed) return;
            }
            observer.complete();
          });
        });
      };
      _createClass(Observable2, null, [{
        key: SymbolSpecies,
        get: function() {
          return this;
        }
      }]);
      return Observable2;
    }();
    if (hasSymbols()) {
      Object.defineProperty(Observable, Symbol("extensions"), {
        value: {
          symbol: SymbolObservable,
          hostReportError
        },
        configurable: true
      });
    }
  }
});

// ../node_modules/symbol-observable/es/ponyfill.js
function symbolObservablePonyfill(root2) {
  var result2;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result2 = Symbol2.observable;
    } else {
      if (typeof Symbol2.for === "function") {
        result2 = Symbol2.for("https://github.com/benlesh/symbol-observable");
      } else {
        result2 = Symbol2("https://github.com/benlesh/symbol-observable");
      }
      try {
        Symbol2.observable = result2;
      } catch (err) {
      }
    }
  } else {
    result2 = "@@observable";
  }
  return result2;
}
var import_dist493, import_dist494, import_dist495;
var init_ponyfill = __esm({
  "../node_modules/symbol-observable/es/ponyfill.js"() {
    import_dist493 = __toESM(require_dist());
    import_dist494 = __toESM(require_dist2());
    import_dist495 = __toESM(require_dist3());
  }
});

// ../node_modules/symbol-observable/es/index.js
var es_exports = {};
__export(es_exports, {
  default: () => es_default
});
var import_dist496, import_dist497, import_dist498, root, result, es_default;
var init_es = __esm({
  "../node_modules/symbol-observable/es/index.js"() {
    import_dist496 = __toESM(require_dist());
    import_dist497 = __toESM(require_dist2());
    import_dist498 = __toESM(require_dist3());
    init_ponyfill();
    if (typeof self !== "undefined") {
      root = self;
    } else if (typeof window !== "undefined") {
      root = window;
    } else if (typeof global !== "undefined") {
      root = global;
    } else if (typeof module !== "undefined") {
      root = module;
    } else {
      root = Function("return this")();
    }
    result = symbolObservablePonyfill(root);
    es_default = result;
  }
});

// ../node_modules/@apollo/client/utilities/observables/Observable.js
var import_dist499, import_dist500, import_dist501, prototype, fakeObsSymbol;
var init_Observable = __esm({
  "../node_modules/@apollo/client/utilities/observables/Observable.js"() {
    import_dist499 = __toESM(require_dist(), 1);
    import_dist500 = __toESM(require_dist2(), 1);
    import_dist501 = __toESM(require_dist3(), 1);
    init_module();
    init_es();
    prototype = Observable.prototype;
    fakeObsSymbol = "@@observable";
    if (!prototype[fakeObsSymbol]) {
      prototype[fakeObsSymbol] = function() {
        return this;
      };
    }
  }
});

// ../node_modules/@apollo/client/utilities/promises/decoration.js
function createFulfilledPromise(value) {
  var promise = Promise.resolve(value);
  promise.status = "fulfilled";
  promise.value = value;
  return promise;
}
function createRejectedPromise(reason) {
  var promise = Promise.reject(reason);
  promise.catch(function() {
  });
  promise.status = "rejected";
  promise.reason = reason;
  return promise;
}
function isStatefulPromise(promise) {
  return "status" in promise;
}
function wrapPromiseWithState(promise) {
  if (isStatefulPromise(promise)) {
    return promise;
  }
  var pendingPromise = promise;
  pendingPromise.status = "pending";
  pendingPromise.then(function(value) {
    if (pendingPromise.status === "pending") {
      var fulfilledPromise = pendingPromise;
      fulfilledPromise.status = "fulfilled";
      fulfilledPromise.value = value;
    }
  }, function(reason) {
    if (pendingPromise.status === "pending") {
      var rejectedPromise = pendingPromise;
      rejectedPromise.status = "rejected";
      rejectedPromise.reason = reason;
    }
  });
  return promise;
}
var import_dist502, import_dist503, import_dist504;
var init_decoration = __esm({
  "../node_modules/@apollo/client/utilities/promises/decoration.js"() {
    import_dist502 = __toESM(require_dist(), 1);
    import_dist503 = __toESM(require_dist2(), 1);
    import_dist504 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/utilities/common/cloneDeep.js
function cloneDeep(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen) {
  switch (toString.call(val)) {
    case "[object Array]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_1 = val.slice(0);
      seen.set(val, copy_1);
      copy_1.forEach(function(child, i) {
        copy_1[i] = cloneDeepHelper(child, seen);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper(val[key], seen);
      });
      return copy_2;
    }
    default:
      return val;
  }
}
var import_dist505, import_dist506, import_dist507, toString;
var init_cloneDeep = __esm({
  "../node_modules/@apollo/client/utilities/common/cloneDeep.js"() {
    import_dist505 = __toESM(require_dist(), 1);
    import_dist506 = __toESM(require_dist2(), 1);
    import_dist507 = __toESM(require_dist3(), 1);
    toString = Object.prototype.toString;
  }
});

// ../node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js
function deepFreeze(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        if (isNonNullObject(obj[name]))
          workSet.add(obj[name]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e) {
      if (e instanceof TypeError)
        return null;
      throw e;
    }
  }
  return obj;
}
function maybeDeepFreeze(obj) {
  if (globalThis.__DEV__ !== false) {
    deepFreeze(obj);
  }
  return obj;
}
var import_dist508, import_dist509, import_dist510;
var init_maybeDeepFreeze = __esm({
  "../node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js"() {
    import_dist508 = __toESM(require_dist(), 1);
    import_dist509 = __toESM(require_dist2(), 1);
    import_dist510 = __toESM(require_dist3(), 1);
    init_objects();
  }
});

// ../node_modules/@apollo/client/utilities/observables/iteration.js
function iterateObserversSafely(observers, method, argument) {
  var observersWithMethod = [];
  observers.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}
var import_dist511, import_dist512, import_dist513;
var init_iteration = __esm({
  "../node_modules/@apollo/client/utilities/observables/iteration.js"() {
    import_dist511 = __toESM(require_dist(), 1);
    import_dist512 = __toESM(require_dist2(), 1);
    import_dist513 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/utilities/observables/asyncMap.js
function asyncMap(observable, mapFn, catchFn) {
  return new Observable(function(observer) {
    var promiseQueue = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(callback) {
        return new Promise(function(resolve) {
          return resolve(callback());
        });
      }
    };
    function makeCallback(examiner, key) {
      return function(arg) {
        if (examiner) {
          var both = function() {
            return observer.closed ? (
              /* will be swallowed */
              0
            ) : examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result2) {
            return observer.next(result2);
          }, function(error) {
            return observer.error(error);
          });
        } else {
          observer[key](arg);
        }
      };
    }
    var handler = {
      next: makeCallback(mapFn, "next"),
      error: makeCallback(catchFn, "error"),
      complete: function() {
        promiseQueue.then(function() {
          return observer.complete();
        });
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}
var import_dist514, import_dist515, import_dist516;
var init_asyncMap = __esm({
  "../node_modules/@apollo/client/utilities/observables/asyncMap.js"() {
    import_dist514 = __toESM(require_dist(), 1);
    import_dist515 = __toESM(require_dist2(), 1);
    import_dist516 = __toESM(require_dist3(), 1);
    init_Observable();
  }
});

// ../node_modules/@apollo/client/utilities/observables/subclassing.js
function fixObservableSubclass(subclass) {
  function set(key) {
    Object.defineProperty(subclass, key, { value: Observable });
  }
  if (canUseSymbol && Symbol.species) {
    set(Symbol.species);
  }
  set("@@species");
  return subclass;
}
var import_dist517, import_dist518, import_dist519;
var init_subclassing = __esm({
  "../node_modules/@apollo/client/utilities/observables/subclassing.js"() {
    import_dist517 = __toESM(require_dist(), 1);
    import_dist518 = __toESM(require_dist2(), 1);
    import_dist519 = __toESM(require_dist3(), 1);
    init_Observable();
    init_canUse();
  }
});

// ../node_modules/@apollo/client/utilities/observables/Concast.js
function isPromiseLike2(value) {
  return value && typeof value.then === "function";
}
var import_dist520, import_dist521, import_dist522, Concast;
var init_Concast = __esm({
  "../node_modules/@apollo/client/utilities/observables/Concast.js"() {
    import_dist520 = __toESM(require_dist(), 1);
    import_dist521 = __toESM(require_dist2(), 1);
    import_dist522 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_Observable();
    init_iteration();
    init_subclassing();
    Concast = /** @class */
    function(_super) {
      __extends(Concast2, _super);
      function Concast2(sources) {
        var _this = _super.call(this, function(observer) {
          _this.addObserver(observer);
          return function() {
            return _this.removeObserver(observer);
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.promise = new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        });
        _this.handlers = {
          next: function(result2) {
            if (_this.sub !== null) {
              _this.latest = ["next", result2];
              _this.notify("next", result2);
              iterateObserversSafely(_this.observers, "next", result2);
            }
          },
          error: function(error) {
            var sub = _this.sub;
            if (sub !== null) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              _this.latest = ["error", error];
              _this.reject(error);
              _this.notify("error", error);
              iterateObserversSafely(_this.observers, "error", error);
            }
          },
          complete: function() {
            var _a2 = _this, sub = _a2.sub, _b = _a2.sources, sources2 = _b === void 0 ? [] : _b;
            if (sub !== null) {
              var value = sources2.shift();
              if (!value) {
                if (sub)
                  setTimeout(function() {
                    return sub.unsubscribe();
                  });
                _this.sub = null;
                if (_this.latest && _this.latest[0] === "next") {
                  _this.resolve(_this.latest[1]);
                } else {
                  _this.resolve();
                }
                _this.notify("complete");
                iterateObserversSafely(_this.observers, "complete");
              } else if (isPromiseLike2(value)) {
                value.then(function(obs) {
                  return _this.sub = obs.subscribe(_this.handlers);
                }, _this.handlers.error);
              } else {
                _this.sub = value.subscribe(_this.handlers);
              }
            }
          }
        };
        _this.nextResultListeners = /* @__PURE__ */ new Set();
        _this.cancel = function(reason) {
          _this.reject(reason);
          _this.sources = [];
          _this.handlers.complete();
        };
        _this.promise.catch(function(_) {
        });
        if (typeof sources === "function") {
          sources = [new Observable(sources)];
        }
        if (isPromiseLike2(sources)) {
          sources.then(function(iterable) {
            return _this.start(iterable);
          }, _this.handlers.error);
        } else {
          _this.start(sources);
        }
        return _this;
      }
      Concast2.prototype.start = function(sources) {
        if (this.sub !== void 0)
          return;
        this.sources = Array.from(sources);
        this.handlers.complete();
      };
      Concast2.prototype.deliverLastMessage = function(observer) {
        if (this.latest) {
          var nextOrError = this.latest[0];
          var method = observer[nextOrError];
          if (method) {
            method.call(observer, this.latest[1]);
          }
          if (this.sub === null && nextOrError === "next" && observer.complete) {
            observer.complete();
          }
        }
      };
      Concast2.prototype.addObserver = function(observer) {
        if (!this.observers.has(observer)) {
          this.deliverLastMessage(observer);
          this.observers.add(observer);
        }
      };
      Concast2.prototype.removeObserver = function(observer) {
        if (this.observers.delete(observer) && this.observers.size < 1) {
          this.handlers.complete();
        }
      };
      Concast2.prototype.notify = function(method, arg) {
        var nextResultListeners = this.nextResultListeners;
        if (nextResultListeners.size) {
          this.nextResultListeners = /* @__PURE__ */ new Set();
          nextResultListeners.forEach(function(listener) {
            return listener(method, arg);
          });
        }
      };
      Concast2.prototype.beforeNext = function(callback) {
        var called = false;
        this.nextResultListeners.add(function(method, arg) {
          if (!called) {
            called = true;
            callback(method, arg);
          }
        });
      };
      return Concast2;
    }(Observable);
    fixObservableSubclass(Concast);
  }
});

// ../node_modules/@apollo/client/utilities/common/incrementalResult.js
function isExecutionPatchIncrementalResult(value) {
  return "incremental" in value;
}
function isExecutionPatchInitialResult(value) {
  return "hasNext" in value && "data" in value;
}
function isExecutionPatchResult(value) {
  return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);
}
function isApolloPayloadResult(value) {
  return isNonNullObject(value) && "payload" in value;
}
function mergeIncrementalData(prevResult, result2) {
  var mergedData = prevResult;
  var merger = new DeepMerger();
  if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
    result2.incremental.forEach(function(_a2) {
      var data = _a2.data, path = _a2.path;
      for (var i = path.length - 1; i >= 0; --i) {
        var key = path[i];
        var isNumericKey = !isNaN(+key);
        var parent_1 = isNumericKey ? [] : {};
        parent_1[key] = data;
        data = parent_1;
      }
      mergedData = merger.merge(mergedData, data);
    });
  }
  return mergedData;
}
var import_dist523, import_dist524, import_dist525;
var init_incrementalResult = __esm({
  "../node_modules/@apollo/client/utilities/common/incrementalResult.js"() {
    import_dist523 = __toESM(require_dist(), 1);
    import_dist524 = __toESM(require_dist2(), 1);
    import_dist525 = __toESM(require_dist3(), 1);
    init_objects();
    init_arrays();
    init_mergeDeep();
  }
});

// ../node_modules/@apollo/client/utilities/common/errorHandling.js
function graphQLResultHasError(result2) {
  var errors = getGraphQLErrorsFromResult(result2);
  return isNonEmptyArray(errors);
}
function getGraphQLErrorsFromResult(result2) {
  var graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
  if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
    result2.incremental.forEach(function(incrementalResult) {
      if (incrementalResult.errors) {
        graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
      }
    });
  }
  return graphQLErrors;
}
var import_dist526, import_dist527, import_dist528;
var init_errorHandling = __esm({
  "../node_modules/@apollo/client/utilities/common/errorHandling.js"() {
    import_dist526 = __toESM(require_dist(), 1);
    import_dist527 = __toESM(require_dist2(), 1);
    import_dist528 = __toESM(require_dist3(), 1);
    init_arrays();
    init_incrementalResult();
  }
});

// ../node_modules/@apollo/client/utilities/common/compact.js
function compact() {
  var objects = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    objects[_i] = arguments[_i];
  }
  var result2 = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result2[key] = value;
      }
    });
  });
  return result2;
}
var import_dist529, import_dist530, import_dist531;
var init_compact = __esm({
  "../node_modules/@apollo/client/utilities/common/compact.js"() {
    import_dist529 = __toESM(require_dist(), 1);
    import_dist530 = __toESM(require_dist2(), 1);
    import_dist531 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/utilities/common/mergeOptions.js
function mergeOptions(defaults, options) {
  return compact(defaults, options, options.variables && {
    variables: compact(__assign(__assign({}, defaults && defaults.variables), options.variables))
  });
}
var import_dist532, import_dist533, import_dist534;
var init_mergeOptions = __esm({
  "../node_modules/@apollo/client/utilities/common/mergeOptions.js"() {
    import_dist532 = __toESM(require_dist(), 1);
    import_dist533 = __toESM(require_dist2(), 1);
    import_dist534 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_compact();
  }
});

// ../node_modules/@apollo/client/utilities/common/omitDeep.js
var import_dist535, import_dist536, import_dist537;
var init_omitDeep = __esm({
  "../node_modules/@apollo/client/utilities/common/omitDeep.js"() {
    import_dist535 = __toESM(require_dist(), 1);
    import_dist536 = __toESM(require_dist2(), 1);
    import_dist537 = __toESM(require_dist3(), 1);
    init_objects();
  }
});

// ../node_modules/@apollo/client/utilities/common/stripTypename.js
var import_dist538, import_dist539, import_dist540;
var init_stripTypename = __esm({
  "../node_modules/@apollo/client/utilities/common/stripTypename.js"() {
    import_dist538 = __toESM(require_dist(), 1);
    import_dist539 = __toESM(require_dist2(), 1);
    import_dist540 = __toESM(require_dist3(), 1);
    init_omitDeep();
  }
});

// ../node_modules/@apollo/client/utilities/types/IsStrictlyAny.js
var import_dist541, import_dist542, import_dist543;
var init_IsStrictlyAny = __esm({
  "../node_modules/@apollo/client/utilities/types/IsStrictlyAny.js"() {
    import_dist541 = __toESM(require_dist(), 1);
    import_dist542 = __toESM(require_dist2(), 1);
    import_dist543 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/utilities/index.js
var import_dist544, import_dist545, import_dist546;
var init_utilities2 = __esm({
  "../node_modules/@apollo/client/utilities/index.js"() {
    import_dist544 = __toESM(require_dist(), 1);
    import_dist545 = __toESM(require_dist2(), 1);
    import_dist546 = __toESM(require_dist3(), 1);
    init_globals();
    init_directives2();
    init_DocumentTransform();
    init_fragments();
    init_getFromAST();
    init_print();
    init_storeUtils();
    init_transform();
    init_operations();
    init_pagination();
    init_Observable();
    init_decoration();
    init_mergeDeep();
    init_cloneDeep();
    init_maybeDeepFreeze();
    init_iteration();
    init_asyncMap();
    init_Concast();
    init_subclassing();
    init_arrays();
    init_objects();
    init_errorHandling();
    init_canUse();
    init_compact();
    init_makeUniqueId();
    init_stringifyForDisplay();
    init_mergeOptions();
    init_incrementalResult();
    init_canonicalStringify();
    init_omitDeep();
    init_stripTypename();
    init_IsStrictlyAny();
    init_caching();
  }
});

// ../node_modules/@apollo/client/link/utils/fromError.js
function fromError(errorValue) {
  return new Observable(function(observer) {
    observer.error(errorValue);
  });
}
var import_dist547, import_dist548, import_dist549;
var init_fromError = __esm({
  "../node_modules/@apollo/client/link/utils/fromError.js"() {
    import_dist547 = __toESM(require_dist(), 1);
    import_dist548 = __toESM(require_dist2(), 1);
    import_dist549 = __toESM(require_dist3(), 1);
    init_utilities2();
  }
});

// ../node_modules/@apollo/client/link/utils/toPromise.js
function toPromise(observable) {
  var completed = false;
  return new Promise(function(resolve, reject) {
    observable.subscribe({
      next: function(data) {
        if (completed) {
          globalThis.__DEV__ !== false && invariant2.warn(42);
        } else {
          completed = true;
          resolve(data);
        }
      },
      error: reject
    });
  });
}
var import_dist550, import_dist551, import_dist552;
var init_toPromise = __esm({
  "../node_modules/@apollo/client/link/utils/toPromise.js"() {
    import_dist550 = __toESM(require_dist(), 1);
    import_dist551 = __toESM(require_dist2(), 1);
    import_dist552 = __toESM(require_dist3(), 1);
    init_globals();
  }
});

// ../node_modules/@apollo/client/link/utils/fromPromise.js
function fromPromise(promise) {
  return new Observable(function(observer) {
    promise.then(function(value) {
      observer.next(value);
      observer.complete();
    }).catch(observer.error.bind(observer));
  });
}
var import_dist553, import_dist554, import_dist555;
var init_fromPromise = __esm({
  "../node_modules/@apollo/client/link/utils/fromPromise.js"() {
    import_dist553 = __toESM(require_dist(), 1);
    import_dist554 = __toESM(require_dist2(), 1);
    import_dist555 = __toESM(require_dist3(), 1);
    init_utilities2();
  }
});

// ../node_modules/@apollo/client/link/utils/throwServerError.js
var import_dist556, import_dist557, import_dist558, throwServerError;
var init_throwServerError = __esm({
  "../node_modules/@apollo/client/link/utils/throwServerError.js"() {
    import_dist556 = __toESM(require_dist(), 1);
    import_dist557 = __toESM(require_dist2(), 1);
    import_dist558 = __toESM(require_dist3(), 1);
    throwServerError = function(response, result2, message) {
      var error = new Error(message);
      error.name = "ServerError";
      error.response = response;
      error.statusCode = response.status;
      error.result = result2;
      throw error;
    };
  }
});

// ../node_modules/@apollo/client/link/utils/validateOperation.js
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
    var key = _a2[_i];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw newInvariantError(43, key);
    }
  }
  return operation;
}
var import_dist559, import_dist560, import_dist561;
var init_validateOperation = __esm({
  "../node_modules/@apollo/client/link/utils/validateOperation.js"() {
    import_dist559 = __toESM(require_dist(), 1);
    import_dist560 = __toESM(require_dist2(), 1);
    import_dist561 = __toESM(require_dist3(), 1);
    init_globals();
  }
});

// ../node_modules/@apollo/client/link/utils/createOperation.js
function createOperation(starting, operation) {
  var context = __assign({}, starting);
  var setContext = function(next) {
    if (typeof next === "function") {
      context = __assign(__assign({}, context), next(context));
    } else {
      context = __assign(__assign({}, context), next);
    }
  };
  var getContext = function() {
    return __assign({}, context);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  return operation;
}
var import_dist562, import_dist563, import_dist564;
var init_createOperation = __esm({
  "../node_modules/@apollo/client/link/utils/createOperation.js"() {
    import_dist562 = __toESM(require_dist(), 1);
    import_dist563 = __toESM(require_dist2(), 1);
    import_dist564 = __toESM(require_dist3(), 1);
    init_tslib_es6();
  }
});

// ../node_modules/@apollo/client/link/utils/transformOperation.js
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}
var import_dist565, import_dist566, import_dist567;
var init_transformOperation = __esm({
  "../node_modules/@apollo/client/link/utils/transformOperation.js"() {
    import_dist565 = __toESM(require_dist(), 1);
    import_dist566 = __toESM(require_dist2(), 1);
    import_dist567 = __toESM(require_dist3(), 1);
    init_utilities2();
  }
});

// ../node_modules/@apollo/client/link/utils/filterOperationVariables.js
function filterOperationVariables(variables, query) {
  var result2 = __assign({}, variables);
  var unusedNames = new Set(Object.keys(variables));
  visit(query, {
    Variable: function(node, _key, parent) {
      if (parent && parent.kind !== "VariableDefinition") {
        unusedNames.delete(node.name.value);
      }
    }
  });
  unusedNames.forEach(function(name) {
    delete result2[name];
  });
  return result2;
}
var import_dist568, import_dist569, import_dist570;
var init_filterOperationVariables = __esm({
  "../node_modules/@apollo/client/link/utils/filterOperationVariables.js"() {
    import_dist568 = __toESM(require_dist(), 1);
    import_dist569 = __toESM(require_dist2(), 1);
    import_dist570 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_graphql2();
  }
});

// ../node_modules/@apollo/client/link/utils/index.js
var import_dist571, import_dist572, import_dist573;
var init_utils = __esm({
  "../node_modules/@apollo/client/link/utils/index.js"() {
    import_dist571 = __toESM(require_dist(), 1);
    import_dist572 = __toESM(require_dist2(), 1);
    import_dist573 = __toESM(require_dist3(), 1);
    init_globals();
    init_fromError();
    init_toPromise();
    init_fromPromise();
    init_throwServerError();
    init_validateOperation();
    init_createOperation();
    init_transformOperation();
    init_filterOperationVariables();
  }
});

// ../node_modules/@apollo/client/link/core/ApolloLink.js
function passthrough(op, forward) {
  return forward ? forward(op) : Observable.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
  return link.request.length <= 1;
}
var import_dist574, import_dist575, import_dist576, ApolloLink;
var init_ApolloLink = __esm({
  "../node_modules/@apollo/client/link/core/ApolloLink.js"() {
    import_dist574 = __toESM(require_dist(), 1);
    import_dist575 = __toESM(require_dist2(), 1);
    import_dist576 = __toESM(require_dist3(), 1);
    init_globals();
    init_utilities2();
    init_utils();
    ApolloLink = /** @class */
    function() {
      function ApolloLink2(request) {
        if (request)
          this.request = request;
      }
      ApolloLink2.empty = function() {
        return new ApolloLink2(function() {
          return Observable.of();
        });
      };
      ApolloLink2.from = function(links) {
        if (links.length === 0)
          return ApolloLink2.empty();
        return links.map(toLink).reduce(function(x, y) {
          return x.concat(y);
        });
      };
      ApolloLink2.split = function(test, left, right) {
        var leftLink = toLink(left);
        var rightLink = toLink(right || new ApolloLink2(passthrough));
        var ret;
        if (isTerminating(leftLink) && isTerminating(rightLink)) {
          ret = new ApolloLink2(function(operation) {
            return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
          });
        } else {
          ret = new ApolloLink2(function(operation, forward) {
            return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
          });
        }
        return Object.assign(ret, { left: leftLink, right: rightLink });
      };
      ApolloLink2.execute = function(link, operation) {
        return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
      };
      ApolloLink2.concat = function(first, second) {
        var firstLink = toLink(first);
        if (isTerminating(firstLink)) {
          globalThis.__DEV__ !== false && invariant2.warn(35, firstLink);
          return firstLink;
        }
        var nextLink = toLink(second);
        var ret;
        if (isTerminating(nextLink)) {
          ret = new ApolloLink2(function(operation) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op) || Observable.of();
            }) || Observable.of();
          });
        } else {
          ret = new ApolloLink2(function(operation, forward) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op, forward) || Observable.of();
            }) || Observable.of();
          });
        }
        return Object.assign(ret, { left: firstLink, right: nextLink });
      };
      ApolloLink2.prototype.split = function(test, left, right) {
        return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
      };
      ApolloLink2.prototype.concat = function(next) {
        return ApolloLink2.concat(this, next);
      };
      ApolloLink2.prototype.request = function(operation, forward) {
        throw newInvariantError(36);
      };
      ApolloLink2.prototype.onError = function(error, observer) {
        if (observer && observer.error) {
          observer.error(error);
          return false;
        }
        throw error;
      };
      ApolloLink2.prototype.setOnError = function(fn) {
        this.onError = fn;
        return this;
      };
      return ApolloLink2;
    }();
  }
});

// ../node_modules/@apollo/client/link/core/split.js
var import_dist577, import_dist578, import_dist579, split;
var init_split = __esm({
  "../node_modules/@apollo/client/link/core/split.js"() {
    import_dist577 = __toESM(require_dist(), 1);
    import_dist578 = __toESM(require_dist2(), 1);
    import_dist579 = __toESM(require_dist3(), 1);
    init_ApolloLink();
    split = ApolloLink.split;
  }
});

// ../node_modules/@apollo/client/link/core/empty.js
var import_dist580, import_dist581, import_dist582, empty;
var init_empty = __esm({
  "../node_modules/@apollo/client/link/core/empty.js"() {
    import_dist580 = __toESM(require_dist(), 1);
    import_dist581 = __toESM(require_dist2(), 1);
    import_dist582 = __toESM(require_dist3(), 1);
    init_ApolloLink();
    empty = ApolloLink.empty;
  }
});

// ../node_modules/@apollo/client/link/core/from.js
var import_dist583, import_dist584, import_dist585, from;
var init_from = __esm({
  "../node_modules/@apollo/client/link/core/from.js"() {
    import_dist583 = __toESM(require_dist(), 1);
    import_dist584 = __toESM(require_dist2(), 1);
    import_dist585 = __toESM(require_dist3(), 1);
    init_ApolloLink();
    from = ApolloLink.from;
  }
});

// ../node_modules/@apollo/client/link/core/concat.js
var import_dist586, import_dist587, import_dist588, concat;
var init_concat = __esm({
  "../node_modules/@apollo/client/link/core/concat.js"() {
    import_dist586 = __toESM(require_dist(), 1);
    import_dist587 = __toESM(require_dist2(), 1);
    import_dist588 = __toESM(require_dist3(), 1);
    init_ApolloLink();
    concat = ApolloLink.concat;
  }
});

// ../node_modules/@apollo/client/link/core/execute.js
var import_dist589, import_dist590, import_dist591, execute2;
var init_execute2 = __esm({
  "../node_modules/@apollo/client/link/core/execute.js"() {
    import_dist589 = __toESM(require_dist(), 1);
    import_dist590 = __toESM(require_dist2(), 1);
    import_dist591 = __toESM(require_dist3(), 1);
    init_ApolloLink();
    execute2 = ApolloLink.execute;
  }
});

// ../node_modules/@apollo/client/link/core/types.js
var import_dist592, import_dist593, import_dist594;
var init_types = __esm({
  "../node_modules/@apollo/client/link/core/types.js"() {
    import_dist592 = __toESM(require_dist(), 1);
    import_dist593 = __toESM(require_dist2(), 1);
    import_dist594 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/link/core/index.js
var import_dist595, import_dist596, import_dist597;
var init_core = __esm({
  "../node_modules/@apollo/client/link/core/index.js"() {
    import_dist595 = __toESM(require_dist(), 1);
    import_dist596 = __toESM(require_dist2(), 1);
    import_dist597 = __toESM(require_dist3(), 1);
    init_globals();
    init_empty();
    init_from();
    init_split();
    init_concat();
    init_execute2();
    init_ApolloLink();
    init_types();
  }
});

// ../node_modules/@apollo/client/cache/inmemory/fixPolyfills.js
var import_dist598, import_dist599, import_dist600;
var init_fixPolyfills = __esm({
  "../node_modules/@apollo/client/cache/inmemory/fixPolyfills.js"() {
    "use strict";
    import_dist598 = __toESM(require_dist(), 1);
    import_dist599 = __toESM(require_dist2(), 1);
    import_dist600 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@wry/equality/lib/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  default: () => lib_default,
  equal: () => equal
});
function equal(a, b) {
  try {
    return check(a, b);
  } finally {
    previousComparisons.clear();
  }
}
function check(a, b) {
  if (a === b) {
    return true;
  }
  const aTag = toString2.call(a);
  const bTag = toString2.call(b);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a.length !== b.length)
        return false;
    case "[object Object]": {
      if (previouslyCompared(a, b))
        return true;
      const aKeys = definedKeys(a);
      const bKeys = definedKeys(b);
      const keyCount = aKeys.length;
      if (keyCount !== bKeys.length)
        return false;
      for (let k = 0; k < keyCount; ++k) {
        if (!hasOwnProperty6.call(b, aKeys[k])) {
          return false;
        }
      }
      for (let k = 0; k < keyCount; ++k) {
        const key = aKeys[k];
        if (!check(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a.name === b.name && a.message === b.message;
    case "[object Number]":
      if (a !== a)
        return b !== b;
    case "[object Boolean]":
    case "[object Date]":
      return +a === +b;
    case "[object RegExp]":
    case "[object String]":
      return a == `${b}`;
    case "[object Map]":
    case "[object Set]": {
      if (a.size !== b.size)
        return false;
      if (previouslyCompared(a, b))
        return true;
      const aIterator = a.entries();
      const isMap = aTag === "[object Map]";
      while (true) {
        const info = aIterator.next();
        if (info.done)
          break;
        const [aKey, aValue] = info.value;
        if (!b.has(aKey)) {
          return false;
        }
        if (isMap && !check(aValue, b.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case "[object DataView]": {
      let len = a.byteLength;
      if (len === b.byteLength) {
        while (len-- && a[len] === b[len]) {
        }
      }
      return len === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const aCode = fnToStr.call(a);
      if (aCode !== fnToStr.call(b)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
  return this[key] !== void 0;
}
function endsWith(full, suffix) {
  const fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a, b) {
  let bSet = previousComparisons.get(a);
  if (bSet) {
    if (bSet.has(b))
      return true;
  } else {
    previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
  }
  bSet.add(b);
  return false;
}
var import_dist601, import_dist602, import_dist603, toString2, hasOwnProperty6, fnToStr, previousComparisons, lib_default, nativeCodeSuffix;
var init_lib6 = __esm({
  "../node_modules/@wry/equality/lib/index.js"() {
    import_dist601 = __toESM(require_dist());
    import_dist602 = __toESM(require_dist2());
    import_dist603 = __toESM(require_dist3());
    ({ toString: toString2, hasOwnProperty: hasOwnProperty6 } = Object.prototype);
    fnToStr = Function.prototype.toString;
    previousComparisons = /* @__PURE__ */ new Map();
    lib_default = equal;
    nativeCodeSuffix = "{ [native code] }";
  }
});

// ../node_modules/@apollo/client/core/equalByQuery.js
function equalByQuery(query, _a2, _b, variables) {
  var aData = _a2.data, aRest = __rest(_a2, ["data"]);
  var bData = _b.data, bRest = __rest(_b, ["data"]);
  return lib_default(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {
    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
    variables
  });
}
function equalBySelectionSet(selectionSet, aResult, bResult, context) {
  if (aResult === bResult) {
    return true;
  }
  var seenSelections = /* @__PURE__ */ new Set();
  return selectionSet.selections.every(function(selection) {
    if (seenSelections.has(selection))
      return true;
    seenSelections.add(selection);
    if (!shouldInclude(selection, context.variables))
      return true;
    if (selectionHasNonreactiveDirective(selection))
      return true;
    if (isField(selection)) {
      var resultKey = resultKeyNameFromField(selection);
      var aResultChild = aResult && aResult[resultKey];
      var bResultChild = bResult && bResult[resultKey];
      var childSelectionSet = selection.selectionSet;
      if (!childSelectionSet) {
        return lib_default(aResultChild, bResultChild);
      }
      var aChildIsArray = Array.isArray(aResultChild);
      var bChildIsArray = Array.isArray(bResultChild);
      if (aChildIsArray !== bChildIsArray)
        return false;
      if (aChildIsArray && bChildIsArray) {
        var length_1 = aResultChild.length;
        if (bResultChild.length !== length_1) {
          return false;
        }
        for (var i = 0; i < length_1; ++i) {
          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
            return false;
          }
        }
        return true;
      }
      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);
    } else {
      var fragment = getFragmentFromSelection(selection, context.fragmentMap);
      if (fragment) {
        if (selectionHasNonreactiveDirective(fragment))
          return true;
        return equalBySelectionSet(
          fragment.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          aResult,
          bResult,
          context
        );
      }
    }
  });
}
function selectionHasNonreactiveDirective(selection) {
  return !!selection.directives && selection.directives.some(directiveIsNonreactive);
}
function directiveIsNonreactive(dir) {
  return dir.name.value === "nonreactive";
}
var import_dist604, import_dist605, import_dist606;
var init_equalByQuery = __esm({
  "../node_modules/@apollo/client/core/equalByQuery.js"() {
    import_dist604 = __toESM(require_dist(), 1);
    import_dist605 = __toESM(require_dist2(), 1);
    import_dist606 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_lib6();
    init_utilities2();
  }
});

// ../node_modules/@apollo/client/cache/core/cache.js
var import_dist607, import_dist608, import_dist609, ApolloCache;
var init_cache = __esm({
  "../node_modules/@apollo/client/cache/core/cache.js"() {
    import_dist607 = __toESM(require_dist(), 1);
    import_dist608 = __toESM(require_dist2(), 1);
    import_dist609 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_lib5();
    init_utilities2();
    init_lib2();
    init_getMemoryInternals();
    init_equalByQuery();
    ApolloCache = /** @class */
    function() {
      function ApolloCache2() {
        this.assumeImmutableResults = false;
        this.getFragmentDoc = wrap3(getFragmentQueryDocument, {
          max: cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
          cache: WeakCache
        });
      }
      ApolloCache2.prototype.batch = function(options) {
        var _this = this;
        var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
        var updateResult;
        this.performTransaction(function() {
          return updateResult = options.update(_this);
        }, optimisticId);
        return updateResult;
      };
      ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
        this.performTransaction(transaction, optimisticId);
      };
      ApolloCache2.prototype.transformDocument = function(document) {
        return document;
      };
      ApolloCache2.prototype.transformForLink = function(document) {
        return document;
      };
      ApolloCache2.prototype.identify = function(object) {
        return;
      };
      ApolloCache2.prototype.gc = function() {
        return [];
      };
      ApolloCache2.prototype.modify = function(options) {
        return false;
      };
      ApolloCache2.prototype.readQuery = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options.optimistic;
        }
        return this.read(__assign(__assign({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
      };
      ApolloCache2.prototype.watchFragment = function(options) {
        var _this = this;
        var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, otherOptions = __rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
        var query = this.getFragmentDoc(fragment, fragmentName);
        var diffOptions = __assign(__assign({}, otherOptions), { returnPartialData: true, id: typeof from2 === "string" ? from2 : this.identify(from2), query, optimistic });
        var latestDiff;
        return new Observable(function(observer) {
          return _this.watch(__assign(__assign({}, diffOptions), { immediate: true, callback: function(diff2) {
            if (
              // Always ensure we deliver the first result
              latestDiff && equalByQuery(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data: diff2.result })
            ) {
              return;
            }
            var result2 = {
              data: diff2.result,
              complete: !!diff2.complete
            };
            if (diff2.missing) {
              result2.missing = mergeDeepArray(diff2.missing.map(function(error) {
                return error.missing;
              }));
            }
            latestDiff = diff2;
            observer.next(result2);
          } }));
        });
      };
      ApolloCache2.prototype.readFragment = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options.optimistic;
        }
        return this.read(__assign(__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
      };
      ApolloCache2.prototype.writeQuery = function(_a2) {
        var id = _a2.id, data = _a2.data, options = __rest(_a2, ["id", "data"]);
        return this.write(Object.assign(options, {
          dataId: id || "ROOT_QUERY",
          result: data
        }));
      };
      ApolloCache2.prototype.writeFragment = function(_a2) {
        var id = _a2.id, data = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = __rest(_a2, ["id", "data", "fragment", "fragmentName"]);
        return this.write(Object.assign(options, {
          query: this.getFragmentDoc(fragment, fragmentName),
          dataId: id,
          result: data
        }));
      };
      ApolloCache2.prototype.updateQuery = function(options, update) {
        return this.batch({
          update: function(cache2) {
            var value = cache2.readQuery(options);
            var data = update(value);
            if (data === void 0 || data === null)
              return value;
            cache2.writeQuery(__assign(__assign({}, options), { data }));
            return data;
          }
        });
      };
      ApolloCache2.prototype.updateFragment = function(options, update) {
        return this.batch({
          update: function(cache2) {
            var value = cache2.readFragment(options);
            var data = update(value);
            if (data === void 0 || data === null)
              return value;
            cache2.writeFragment(__assign(__assign({}, options), { data }));
            return data;
          }
        });
      };
      return ApolloCache2;
    }();
    if (globalThis.__DEV__ !== false) {
      ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;
    }
  }
});

// ../node_modules/@apollo/client/cache/core/types/common.js
var import_dist610, import_dist611, import_dist612, MissingFieldError;
var init_common = __esm({
  "../node_modules/@apollo/client/cache/core/types/common.js"() {
    import_dist610 = __toESM(require_dist(), 1);
    import_dist611 = __toESM(require_dist2(), 1);
    import_dist612 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    MissingFieldError = /** @class */
    function(_super) {
      __extends(MissingFieldError2, _super);
      function MissingFieldError2(message, path, query, variables) {
        var _a2;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.path = path;
        _this.query = query;
        _this.variables = variables;
        if (Array.isArray(_this.path)) {
          _this.missing = _this.message;
          for (var i = _this.path.length - 1; i >= 0; --i) {
            _this.missing = (_a2 = {}, _a2[_this.path[i]] = _this.missing, _a2);
          }
        } else {
          _this.missing = _this.path;
        }
        _this.__proto__ = MissingFieldError2.prototype;
        return _this;
      }
      return MissingFieldError2;
    }(Error);
  }
});

// ../node_modules/@apollo/client/cache/inmemory/helpers.js
function isNullish(value) {
  return value === null || value === void 0;
}
function defaultDataIdFromObject(_a2, context) {
  var __typename = _a2.__typename, id = _a2.id, _id = _a2._id;
  if (typeof __typename === "string") {
    if (context) {
      context.keyObject = !isNullish(id) ? { id } : !isNullish(_id) ? { _id } : void 0;
    }
    if (isNullish(id) && !isNullish(_id)) {
      id = _id;
    }
    if (!isNullish(id)) {
      return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
    }
  }
}
function normalizeConfig(config) {
  return compact(defaultConfig, config);
}
function shouldCanonizeResults(config) {
  var value = config.canonizeResults;
  return value === void 0 ? defaultConfig.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
function fieldNameFromStoreName(storeFieldName) {
  var match = storeFieldName.match(TypeOrFieldNameRegExp);
  return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result2, variables) {
  if (isNonNullObject(result2)) {
    return isArray(result2) ? result2.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField(field) && shouldInclude(field, variables)) {
        var key = resultKeyNameFromField(field);
        return hasOwn.call(result2, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result2[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject(value) && !isReference(value) && !isArray(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}
function extractFragmentContext(document, fragments) {
  var fragmentMap = createFragmentMap(getFragmentDefinitions(document));
  return {
    fragmentMap,
    lookupFragment: function(name) {
      var def = fragmentMap[name];
      if (!def && fragments) {
        def = fragments.lookup(name);
      }
      return def || null;
    }
  };
}
var import_dist613, import_dist614, import_dist615, hasOwn, defaultConfig, TypeOrFieldNameRegExp;
var init_helpers2 = __esm({
  "../node_modules/@apollo/client/cache/inmemory/helpers.js"() {
    import_dist613 = __toESM(require_dist(), 1);
    import_dist614 = __toESM(require_dist2(), 1);
    import_dist615 = __toESM(require_dist3(), 1);
    init_utilities2();
    hasOwn = Object.prototype.hasOwnProperty;
    defaultConfig = {
      dataIdFromObject: defaultDataIdFromObject,
      addTypename: true,
      resultCaching: true,
      // Thanks to the shouldCanonizeResults helper, this should be the only line
      // you have to change to reenable canonization by default in the future.
      canonizeResults: false
    };
    TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
  }
});

// ../node_modules/@apollo/client/cache/inmemory/entityStore.js
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}
var import_dist616, import_dist617, import_dist618, DELETE, delModifier, INVALIDATE, EntityStore, CacheGroup, Layer, Stump;
var init_entityStore = __esm({
  "../node_modules/@apollo/client/cache/inmemory/entityStore.js"() {
    import_dist616 = __toESM(require_dist(), 1);
    import_dist617 = __toESM(require_dist2(), 1);
    import_dist618 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_lib5();
    init_lib6();
    init_lib();
    init_utilities2();
    init_helpers2();
    DELETE = /* @__PURE__ */ Object.create(null);
    delModifier = function() {
      return DELETE;
    };
    INVALIDATE = /* @__PURE__ */ Object.create(null);
    EntityStore = /** @class */
    function() {
      function EntityStore2(policies, group) {
        var _this = this;
        this.policies = policies;
        this.group = group;
        this.data = /* @__PURE__ */ Object.create(null);
        this.rootIds = /* @__PURE__ */ Object.create(null);
        this.refs = /* @__PURE__ */ Object.create(null);
        this.getFieldValue = function(objectOrReference, storeFieldName) {
          return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
        };
        this.canRead = function(objOrRef) {
          return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
        };
        this.toReference = function(objOrIdOrRef, mergeIntoStore) {
          if (typeof objOrIdOrRef === "string") {
            return makeReference(objOrIdOrRef);
          }
          if (isReference(objOrIdOrRef)) {
            return objOrIdOrRef;
          }
          var id = _this.policies.identify(objOrIdOrRef)[0];
          if (id) {
            var ref = makeReference(id);
            if (mergeIntoStore) {
              _this.merge(id, objOrIdOrRef);
            }
            return ref;
          }
        };
      }
      EntityStore2.prototype.toObject = function() {
        return __assign({}, this.data);
      };
      EntityStore2.prototype.has = function(dataId) {
        return this.lookup(dataId, true) !== void 0;
      };
      EntityStore2.prototype.get = function(dataId, fieldName) {
        this.group.depend(dataId, fieldName);
        if (hasOwn.call(this.data, dataId)) {
          var storeObject = this.data[dataId];
          if (storeObject && hasOwn.call(storeObject, fieldName)) {
            return storeObject[fieldName];
          }
        }
        if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
          return this.policies.rootTypenamesById[dataId];
        }
        if (this instanceof Layer) {
          return this.parent.get(dataId, fieldName);
        }
      };
      EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
        if (dependOnExistence)
          this.group.depend(dataId, "__exists");
        if (hasOwn.call(this.data, dataId)) {
          return this.data[dataId];
        }
        if (this instanceof Layer) {
          return this.parent.lookup(dataId, dependOnExistence);
        }
        if (this.policies.rootTypenamesById[dataId]) {
          return /* @__PURE__ */ Object.create(null);
        }
      };
      EntityStore2.prototype.merge = function(older, newer) {
        var _this = this;
        var dataId;
        if (isReference(older))
          older = older.__ref;
        if (isReference(newer))
          newer = newer.__ref;
        var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
        var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
        if (!incoming)
          return;
        invariant2(typeof dataId === "string", 1);
        var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
        this.data[dataId] = merged;
        if (merged !== existing) {
          delete this.refs[dataId];
          if (this.group.caching) {
            var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
            if (!existing)
              fieldsToDirty_1.__exists = 1;
            Object.keys(incoming).forEach(function(storeFieldName) {
              if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                fieldsToDirty_1[storeFieldName] = 1;
                var fieldName = fieldNameFromStoreName(storeFieldName);
                if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                  fieldsToDirty_1[fieldName] = 1;
                }
                if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                  delete merged[storeFieldName];
                }
              }
            });
            if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings
            // automatically from store.get, we don't need to dirty the
            // ROOT_QUERY.__typename field if merged.__typename is equal
            // to the default string (usually "Query").
            this.policies.rootTypenamesById[dataId] === merged.__typename) {
              delete fieldsToDirty_1.__typename;
            }
            Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
              return _this.group.dirty(dataId, fieldName);
            });
          }
        }
      };
      EntityStore2.prototype.modify = function(dataId, fields) {
        var _this = this;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var changedFields_1 = /* @__PURE__ */ Object.create(null);
          var needToMerge_1 = false;
          var allDeleted_1 = true;
          var sharedDetails_1 = {
            DELETE,
            INVALIDATE,
            isReference,
            toReference: this.toReference,
            canRead: this.canRead,
            readField: function(fieldNameOrOptions, from2) {
              return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                fieldName: fieldNameOrOptions,
                from: from2 || makeReference(dataId)
              } : fieldNameOrOptions, { store: _this });
            }
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            var fieldName = fieldNameFromStoreName(storeFieldName);
            var fieldValue = storeObject[storeFieldName];
            if (fieldValue === void 0)
              return;
            var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
            if (modify) {
              var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
              if (newValue === INVALIDATE) {
                _this.group.dirty(dataId, storeFieldName);
              } else {
                if (newValue === DELETE)
                  newValue = void 0;
                if (newValue !== fieldValue) {
                  changedFields_1[storeFieldName] = newValue;
                  needToMerge_1 = true;
                  fieldValue = newValue;
                  if (globalThis.__DEV__ !== false) {
                    var checkReference = function(ref) {
                      if (_this.lookup(ref.__ref) === void 0) {
                        globalThis.__DEV__ !== false && invariant2.warn(2, ref);
                        return true;
                      }
                    };
                    if (isReference(newValue)) {
                      checkReference(newValue);
                    } else if (Array.isArray(newValue)) {
                      var seenReference = false;
                      var someNonReference = void 0;
                      for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {
                        var value = newValue_1[_i];
                        if (isReference(value)) {
                          seenReference = true;
                          if (checkReference(value))
                            break;
                        } else {
                          if (typeof value === "object" && !!value) {
                            var id = _this.policies.identify(value)[0];
                            if (id) {
                              someNonReference = value;
                            }
                          }
                        }
                        if (seenReference && someNonReference !== void 0) {
                          globalThis.__DEV__ !== false && invariant2.warn(3, someNonReference);
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (fieldValue !== void 0) {
              allDeleted_1 = false;
            }
          });
          if (needToMerge_1) {
            this.merge(dataId, changedFields_1);
            if (allDeleted_1) {
              if (this instanceof Layer) {
                this.data[dataId] = void 0;
              } else {
                delete this.data[dataId];
              }
              this.group.dirty(dataId, "__exists");
            }
            return true;
          }
        }
        return false;
      };
      EntityStore2.prototype.delete = function(dataId, fieldName, args) {
        var _a2;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var typename = this.getFieldValue(storeObject, "__typename");
          var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
          return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier, _a2) : delModifier);
        }
        return false;
      };
      EntityStore2.prototype.evict = function(options, limit) {
        var evicted = false;
        if (options.id) {
          if (hasOwn.call(this.data, options.id)) {
            evicted = this.delete(options.id, options.fieldName, options.args);
          }
          if (this instanceof Layer && this !== limit) {
            evicted = this.parent.evict(options, limit) || evicted;
          }
          if (options.fieldName || evicted) {
            this.group.dirty(options.id, options.fieldName || "__exists");
          }
        }
        return evicted;
      };
      EntityStore2.prototype.clear = function() {
        this.replace(null);
      };
      EntityStore2.prototype.extract = function() {
        var _this = this;
        var obj = this.toObject();
        var extraRootIds = [];
        this.getRootIdSet().forEach(function(id) {
          if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
            extraRootIds.push(id);
          }
        });
        if (extraRootIds.length) {
          obj.__META = { extraRootIds: extraRootIds.sort() };
        }
        return obj;
      };
      EntityStore2.prototype.replace = function(newData) {
        var _this = this;
        Object.keys(this.data).forEach(function(dataId) {
          if (!(newData && hasOwn.call(newData, dataId))) {
            _this.delete(dataId);
          }
        });
        if (newData) {
          var __META = newData.__META, rest_1 = __rest(newData, ["__META"]);
          Object.keys(rest_1).forEach(function(dataId) {
            _this.merge(dataId, rest_1[dataId]);
          });
          if (__META) {
            __META.extraRootIds.forEach(this.retain, this);
          }
        }
      };
      EntityStore2.prototype.retain = function(rootId) {
        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
      };
      EntityStore2.prototype.release = function(rootId) {
        if (this.rootIds[rootId] > 0) {
          var count = --this.rootIds[rootId];
          if (!count)
            delete this.rootIds[rootId];
          return count;
        }
        return 0;
      };
      EntityStore2.prototype.getRootIdSet = function(ids) {
        if (ids === void 0) {
          ids = /* @__PURE__ */ new Set();
        }
        Object.keys(this.rootIds).forEach(ids.add, ids);
        if (this instanceof Layer) {
          this.parent.getRootIdSet(ids);
        } else {
          Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
        }
        return ids;
      };
      EntityStore2.prototype.gc = function() {
        var _this = this;
        var ids = this.getRootIdSet();
        var snapshot = this.toObject();
        ids.forEach(function(id) {
          if (hasOwn.call(snapshot, id)) {
            Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
            delete snapshot[id];
          }
        });
        var idsToRemove = Object.keys(snapshot);
        if (idsToRemove.length) {
          var root_1 = this;
          while (root_1 instanceof Layer)
            root_1 = root_1.parent;
          idsToRemove.forEach(function(id) {
            return root_1.delete(id);
          });
        }
        return idsToRemove;
      };
      EntityStore2.prototype.findChildRefIds = function(dataId) {
        if (!hasOwn.call(this.refs, dataId)) {
          var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
          var root2 = this.data[dataId];
          if (!root2)
            return found_1;
          var workSet_1 = /* @__PURE__ */ new Set([root2]);
          workSet_1.forEach(function(obj) {
            if (isReference(obj)) {
              found_1[obj.__ref] = true;
            }
            if (isNonNullObject(obj)) {
              Object.keys(obj).forEach(function(key) {
                var child = obj[key];
                if (isNonNullObject(child)) {
                  workSet_1.add(child);
                }
              });
            }
          });
        }
        return this.refs[dataId];
      };
      EntityStore2.prototype.makeCacheKey = function() {
        return this.group.keyMaker.lookupArray(arguments);
      };
      return EntityStore2;
    }();
    CacheGroup = /** @class */
    function() {
      function CacheGroup2(caching, parent) {
        if (parent === void 0) {
          parent = null;
        }
        this.caching = caching;
        this.parent = parent;
        this.d = null;
        this.resetCaching();
      }
      CacheGroup2.prototype.resetCaching = function() {
        this.d = this.caching ? dep() : null;
        this.keyMaker = new Trie(canUseWeakMap);
      };
      CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
        if (this.d) {
          this.d(makeDepKey(dataId, storeFieldName));
          var fieldName = fieldNameFromStoreName(storeFieldName);
          if (fieldName !== storeFieldName) {
            this.d(makeDepKey(dataId, fieldName));
          }
          if (this.parent) {
            this.parent.depend(dataId, storeFieldName);
          }
        }
      };
      CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
        if (this.d) {
          this.d.dirty(
            makeDepKey(dataId, storeFieldName),
            // When storeFieldName === "__exists", that means the entity identified
            // by dataId has either disappeared from the cache or was newly added,
            // so the result caching system would do well to "forget everything it
            // knows" about that object. To achieve that kind of invalidation, we
            // not only dirty the associated result cache entry, but also remove it
            // completely from the dependency graph. For the optimism implementation
            // details, see https://github.com/benjamn/optimism/pull/195.
            storeFieldName === "__exists" ? "forget" : "setDirty"
          );
        }
      };
      return CacheGroup2;
    }();
    (function(EntityStore2) {
      var Root = (
        /** @class */
        function(_super) {
          __extends(Root2, _super);
          function Root2(_a2) {
            var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
            var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
            _this.stump = new Stump(_this);
            _this.storageTrie = new Trie(canUseWeakMap);
            if (seed)
              _this.replace(seed);
            return _this;
          }
          Root2.prototype.addLayer = function(layerId, replay) {
            return this.stump.addLayer(layerId, replay);
          };
          Root2.prototype.removeLayer = function() {
            return this;
          };
          Root2.prototype.getStorage = function() {
            return this.storageTrie.lookupArray(arguments);
          };
          return Root2;
        }(EntityStore2)
      );
      EntityStore2.Root = Root;
    })(EntityStore || (EntityStore = {}));
    Layer = /** @class */
    function(_super) {
      __extends(Layer2, _super);
      function Layer2(id, parent, replay, group) {
        var _this = _super.call(this, parent.policies, group) || this;
        _this.id = id;
        _this.parent = parent;
        _this.replay = replay;
        _this.group = group;
        replay(_this);
        return _this;
      }
      Layer2.prototype.addLayer = function(layerId, replay) {
        return new Layer2(layerId, this, replay, this.group);
      };
      Layer2.prototype.removeLayer = function(layerId) {
        var _this = this;
        var parent = this.parent.removeLayer(layerId);
        if (layerId === this.id) {
          if (this.group.caching) {
            Object.keys(this.data).forEach(function(dataId) {
              var ownStoreObject = _this.data[dataId];
              var parentStoreObject = parent["lookup"](dataId);
              if (!parentStoreObject) {
                _this.delete(dataId);
              } else if (!ownStoreObject) {
                _this.group.dirty(dataId, "__exists");
                Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                  _this.group.dirty(dataId, storeFieldName);
                });
              } else if (ownStoreObject !== parentStoreObject) {
                Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                  if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                    _this.group.dirty(dataId, storeFieldName);
                  }
                });
              }
            });
          }
          return parent;
        }
        if (parent === this.parent)
          return this;
        return parent.addLayer(this.id, this.replay);
      };
      Layer2.prototype.toObject = function() {
        return __assign(__assign({}, this.parent.toObject()), this.data);
      };
      Layer2.prototype.findChildRefIds = function(dataId) {
        var fromParent = this.parent.findChildRefIds(dataId);
        return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
      };
      Layer2.prototype.getStorage = function() {
        var p = this.parent;
        while (p.parent)
          p = p.parent;
        return p.getStorage.apply(
          p,
          // @ts-expect-error
          arguments
        );
      };
      return Layer2;
    }(EntityStore);
    Stump = /** @class */
    function(_super) {
      __extends(Stump2, _super);
      function Stump2(root2) {
        return _super.call(this, "EntityStore.Stump", root2, function() {
        }, new CacheGroup(root2.group.caching, root2.group)) || this;
      }
      Stump2.prototype.removeLayer = function() {
        return this;
      };
      Stump2.prototype.merge = function(older, newer) {
        return this.parent.merge(older, newer);
      };
      return Stump2;
    }(Layer);
  }
});

// ../node_modules/@apollo/client/cache/inmemory/object-canon.js
function shallowCopy(value) {
  if (isNonNullObject(value)) {
    return isArray(value) ? value.slice(0) : __assign({ __proto__: Object.getPrototypeOf(value) }, value);
  }
  return value;
}
var import_dist619, import_dist620, import_dist621, ObjectCanon;
var init_object_canon = __esm({
  "../node_modules/@apollo/client/cache/inmemory/object-canon.js"() {
    import_dist619 = __toESM(require_dist(), 1);
    import_dist620 = __toESM(require_dist2(), 1);
    import_dist621 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_lib();
    init_utilities2();
    init_helpers2();
    ObjectCanon = /** @class */
    function() {
      function ObjectCanon2() {
        this.known = new (canUseWeakSet ? WeakSet : Set)();
        this.pool = new Trie(canUseWeakMap);
        this.passes = /* @__PURE__ */ new WeakMap();
        this.keysByJSON = /* @__PURE__ */ new Map();
        this.empty = this.admit({});
      }
      ObjectCanon2.prototype.isKnown = function(value) {
        return isNonNullObject(value) && this.known.has(value);
      };
      ObjectCanon2.prototype.pass = function(value) {
        if (isNonNullObject(value)) {
          var copy = shallowCopy(value);
          this.passes.set(copy, value);
          return copy;
        }
        return value;
      };
      ObjectCanon2.prototype.admit = function(value) {
        var _this = this;
        if (isNonNullObject(value)) {
          var original = this.passes.get(value);
          if (original)
            return original;
          var proto = Object.getPrototypeOf(value);
          switch (proto) {
            case Array.prototype: {
              if (this.known.has(value))
                return value;
              var array = value.map(this.admit, this);
              var node = this.pool.lookupArray(array);
              if (!node.array) {
                this.known.add(node.array = array);
                if (globalThis.__DEV__ !== false) {
                  Object.freeze(array);
                }
              }
              return node.array;
            }
            case null:
            case Object.prototype: {
              if (this.known.has(value))
                return value;
              var proto_1 = Object.getPrototypeOf(value);
              var array_1 = [proto_1];
              var keys = this.sortedKeys(value);
              array_1.push(keys.json);
              var firstValueIndex_1 = array_1.length;
              keys.sorted.forEach(function(key) {
                array_1.push(_this.admit(value[key]));
              });
              var node = this.pool.lookupArray(array_1);
              if (!node.object) {
                var obj_1 = node.object = Object.create(proto_1);
                this.known.add(obj_1);
                keys.sorted.forEach(function(key, i) {
                  obj_1[key] = array_1[firstValueIndex_1 + i];
                });
                if (globalThis.__DEV__ !== false) {
                  Object.freeze(obj_1);
                }
              }
              return node.object;
            }
          }
        }
        return value;
      };
      ObjectCanon2.prototype.sortedKeys = function(obj) {
        var keys = Object.keys(obj);
        var node = this.pool.lookupArray(keys);
        if (!node.keys) {
          keys.sort();
          var json = JSON.stringify(keys);
          if (!(node.keys = this.keysByJSON.get(json))) {
            this.keysByJSON.set(json, node.keys = { sorted: keys, json });
          }
        }
        return node.keys;
      };
      return ObjectCanon2;
    }();
  }
});

// ../node_modules/@apollo/client/cache/inmemory/readFromStore.js
function execSelectionSetKeyArgs(options) {
  return [
    options.selectionSet,
    options.objectOrReference,
    options.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    options.context.canonizeResults
  ];
}
function firstMissing(tree) {
  try {
    JSON.stringify(tree, function(_, value) {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result2) {
    return result2;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
    workSet_1.forEach(function(value) {
      if (isNonNullObject(value)) {
        invariant2(
          !isReference(value),
          10,
          getTypenameFromStoreObject(store, value),
          field.name.value
        );
        Object.values(value).forEach(workSet_1.add, workSet_1);
      }
    });
  }
}
var import_dist622, import_dist623, import_dist624, StoreReader;
var init_readFromStore = __esm({
  "../node_modules/@apollo/client/cache/inmemory/readFromStore.js"() {
    import_dist622 = __toESM(require_dist(), 1);
    import_dist623 = __toESM(require_dist2(), 1);
    import_dist624 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_graphql2();
    init_lib5();
    init_utilities2();
    init_entityStore();
    init_helpers2();
    init_common();
    init_object_canon();
    StoreReader = /** @class */
    function() {
      function StoreReader2(config) {
        var _this = this;
        this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
        this.config = compact(config, {
          addTypename: config.addTypename !== false,
          canonizeResults: shouldCanonizeResults(config)
        });
        this.canon = config.canon || new ObjectCanon();
        this.executeSelectionSet = wrap3(function(options) {
          var _a2;
          var canonizeResults = options.context.canonizeResults;
          var peekArgs = execSelectionSetKeyArgs(options);
          peekArgs[3] = !canonizeResults;
          var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
          if (other) {
            if (canonizeResults) {
              return __assign(__assign({}, other), {
                // If we previously read this result without canonizing it, we can
                // reuse that result simply by canonizing it now.
                result: _this.canon.admit(other.result)
              });
            }
            return other;
          }
          maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
          return _this.execSelectionSetImpl(options);
        }, {
          max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
          keyArgs: execSelectionSetKeyArgs,
          // Note that the parameters of makeCacheKey are determined by the
          // array returned by keyArgs.
          makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
            if (supportsResultCaching(context.store)) {
              return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
            }
          }
        });
        this.executeSubSelectedArray = wrap3(function(options) {
          maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
          return _this.execSubSelectedArrayImpl(options);
        }, {
          max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
          makeCacheKey: function(_a2) {
            var field = _a2.field, array = _a2.array, context = _a2.context;
            if (supportsResultCaching(context.store)) {
              return context.store.makeCacheKey(field, array, context.varString);
            }
          }
        });
      }
      StoreReader2.prototype.resetCanon = function() {
        this.canon = new ObjectCanon();
      };
      StoreReader2.prototype.diffQueryAgainstStore = function(_a2) {
        var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
        var policies = this.config.cache.policies;
        variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);
        var rootRef = makeReference(rootId);
        var execResult = this.executeSelectionSet({
          selectionSet: getMainDefinition(query).selectionSet,
          objectOrReference: rootRef,
          enclosingRef: rootRef,
          context: __assign({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
        });
        var missing;
        if (execResult.missing) {
          missing = [
            new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)
          ];
          if (!returnPartialData) {
            throw missing[0];
          }
        }
        return {
          result: execResult.result,
          complete: !missing,
          missing
        };
      };
      StoreReader2.prototype.isFresh = function(result2, parent, selectionSet, context) {
        if (supportsResultCaching(context.store) && this.knownResults.get(result2) === selectionSet) {
          var latest = this.executeSelectionSet.peek(
            selectionSet,
            parent,
            context,
            // If result is canonical, then it could only have been previously
            // cached by the canonizing version of executeSelectionSet, so we can
            // avoid checking both possibilities here.
            this.canon.isKnown(result2)
          );
          if (latest && result2 === latest.result) {
            return true;
          }
        }
        return false;
      };
      StoreReader2.prototype.execSelectionSetImpl = function(_a2) {
        var _this = this;
        var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context = _a2.context;
        if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
          return {
            result: this.canon.empty,
            missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
          };
        }
        var variables = context.variables, policies = context.policies, store = context.store;
        var typename = store.getFieldValue(objectOrReference, "__typename");
        var objectsToMerge = [];
        var missing;
        var missingMerger = new DeepMerger();
        if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
          objectsToMerge.push({ __typename: typename });
        }
        function handleMissing(result3, resultName) {
          var _a3;
          if (result3.missing) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result3.missing, _a3));
          }
          return result3.result;
        }
        var workSet = new Set(selectionSet.selections);
        workSet.forEach(function(selection) {
          var _a3, _b;
          if (!shouldInclude(selection, variables))
            return;
          if (isField(selection)) {
            var fieldValue = policies.readField({
              fieldName: selection.name.value,
              field: selection,
              variables: context.variables,
              from: objectOrReference
            }, context);
            var resultName = resultKeyNameFromField(selection);
            if (fieldValue === void 0) {
              if (!addTypenameToDocument.added(selection)) {
                missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
              }
            } else if (isArray(fieldValue)) {
              if (fieldValue.length > 0) {
                fieldValue = handleMissing(_this.executeSubSelectedArray({
                  field: selection,
                  array: fieldValue,
                  enclosingRef,
                  context
                }), resultName);
              }
            } else if (!selection.selectionSet) {
              if (context.canonizeResults) {
                fieldValue = _this.canon.pass(fieldValue);
              }
            } else if (fieldValue != null) {
              fieldValue = handleMissing(_this.executeSelectionSet({
                selectionSet: selection.selectionSet,
                objectOrReference: fieldValue,
                enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
                context
              }), resultName);
            }
            if (fieldValue !== void 0) {
              objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
            }
          } else {
            var fragment = getFragmentFromSelection(selection, context.lookupFragment);
            if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
              throw newInvariantError(9, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename)) {
              fragment.selectionSet.selections.forEach(workSet.add, workSet);
            }
          }
        });
        var result2 = mergeDeepArray(objectsToMerge);
        var finalResult = { result: result2, missing };
        var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
        if (frozen.result) {
          this.knownResults.set(frozen.result, selectionSet);
        }
        return frozen;
      };
      StoreReader2.prototype.execSubSelectedArrayImpl = function(_a2) {
        var _this = this;
        var field = _a2.field, array = _a2.array, enclosingRef = _a2.enclosingRef, context = _a2.context;
        var missing;
        var missingMerger = new DeepMerger();
        function handleMissing(childResult, i) {
          var _a3;
          if (childResult.missing) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[i] = childResult.missing, _a3));
          }
          return childResult.result;
        }
        if (field.selectionSet) {
          array = array.filter(context.store.canRead);
        }
        array = array.map(function(item, i) {
          if (item === null) {
            return null;
          }
          if (isArray(item)) {
            return handleMissing(_this.executeSubSelectedArray({
              field,
              array: item,
              enclosingRef,
              context
            }), i);
          }
          if (field.selectionSet) {
            return handleMissing(_this.executeSelectionSet({
              selectionSet: field.selectionSet,
              objectOrReference: item,
              enclosingRef: isReference(item) ? item : enclosingRef,
              context
            }), i);
          }
          if (globalThis.__DEV__ !== false) {
            assertSelectionSetForIdValue(context.store, field, item);
          }
          return item;
        });
        return {
          result: context.canonizeResults ? this.canon.admit(array) : array,
          missing
        };
      };
      return StoreReader2;
    }();
  }
});

// ../node_modules/@apollo/client/cache/inmemory/reactiveVars.js
function getCacheInfo(cache2) {
  var info = cacheInfoMap.get(cache2);
  if (!info) {
    cacheInfoMap.set(cache2, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.forgetCache(cache2);
  });
}
function recallCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.attachCache(cache2);
  });
}
function makeVar(value) {
  var caches2 = /* @__PURE__ */ new Set();
  var listeners = /* @__PURE__ */ new Set();
  var rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches2.forEach(function(cache3) {
          getCacheInfo(cache3).dep.dirty(rv);
          broadcast(cache3);
        });
        var oldListeners = Array.from(listeners);
        listeners.clear();
        oldListeners.forEach(function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache2 = cacheSlot.getValue();
      if (cache2) {
        attach(cache2);
        getCacheInfo(cache2).dep(rv);
      }
    }
    return value;
  };
  rv.onNextChange = function(listener) {
    listeners.add(listener);
    return function() {
      listeners.delete(listener);
    };
  };
  var attach = rv.attachCache = function(cache2) {
    caches2.add(cache2);
    getCacheInfo(cache2).vars.add(rv);
    return rv;
  };
  rv.forgetCache = function(cache2) {
    return caches2.delete(cache2);
  };
  return rv;
}
function broadcast(cache2) {
  if (cache2.broadcastWatches) {
    cache2.broadcastWatches();
  }
}
var import_dist625, import_dist626, import_dist627, cacheSlot, cacheInfoMap;
var init_reactiveVars = __esm({
  "../node_modules/@apollo/client/cache/inmemory/reactiveVars.js"() {
    import_dist625 = __toESM(require_dist(), 1);
    import_dist626 = __toESM(require_dist2(), 1);
    import_dist627 = __toESM(require_dist3(), 1);
    init_lib5();
    cacheSlot = new Slot();
    cacheInfoMap = /* @__PURE__ */ new WeakMap();
  }
});

// ../node_modules/@apollo/client/cache/inmemory/key-extractor.js
function lookupSpecifierInfo(spec) {
  var cacheKey = JSON.stringify(spec);
  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {
    var extract = function(from2, key) {
      return context.readField(key, from2);
    };
    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
      var extracted = extractKeyPath(
        context.storeObject,
        schemaKeyPath,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        extract
      );
      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {
        extracted = extractKeyPath(object, schemaKeyPath, extractKey);
      }
      invariant2(extracted !== void 0, 4, schemaKeyPath.join("."), object);
      return extracted;
    });
    return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
  });
}
function keyArgsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
    var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
    var collected = collectSpecifierPaths(specifier, function(keyPath) {
      var firstKey = keyPath[0];
      var firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray(field.directives)) {
          var directiveName_1 = firstKey.slice(1);
          var d = field.directives.find(function(d2) {
            return d2.name.value === directiveName_1;
          });
          var directiveArgs = d && argumentsObjectFromField(d, variables);
          return directiveArgs && extractKeyPath(
            directiveArgs,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            keyPath.slice(1)
          );
        }
        return;
      }
      if (firstChar === "$") {
        var variableName = firstKey.slice(1);
        if (variables && hasOwn.call(variables, variableName)) {
          var varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    var suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  var merger = new DeepMerger();
  return getSpecifierPaths(specifier).reduce(function(collected, path) {
    var _a2;
    var toMerge = extractor(path);
    if (toMerge !== void 0) {
      for (var i = path.length - 1; i >= 0; --i) {
        toMerge = (_a2 = {}, _a2[path[i]] = toMerge, _a2);
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, /* @__PURE__ */ Object.create(null));
}
function getSpecifierPaths(spec) {
  var info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    var paths_1 = info.paths = [];
    var currentPath_1 = [];
    spec.forEach(function(s, i) {
      if (isArray(s)) {
        getSpecifierPaths(s).forEach(function(p) {
          return paths_1.push(currentPath_1.concat(p));
        });
        currentPath_1.length = 0;
      } else {
        currentPath_1.push(s);
        if (!isArray(spec[i + 1])) {
          paths_1.push(currentPath_1.slice(0));
          currentPath_1.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object, key) {
  return object[key];
}
function extractKeyPath(object, path, extract) {
  extract = extract || extractKey;
  return normalize(path.reduce(function reducer(obj, key) {
    return isArray(obj) ? obj.map(function(child) {
      return reducer(child, key);
    }) : obj && extract(obj, key);
  }, object));
}
function normalize(value) {
  if (isNonNullObject(value)) {
    if (isArray(value)) {
      return value.map(normalize);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
      return extractKeyPath(value, path);
    });
  }
  return value;
}
var import_dist628, import_dist629, import_dist630, specifierInfoCache;
var init_key_extractor = __esm({
  "../node_modules/@apollo/client/cache/inmemory/key-extractor.js"() {
    import_dist628 = __toESM(require_dist(), 1);
    import_dist629 = __toESM(require_dist2(), 1);
    import_dist630 = __toESM(require_dist3(), 1);
    init_globals();
    init_utilities2();
    init_helpers2();
    specifierInfoCache = /* @__PURE__ */ Object.create(null);
  }
});

// ../node_modules/@apollo/client/cache/inmemory/policies.js
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context.variables;
  var _a2 = context.store, toReference = _a2.toReference, canRead = _a2.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function() {
      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
    },
    mergeObjects: makeMergeObjectsFunction(context.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
  var options;
  if (typeof fieldNameOrOptions === "string") {
    options = {
      fieldName: fieldNameOrOptions,
      // Default to objectOrReference only when no second argument was
      // passed for the from parameter, not when undefined is explicitly
      // passed as the second argument.
      from: argc > 1 ? from2 : objectOrReference
    };
  } else {
    options = __assign({}, fieldNameOrOptions);
    if (!hasOwn.call(options, "from")) {
      options.from = objectOrReference;
    }
  }
  if (globalThis.__DEV__ !== false && options.from === void 0) {
    globalThis.__DEV__ !== false && invariant2.warn(7, stringifyForDisplay(Array.from(readFieldArgs)));
  }
  if (void 0 === options.variables) {
    options.variables = variables;
  }
  return options;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray(existing) || isArray(incoming)) {
      throw newInvariantError(8);
    }
    if (isNonNullObject(existing) && isNonNullObject(incoming)) {
      var eType = store.getFieldValue(existing, "__typename");
      var iType = store.getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return __assign(__assign({}, existing), incoming);
      }
    }
    return incoming;
  };
}
var import_dist631, import_dist632, import_dist633, nullKeyFieldsFn, simpleKeyArgsFn, mergeTrueFn, mergeFalseFn, Policies;
var init_policies = __esm({
  "../node_modules/@apollo/client/cache/inmemory/policies.js"() {
    import_dist631 = __toESM(require_dist(), 1);
    import_dist632 = __toESM(require_dist2(), 1);
    import_dist633 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_utilities2();
    init_helpers2();
    init_reactiveVars();
    init_key_extractor();
    nullKeyFieldsFn = function() {
      return void 0;
    };
    simpleKeyArgsFn = function(_args, context) {
      return context.fieldName;
    };
    mergeTrueFn = function(existing, incoming, _a2) {
      var mergeObjects = _a2.mergeObjects;
      return mergeObjects(existing, incoming);
    };
    mergeFalseFn = function(_, incoming) {
      return incoming;
    };
    Policies = /** @class */
    function() {
      function Policies2(config) {
        this.config = config;
        this.typePolicies = /* @__PURE__ */ Object.create(null);
        this.toBeAdded = /* @__PURE__ */ Object.create(null);
        this.supertypeMap = /* @__PURE__ */ new Map();
        this.fuzzySubtypes = /* @__PURE__ */ new Map();
        this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
        this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
        this.usingPossibleTypes = false;
        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);
        this.cache = this.config.cache;
        this.setRootTypename("Query");
        this.setRootTypename("Mutation");
        this.setRootTypename("Subscription");
        if (config.possibleTypes) {
          this.addPossibleTypes(config.possibleTypes);
        }
        if (config.typePolicies) {
          this.addTypePolicies(config.typePolicies);
        }
      }
      Policies2.prototype.identify = function(object, partialContext) {
        var _a2;
        var policies = this;
        var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object.__typename;
        if (typename === this.rootTypenamesById.ROOT_QUERY) {
          return ["ROOT_QUERY"];
        }
        var storeObject = partialContext && partialContext.storeObject || object;
        var context = __assign(__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
          var options = normalizeReadFieldOptions(arguments, storeObject);
          return policies.readField(options, {
            store: policies.cache["data"],
            variables: options.variables
          });
        } });
        var id;
        var policy = typename && this.getTypePolicy(typename);
        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
        while (keyFn) {
          var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);
          if (isArray(specifierOrId)) {
            keyFn = keyFieldsFnFromSpecifier(specifierOrId);
          } else {
            id = specifierOrId;
            break;
          }
        }
        id = id ? String(id) : void 0;
        return context.keyObject ? [id, context.keyObject] : [id];
      };
      Policies2.prototype.addTypePolicies = function(typePolicies) {
        var _this = this;
        Object.keys(typePolicies).forEach(function(typename) {
          var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = __rest(_a2, ["queryType", "mutationType", "subscriptionType"]);
          if (queryType)
            _this.setRootTypename("Query", typename);
          if (mutationType)
            _this.setRootTypename("Mutation", typename);
          if (subscriptionType)
            _this.setRootTypename("Subscription", typename);
          if (hasOwn.call(_this.toBeAdded, typename)) {
            _this.toBeAdded[typename].push(incoming);
          } else {
            _this.toBeAdded[typename] = [incoming];
          }
        });
      };
      Policies2.prototype.updateTypePolicy = function(typename, incoming) {
        var _this = this;
        var existing = this.getTypePolicy(typename);
        var keyFields = incoming.keyFields, fields = incoming.fields;
        function setMerge(existing2, merge) {
          existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
        }
        setMerge(existing, incoming.merge);
        existing.keyFn = // Pass false to disable normalization for this typename.
        keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
        if (fields) {
          Object.keys(fields).forEach(function(fieldName) {
            var existing2 = _this.getFieldPolicy(typename, fieldName, true);
            var incoming2 = fields[fieldName];
            if (typeof incoming2 === "function") {
              existing2.read = incoming2;
            } else {
              var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;
              existing2.keyFn = // Pass false to disable argument-based differentiation of
              // field identities.
              keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
              if (typeof read === "function") {
                existing2.read = read;
              }
              setMerge(existing2, merge);
            }
            if (existing2.read && existing2.merge) {
              existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
            }
          });
        }
      };
      Policies2.prototype.setRootTypename = function(which, typename) {
        if (typename === void 0) {
          typename = which;
        }
        var rootId = "ROOT_" + which.toUpperCase();
        var old = this.rootTypenamesById[rootId];
        if (typename !== old) {
          invariant2(!old || old === which, 5, which);
          if (old)
            delete this.rootIdsByTypename[old];
          this.rootIdsByTypename[typename] = rootId;
          this.rootTypenamesById[rootId] = typename;
        }
      };
      Policies2.prototype.addPossibleTypes = function(possibleTypes) {
        var _this = this;
        this.usingPossibleTypes = true;
        Object.keys(possibleTypes).forEach(function(supertype) {
          _this.getSupertypeSet(supertype, true);
          possibleTypes[supertype].forEach(function(subtype) {
            _this.getSupertypeSet(subtype, true).add(supertype);
            var match = subtype.match(TypeOrFieldNameRegExp);
            if (!match || match[0] !== subtype) {
              _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
            }
          });
        });
      };
      Policies2.prototype.getTypePolicy = function(typename) {
        var _this = this;
        if (!hasOwn.call(this.typePolicies, typename)) {
          var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
          policy_1.fields = /* @__PURE__ */ Object.create(null);
          var supertypes_1 = this.supertypeMap.get(typename);
          if (!supertypes_1 && this.fuzzySubtypes.size) {
            supertypes_1 = this.getSupertypeSet(typename, true);
            this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
              if (regExp.test(typename)) {
                var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
                if (fuzzySupertypes) {
                  fuzzySupertypes.forEach(function(supertype) {
                    return supertypes_1.add(supertype);
                  });
                }
              }
            });
          }
          if (supertypes_1 && supertypes_1.size) {
            supertypes_1.forEach(function(supertype) {
              var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = __rest(_a2, ["fields"]);
              Object.assign(policy_1, rest);
              Object.assign(policy_1.fields, fields);
            });
          }
        }
        var inbox = this.toBeAdded[typename];
        if (inbox && inbox.length) {
          inbox.splice(0).forEach(function(policy) {
            _this.updateTypePolicy(typename, policy);
          });
        }
        return this.typePolicies[typename];
      };
      Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
        if (typename) {
          var fieldPolicies = this.getTypePolicy(typename).fields;
          return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
        }
      };
      Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
        var supertypeSet = this.supertypeMap.get(subtype);
        if (!supertypeSet && createIfMissing) {
          this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
        }
        return supertypeSet;
      };
      Policies2.prototype.fragmentMatches = function(fragment, typename, result2, variables) {
        var _this = this;
        if (!fragment.typeCondition)
          return true;
        if (!typename)
          return false;
        var supertype = fragment.typeCondition.name.value;
        if (typename === supertype)
          return true;
        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
          var typenameSupertypeSet = this.getSupertypeSet(typename, true);
          var workQueue_1 = [typenameSupertypeSet];
          var maybeEnqueue_1 = function(subtype) {
            var supertypeSet2 = _this.getSupertypeSet(subtype, false);
            if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
              workQueue_1.push(supertypeSet2);
            }
          };
          var needToCheckFuzzySubtypes = !!(result2 && this.fuzzySubtypes.size);
          var checkingFuzzySubtypes = false;
          for (var i = 0; i < workQueue_1.length; ++i) {
            var supertypeSet = workQueue_1[i];
            if (supertypeSet.has(supertype)) {
              if (!typenameSupertypeSet.has(supertype)) {
                if (checkingFuzzySubtypes) {
                  globalThis.__DEV__ !== false && invariant2.warn(6, typename, supertype);
                }
                typenameSupertypeSet.add(supertype);
              }
              return true;
            }
            supertypeSet.forEach(maybeEnqueue_1);
            if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all
            // non-fuzzy subtypes (after the final iteration of the loop).
            i === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result
            // after we verify the supertype, but this check is often less
            // expensive than that search, and we will have to do the
            // comparison anyway whenever we find a potential match.
            selectionSetMatchesResult(fragment.selectionSet, result2, variables)) {
              needToCheckFuzzySubtypes = false;
              checkingFuzzySubtypes = true;
              this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
                var match = typename.match(regExp);
                if (match && match[0] === typename) {
                  maybeEnqueue_1(fuzzyString);
                }
              });
            }
          }
        }
        return false;
      };
      Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return !!(policy && policy.keyFn);
      };
      Policies2.prototype.getStoreFieldName = function(fieldSpec) {
        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
        var policy = this.getFieldPolicy(typename, fieldName, false);
        var storeFieldName;
        var keyFn = policy && policy.keyFn;
        if (keyFn && typename) {
          var context = {
            typename,
            fieldName,
            field: fieldSpec.field || null,
            variables: fieldSpec.variables
          };
          var args = argsFromFieldSpecifier(fieldSpec);
          while (keyFn) {
            var specifierOrString = keyFn(args, context);
            if (isArray(specifierOrString)) {
              keyFn = keyArgsFnFromSpecifier(specifierOrString);
            } else {
              storeFieldName = specifierOrString || fieldName;
              break;
            }
          }
        }
        if (storeFieldName === void 0) {
          storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
        }
        if (storeFieldName === false) {
          return fieldName;
        }
        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
      };
      Policies2.prototype.readField = function(options, context) {
        var objectOrReference = options.from;
        if (!objectOrReference)
          return;
        var nameOrField = options.field || options.fieldName;
        if (!nameOrField)
          return;
        if (options.typename === void 0) {
          var typename = context.store.getFieldValue(objectOrReference, "__typename");
          if (typename)
            options.typename = typename;
        }
        var storeFieldName = this.getStoreFieldName(options);
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
        var policy = this.getFieldPolicy(options.typename, fieldName, false);
        var read = policy && policy.read;
        if (read) {
          var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
          return cacheSlot.withValue(this.cache, read, [
            existing,
            readOptions
          ]);
        }
        return existing;
      };
      Policies2.prototype.getReadFunction = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return policy && policy.read;
      };
      Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
        var policy = this.getFieldPolicy(parentTypename, fieldName, false);
        var merge = policy && policy.merge;
        if (!merge && childTypename) {
          policy = this.getTypePolicy(childTypename);
          merge = policy && policy.merge;
        }
        return merge;
      };
      Policies2.prototype.runMergeFunction = function(existing, incoming, _a2, context, storage) {
        var field = _a2.field, typename = _a2.typename, merge = _a2.merge;
        if (merge === mergeTrueFn) {
          return makeMergeObjectsFunction(context.store)(existing, incoming);
        }
        if (merge === mergeFalseFn) {
          return incoming;
        }
        if (context.overwrite) {
          existing = void 0;
        }
        return merge(existing, incoming, makeFieldFunctionOptions(
          this,
          // Unlike options.readField for read functions, we do not fall
          // back to the current object if no foreignObjOrRef is provided,
          // because it's not clear what the current object should be for
          // merge functions: the (possibly undefined) existing object, or
          // the incoming object? If you think your merge function needs
          // to read sibling fields in order to produce a new value for
          // the current field, you might want to rethink your strategy,
          // because that's a recipe for making merge behavior sensitive
          // to the order in which fields are written into the cache.
          // However, readField(name, ref) is useful for merge functions
          // that need to deduplicate child objects and references.
          void 0,
          {
            typename,
            fieldName: field.name.value,
            field,
            variables: context.variables
          },
          context,
          storage || /* @__PURE__ */ Object.create(null)
        ));
      };
      return Policies2;
    }();
  }
});

// ../node_modules/@apollo/client/cache/inmemory/writeToStore.js
function getContextFlavor(context, clientOnly, deferred) {
  var key = "".concat(clientOnly).concat(deferred);
  var flavored = context.flavors.get(key);
  if (!flavored) {
    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), { clientOnly, deferred }));
  }
  return flavored;
}
function getChildMergeTree(_a2, name) {
  var map = _a2.map;
  if (!map.has(name)) {
    map.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map.get(name);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;
  var needToMergeMaps = left.map.size && right.map.size;
  var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  var merged = { info, map };
  if (needToMergeMaps) {
    var remainingRightKeys_1 = new Set(right.map.keys());
    left.map.forEach(function(leftTree, key) {
      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
      remainingRightKeys_1.delete(key);
    });
    remainingRightKeys_1.forEach(function(key) {
      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree) {
  return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree(_a2, name) {
  var map = _a2.map;
  var childTree = map.get(name);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map.delete(name);
  }
}
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  var getChild = function(objOrRef) {
    var child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  var existing = getChild(existingRef);
  if (!existing)
    return;
  var incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference(existing))
    return;
  if (equal(existing, incoming))
    return;
  if (Object.keys(existing).every(function(key) {
    return store.getFieldValue(incoming, key) !== void 0;
  })) {
    return;
  }
  var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var typeDotName = "".concat(parentType, ".").concat(fieldName);
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  var childTypenames = [];
  if (!isArray(existing) && !isArray(incoming)) {
    [existing, incoming].forEach(function(child) {
      var typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  globalThis.__DEV__ !== false && invariant2.warn(14, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, __assign({}, existing), __assign({}, incoming));
}
var import_dist634, import_dist635, import_dist636, StoreWriter, emptyMergeTreePool, warnings;
var init_writeToStore = __esm({
  "../node_modules/@apollo/client/cache/inmemory/writeToStore.js"() {
    import_dist634 = __toESM(require_dist(), 1);
    import_dist635 = __toESM(require_dist2(), 1);
    import_dist636 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_lib6();
    init_lib();
    init_graphql2();
    init_utilities2();
    init_helpers2();
    init_policies();
    StoreWriter = /** @class */
    function() {
      function StoreWriter2(cache2, reader, fragments) {
        this.cache = cache2;
        this.reader = reader;
        this.fragments = fragments;
      }
      StoreWriter2.prototype.writeToStore = function(store, _a2) {
        var _this = this;
        var query = _a2.query, result2 = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
        var operationDefinition = getOperationDefinition(query);
        var merger = makeProcessedFieldsMerger();
        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);
        var context = __assign(__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
          return merger.merge(existing, incoming);
        }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
        var ref = this.processSelectionSet({
          result: result2 || /* @__PURE__ */ Object.create(null),
          dataId,
          selectionSet: operationDefinition.selectionSet,
          mergeTree: { map: /* @__PURE__ */ new Map() },
          context
        });
        if (!isReference(ref)) {
          throw newInvariantError(11, result2);
        }
        context.incomingById.forEach(function(_a3, dataId2) {
          var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
          var entityRef = makeReference(dataId2);
          if (mergeTree && mergeTree.map.size) {
            var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
            if (isReference(applied)) {
              return;
            }
            storeObject = applied;
          }
          if (globalThis.__DEV__ !== false && !context.overwrite) {
            var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
            fieldNodeSet.forEach(function(field) {
              if (field.selectionSet) {
                fieldsWithSelectionSets_1[field.name.value] = true;
              }
            });
            var hasSelectionSet_1 = function(storeFieldName) {
              return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
            };
            var hasMergeFunction_1 = function(storeFieldName) {
              var childTree = mergeTree && mergeTree.map.get(storeFieldName);
              return Boolean(childTree && childTree.info && childTree.info.merge);
            };
            Object.keys(storeObject).forEach(function(storeFieldName) {
              if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
                warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
              }
            });
          }
          store.merge(dataId2, storeObject);
        });
        store.retain(ref.__ref);
        return ref;
      };
      StoreWriter2.prototype.processSelectionSet = function(_a2) {
        var _this = this;
        var dataId = _a2.dataId, result2 = _a2.result, selectionSet = _a2.selectionSet, context = _a2.context, mergeTree = _a2.mergeTree;
        var policies = this.cache.policies;
        var incoming = /* @__PURE__ */ Object.create(null);
        var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result2, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
        if ("string" === typeof typename) {
          incoming.__typename = typename;
        }
        var readField = function() {
          var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
          if (isReference(options.from)) {
            var info = context.incomingById.get(options.from.__ref);
            if (info) {
              var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);
              if (result_1 !== void 0) {
                return result_1;
              }
            }
          }
          return policies.readField(options, context);
        };
        var fieldNodeSet = /* @__PURE__ */ new Set();
        this.flattenFields(
          selectionSet,
          result2,
          // This WriteContext will be the default context value for fields returned
          // by the flattenFields method, but some fields may be assigned a modified
          // context, depending on the presence of @client and other directives.
          context,
          typename
        ).forEach(function(context2, field) {
          var _a3;
          var resultFieldKey = resultKeyNameFromField(field);
          var value = result2[resultFieldKey];
          fieldNodeSet.add(field);
          if (value !== void 0) {
            var storeFieldName = policies.getStoreFieldName({
              typename,
              fieldName: field.name.value,
              field,
              variables: context2.variables
            });
            var childTree = getChildMergeTree(mergeTree, storeFieldName);
            var incomingValue = _this.processFieldValue(
              value,
              field,
              // Reset context.clientOnly and context.deferred to their default
              // values before processing nested selection sets.
              field.selectionSet ? getContextFlavor(context2, false, false) : context2,
              childTree
            );
            var childTypename = void 0;
            if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
              childTypename = readField("__typename", incomingValue);
            }
            var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
            if (merge) {
              childTree.info = {
                // TODO Check compatibility against any existing childTree.field?
                field,
                typename,
                merge
              };
            } else {
              maybeRecycleChildMergeTree(mergeTree, storeFieldName);
            }
            incoming = context2.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
          } else if (globalThis.__DEV__ !== false && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && // If the field has a read function, it may be a synthetic field or
          // provide a default value, so its absence from the written data should
          // not be cause for alarm.
          !policies.getReadFunction(typename, field.name.value)) {
            globalThis.__DEV__ !== false && invariant2.error(12, resultKeyNameFromField(field), result2);
          }
        });
        try {
          var _b = policies.identify(result2, {
            typename,
            selectionSet,
            fragmentMap: context.fragmentMap,
            storeObject: incoming,
            readField
          }), id = _b[0], keyObject = _b[1];
          dataId = dataId || id;
          if (keyObject) {
            incoming = context.merge(incoming, keyObject);
          }
        } catch (e) {
          if (!dataId)
            throw e;
        }
        if ("string" === typeof dataId) {
          var dataRef = makeReference(dataId);
          var sets = context.written[dataId] || (context.written[dataId] = []);
          if (sets.indexOf(selectionSet) >= 0)
            return dataRef;
          sets.push(selectionSet);
          if (this.reader && this.reader.isFresh(result2, dataRef, selectionSet, context)) {
            return dataRef;
          }
          var previous_1 = context.incomingById.get(dataId);
          if (previous_1) {
            previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
            previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
            fieldNodeSet.forEach(function(field) {
              return previous_1.fieldNodeSet.add(field);
            });
          } else {
            context.incomingById.set(dataId, {
              storeObject: incoming,
              // Save a reference to mergeTree only if it is not empty, because
              // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
              // reused for entirely different parts of the result tree.
              mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
              fieldNodeSet
            });
          }
          return dataRef;
        }
        return incoming;
      };
      StoreWriter2.prototype.processFieldValue = function(value, field, context, mergeTree) {
        var _this = this;
        if (!field.selectionSet || value === null) {
          return globalThis.__DEV__ !== false ? cloneDeep(value) : value;
        }
        if (isArray(value)) {
          return value.map(function(item, i) {
            var value2 = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));
            maybeRecycleChildMergeTree(mergeTree, i);
            return value2;
          });
        }
        return this.processSelectionSet({
          result: value,
          selectionSet: field.selectionSet,
          context,
          mergeTree
        });
      };
      StoreWriter2.prototype.flattenFields = function(selectionSet, result2, context, typename) {
        if (typename === void 0) {
          typename = getTypenameFromResult(result2, selectionSet, context.fragmentMap);
        }
        var fieldMap = /* @__PURE__ */ new Map();
        var policies = this.cache.policies;
        var limitingTrie = new Trie(false);
        (function flatten(selectionSet2, inheritedContext) {
          var visitedNode = limitingTrie.lookup(
            selectionSet2,
            // Because we take inheritedClientOnly and inheritedDeferred into
            // consideration here (in addition to selectionSet), it's possible for
            // the same selection set to be flattened more than once, if it appears
            // in the query with different @client and/or @directive configurations.
            inheritedContext.clientOnly,
            inheritedContext.deferred
          );
          if (visitedNode.visited)
            return;
          visitedNode.visited = true;
          selectionSet2.selections.forEach(function(selection) {
            if (!shouldInclude(selection, context.variables))
              return;
            var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
            if (
              // Since the presence of @client or @defer on this field can only
              // cause clientOnly or deferred to become true, we can skip the
              // forEach loop if both clientOnly and deferred are already true.
              !(clientOnly && deferred) && isNonEmptyArray(selection.directives)
            ) {
              selection.directives.forEach(function(dir) {
                var name = dir.name.value;
                if (name === "client")
                  clientOnly = true;
                if (name === "defer") {
                  var args = argumentsObjectFromField(dir, context.variables);
                  if (!args || args.if !== false) {
                    deferred = true;
                  }
                }
              });
            }
            if (isField(selection)) {
              var existing = fieldMap.get(selection);
              if (existing) {
                clientOnly = clientOnly && existing.clientOnly;
                deferred = deferred && existing.deferred;
              }
              fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
            } else {
              var fragment = getFragmentFromSelection(selection, context.lookupFragment);
              if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
                throw newInvariantError(13, selection.name.value);
              }
              if (fragment && policies.fragmentMatches(fragment, typename, result2, context.variables)) {
                flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
              }
            }
          });
        })(selectionSet, context);
        return fieldMap;
      };
      StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
        var _a2;
        var _this = this;
        if (mergeTree.map.size && !isReference(incoming)) {
          var e_1 = (
            // Items in the same position in different arrays are not
            // necessarily related to each other, so when incoming is an array
            // we process its elements as if there was no existing data.
            !isArray(incoming) && // Likewise, existing must be either a Reference or a StoreObject
            // in order for its fields to be safe to merge with the fields of
            // the incoming object.
            (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0
          );
          var i_1 = incoming;
          if (e_1 && !getStorageArgs) {
            getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
          }
          var changedFields_1;
          var getValue_1 = function(from2, name) {
            return isArray(from2) ? typeof name === "number" ? from2[name] : void 0 : context.store.getFieldValue(from2, String(name));
          };
          mergeTree.map.forEach(function(childTree, storeFieldName) {
            var eVal = getValue_1(e_1, storeFieldName);
            var iVal = getValue_1(i_1, storeFieldName);
            if (void 0 === iVal)
              return;
            if (getStorageArgs) {
              getStorageArgs.push(storeFieldName);
            }
            var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
            if (aVal !== iVal) {
              changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
              changedFields_1.set(storeFieldName, aVal);
            }
            if (getStorageArgs) {
              invariant2(getStorageArgs.pop() === storeFieldName);
            }
          });
          if (changedFields_1) {
            incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);
            changedFields_1.forEach(function(value, name) {
              incoming[name] = value;
            });
          }
        }
        if (mergeTree.info) {
          return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a2 = context.store).getStorage.apply(_a2, getStorageArgs));
        }
        return incoming;
      };
      return StoreWriter2;
    }();
    emptyMergeTreePool = [];
    warnings = /* @__PURE__ */ new Set();
  }
});

// ../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js
var import_dist637, import_dist638, import_dist639, InMemoryCache;
var init_inMemoryCache = __esm({
  "../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js"() {
    import_dist637 = __toESM(require_dist(), 1);
    import_dist638 = __toESM(require_dist2(), 1);
    import_dist639 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_fixPolyfills();
    init_lib5();
    init_lib6();
    init_cache();
    init_common();
    init_utilities2();
    init_readFromStore();
    init_writeToStore();
    init_entityStore();
    init_reactiveVars();
    init_policies();
    init_helpers2();
    init_getMemoryInternals();
    InMemoryCache = /** @class */
    function(_super) {
      __extends(InMemoryCache2, _super);
      function InMemoryCache2(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this) || this;
        _this.watches = /* @__PURE__ */ new Set();
        _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);
        _this.assumeImmutableResults = true;
        _this.makeVar = makeVar;
        _this.txCount = 0;
        _this.config = normalizeConfig(config);
        _this.addTypename = !!_this.config.addTypename;
        _this.policies = new Policies({
          cache: _this,
          dataIdFromObject: _this.config.dataIdFromObject,
          possibleTypes: _this.config.possibleTypes,
          typePolicies: _this.config.typePolicies
        });
        _this.init();
        return _this;
      }
      InMemoryCache2.prototype.init = function() {
        var rootStore = this.data = new EntityStore.Root({
          policies: this.policies,
          resultCaching: this.config.resultCaching
        });
        this.optimisticData = rootStore.stump;
        this.resetResultCache();
      };
      InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
        var _this = this;
        var previousReader = this.storeReader;
        var fragments = this.config.fragments;
        this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
          cache: this,
          addTypename: this.addTypename,
          resultCacheMaxSize: this.config.resultCacheMaxSize,
          canonizeResults: shouldCanonizeResults(this.config),
          canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
          fragments
        }), fragments);
        this.maybeBroadcastWatch = wrap3(function(c, options) {
          return _this.broadcastWatch(c, options);
        }, {
          max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
          makeCacheKey: function(c) {
            var store = c.optimistic ? _this.optimisticData : _this.data;
            if (supportsResultCaching(store)) {
              var optimistic = c.optimistic, id = c.id, variables = c.variables;
              return store.makeCacheKey(
                c.query,
                // Different watches can have the same query, optimistic
                // status, rootId, and variables, but if their callbacks are
                // different, the (identical) result needs to be delivered to
                // each distinct callback. The easiest way to achieve that
                // separation is to include c.callback in the cache key for
                // maybeBroadcastWatch calls. See issue #5733.
                c.callback,
                canonicalStringify({ optimistic, id, variables })
              );
            }
          }
        });
        (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
          return group.resetCaching();
        });
      };
      InMemoryCache2.prototype.restore = function(data) {
        this.init();
        if (data)
          this.data.replace(data);
        return this;
      };
      InMemoryCache2.prototype.extract = function(optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return (optimistic ? this.optimisticData : this.data).extract();
      };
      InMemoryCache2.prototype.read = function(options) {
        var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
        try {
          return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
        } catch (e) {
          if (e instanceof MissingFieldError) {
            return null;
          }
          throw e;
        }
      };
      InMemoryCache2.prototype.write = function(options) {
        try {
          ++this.txCount;
          return this.storeWriter.writeToStore(this.data, options);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache2.prototype.modify = function(options) {
        if (hasOwn.call(options, "id") && !options.id) {
          return false;
        }
        var store = options.optimistic ? this.optimisticData : this.data;
        try {
          ++this.txCount;
          return store.modify(options.id || "ROOT_QUERY", options.fields);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache2.prototype.diff = function(options) {
        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
      };
      InMemoryCache2.prototype.watch = function(watch) {
        var _this = this;
        if (!this.watches.size) {
          recallCache(this);
        }
        this.watches.add(watch);
        if (watch.immediate) {
          this.maybeBroadcastWatch(watch);
        }
        return function() {
          if (_this.watches.delete(watch) && !_this.watches.size) {
            forgetCache(_this);
          }
          _this.maybeBroadcastWatch.forget(watch);
        };
      };
      InMemoryCache2.prototype.gc = function(options) {
        var _a2;
        canonicalStringify.reset();
        print2.reset();
        this.addTypenameTransform.resetCache();
        (_a2 = this.config.fragments) === null || _a2 === void 0 ? void 0 : _a2.resetCaches();
        var ids = this.optimisticData.gc();
        if (options && !this.txCount) {
          if (options.resetResultCache) {
            this.resetResultCache(options.resetResultIdentities);
          } else if (options.resetResultIdentities) {
            this.storeReader.resetCanon();
          }
        }
        return ids;
      };
      InMemoryCache2.prototype.retain = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).retain(rootId);
      };
      InMemoryCache2.prototype.release = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).release(rootId);
      };
      InMemoryCache2.prototype.identify = function(object) {
        if (isReference(object))
          return object.__ref;
        try {
          return this.policies.identify(object)[0];
        } catch (e) {
          globalThis.__DEV__ !== false && invariant2.warn(e);
        }
      };
      InMemoryCache2.prototype.evict = function(options) {
        if (!options.id) {
          if (hasOwn.call(options, "id")) {
            return false;
          }
          options = __assign(__assign({}, options), { id: "ROOT_QUERY" });
        }
        try {
          ++this.txCount;
          return this.optimisticData.evict(options, this.data);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache2.prototype.reset = function(options) {
        var _this = this;
        this.init();
        canonicalStringify.reset();
        if (options && options.discardWatches) {
          this.watches.forEach(function(watch) {
            return _this.maybeBroadcastWatch.forget(watch);
          });
          this.watches.clear();
          forgetCache(this);
        } else {
          this.broadcastWatches();
        }
        return Promise.resolve();
      };
      InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
        if (newOptimisticData !== this.optimisticData) {
          this.optimisticData = newOptimisticData;
          this.broadcastWatches();
        }
      };
      InMemoryCache2.prototype.batch = function(options) {
        var _this = this;
        var update = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
        var updateResult;
        var perform = function(layer) {
          var _a3 = _this, data = _a3.data, optimisticData = _a3.optimisticData;
          ++_this.txCount;
          if (layer) {
            _this.data = _this.optimisticData = layer;
          }
          try {
            return updateResult = update(_this);
          } finally {
            --_this.txCount;
            _this.data = data;
            _this.optimisticData = optimisticData;
          }
        };
        var alreadyDirty = /* @__PURE__ */ new Set();
        if (onWatchUpdated && !this.txCount) {
          this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function(watch) {
            alreadyDirty.add(watch);
            return false;
          } }));
        }
        if (typeof optimistic === "string") {
          this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
        } else if (optimistic === false) {
          perform(this.data);
        } else {
          perform();
        }
        if (typeof removeOptimistic === "string") {
          this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
        }
        if (onWatchUpdated && alreadyDirty.size) {
          this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function(watch, diff2) {
            var result2 = onWatchUpdated.call(this, watch, diff2);
            if (result2 !== false) {
              alreadyDirty.delete(watch);
            }
            return result2;
          } }));
          if (alreadyDirty.size) {
            alreadyDirty.forEach(function(watch) {
              return _this.maybeBroadcastWatch.dirty(watch);
            });
          }
        } else {
          this.broadcastWatches(options);
        }
        return updateResult;
      };
      InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
        return this.batch({
          update,
          optimistic: optimisticId || optimisticId !== null
        });
      };
      InMemoryCache2.prototype.transformDocument = function(document) {
        return this.addTypenameToDocument(this.addFragmentsToDocument(document));
      };
      InMemoryCache2.prototype.broadcastWatches = function(options) {
        var _this = this;
        if (!this.txCount) {
          this.watches.forEach(function(c) {
            return _this.maybeBroadcastWatch(c, options);
          });
        }
      };
      InMemoryCache2.prototype.addFragmentsToDocument = function(document) {
        var fragments = this.config.fragments;
        return fragments ? fragments.transform(document) : document;
      };
      InMemoryCache2.prototype.addTypenameToDocument = function(document) {
        if (this.addTypename) {
          return this.addTypenameTransform.transformDocument(document);
        }
        return document;
      };
      InMemoryCache2.prototype.broadcastWatch = function(c, options) {
        var lastDiff = c.lastDiff;
        var diff2 = this.diff(c);
        if (options) {
          if (c.optimistic && typeof options.optimistic === "string") {
            diff2.fromOptimisticTransaction = true;
          }
          if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff2, lastDiff) === false) {
            return;
          }
        }
        if (!lastDiff || !equal(lastDiff.result, diff2.result)) {
          c.callback(c.lastDiff = diff2, lastDiff);
        }
      };
      return InMemoryCache2;
    }(ApolloCache);
    if (globalThis.__DEV__ !== false) {
      InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;
    }
  }
});

// ../node_modules/@apollo/client/cache/core/types/Cache.js
var import_dist640, import_dist641, import_dist642, Cache;
var init_Cache = __esm({
  "../node_modules/@apollo/client/cache/core/types/Cache.js"() {
    import_dist640 = __toESM(require_dist(), 1);
    import_dist641 = __toESM(require_dist2(), 1);
    import_dist642 = __toESM(require_dist3(), 1);
    /* @__PURE__ */ (function(Cache2) {
    })(Cache || (Cache = {}));
  }
});

// ../node_modules/@apollo/client/cache/inmemory/fragmentRegistry.js
var import_dist643, import_dist644, import_dist645, FragmentRegistry;
var init_fragmentRegistry = __esm({
  "../node_modules/@apollo/client/cache/inmemory/fragmentRegistry.js"() {
    import_dist643 = __toESM(require_dist(), 1);
    import_dist644 = __toESM(require_dist2(), 1);
    import_dist645 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_graphql2();
    init_lib5();
    init_utilities2();
    init_lib2();
    FragmentRegistry = /** @class */
    function() {
      function FragmentRegistry2() {
        var fragments = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fragments[_i] = arguments[_i];
        }
        this.registry = /* @__PURE__ */ Object.create(null);
        this.resetCaches();
        if (fragments.length) {
          this.register.apply(this, fragments);
        }
      }
      FragmentRegistry2.prototype.register = function() {
        var _this = this;
        var fragments = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fragments[_i] = arguments[_i];
        }
        var definitions = /* @__PURE__ */ new Map();
        fragments.forEach(function(doc) {
          getFragmentDefinitions(doc).forEach(function(node) {
            definitions.set(node.name.value, node);
          });
        });
        definitions.forEach(function(node, name) {
          if (node !== _this.registry[name]) {
            _this.registry[name] = node;
            _this.invalidate(name);
          }
        });
        return this;
      };
      FragmentRegistry2.prototype.invalidate = function(name) {
      };
      FragmentRegistry2.prototype.resetCaches = function() {
        var proto = FragmentRegistry2.prototype;
        this.invalidate = (this.lookup = wrap3(proto.lookup.bind(this), {
          makeCacheKey: function(arg) {
            return arg;
          },
          max: cacheSizes["fragmentRegistry.lookup"] || 1e3
        })).dirty;
        this.transform = wrap3(proto.transform.bind(this), {
          cache: WeakCache,
          max: cacheSizes["fragmentRegistry.transform"] || 2e3
        });
        this.findFragmentSpreads = wrap3(proto.findFragmentSpreads.bind(this), {
          cache: WeakCache,
          max: cacheSizes["fragmentRegistry.findFragmentSpreads"] || 4e3
        });
      };
      FragmentRegistry2.prototype.lookup = function(fragmentName) {
        return this.registry[fragmentName] || null;
      };
      FragmentRegistry2.prototype.transform = function(document) {
        var _this = this;
        var defined = /* @__PURE__ */ new Map();
        getFragmentDefinitions(document).forEach(function(def) {
          defined.set(def.name.value, def);
        });
        var unbound = /* @__PURE__ */ new Set();
        var enqueue2 = function(spreadName) {
          if (!defined.has(spreadName)) {
            unbound.add(spreadName);
          }
        };
        var enqueueChildSpreads = function(node) {
          return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue2);
        };
        enqueueChildSpreads(document);
        var missing = [];
        var map = /* @__PURE__ */ Object.create(null);
        unbound.forEach(function(fragmentName) {
          var knownFragmentDef = defined.get(fragmentName);
          if (knownFragmentDef) {
            enqueueChildSpreads(map[fragmentName] = knownFragmentDef);
          } else {
            missing.push(fragmentName);
            var def = _this.lookup(fragmentName);
            if (def) {
              enqueueChildSpreads(map[fragmentName] = def);
            }
          }
        });
        if (missing.length) {
          var defsToAppend_1 = [];
          missing.forEach(function(name) {
            var def = map[name];
            if (def) {
              defsToAppend_1.push(def);
            }
          });
          if (defsToAppend_1.length) {
            document = __assign(__assign({}, document), { definitions: document.definitions.concat(defsToAppend_1) });
          }
        }
        return document;
      };
      FragmentRegistry2.prototype.findFragmentSpreads = function(root2) {
        var spreads = /* @__PURE__ */ Object.create(null);
        visit(root2, {
          FragmentSpread: function(node) {
            spreads[node.name.value] = node;
          }
        });
        return spreads;
      };
      return FragmentRegistry2;
    }();
  }
});

// ../node_modules/@apollo/client/cache/inmemory/types.js
var import_dist646, import_dist647, import_dist648;
var init_types2 = __esm({
  "../node_modules/@apollo/client/cache/inmemory/types.js"() {
    import_dist646 = __toESM(require_dist(), 1);
    import_dist647 = __toESM(require_dist2(), 1);
    import_dist648 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/cache/index.js
var import_dist649, import_dist650, import_dist651;
var init_cache2 = __esm({
  "../node_modules/@apollo/client/cache/index.js"() {
    import_dist649 = __toESM(require_dist(), 1);
    import_dist650 = __toESM(require_dist2(), 1);
    import_dist651 = __toESM(require_dist3(), 1);
    init_globals();
    init_cache();
    init_Cache();
    init_common();
    init_utilities2();
    init_entityStore();
    init_helpers2();
    init_inMemoryCache();
    init_reactiveVars();
    init_policies();
    init_fragmentRegistry();
    init_types2();
  }
});

// ../node_modules/@apollo/client/link/http/iterators/async.js
function asyncIterator(source) {
  var _a2;
  var iterator = source[Symbol.asyncIterator]();
  return _a2 = {
    next: function() {
      return iterator.next();
    }
  }, _a2[Symbol.asyncIterator] = function() {
    return this;
  }, _a2;
}
var import_dist652, import_dist653, import_dist654;
var init_async = __esm({
  "../node_modules/@apollo/client/link/http/iterators/async.js"() {
    import_dist652 = __toESM(require_dist(), 1);
    import_dist653 = __toESM(require_dist2(), 1);
    import_dist654 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/link/http/iterators/nodeStream.js
function nodeStreamIterator(stream) {
  var cleanup = null;
  var error = null;
  var done = false;
  var data = [];
  var waiting = [];
  function onData(chunk) {
    if (error)
      return;
    if (waiting.length) {
      var shiftedArr = waiting.shift();
      if (Array.isArray(shiftedArr) && shiftedArr[0]) {
        return shiftedArr[0]({ value: chunk, done: false });
      }
    }
    data.push(chunk);
  }
  function onError(err) {
    error = err;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[1](err);
    });
    !cleanup || cleanup();
  }
  function onEnd() {
    done = true;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[0]({ value: void 0, done: true });
    });
    !cleanup || cleanup();
  }
  cleanup = function() {
    cleanup = null;
    stream.removeListener("data", onData);
    stream.removeListener("error", onError);
    stream.removeListener("end", onEnd);
    stream.removeListener("finish", onEnd);
    stream.removeListener("close", onEnd);
  };
  stream.on("data", onData);
  stream.on("error", onError);
  stream.on("end", onEnd);
  stream.on("finish", onEnd);
  stream.on("close", onEnd);
  function getNext() {
    return new Promise(function(resolve, reject) {
      if (error)
        return reject(error);
      if (data.length)
        return resolve({ value: data.shift(), done: false });
      if (done)
        return resolve({ value: void 0, done: true });
      waiting.push([resolve, reject]);
    });
  }
  var iterator = {
    next: function() {
      return getNext();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
var import_dist655, import_dist656, import_dist657;
var init_nodeStream = __esm({
  "../node_modules/@apollo/client/link/http/iterators/nodeStream.js"() {
    import_dist655 = __toESM(require_dist(), 1);
    import_dist656 = __toESM(require_dist2(), 1);
    import_dist657 = __toESM(require_dist3(), 1);
    init_utilities2();
  }
});

// ../node_modules/@apollo/client/link/http/iterators/promise.js
function promiseIterator(promise) {
  var resolved = false;
  var iterator = {
    next: function() {
      if (resolved)
        return Promise.resolve({
          value: void 0,
          done: true
        });
      resolved = true;
      return new Promise(function(resolve, reject) {
        promise.then(function(value) {
          resolve({ value, done: false });
        }).catch(reject);
      });
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
var import_dist658, import_dist659, import_dist660;
var init_promise = __esm({
  "../node_modules/@apollo/client/link/http/iterators/promise.js"() {
    import_dist658 = __toESM(require_dist(), 1);
    import_dist659 = __toESM(require_dist2(), 1);
    import_dist660 = __toESM(require_dist3(), 1);
    init_utilities2();
  }
});

// ../node_modules/@apollo/client/link/http/iterators/reader.js
function readerIterator(reader) {
  var iterator = {
    next: function() {
      return reader.read();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
var import_dist661, import_dist662, import_dist663;
var init_reader = __esm({
  "../node_modules/@apollo/client/link/http/iterators/reader.js"() {
    import_dist661 = __toESM(require_dist(), 1);
    import_dist662 = __toESM(require_dist2(), 1);
    import_dist663 = __toESM(require_dist3(), 1);
    init_utilities2();
  }
});

// ../node_modules/@apollo/client/link/http/responseIterator.js
function isNodeResponse(value) {
  return !!value.body;
}
function isReadableStream(value) {
  return !!value.getReader;
}
function isAsyncIterableIterator(value) {
  return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
}
function isStreamableBlob(value) {
  return !!value.stream;
}
function isBlob(value) {
  return !!value.arrayBuffer;
}
function isNodeReadableStream(value) {
  return !!value.pipe;
}
function responseIterator(response) {
  var body = response;
  if (isNodeResponse(response))
    body = response.body;
  if (isAsyncIterableIterator(body))
    return asyncIterator(body);
  if (isReadableStream(body))
    return readerIterator(body.getReader());
  if (isStreamableBlob(body)) {
    return readerIterator(body.stream().getReader());
  }
  if (isBlob(body))
    return promiseIterator(body.arrayBuffer());
  if (isNodeReadableStream(body))
    return nodeStreamIterator(body);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var import_dist664, import_dist665, import_dist666;
var init_responseIterator = __esm({
  "../node_modules/@apollo/client/link/http/responseIterator.js"() {
    import_dist664 = __toESM(require_dist(), 1);
    import_dist665 = __toESM(require_dist2(), 1);
    import_dist666 = __toESM(require_dist3(), 1);
    init_utilities2();
    init_async();
    init_nodeStream();
    init_promise();
    init_reader();
  }
});

// ../node_modules/@apollo/client/errors/index.js
function graphQLResultHasProtocolErrors(result2) {
  if (result2.extensions) {
    return Array.isArray(result2.extensions[PROTOCOL_ERRORS_SYMBOL]);
  }
  return false;
}
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var import_dist667, import_dist668, import_dist669, PROTOCOL_ERRORS_SYMBOL, generateErrorMessage, ApolloError;
var init_errors = __esm({
  "../node_modules/@apollo/client/errors/index.js"() {
    import_dist667 = __toESM(require_dist(), 1);
    import_dist668 = __toESM(require_dist2(), 1);
    import_dist669 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_utilities2();
    PROTOCOL_ERRORS_SYMBOL = Symbol();
    generateErrorMessage = function(err) {
      var errors = __spreadArray(__spreadArray(__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
      if (err.networkError)
        errors.push(err.networkError);
      return errors.map(function(err2) {
        return isNonNullObject(err2) && err2.message || "Error message not found.";
      }).join("\n");
    };
    ApolloError = /** @class */
    function(_super) {
      __extends(ApolloError2, _super);
      function ApolloError2(_a2) {
        var graphQLErrors = _a2.graphQLErrors, protocolErrors = _a2.protocolErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.name = "ApolloError";
        _this.graphQLErrors = graphQLErrors || [];
        _this.protocolErrors = protocolErrors || [];
        _this.clientErrors = clientErrors || [];
        _this.networkError = networkError || null;
        _this.message = errorMessage || generateErrorMessage(_this);
        _this.extraInfo = extraInfo;
        _this.cause = __spreadArray(__spreadArray(__spreadArray([
          networkError
        ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e) {
          return !!e;
        }) || null;
        _this.__proto__ = ApolloError2.prototype;
        return _this;
      }
      return ApolloError2;
    }(Error);
  }
});

// ../node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js
function readMultipartBody(response, nextValue) {
  return __awaiter(this, void 0, void 0, function() {
    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a2, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result2, next;
    var _b, _c;
    var _d;
    return __generator(this, function(_e) {
      switch (_e.label) {
        case 0:
          if (TextDecoder === void 0) {
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          }
          decoder = new TextDecoder("utf-8");
          contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
          delimiter = "boundary=";
          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
          boundary = "\r\n--".concat(boundaryVal);
          buffer = "";
          iterator = responseIterator(response);
          running = true;
          _e.label = 1;
        case 1:
          if (!running) return [3, 3];
          return [4, iterator.next()];
        case 2:
          _a2 = _e.sent(), value = _a2.value, done = _a2.done;
          chunk = typeof value === "string" ? value : decoder.decode(value);
          searchFrom = buffer.length - boundary.length + 1;
          running = !done;
          buffer += chunk;
          bi = buffer.indexOf(boundary, searchFrom);
          while (bi > -1) {
            message = void 0;
            _b = [
              buffer.slice(0, bi),
              buffer.slice(bi + boundary.length)
            ], message = _b[0], buffer = _b[1];
            i = message.indexOf("\r\n\r\n");
            headers = parseHeaders(message.slice(0, i));
            contentType_1 = headers["content-type"];
            if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
              throw new Error("Unsupported patch content type: application/json is required.");
            }
            body = message.slice(i);
            if (body) {
              result2 = parseJsonBody(response, body);
              if (Object.keys(result2).length > 1 || "data" in result2 || "incremental" in result2 || "errors" in result2 || "payload" in result2) {
                if (isApolloPayloadResult(result2)) {
                  next = {};
                  if ("payload" in result2) {
                    if (Object.keys(result2).length === 1 && result2.payload === null) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    next = __assign({}, result2.payload);
                  }
                  if ("errors" in result2) {
                    next = __assign(__assign({}, next), { extensions: __assign(__assign({}, "extensions" in next ? next.extensions : null), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result2.errors, _c)) });
                  }
                  nextValue(next);
                } else {
                  nextValue(result2);
                }
              } else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(result2).length === 1 && "hasNext" in result2 && !result2.hasNext
              ) {
                return [
                  2
                  /*return*/
                ];
              }
            }
            bi = buffer.indexOf(boundary);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function parseHeaders(headerText) {
  var headersInit = {};
  headerText.split("\n").forEach(function(line) {
    var i = line.indexOf(":");
    if (i > -1) {
      var name_1 = line.slice(0, i).trim().toLowerCase();
      var value = line.slice(i + 1).trim();
      headersInit[name_1] = value;
    }
  });
  return headersInit;
}
function parseJsonBody(response, bodyText) {
  if (response.status >= 300) {
    var getResult = function() {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        return bodyText;
      }
    };
    throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
  }
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    var parseError = err;
    parseError.name = "ServerParseError";
    parseError.response = response;
    parseError.statusCode = response.status;
    parseError.bodyText = bodyText;
    throw parseError;
  }
}
function handleError(err, observer) {
  if (err.result && err.result.errors && err.result.data) {
    observer.next(err.result);
  }
  observer.error(err);
}
function parseAndCheckHttpResponse(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      return parseJsonBody(response, bodyText);
    }).then(function(result2) {
      if (!Array.isArray(result2) && !hasOwnProperty7.call(result2, "data") && !hasOwnProperty7.call(result2, "errors")) {
        throwServerError(response, result2, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName, "'."));
      }
      return result2;
    });
  };
}
var import_dist670, import_dist671, import_dist672, hasOwnProperty7;
var init_parseAndCheckHttpResponse = __esm({
  "../node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js"() {
    import_dist670 = __toESM(require_dist(), 1);
    import_dist671 = __toESM(require_dist2(), 1);
    import_dist672 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_responseIterator();
    init_utils();
    init_errors();
    init_incrementalResult();
    hasOwnProperty7 = Object.prototype.hasOwnProperty;
  }
});

// ../node_modules/@apollo/client/link/http/serializeFetchParameter.js
var import_dist673, import_dist674, import_dist675, serializeFetchParameter;
var init_serializeFetchParameter = __esm({
  "../node_modules/@apollo/client/link/http/serializeFetchParameter.js"() {
    import_dist673 = __toESM(require_dist(), 1);
    import_dist674 = __toESM(require_dist2(), 1);
    import_dist675 = __toESM(require_dist3(), 1);
    init_globals();
    serializeFetchParameter = function(p, label) {
      var serialized;
      try {
        serialized = JSON.stringify(p);
      } catch (e) {
        var parseError = newInvariantError(39, label, e.message);
        parseError.parseError = e;
        throw parseError;
      }
      return serialized;
    };
  }
});

// ../node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js
function selectHttpOptionsAndBody(operation, fallbackConfig) {
  var configs = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }
  configs.unshift(fallbackConfig);
  return selectHttpOptionsAndBodyInternal.apply(void 0, __spreadArray([
    operation,
    defaultPrinter
  ], configs, false));
}
function selectHttpOptionsAndBodyInternal(operation, printer) {
  var configs = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }
  var options = {};
  var http = {};
  configs.forEach(function(config) {
    options = __assign(__assign(__assign({}, options), config.options), { headers: __assign(__assign({}, options.headers), config.headers) });
    if (config.credentials) {
      options.credentials = config.credentials;
    }
    http = __assign(__assign({}, http), config.http);
  });
  if (options.headers) {
    options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
  }
  var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
  var body = { operationName: operationName2, variables };
  if (http.includeExtensions)
    body.extensions = extensions;
  if (http.includeQuery)
    body.query = printer(query, print2);
  return {
    options,
    body
  };
}
function removeDuplicateHeaders(headers, preserveHeaderCase) {
  if (!preserveHeaderCase) {
    var normalizedHeaders_1 = /* @__PURE__ */ Object.create(null);
    Object.keys(Object(headers)).forEach(function(name) {
      normalizedHeaders_1[name.toLowerCase()] = headers[name];
    });
    return normalizedHeaders_1;
  }
  var headerData = /* @__PURE__ */ Object.create(null);
  Object.keys(Object(headers)).forEach(function(name) {
    headerData[name.toLowerCase()] = {
      originalName: name,
      value: headers[name]
    };
  });
  var normalizedHeaders = /* @__PURE__ */ Object.create(null);
  Object.keys(headerData).forEach(function(name) {
    normalizedHeaders[headerData[name].originalName] = headerData[name].value;
  });
  return normalizedHeaders;
}
var import_dist676, import_dist677, import_dist678, defaultHttpOptions, defaultHeaders, defaultOptions, fallbackHttpConfig, defaultPrinter;
var init_selectHttpOptionsAndBody = __esm({
  "../node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js"() {
    import_dist676 = __toESM(require_dist(), 1);
    import_dist677 = __toESM(require_dist2(), 1);
    import_dist678 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_utilities2();
    defaultHttpOptions = {
      includeQuery: true,
      includeExtensions: false,
      preserveHeaderCase: false
    };
    defaultHeaders = {
      // headers are case insensitive (https://stackoverflow.com/a/5259004)
      accept: "*/*",
      // The content-type header describes the type of the body of the request, and
      // so it typically only is sent with requests that actually have bodies. One
      // could imagine that Apollo Client would remove this header when constructing
      // a GET request (which has no body), but we historically have not done that.
      // This means that browsers will preflight all Apollo Client requests (even
      // GET requests). Apollo Server's CSRF prevention feature (introduced in
      // AS3.7) takes advantage of this fact and does not block requests with this
      // header. If you want to drop this header from GET requests, then you should
      // probably replace it with a `apollo-require-preflight` header, or servers
      // with CSRF prevention enabled might block your GET request. See
      // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
      // for more details.
      "content-type": "application/json"
    };
    defaultOptions = {
      method: "POST"
    };
    fallbackHttpConfig = {
      http: defaultHttpOptions,
      headers: defaultHeaders,
      options: defaultOptions
    };
    defaultPrinter = function(ast, printer) {
      return printer(ast);
    };
  }
});

// ../node_modules/@apollo/client/link/http/checkFetcher.js
var import_dist679, import_dist680, import_dist681, checkFetcher;
var init_checkFetcher = __esm({
  "../node_modules/@apollo/client/link/http/checkFetcher.js"() {
    import_dist679 = __toESM(require_dist(), 1);
    import_dist680 = __toESM(require_dist2(), 1);
    import_dist681 = __toESM(require_dist3(), 1);
    init_globals();
    checkFetcher = function(fetcher) {
      if (!fetcher && typeof fetch === "undefined") {
        throw newInvariantError(37);
      }
    };
  }
});

// ../node_modules/@apollo/client/link/http/createSignalIfSupported.js
var import_dist682, import_dist683, import_dist684, createSignalIfSupported;
var init_createSignalIfSupported = __esm({
  "../node_modules/@apollo/client/link/http/createSignalIfSupported.js"() {
    import_dist682 = __toESM(require_dist(), 1);
    import_dist683 = __toESM(require_dist2(), 1);
    import_dist684 = __toESM(require_dist3(), 1);
    createSignalIfSupported = function() {
      if (typeof AbortController === "undefined")
        return { controller: false, signal: false };
      var controller = new AbortController();
      var signal = controller.signal;
      return { controller, signal };
    };
  }
});

// ../node_modules/@apollo/client/link/http/selectURI.js
var import_dist685, import_dist686, import_dist687, selectURI;
var init_selectURI = __esm({
  "../node_modules/@apollo/client/link/http/selectURI.js"() {
    import_dist685 = __toESM(require_dist(), 1);
    import_dist686 = __toESM(require_dist2(), 1);
    import_dist687 = __toESM(require_dist3(), 1);
    selectURI = function(operation, fallbackURI) {
      var context = operation.getContext();
      var contextURI = context.uri;
      if (contextURI) {
        return contextURI;
      } else if (typeof fallbackURI === "function") {
        return fallbackURI(operation);
      } else {
        return fallbackURI || "/graphql";
      }
    };
  }
});

// ../node_modules/@apollo/client/link/http/rewriteURIForGET.js
function rewriteURIForGET(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}
var import_dist688, import_dist689, import_dist690;
var init_rewriteURIForGET = __esm({
  "../node_modules/@apollo/client/link/http/rewriteURIForGET.js"() {
    import_dist688 = __toESM(require_dist(), 1);
    import_dist689 = __toESM(require_dist2(), 1);
    import_dist690 = __toESM(require_dist3(), 1);
    init_serializeFetchParameter();
  }
});

// ../node_modules/@apollo/client/link/http/createHttpLink.js
var import_dist691, import_dist692, import_dist693, backupFetch, createHttpLink;
var init_createHttpLink = __esm({
  "../node_modules/@apollo/client/link/http/createHttpLink.js"() {
    import_dist691 = __toESM(require_dist(), 1);
    import_dist692 = __toESM(require_dist2(), 1);
    import_dist693 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_core();
    init_utilities2();
    init_serializeFetchParameter();
    init_selectURI();
    init_parseAndCheckHttpResponse();
    init_checkFetcher();
    init_selectHttpOptionsAndBody();
    init_rewriteURIForGET();
    init_utils();
    init_utilities2();
    backupFetch = maybe(function() {
      return fetch;
    });
    createHttpLink = function(linkOptions) {
      if (linkOptions === void 0) {
        linkOptions = {};
      }
      var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print3 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
      if (globalThis.__DEV__ !== false) {
        checkFetcher(preferredFetch || backupFetch);
      }
      var linkConfig = {
        http: { includeExtensions, preserveHeaderCase },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers
      };
      return new ApolloLink(function(operation) {
        var chosenURI = selectURI(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
          var _a3 = context.clientAwareness, name_1 = _a3.name, version3 = _a3.version;
          if (name_1) {
            clientAwarenessHeaders["apollographql-client-name"] = name_1;
          }
          if (version3) {
            clientAwarenessHeaders["apollographql-client-version"] = version3;
          }
        }
        var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);
        var contextConfig = {
          http: context.http,
          options: context.fetchOptions,
          credentials: context.credentials,
          headers: contextHeaders
        };
        if (hasDirectives(["client"], operation.query)) {
          var transformedQuery = removeClientSetsFromDocument(operation.query);
          if (!transformedQuery) {
            return fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
          }
          operation.query = transformedQuery;
        }
        var _b2 = selectHttpOptionsAndBodyInternal(operation, print3, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
        if (body.variables && !includeUnusedVariables) {
          body.variables = filterOperationVariables(body.variables, operation.query);
        }
        var controller;
        if (!options.signal && typeof AbortController !== "undefined") {
          controller = new AbortController();
          options.signal = controller.signal;
        }
        var definitionIsMutation = function(d) {
          return d.kind === "OperationDefinition" && d.operation === "mutation";
        };
        var definitionIsSubscription = function(d) {
          return d.kind === "OperationDefinition" && d.operation === "subscription";
        };
        var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));
        var hasDefer = hasDirectives(["defer"], operation.query);
        if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
          options.method = "GET";
        }
        if (hasDefer || isSubscription) {
          options.headers = options.headers || {};
          var acceptHeader = "multipart/mixed;";
          if (isSubscription && hasDefer) {
            globalThis.__DEV__ !== false && invariant2.warn(38);
          }
          if (isSubscription) {
            acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
          } else if (hasDefer) {
            acceptHeader += "deferSpec=20220824,application/json";
          }
          options.headers.accept = acceptHeader;
        }
        if (options.method === "GET") {
          var _c2 = rewriteURIForGET(chosenURI, body), newURI = _c2.newURI, parseError = _c2.parseError;
          if (parseError) {
            return fromError(parseError);
          }
          chosenURI = newURI;
        } else {
          try {
            options.body = serializeFetchParameter(body, "Payload");
          } catch (parseError2) {
            return fromError(parseError2);
          }
        }
        return new Observable(function(observer) {
          var currentFetch = preferredFetch || maybe(function() {
            return fetch;
          }) || backupFetch;
          var observerNext = observer.next.bind(observer);
          currentFetch(chosenURI, options).then(function(response) {
            var _a4;
            operation.setContext({ response });
            var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
            if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
              return readMultipartBody(response, observerNext);
            } else {
              return parseAndCheckHttpResponse(operation)(response).then(observerNext);
            }
          }).then(function() {
            controller = void 0;
            observer.complete();
          }).catch(function(err) {
            controller = void 0;
            handleError(err, observer);
          });
          return function() {
            if (controller)
              controller.abort();
          };
        });
      });
    };
  }
});

// ../node_modules/@apollo/client/link/http/HttpLink.js
var import_dist694, import_dist695, import_dist696, HttpLink;
var init_HttpLink = __esm({
  "../node_modules/@apollo/client/link/http/HttpLink.js"() {
    import_dist694 = __toESM(require_dist(), 1);
    import_dist695 = __toESM(require_dist2(), 1);
    import_dist696 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_core();
    init_createHttpLink();
    HttpLink = /** @class */
    function(_super) {
      __extends(HttpLink2, _super);
      function HttpLink2(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this, createHttpLink(options).request) || this;
        _this.options = options;
        return _this;
      }
      return HttpLink2;
    }(ApolloLink);
  }
});

// ../node_modules/@apollo/client/link/http/index.js
var import_dist697, import_dist698, import_dist699;
var init_http = __esm({
  "../node_modules/@apollo/client/link/http/index.js"() {
    import_dist697 = __toESM(require_dist(), 1);
    import_dist698 = __toESM(require_dist2(), 1);
    import_dist699 = __toESM(require_dist3(), 1);
    init_globals();
    init_parseAndCheckHttpResponse();
    init_serializeFetchParameter();
    init_selectHttpOptionsAndBody();
    init_checkFetcher();
    init_createSignalIfSupported();
    init_selectURI();
    init_createHttpLink();
    init_HttpLink();
    init_rewriteURIForGET();
  }
});

// ../node_modules/@apollo/client/core/networkStatus.js
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}
function isNetworkRequestSettled(networkStatus) {
  return networkStatus === 7 || networkStatus === 8;
}
var import_dist700, import_dist701, import_dist702, NetworkStatus;
var init_networkStatus = __esm({
  "../node_modules/@apollo/client/core/networkStatus.js"() {
    import_dist700 = __toESM(require_dist(), 1);
    import_dist701 = __toESM(require_dist2(), 1);
    import_dist702 = __toESM(require_dist3(), 1);
    (function(NetworkStatus2) {
      NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
      NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
      NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
      NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
      NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
      NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
      NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
    })(NetworkStatus || (NetworkStatus = {}));
  }
});

// ../node_modules/@apollo/client/core/ObservableQuery.js
function reobserveCacheFirst(obsQuery) {
  var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
  if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
    return obsQuery.reobserve({
      fetchPolicy: "cache-first",
      // Use a temporary nextFetchPolicy function that replaces itself with the
      // previous nextFetchPolicy value and returns the original fetchPolicy.
      nextFetchPolicy: function(currentFetchPolicy, context) {
        this.nextFetchPolicy = nextFetchPolicy;
        if (typeof this.nextFetchPolicy === "function") {
          return this.nextFetchPolicy(currentFetchPolicy, context);
        }
        return fetchPolicy;
      }
    });
  }
  return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
  globalThis.__DEV__ !== false && invariant2.error(23, error.message, error.stack);
}
function logMissingFieldErrors(missing) {
  if (globalThis.__DEV__ !== false && missing) {
    globalThis.__DEV__ !== false && invariant2.debug(24, missing);
  }
}
function skipCacheDataFor(fetchPolicy) {
  return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
}
var import_dist703, import_dist704, import_dist705, assign, hasOwnProperty8, ObservableQuery;
var init_ObservableQuery = __esm({
  "../node_modules/@apollo/client/core/ObservableQuery.js"() {
    import_dist703 = __toESM(require_dist(), 1);
    import_dist704 = __toESM(require_dist2(), 1);
    import_dist705 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_lib6();
    init_networkStatus();
    init_utilities2();
    init_equalByQuery();
    assign = Object.assign;
    hasOwnProperty8 = Object.hasOwnProperty;
    ObservableQuery = /** @class */
    function(_super) {
      __extends(ObservableQuery2, _super);
      function ObservableQuery2(_a2) {
        var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
        var _this = _super.call(this, function(observer) {
          try {
            var subObserver = observer._subscription._observer;
            if (subObserver && !subObserver.error) {
              subObserver.error = defaultSubscriptionObserverErrorCallback;
            }
          } catch (_a3) {
          }
          var first = !_this.observers.size;
          _this.observers.add(observer);
          var last = _this.last;
          if (last && last.error) {
            observer.error && observer.error(last.error);
          } else if (last && last.result) {
            observer.next && observer.next(last.result);
          }
          if (first) {
            _this.reobserve().catch(function() {
            });
          }
          return function() {
            if (_this.observers.delete(observer) && !_this.observers.size) {
              _this.tearDownQuery();
            }
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.subscriptions = /* @__PURE__ */ new Set();
        _this.queryInfo = queryInfo;
        _this.queryManager = queryManager;
        _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);
        _this.isTornDown = false;
        _this.subscribeToMore = _this.subscribeToMore.bind(_this);
        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
        _this.options = __assign(__assign({}, options), {
          // Remember the initial options.fetchPolicy so we can revert back to this
          // policy when variables change. This information can also be specified
          // (or overridden) by providing options.initialFetchPolicy explicitly.
          initialFetchPolicy,
          // This ensures this.options.fetchPolicy always has a string value, in
          // case options.fetchPolicy was not provided.
          fetchPolicy
        });
        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
        var opDef = getOperationDefinition(_this.query);
        _this.queryName = opDef && opDef.name && opDef.name.value;
        return _this;
      }
      Object.defineProperty(ObservableQuery2.prototype, "query", {
        // The `query` computed property will always reflect the document transformed
        // by the last run query. `this.options.query` will always reflect the raw
        // untransformed query to ensure document transforms with runtime conditionals
        // are run on the original document.
        get: function() {
          return this.lastQuery || this.options.query;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObservableQuery2.prototype, "variables", {
        // Computed shorthand for this.options.variables, preserved for
        // backwards compatibility.
        /**
         * An object containing the variables that were provided for the query.
         */
        get: function() {
          return this.options.variables;
        },
        enumerable: false,
        configurable: true
      });
      ObservableQuery2.prototype.result = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var observer = {
            next: function(result2) {
              resolve(result2);
              _this.observers.delete(observer);
              if (!_this.observers.size) {
                _this.queryManager.removeQuery(_this.queryId);
              }
              setTimeout(function() {
                subscription.unsubscribe();
              }, 0);
            },
            error: reject
          };
          var subscription = _this.subscribe(observer);
        });
      };
      ObservableQuery2.prototype.resetDiff = function() {
        this.queryInfo.resetDiff();
      };
      ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
        if (saveAsLastResult === void 0) {
          saveAsLastResult = true;
        }
        var lastResult = this.getLastResult(true);
        var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
        var result2 = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
        var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
        if (
          // These fetch policies should never deliver data from the cache, unless
          // redelivering a previously delivered result.
          skipCacheDataFor(fetchPolicy) || // If this.options.query has @client(always: true) fields, we cannot
          // trust diff.result, since it was read from the cache without running
          // local resolvers (and it's too late to run resolvers now, since we must
          // return a result synchronously).
          this.queryManager.getDocumentInfo(this.query).hasForcedResolvers
        ) {
        } else if (this.waitForOwnResult) {
          this.queryInfo["updateWatch"]();
        } else {
          var diff2 = this.queryInfo.getDiff();
          if (diff2.complete || this.options.returnPartialData) {
            result2.data = diff2.result;
          }
          if (equal(result2.data, {})) {
            result2.data = void 0;
          }
          if (diff2.complete) {
            delete result2.partial;
            if (diff2.complete && result2.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
              result2.networkStatus = NetworkStatus.ready;
              result2.loading = false;
            }
          } else {
            result2.partial = true;
          }
          if (globalThis.__DEV__ !== false && !diff2.complete && !this.options.partialRefetch && !result2.loading && !result2.data && !result2.error) {
            logMissingFieldErrors(diff2.missing);
          }
        }
        if (saveAsLastResult) {
          this.updateLastResult(result2);
        }
        return result2;
      };
      ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
        if (!this.last) {
          return true;
        }
        var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !equalByQuery(this.query, this.last.result, newResult, this.variables) : !equal(this.last.result, newResult);
        return resultIsDifferent || variables && !equal(this.last.variables, variables);
      };
      ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
        var last = this.last;
        if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {
          return last[key];
        }
      };
      ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
        return this.getLast("result", variablesMustMatch);
      };
      ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
        return this.getLast("error", variablesMustMatch);
      };
      ObservableQuery2.prototype.resetLastResults = function() {
        delete this.last;
        this.isTornDown = false;
      };
      ObservableQuery2.prototype.resetQueryStoreErrors = function() {
        this.queryManager.resetErrors(this.queryId);
      };
      ObservableQuery2.prototype.refetch = function(variables) {
        var _a2;
        var reobserveOptions = {
          // Always disable polling for refetches.
          pollInterval: 0
        };
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === "cache-and-network") {
          reobserveOptions.fetchPolicy = fetchPolicy;
        } else if (fetchPolicy === "no-cache") {
          reobserveOptions.fetchPolicy = "no-cache";
        } else {
          reobserveOptions.fetchPolicy = "network-only";
        }
        if (globalThis.__DEV__ !== false && variables && hasOwnProperty8.call(variables, "variables")) {
          var queryDef = getQueryDefinition(this.query);
          var vars = queryDef.variableDefinitions;
          if (!vars || !vars.some(function(v) {
            return v.variable.name.value === "variables";
          })) {
            globalThis.__DEV__ !== false && invariant2.warn(
              20,
              variables,
              ((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || queryDef
            );
          }
        }
        if (variables && !equal(this.options.variables, variables)) {
          reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);
        }
        this.queryInfo.resetLastWrite();
        return this.reobserve(reobserveOptions, NetworkStatus.refetch);
      };
      ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
        var _this = this;
        var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
          // The fetchMore request goes immediately to the network and does
          // not automatically write its result to the cache (hence no-cache
          // instead of network-only), because we allow the caller of
          // fetchMore to provide an updateQuery callback that determines how
          // the data gets written to the cache.
          fetchPolicy: "no-cache"
        });
        combinedOptions.query = this.transformDocument(combinedOptions.query);
        var qid = this.queryManager.generateQueryId();
        this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
        var queryInfo = this.queryInfo;
        var originalNetworkStatus = queryInfo.networkStatus;
        queryInfo.networkStatus = NetworkStatus.fetchMore;
        if (combinedOptions.notifyOnNetworkStatusChange) {
          this.observe();
        }
        var updatedQuerySet = /* @__PURE__ */ new Set();
        return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
          _this.queryManager.removeQuery(qid);
          if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
            queryInfo.networkStatus = originalNetworkStatus;
          }
          _this.queryManager.cache.batch({
            update: function(cache2) {
              var updateQuery = fetchMoreOptions.updateQuery;
              if (updateQuery) {
                cache2.updateQuery({
                  query: _this.query,
                  variables: _this.variables,
                  returnPartialData: true,
                  optimistic: false
                }, function(previous) {
                  return updateQuery(previous, {
                    fetchMoreResult: fetchMoreResult.data,
                    variables: combinedOptions.variables
                  });
                });
              } else {
                cache2.writeQuery({
                  query: combinedOptions.query,
                  variables: combinedOptions.variables,
                  data: fetchMoreResult.data
                });
              }
            },
            onWatchUpdated: function(watch) {
              updatedQuerySet.add(watch.query);
            }
          });
          return fetchMoreResult;
        }).finally(function() {
          if (!updatedQuerySet.has(_this.query)) {
            reobserveCacheFirst(_this);
          }
        });
      };
      ObservableQuery2.prototype.subscribeToMore = function(options) {
        var _this = this;
        var subscription = this.queryManager.startGraphQLSubscription({
          query: options.document,
          variables: options.variables,
          context: options.context
        }).subscribe({
          next: function(subscriptionData) {
            var updateQuery = options.updateQuery;
            if (updateQuery) {
              _this.updateQuery(function(previous, _a2) {
                var variables = _a2.variables;
                return updateQuery(previous, {
                  subscriptionData,
                  variables
                });
              });
            }
          },
          error: function(err) {
            if (options.onError) {
              options.onError(err);
              return;
            }
            globalThis.__DEV__ !== false && invariant2.error(21, err);
          }
        });
        this.subscriptions.add(subscription);
        return function() {
          if (_this.subscriptions.delete(subscription)) {
            subscription.unsubscribe();
          }
        };
      };
      ObservableQuery2.prototype.setOptions = function(newOptions) {
        return this.reobserve(newOptions);
      };
      ObservableQuery2.prototype.silentSetOptions = function(newOptions) {
        var mergedOptions = compact(this.options, newOptions || {});
        assign(this.options, mergedOptions);
      };
      ObservableQuery2.prototype.setVariables = function(variables) {
        if (equal(this.variables, variables)) {
          return this.observers.size ? this.result() : Promise.resolve();
        }
        this.options.variables = variables;
        if (!this.observers.size) {
          return Promise.resolve();
        }
        return this.reobserve({
          // Reset options.fetchPolicy to its original value.
          fetchPolicy: this.options.initialFetchPolicy,
          variables
        }, NetworkStatus.setVariables);
      };
      ObservableQuery2.prototype.updateQuery = function(mapFn) {
        var queryManager = this.queryManager;
        var result2 = queryManager.cache.diff({
          query: this.options.query,
          variables: this.variables,
          returnPartialData: true,
          optimistic: false
        }).result;
        var newResult = mapFn(result2, {
          variables: this.variables
        });
        if (newResult) {
          queryManager.cache.writeQuery({
            query: this.options.query,
            data: newResult,
            variables: this.variables
          });
          queryManager.broadcastQueries();
        }
      };
      ObservableQuery2.prototype.startPolling = function(pollInterval) {
        this.options.pollInterval = pollInterval;
        this.updatePolling();
      };
      ObservableQuery2.prototype.stopPolling = function() {
        this.options.pollInterval = 0;
        this.updatePolling();
      };
      ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
        if (options.nextFetchPolicy) {
          var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
          if (fetchPolicy === "standby") {
          } else if (typeof options.nextFetchPolicy === "function") {
            options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
              reason,
              options,
              observable: this,
              initialFetchPolicy
            });
          } else if (reason === "variables-changed") {
            options.fetchPolicy = initialFetchPolicy;
          } else {
            options.fetchPolicy = options.nextFetchPolicy;
          }
        }
        return options.fetchPolicy;
      };
      ObservableQuery2.prototype.fetch = function(options, newNetworkStatus, query) {
        this.queryManager.setObservableQuery(this);
        return this.queryManager["fetchConcastWithInfo"](this.queryId, options, newNetworkStatus, query);
      };
      ObservableQuery2.prototype.updatePolling = function() {
        var _this = this;
        if (this.queryManager.ssrMode) {
          return;
        }
        var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
        if (!pollInterval || !this.hasObservers()) {
          if (pollingInfo) {
            clearTimeout(pollingInfo.timeout);
            delete this.pollingInfo;
          }
          return;
        }
        if (pollingInfo && pollingInfo.interval === pollInterval) {
          return;
        }
        invariant2(pollInterval, 22);
        var info = pollingInfo || (this.pollingInfo = {});
        info.interval = pollInterval;
        var maybeFetch = function() {
          var _a3, _b;
          if (_this.pollingInfo) {
            if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a3 = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a3))) {
              _this.reobserve({
                // Most fetchPolicy options don't make sense to use in a polling context, as
                // users wouldn't want to be polling the cache directly. However, network-only and
                // no-cache are both useful for when the user wants to control whether or not the
                // polled results are written to the cache.
                fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
              }, NetworkStatus.poll).then(poll, poll);
            } else {
              poll();
            }
          }
        };
        var poll = function() {
          var info2 = _this.pollingInfo;
          if (info2) {
            clearTimeout(info2.timeout);
            info2.timeout = setTimeout(maybeFetch, info2.interval);
          }
        };
        poll();
      };
      ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
        if (variables === void 0) {
          variables = this.variables;
        }
        var error = this.getLastError();
        if (error && this.last && !equal(variables, this.last.variables)) {
          error = void 0;
        }
        return this.last = __assign({ result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables }, error ? { error } : null);
      };
      ObservableQuery2.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
        var _this = this;
        this.isTornDown = false;
        var useDisposableConcast = (
          // Refetching uses a disposable Concast to allow refetches using different
          // options/variables, without permanently altering the options of the
          // original ObservableQuery.
          newNetworkStatus === NetworkStatus.refetch || // The fetchMore method does not actually call the reobserve method, but,
          // if it did, it would definitely use a disposable Concast.
          newNetworkStatus === NetworkStatus.fetchMore || // Polling uses a disposable Concast so the polling options (which force
          // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
          newNetworkStatus === NetworkStatus.poll
        );
        var oldVariables = this.options.variables;
        var oldFetchPolicy = this.options.fetchPolicy;
        var mergedOptions = compact(this.options, newOptions || {});
        var options = useDisposableConcast ? (
          // Disposable Concast fetches receive a shallow copy of this.options
          // (merged with newOptions), leaving this.options unmodified.
          mergedOptions
        ) : assign(this.options, mergedOptions);
        var query = this.transformDocument(options.query);
        this.lastQuery = query;
        if (!useDisposableConcast) {
          this.updatePolling();
          if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently "standby".
          options.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
          // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
          (options.fetchPolicy === oldFetchPolicy || // A `nextFetchPolicy` function has even higher priority, though,
          // so in that case `applyNextFetchPolicy` must be called.
          typeof options.nextFetchPolicy === "function")) {
            this.applyNextFetchPolicy("variables-changed", options);
            if (newNetworkStatus === void 0) {
              newNetworkStatus = NetworkStatus.setVariables;
            }
          }
        }
        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));
        var finishWaitingForOwnResult = function() {
          if (_this.concast === concast) {
            _this.waitForOwnResult = false;
          }
        };
        var variables = options.variables && __assign({}, options.variables);
        var _a2 = this.fetch(options, newNetworkStatus, query), concast = _a2.concast, fromLink = _a2.fromLink;
        var observer = {
          next: function(result2) {
            if (equal(_this.variables, variables)) {
              finishWaitingForOwnResult();
              _this.reportResult(result2, variables);
            }
          },
          error: function(error) {
            if (equal(_this.variables, variables)) {
              finishWaitingForOwnResult();
              _this.reportError(error, variables);
            }
          }
        };
        if (!useDisposableConcast && (fromLink || !this.concast)) {
          if (this.concast && this.observer) {
            this.concast.removeObserver(this.observer);
          }
          this.concast = concast;
          this.observer = observer;
        }
        concast.addObserver(observer);
        return concast;
      };
      ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
        return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;
      };
      ObservableQuery2.prototype.resubscribeAfterError = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var last = this.last;
        this.resetLastResults();
        var subscription = this.subscribe.apply(this, args);
        this.last = last;
        return subscription;
      };
      ObservableQuery2.prototype.observe = function() {
        this.reportResult(
          // Passing false is important so that this.getCurrentResult doesn't
          // save the fetchMore result as this.lastResult, causing it to be
          // ignored due to the this.isDifferentFromLastResult check in
          // this.reportResult.
          this.getCurrentResult(false),
          this.variables
        );
      };
      ObservableQuery2.prototype.reportResult = function(result2, variables) {
        var lastError = this.getLastError();
        var isDifferent = this.isDifferentFromLastResult(result2, variables);
        if (lastError || !result2.partial || this.options.returnPartialData) {
          this.updateLastResult(result2, variables);
        }
        if (lastError || isDifferent) {
          iterateObserversSafely(this.observers, "next", result2);
        }
      };
      ObservableQuery2.prototype.reportError = function(error, variables) {
        var errorResult = __assign(__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
        this.updateLastResult(errorResult, variables);
        iterateObserversSafely(this.observers, "error", this.last.error = error);
      };
      ObservableQuery2.prototype.hasObservers = function() {
        return this.observers.size > 0;
      };
      ObservableQuery2.prototype.tearDownQuery = function() {
        if (this.isTornDown)
          return;
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
          delete this.concast;
          delete this.observer;
        }
        this.stopPolling();
        this.subscriptions.forEach(function(sub) {
          return sub.unsubscribe();
        });
        this.subscriptions.clear();
        this.queryManager.stopQuery(this.queryId);
        this.observers.clear();
        this.isTornDown = true;
      };
      ObservableQuery2.prototype.transformDocument = function(document) {
        return this.queryManager.transform(document);
      };
      return ObservableQuery2;
    }(Observable);
    fixObservableSubclass(ObservableQuery);
  }
});

// ../node_modules/@apollo/client/core/QueryInfo.js
function wrapDestructiveCacheMethod(cache2, methodName) {
  var original = cache2[methodName];
  if (typeof original === "function") {
    cache2[methodName] = function() {
      destructiveMethodCounts.set(
        cache2,
        // The %1e15 allows the count to wrap around to 0 safely every
        // quadrillion evictions, so there's no risk of overflow. To be
        // clear, this is more of a pedantic principle than something
        // that matters in any conceivable practical scenario.
        (destructiveMethodCounts.get(cache2) + 1) % 1e15
      );
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
function shouldWriteResult(result2, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError(result2);
  if (!writeWithErrors && ignoreErrors && result2.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}
var import_dist706, import_dist707, import_dist708, destructiveMethodCounts, QueryInfo;
var init_QueryInfo = __esm({
  "../node_modules/@apollo/client/core/QueryInfo.js"() {
    import_dist706 = __toESM(require_dist(), 1);
    import_dist707 = __toESM(require_dist2(), 1);
    import_dist708 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_lib6();
    init_utilities2();
    init_utilities2();
    init_ObservableQuery();
    init_utilities2();
    init_networkStatus();
    destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
    QueryInfo = /** @class */
    function() {
      function QueryInfo2(queryManager, queryId) {
        if (queryId === void 0) {
          queryId = queryManager.generateQueryId();
        }
        this.queryId = queryId;
        this.listeners = /* @__PURE__ */ new Set();
        this.document = null;
        this.lastRequestId = 1;
        this.stopped = false;
        this.dirty = false;
        this.observableQuery = null;
        var cache2 = this.cache = queryManager.cache;
        if (!destructiveMethodCounts.has(cache2)) {
          destructiveMethodCounts.set(cache2, 0);
          wrapDestructiveCacheMethod(cache2, "evict");
          wrapDestructiveCacheMethod(cache2, "modify");
          wrapDestructiveCacheMethod(cache2, "reset");
        }
      }
      QueryInfo2.prototype.init = function(query) {
        var networkStatus = query.networkStatus || NetworkStatus.loading;
        if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {
          networkStatus = NetworkStatus.setVariables;
        }
        if (!equal(query.variables, this.variables)) {
          this.lastDiff = void 0;
        }
        Object.assign(this, {
          document: query.document,
          variables: query.variables,
          networkError: null,
          graphQLErrors: this.graphQLErrors || [],
          networkStatus
        });
        if (query.observableQuery) {
          this.setObservableQuery(query.observableQuery);
        }
        if (query.lastRequestId) {
          this.lastRequestId = query.lastRequestId;
        }
        return this;
      };
      QueryInfo2.prototype.reset = function() {
        cancelNotifyTimeout(this);
        this.dirty = false;
      };
      QueryInfo2.prototype.resetDiff = function() {
        this.lastDiff = void 0;
      };
      QueryInfo2.prototype.getDiff = function() {
        var options = this.getDiffOptions();
        if (this.lastDiff && equal(options, this.lastDiff.options)) {
          return this.lastDiff.diff;
        }
        this.updateWatch(this.variables);
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return { complete: false };
        }
        var diff2 = this.cache.diff(options);
        this.updateLastDiff(diff2, options);
        return diff2;
      };
      QueryInfo2.prototype.updateLastDiff = function(diff2, options) {
        this.lastDiff = diff2 ? {
          diff: diff2,
          options: options || this.getDiffOptions()
        } : void 0;
      };
      QueryInfo2.prototype.getDiffOptions = function(variables) {
        var _a2;
        if (variables === void 0) {
          variables = this.variables;
        }
        return {
          query: this.document,
          variables,
          returnPartialData: true,
          optimistic: true,
          canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
        };
      };
      QueryInfo2.prototype.setDiff = function(diff2) {
        var _this = this;
        var _a2;
        var oldDiff = this.lastDiff && this.lastDiff.diff;
        if (diff2 && !diff2.complete && ((_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.getLastError())) {
          return;
        }
        this.updateLastDiff(diff2);
        if (!this.dirty && !equal(oldDiff && oldDiff.result, diff2 && diff2.result)) {
          this.dirty = true;
          if (!this.notifyTimeout) {
            this.notifyTimeout = setTimeout(function() {
              return _this.notify();
            }, 0);
          }
        }
      };
      QueryInfo2.prototype.setObservableQuery = function(oq) {
        var _this = this;
        if (oq === this.observableQuery)
          return;
        if (this.oqListener) {
          this.listeners.delete(this.oqListener);
        }
        this.observableQuery = oq;
        if (oq) {
          oq["queryInfo"] = this;
          this.listeners.add(this.oqListener = function() {
            var diff2 = _this.getDiff();
            if (diff2.fromOptimisticTransaction) {
              oq["observe"]();
            } else {
              reobserveCacheFirst(oq);
            }
          });
        } else {
          delete this.oqListener;
        }
      };
      QueryInfo2.prototype.notify = function() {
        var _this = this;
        cancelNotifyTimeout(this);
        if (this.shouldNotify()) {
          this.listeners.forEach(function(listener) {
            return listener(_this);
          });
        }
        this.dirty = false;
      };
      QueryInfo2.prototype.shouldNotify = function() {
        if (!this.dirty || !this.listeners.size) {
          return false;
        }
        if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
          var fetchPolicy = this.observableQuery.options.fetchPolicy;
          if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
            return false;
          }
        }
        return true;
      };
      QueryInfo2.prototype.stop = function() {
        if (!this.stopped) {
          this.stopped = true;
          this.reset();
          this.cancel();
          this.cancel = QueryInfo2.prototype.cancel;
          var oq = this.observableQuery;
          if (oq)
            oq.stopPolling();
        }
      };
      QueryInfo2.prototype.cancel = function() {
      };
      QueryInfo2.prototype.updateWatch = function(variables) {
        var _this = this;
        if (variables === void 0) {
          variables = this.variables;
        }
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return;
        }
        var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff2) {
          return _this.setDiff(diff2);
        } });
        if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {
          this.cancel();
          this.cancel = this.cache.watch(this.lastWatch = watchOptions);
        }
      };
      QueryInfo2.prototype.resetLastWrite = function() {
        this.lastWrite = void 0;
      };
      QueryInfo2.prototype.shouldWrite = function(result2, variables) {
        var lastWrite = this.lastWrite;
        return !(lastWrite && // If cache.evict has been called since the last time we wrote this
        // data into the cache, there's a chance writing this result into
        // the cache will repair what was evicted.
        lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result2.data, lastWrite.result.data));
      };
      QueryInfo2.prototype.markResult = function(result2, document, options, cacheWriteBehavior) {
        var _this = this;
        var merger = new DeepMerger();
        var graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
        this.reset();
        if ("incremental" in result2 && isNonEmptyArray(result2.incremental)) {
          var mergedData = mergeIncrementalData(this.getDiff().result, result2);
          result2.data = mergedData;
        } else if ("hasNext" in result2 && result2.hasNext) {
          var diff2 = this.getDiff();
          result2.data = merger.merge(diff2.result, result2.data);
        }
        this.graphQLErrors = graphQLErrors;
        if (options.fetchPolicy === "no-cache") {
          this.updateLastDiff({ result: result2.data, complete: true }, this.getDiffOptions(options.variables));
        } else if (cacheWriteBehavior !== 0) {
          if (shouldWriteResult(result2, options.errorPolicy)) {
            this.cache.performTransaction(function(cache2) {
              if (_this.shouldWrite(result2, options.variables)) {
                cache2.writeQuery({
                  query: document,
                  data: result2.data,
                  variables: options.variables,
                  overwrite: cacheWriteBehavior === 1
                });
                _this.lastWrite = {
                  result: result2,
                  variables: options.variables,
                  dmCount: destructiveMethodCounts.get(_this.cache)
                };
              } else {
                if (_this.lastDiff && _this.lastDiff.diff.complete) {
                  result2.data = _this.lastDiff.diff.result;
                  return;
                }
              }
              var diffOptions = _this.getDiffOptions(options.variables);
              var diff3 = cache2.diff(diffOptions);
              if (!_this.stopped && equal(_this.variables, options.variables)) {
                _this.updateWatch(options.variables);
              }
              _this.updateLastDiff(diff3, diffOptions);
              if (diff3.complete) {
                result2.data = diff3.result;
              }
            });
          } else {
            this.lastWrite = void 0;
          }
        }
      };
      QueryInfo2.prototype.markReady = function() {
        this.networkError = null;
        return this.networkStatus = NetworkStatus.ready;
      };
      QueryInfo2.prototype.markError = function(error) {
        this.networkStatus = NetworkStatus.error;
        this.lastWrite = void 0;
        this.reset();
        if (error.graphQLErrors) {
          this.graphQLErrors = error.graphQLErrors;
        }
        if (error.networkError) {
          this.networkError = error.networkError;
        }
        return error;
      };
      return QueryInfo2;
    }();
  }
});

// ../node_modules/@apollo/client/core/QueryManager.js
var import_dist709, import_dist710, import_dist711, hasOwnProperty9, IGNORE, QueryManager;
var init_QueryManager = __esm({
  "../node_modules/@apollo/client/core/QueryManager.js"() {
    import_dist709 = __toESM(require_dist(), 1);
    import_dist710 = __toESM(require_dist2(), 1);
    import_dist711 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_lib6();
    init_core();
    init_utilities2();
    init_cache2();
    init_utilities2();
    init_incrementalResult();
    init_errors();
    init_ObservableQuery();
    init_networkStatus();
    init_QueryInfo();
    init_errors();
    init_utilities2();
    init_lib();
    init_utilities2();
    hasOwnProperty9 = Object.prototype.hasOwnProperty;
    IGNORE = /* @__PURE__ */ Object.create(null);
    QueryManager = /** @class */
    function() {
      function QueryManager2(options) {
        var _this = this;
        this.clientAwareness = {};
        this.queries = /* @__PURE__ */ new Map();
        this.fetchCancelFns = /* @__PURE__ */ new Map();
        this.transformCache = new AutoCleanedWeakCache(
          cacheSizes["queryManager.getDocumentInfo"] || 2e3
          /* defaultCacheSizes["queryManager.getDocumentInfo"] */
        );
        this.queryIdCounter = 1;
        this.requestIdCounter = 1;
        this.mutationIdCounter = 1;
        this.inFlightLinkObservables = new Trie(false);
        var defaultDocumentTransform = new DocumentTransform(
          function(document) {
            return _this.cache.transformDocument(document);
          },
          // Allow the apollo cache to manage its own transform caches
          { cache: false }
        );
        this.cache = options.cache;
        this.link = options.link;
        this.defaultOptions = options.defaultOptions;
        this.queryDeduplication = options.queryDeduplication;
        this.clientAwareness = options.clientAwareness;
        this.localState = options.localState;
        this.ssrMode = options.ssrMode;
        this.assumeImmutableResults = options.assumeImmutableResults;
        var documentTransform = options.documentTransform;
        this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
        this.defaultContext = options.defaultContext || /* @__PURE__ */ Object.create(null);
        if (this.onBroadcast = options.onBroadcast) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
      }
      QueryManager2.prototype.stop = function() {
        var _this = this;
        this.queries.forEach(function(_info, queryId) {
          _this.stopQueryNoBroadcast(queryId);
        });
        this.cancelPendingFetches(newInvariantError(25));
      };
      QueryManager2.prototype.cancelPendingFetches = function(error) {
        this.fetchCancelFns.forEach(function(cancel) {
          return cancel(error);
        });
        this.fetchCancelFns.clear();
      };
      QueryManager2.prototype.mutate = function(_a2) {
        return __awaiter(this, arguments, void 0, function(_b) {
          var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self2;
          var _c, _d;
          var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || "network-only" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b.keepRootFields, context = _b.context;
          return __generator(this, function(_j) {
            switch (_j.label) {
              case 0:
                invariant2(mutation, 26);
                invariant2(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 27);
                mutationId = this.generateMutationId();
                mutation = this.cache.transformForLink(this.transform(mutation));
                hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
                variables = this.getVariables(mutation, variables);
                if (!hasClientExports2) return [3, 2];
                return [4, this.localState.addExportedVariables(mutation, variables, context)];
              case 1:
                variables = _j.sent();
                _j.label = 2;
              case 2:
                mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                  mutation,
                  variables,
                  loading: true,
                  error: null
                });
                isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                  mutationId,
                  document: mutation,
                  variables,
                  fetchPolicy,
                  errorPolicy,
                  context,
                  updateQueries,
                  update: updateWithProxyFn,
                  keepRootFields
                });
                this.broadcastQueries();
                self2 = this;
                return [2, new Promise(function(resolve, reject) {
                  return asyncMap(self2.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result2) {
                    if (graphQLResultHasError(result2) && errorPolicy === "none") {
                      throw new ApolloError({
                        graphQLErrors: getGraphQLErrorsFromResult(result2)
                      });
                    }
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = null;
                    }
                    var storeResult = __assign({}, result2);
                    if (typeof refetchQueries === "function") {
                      refetchQueries = refetchQueries(storeResult);
                    }
                    if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                      delete storeResult.errors;
                    }
                    return self2.markMutationResult({
                      mutationId,
                      result: storeResult,
                      document: mutation,
                      variables,
                      fetchPolicy,
                      errorPolicy,
                      context,
                      update: updateWithProxyFn,
                      updateQueries,
                      awaitRefetchQueries,
                      refetchQueries,
                      removeOptimistic: isOptimistic ? mutationId : void 0,
                      onQueryUpdated,
                      keepRootFields
                    });
                  }).subscribe({
                    next: function(storeResult) {
                      self2.broadcastQueries();
                      if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                        resolve(storeResult);
                      }
                    },
                    error: function(err) {
                      if (mutationStoreValue) {
                        mutationStoreValue.loading = false;
                        mutationStoreValue.error = err;
                      }
                      if (isOptimistic) {
                        self2.cache.removeOptimistic(mutationId);
                      }
                      self2.broadcastQueries();
                      reject(err instanceof ApolloError ? err : new ApolloError({
                        networkError: err
                      }));
                    }
                  });
                })];
            }
          });
        });
      };
      QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
        var _this = this;
        if (cache2 === void 0) {
          cache2 = this.cache;
        }
        var result2 = mutation.result;
        var cacheWrites = [];
        var skipCache = mutation.fetchPolicy === "no-cache";
        if (!skipCache && shouldWriteResult(result2, mutation.errorPolicy)) {
          if (!isExecutionPatchIncrementalResult(result2)) {
            cacheWrites.push({
              result: result2.data,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
          if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
            var diff2 = cache2.diff({
              id: "ROOT_MUTATION",
              // The cache complains if passed a mutation where it expects a
              // query, so we transform mutations and subscriptions to queries
              // (only once, thanks to this.transformCache).
              query: this.getDocumentInfo(mutation.document).asQuery,
              variables: mutation.variables,
              optimistic: false,
              returnPartialData: true
            });
            var mergedData = void 0;
            if (diff2.result) {
              mergedData = mergeIncrementalData(diff2.result, result2);
            }
            if (typeof mergedData !== "undefined") {
              result2.data = mergedData;
              cacheWrites.push({
                result: mergedData,
                dataId: "ROOT_MUTATION",
                query: mutation.document,
                variables: mutation.variables
              });
            }
          }
          var updateQueries_1 = mutation.updateQueries;
          if (updateQueries_1) {
            this.queries.forEach(function(_a2, queryId) {
              var observableQuery = _a2.observableQuery;
              var queryName = observableQuery && observableQuery.queryName;
              if (!queryName || !hasOwnProperty9.call(updateQueries_1, queryName)) {
                return;
              }
              var updater = updateQueries_1[queryName];
              var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;
              var _c = cache2.diff({
                query: document,
                variables,
                returnPartialData: true,
                optimistic: false
              }), currentQueryResult = _c.result, complete = _c.complete;
              if (complete && currentQueryResult) {
                var nextQueryResult = updater(currentQueryResult, {
                  mutationResult: result2,
                  queryName: document && getOperationName(document) || void 0,
                  queryVariables: variables
                });
                if (nextQueryResult) {
                  cacheWrites.push({
                    result: nextQueryResult,
                    dataId: "ROOT_QUERY",
                    query: document,
                    variables
                  });
                }
              }
            });
          }
        }
        if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
          var results_1 = [];
          this.refetchQueries({
            updateCache: function(cache3) {
              if (!skipCache) {
                cacheWrites.forEach(function(write) {
                  return cache3.write(write);
                });
              }
              var update = mutation.update;
              var isFinalResult = !isExecutionPatchResult(result2) || isExecutionPatchIncrementalResult(result2) && !result2.hasNext;
              if (update) {
                if (!skipCache) {
                  var diff3 = cache3.diff({
                    id: "ROOT_MUTATION",
                    // The cache complains if passed a mutation where it expects a
                    // query, so we transform mutations and subscriptions to queries
                    // (only once, thanks to this.transformCache).
                    query: _this.getDocumentInfo(mutation.document).asQuery,
                    variables: mutation.variables,
                    optimistic: false,
                    returnPartialData: true
                  });
                  if (diff3.complete) {
                    result2 = __assign(__assign({}, result2), { data: diff3.result });
                    if ("incremental" in result2) {
                      delete result2.incremental;
                    }
                    if ("hasNext" in result2) {
                      delete result2.hasNext;
                    }
                  }
                }
                if (isFinalResult) {
                  update(cache3, result2, {
                    context: mutation.context,
                    variables: mutation.variables
                  });
                }
              }
              if (!skipCache && !mutation.keepRootFields && isFinalResult) {
                cache3.modify({
                  id: "ROOT_MUTATION",
                  fields: function(value, _a2) {
                    var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                    return fieldName === "__typename" ? value : DELETE2;
                  }
                });
              }
            },
            include: mutation.refetchQueries,
            // Write the final mutation.result to the root layer of the cache.
            optimistic: false,
            // Remove the corresponding optimistic layer at the same time as we
            // write the final non-optimistic result.
            removeOptimistic: mutation.removeOptimistic,
            // Let the caller of client.mutate optionally determine the refetching
            // behavior for watched queries after the mutation.update function runs.
            // If no onQueryUpdated function was provided for this mutation, pass
            // null instead of undefined to disable the default refetching behavior.
            onQueryUpdated: mutation.onQueryUpdated || null
          }).forEach(function(result3) {
            return results_1.push(result3);
          });
          if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
            return Promise.all(results_1).then(function() {
              return result2;
            });
          }
        }
        return Promise.resolve(result2);
      };
      QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
        var _this = this;
        var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE }) : optimisticResponse;
        if (data === IGNORE) {
          return false;
        }
        this.cache.recordOptimisticTransaction(function(cache2) {
          try {
            _this.markMutationResult(__assign(__assign({}, mutation), { result: { data } }), cache2);
          } catch (error) {
            globalThis.__DEV__ !== false && invariant2.error(error);
          }
        }, mutation.mutationId);
        return true;
      };
      QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
        return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;
      };
      QueryManager2.prototype.getQueryStore = function() {
        var store = /* @__PURE__ */ Object.create(null);
        this.queries.forEach(function(info, queryId) {
          store[queryId] = {
            variables: info.variables,
            networkStatus: info.networkStatus,
            networkError: info.networkError,
            graphQLErrors: info.graphQLErrors
          };
        });
        return store;
      };
      QueryManager2.prototype.resetErrors = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo) {
          queryInfo.networkError = void 0;
          queryInfo.graphQLErrors = [];
        }
      };
      QueryManager2.prototype.transform = function(document) {
        return this.documentTransform.transformDocument(document);
      };
      QueryManager2.prototype.getDocumentInfo = function(document) {
        var transformCache = this.transformCache;
        if (!transformCache.has(document)) {
          var cacheEntry = {
            // TODO These three calls (hasClientExports, shouldForceResolvers, and
            // usesNonreactiveDirective) are performing independent full traversals
            // of the transformed document. We should consider merging these
            // traversals into a single pass in the future, though the work is
            // cached after the first time.
            hasClientExports: hasClientExports(document),
            hasForcedResolvers: this.localState.shouldForceResolvers(document),
            hasNonreactiveDirective: hasDirectives(["nonreactive"], document),
            clientQuery: this.localState.clientQuery(document),
            serverQuery: removeDirectivesFromDocument([
              { name: "client", remove: true },
              { name: "connection" },
              { name: "nonreactive" }
            ], document),
            defaultVars: getDefaultValues(getOperationDefinition(document)),
            // Transform any mutation or subscription operations to query operations
            // so we can read/write them from/to the cache.
            asQuery: __assign(__assign({}, document), { definitions: document.definitions.map(function(def) {
              if (def.kind === "OperationDefinition" && def.operation !== "query") {
                return __assign(__assign({}, def), { operation: "query" });
              }
              return def;
            }) })
          };
          transformCache.set(document, cacheEntry);
        }
        return transformCache.get(document);
      };
      QueryManager2.prototype.getVariables = function(document, variables) {
        return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);
      };
      QueryManager2.prototype.watchQuery = function(options) {
        var query = this.transform(options.query);
        options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });
        if (typeof options.notifyOnNetworkStatusChange === "undefined") {
          options.notifyOnNetworkStatusChange = false;
        }
        var queryInfo = new QueryInfo(this);
        var observable = new ObservableQuery({
          queryManager: this,
          queryInfo,
          options
        });
        observable["lastQuery"] = query;
        this.queries.set(observable.queryId, queryInfo);
        queryInfo.init({
          document: query,
          observableQuery: observable,
          variables: observable.variables
        });
        return observable;
      };
      QueryManager2.prototype.query = function(options, queryId) {
        var _this = this;
        if (queryId === void 0) {
          queryId = this.generateQueryId();
        }
        invariant2(options.query, 28);
        invariant2(options.query.kind === "Document", 29);
        invariant2(!options.returnPartialData, 30);
        invariant2(!options.pollInterval, 31);
        return this.fetchQuery(queryId, __assign(__assign({}, options), { query: this.transform(options.query) })).finally(function() {
          return _this.stopQuery(queryId);
        });
      };
      QueryManager2.prototype.generateQueryId = function() {
        return String(this.queryIdCounter++);
      };
      QueryManager2.prototype.generateRequestId = function() {
        return this.requestIdCounter++;
      };
      QueryManager2.prototype.generateMutationId = function() {
        return String(this.mutationIdCounter++);
      };
      QueryManager2.prototype.stopQueryInStore = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo)
          queryInfo.stop();
      };
      QueryManager2.prototype.clearStore = function(options) {
        if (options === void 0) {
          options = {
            discardWatches: true
          };
        }
        this.cancelPendingFetches(newInvariantError(32));
        this.queries.forEach(function(queryInfo) {
          if (queryInfo.observableQuery) {
            queryInfo.networkStatus = NetworkStatus.loading;
          } else {
            queryInfo.stop();
          }
        });
        if (this.mutationStore) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
        return this.cache.reset(options);
      };
      QueryManager2.prototype.getObservableQueries = function(include) {
        var _this = this;
        if (include === void 0) {
          include = "active";
        }
        var queries = /* @__PURE__ */ new Map();
        var queryNamesAndDocs = /* @__PURE__ */ new Map();
        var legacyQueryOptions = /* @__PURE__ */ new Set();
        if (Array.isArray(include)) {
          include.forEach(function(desc) {
            if (typeof desc === "string") {
              queryNamesAndDocs.set(desc, false);
            } else if (isDocumentNode(desc)) {
              queryNamesAndDocs.set(_this.transform(desc), false);
            } else if (isNonNullObject(desc) && desc.query) {
              legacyQueryOptions.add(desc);
            }
          });
        }
        this.queries.forEach(function(_a2, queryId) {
          var oq = _a2.observableQuery, document = _a2.document;
          if (oq) {
            if (include === "all") {
              queries.set(queryId, oq);
              return;
            }
            var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
            if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
              return;
            }
            if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {
              queries.set(queryId, oq);
              if (queryName)
                queryNamesAndDocs.set(queryName, true);
              if (document)
                queryNamesAndDocs.set(document, true);
            }
          }
        });
        if (legacyQueryOptions.size) {
          legacyQueryOptions.forEach(function(options) {
            var queryId = makeUniqueId("legacyOneTimeQuery");
            var queryInfo = _this.getQuery(queryId).init({
              document: options.query,
              variables: options.variables
            });
            var oq = new ObservableQuery({
              queryManager: _this,
              queryInfo,
              options: __assign(__assign({}, options), { fetchPolicy: "network-only" })
            });
            invariant2(oq.queryId === queryId);
            queryInfo.setObservableQuery(oq);
            queries.set(queryId, oq);
          });
        }
        if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {
          queryNamesAndDocs.forEach(function(included, nameOrDoc) {
            if (!included) {
              globalThis.__DEV__ !== false && invariant2.warn(typeof nameOrDoc === "string" ? 33 : 34, nameOrDoc);
            }
          });
        }
        return queries;
      };
      QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
        var _this = this;
        if (includeStandby === void 0) {
          includeStandby = false;
        }
        var observableQueryPromises = [];
        this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
          var fetchPolicy = observableQuery.options.fetchPolicy;
          observableQuery.resetLastResults();
          if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
            observableQueryPromises.push(observableQuery.refetch());
          }
          _this.getQuery(queryId).setDiff(null);
        });
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
      };
      QueryManager2.prototype.setObservableQuery = function(observableQuery) {
        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
      };
      QueryManager2.prototype.startGraphQLSubscription = function(_a2) {
        var _this = this;
        var query = _a2.query, fetchPolicy = _a2.fetchPolicy, _b = _a2.errorPolicy, errorPolicy = _b === void 0 ? "none" : _b, variables = _a2.variables, _c = _a2.context, context = _c === void 0 ? {} : _c, _d = _a2.extensions, extensions = _d === void 0 ? {} : _d;
        query = this.transform(query);
        variables = this.getVariables(query, variables);
        var makeObservable = function(variables2) {
          return _this.getObservableFromLink(query, context, variables2, extensions).map(function(result2) {
            if (fetchPolicy !== "no-cache") {
              if (shouldWriteResult(result2, errorPolicy)) {
                _this.cache.write({
                  query,
                  result: result2.data,
                  dataId: "ROOT_SUBSCRIPTION",
                  variables: variables2
                });
              }
              _this.broadcastQueries();
            }
            var hasErrors = graphQLResultHasError(result2);
            var hasProtocolErrors = graphQLResultHasProtocolErrors(result2);
            if (hasErrors || hasProtocolErrors) {
              var errors = {};
              if (hasErrors) {
                errors.graphQLErrors = result2.errors;
              }
              if (hasProtocolErrors) {
                errors.protocolErrors = result2.extensions[PROTOCOL_ERRORS_SYMBOL];
              }
              if (errorPolicy === "none" || hasProtocolErrors) {
                throw new ApolloError(errors);
              }
            }
            if (errorPolicy === "ignore") {
              delete result2.errors;
            }
            return result2;
          });
        };
        if (this.getDocumentInfo(query).hasClientExports) {
          var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
          return new Observable(function(observer) {
            var sub = null;
            observablePromise_1.then(function(observable) {
              return sub = observable.subscribe(observer);
            }, observer.error);
            return function() {
              return sub && sub.unsubscribe();
            };
          });
        }
        return makeObservable(variables);
      };
      QueryManager2.prototype.stopQuery = function(queryId) {
        this.stopQueryNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.removeQuery(queryId);
      };
      QueryManager2.prototype.removeQuery = function(queryId) {
        this.fetchCancelFns.delete(queryId);
        if (this.queries.has(queryId)) {
          this.getQuery(queryId).stop();
          this.queries.delete(queryId);
        }
      };
      QueryManager2.prototype.broadcastQueries = function() {
        if (this.onBroadcast)
          this.onBroadcast();
        this.queries.forEach(function(info) {
          return info.notify();
        });
      };
      QueryManager2.prototype.getLocalState = function() {
        return this.localState;
      };
      QueryManager2.prototype.getObservableFromLink = function(query, context, variables, extensions, deduplication) {
        var _this = this;
        var _a2;
        if (deduplication === void 0) {
          deduplication = (_a2 = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
        }
        var observable;
        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
        if (serverQuery) {
          var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
          var operation = {
            query: serverQuery,
            variables,
            operationName: getOperationName(serverQuery) || void 0,
            context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),
            extensions
          };
          context = operation.context;
          if (deduplication) {
            var printedServerQuery_1 = print2(serverQuery);
            var varJson_1 = canonicalStringify(variables);
            var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
            observable = entry.observable;
            if (!observable) {
              var concast = new Concast([
                execute2(link, operation)
              ]);
              observable = entry.observable = concast;
              concast.beforeNext(function() {
                inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
              });
            }
          } else {
            observable = new Concast([
              execute2(link, operation)
            ]);
          }
        } else {
          observable = new Concast([Observable.of({ data: {} })]);
          context = this.prepareContext(context);
        }
        if (clientQuery) {
          observable = asyncMap(observable, function(result2) {
            return _this.localState.runResolvers({
              document: clientQuery,
              remoteResult: result2,
              context,
              variables
            });
          });
        }
        return observable;
      };
      QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
        var requestId = queryInfo.lastRequestId = this.generateRequestId();
        var linkDocument = this.cache.transformForLink(options.query);
        return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result2) {
          var graphQLErrors = getGraphQLErrorsFromResult(result2);
          var hasErrors = graphQLErrors.length > 0;
          if (requestId >= queryInfo.lastRequestId) {
            if (hasErrors && options.errorPolicy === "none") {
              throw queryInfo.markError(new ApolloError({
                graphQLErrors
              }));
            }
            queryInfo.markResult(result2, linkDocument, options, cacheWriteBehavior);
            queryInfo.markReady();
          }
          var aqr = {
            data: result2.data,
            loading: false,
            networkStatus: NetworkStatus.ready
          };
          if (hasErrors && options.errorPolicy !== "ignore") {
            aqr.errors = graphQLErrors;
            aqr.networkStatus = NetworkStatus.error;
          }
          return aqr;
        }, function(networkError) {
          var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
          if (requestId >= queryInfo.lastRequestId) {
            queryInfo.markError(error);
          }
          throw error;
        });
      };
      QueryManager2.prototype.fetchConcastWithInfo = function(queryId, options, networkStatus, query) {
        var _this = this;
        if (networkStatus === void 0) {
          networkStatus = NetworkStatus.loading;
        }
        if (query === void 0) {
          query = options.query;
        }
        var variables = this.getVariables(query, options.variables);
        var queryInfo = this.getQuery(queryId);
        var defaults = this.defaultOptions.watchQuery;
        var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
        var normalized = Object.assign({}, options, {
          query,
          variables,
          fetchPolicy,
          errorPolicy,
          returnPartialData,
          notifyOnNetworkStatusChange,
          context
        });
        var fromVariables = function(variables2) {
          normalized.variables = variables2;
          var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
          if (
            // If we're in standby, postpone advancing options.fetchPolicy using
            // applyNextFetchPolicy.
            normalized.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
            // this is another way to detect when nothing was done/fetched.
            sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery
          ) {
            queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
          }
          return sourcesWithInfo2;
        };
        var cleanupCancelFn = function() {
          return _this.fetchCancelFns.delete(queryId);
        };
        this.fetchCancelFns.set(queryId, function(reason) {
          cleanupCancelFn();
          setTimeout(function() {
            return concast.cancel(reason);
          });
        });
        var concast, containsDataFromLink;
        if (this.getDocumentInfo(normalized.query).hasClientExports) {
          concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
            return sourcesWithInfo2.sources;
          }));
          containsDataFromLink = true;
        } else {
          var sourcesWithInfo = fromVariables(normalized.variables);
          containsDataFromLink = sourcesWithInfo.fromLink;
          concast = new Concast(sourcesWithInfo.sources);
        }
        concast.promise.then(cleanupCancelFn, cleanupCancelFn);
        return {
          concast,
          fromLink: containsDataFromLink
        };
      };
      QueryManager2.prototype.refetchQueries = function(_a2) {
        var _this = this;
        var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
        var includedQueriesById = /* @__PURE__ */ new Map();
        if (include) {
          this.getObservableQueries(include).forEach(function(oq, queryId) {
            includedQueriesById.set(queryId, {
              oq,
              lastDiff: _this.getQuery(queryId).getDiff()
            });
          });
        }
        var results = /* @__PURE__ */ new Map();
        if (updateCache) {
          this.cache.batch({
            update: updateCache,
            // Since you can perform any combination of cache reads and/or writes in
            // the cache.batch update function, its optimistic option can be either
            // a boolean or a string, representing three distinct modes of
            // operation:
            //
            // * false: read/write only the root layer
            // * true: read/write the topmost layer
            // * string: read/write a fresh optimistic layer with that ID string
            //
            // When typeof optimistic === "string", a new optimistic layer will be
            // temporarily created within cache.batch with that string as its ID. If
            // we then pass that same string as the removeOptimistic option, we can
            // make cache.batch immediately remove the optimistic layer after
            // running the updateCache function, triggering only one broadcast.
            //
            // However, the refetchQueries method accepts only true or false for its
            // optimistic option (not string). We interpret true to mean a temporary
            // optimistic layer should be created, to allow efficiently rolling back
            // the effect of the updateCache function, which involves passing a
            // string instead of true as the optimistic option to cache.batch, when
            // refetchQueries receives optimistic: true.
            //
            // In other words, we are deliberately not supporting the use case of
            // writing to an *existing* optimistic layer (using the refetchQueries
            // updateCache function), since that would potentially interfere with
            // other optimistic updates in progress. Instead, you can read/write
            // only the root layer by passing optimistic: false to refetchQueries,
            // or you can read/write a brand new optimistic layer that will be
            // automatically removed by passing optimistic: true.
            optimistic: optimistic && removeOptimistic || false,
            // The removeOptimistic option can also be provided by itself, even if
            // optimistic === false, to remove some previously-added optimistic
            // layer safely and efficiently, like we do in markMutationResult.
            //
            // If an explicit removeOptimistic string is provided with optimistic:
            // true, the removeOptimistic string will determine the ID of the
            // temporary optimistic layer, in case that ever matters.
            removeOptimistic,
            onWatchUpdated: function(watch, diff2, lastDiff) {
              var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
              if (oq) {
                if (onQueryUpdated) {
                  includedQueriesById.delete(oq.queryId);
                  var result2 = onQueryUpdated(oq, diff2, lastDiff);
                  if (result2 === true) {
                    result2 = oq.refetch();
                  }
                  if (result2 !== false) {
                    results.set(oq, result2);
                  }
                  return result2;
                }
                if (onQueryUpdated !== null) {
                  includedQueriesById.set(oq.queryId, { oq, lastDiff, diff: diff2 });
                }
              }
            }
          });
        }
        if (includedQueriesById.size) {
          includedQueriesById.forEach(function(_a3, queryId) {
            var oq = _a3.oq, lastDiff = _a3.lastDiff, diff2 = _a3.diff;
            var result2;
            if (onQueryUpdated) {
              if (!diff2) {
                var info = oq["queryInfo"];
                info.reset();
                diff2 = info.getDiff();
              }
              result2 = onQueryUpdated(oq, diff2, lastDiff);
            }
            if (!onQueryUpdated || result2 === true) {
              result2 = oq.refetch();
            }
            if (result2 !== false) {
              results.set(oq, result2);
            }
            if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
              _this.stopQueryNoBroadcast(queryId);
            }
          });
        }
        if (removeOptimistic) {
          this.cache.removeOptimistic(removeOptimistic);
        }
        return results;
      };
      QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
        var _this = this;
        var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
        var oldNetworkStatus = queryInfo.networkStatus;
        queryInfo.init({
          document: query,
          variables,
          networkStatus
        });
        var readCache = function() {
          return queryInfo.getDiff();
        };
        var resultsFromCache = function(diff3, networkStatus2) {
          if (networkStatus2 === void 0) {
            networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
          }
          var data = diff3.result;
          if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {
            logMissingFieldErrors(diff3.missing);
          }
          var fromData = function(data2) {
            return Observable.of(__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff3.complete ? null : { partial: true }));
          };
          if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
            return _this.localState.runResolvers({
              document: query,
              remoteResult: { data },
              context,
              variables,
              onlyRunForcedResolvers: true
            }).then(function(resolved) {
              return fromData(resolved.data || void 0);
            });
          }
          if (errorPolicy === "none" && networkStatus2 === NetworkStatus.refetch && Array.isArray(diff3.missing)) {
            return fromData(void 0);
          }
          return fromData(data);
        };
        var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
        var resultsFromLink = function() {
          return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
            query,
            variables,
            context,
            fetchPolicy,
            errorPolicy
          });
        };
        var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
        switch (fetchPolicy) {
          default:
          case "cache-first": {
            var diff2 = readCache();
            if (diff2.complete) {
              return {
                fromLink: false,
                sources: [resultsFromCache(diff2, queryInfo.markReady())]
              };
            }
            if (returnPartialData || shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(diff2), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          }
          case "cache-and-network": {
            var diff2 = readCache();
            if (diff2.complete || returnPartialData || shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(diff2), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          }
          case "cache-only":
            return {
              fromLink: false,
              sources: [resultsFromCache(readCache(), queryInfo.markReady())]
            };
          case "network-only":
            if (shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(readCache()), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          case "no-cache":
            if (shouldNotify) {
              return {
                fromLink: true,
                // Note that queryInfo.getDiff() for no-cache queries does not call
                // cache.diff, but instead returns a { complete: false } stub result
                // when there is no queryInfo.diff already defined.
                sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          case "standby":
            return { fromLink: false, sources: [] };
        }
      };
      QueryManager2.prototype.getQuery = function(queryId) {
        if (queryId && !this.queries.has(queryId)) {
          this.queries.set(queryId, new QueryInfo(this, queryId));
        }
        return this.queries.get(queryId);
      };
      QueryManager2.prototype.prepareContext = function(context) {
        if (context === void 0) {
          context = {};
        }
        var newContext = this.localState.prepareContext(context);
        return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
      };
      return QueryManager2;
    }();
  }
});

// ../node_modules/@apollo/client/core/LocalState.js
var import_dist712, import_dist713, import_dist714, LocalState;
var init_LocalState = __esm({
  "../node_modules/@apollo/client/core/LocalState.js"() {
    import_dist712 = __toESM(require_dist(), 1);
    import_dist713 = __toESM(require_dist2(), 1);
    import_dist714 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_graphql2();
    init_utilities2();
    init_cache2();
    LocalState = /** @class */
    function() {
      function LocalState2(_a2) {
        var cache2 = _a2.cache, client = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
        this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
        this.cache = cache2;
        if (client) {
          this.client = client;
        }
        if (resolvers) {
          this.addResolvers(resolvers);
        }
        if (fragmentMatcher) {
          this.setFragmentMatcher(fragmentMatcher);
        }
      }
      LocalState2.prototype.addResolvers = function(resolvers) {
        var _this = this;
        this.resolvers = this.resolvers || {};
        if (Array.isArray(resolvers)) {
          resolvers.forEach(function(resolverGroup) {
            _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
          });
        } else {
          this.resolvers = mergeDeep(this.resolvers, resolvers);
        }
      };
      LocalState2.prototype.setResolvers = function(resolvers) {
        this.resolvers = {};
        this.addResolvers(resolvers);
      };
      LocalState2.prototype.getResolvers = function() {
        return this.resolvers || {};
      };
      LocalState2.prototype.runResolvers = function(_a2) {
        return __awaiter(this, arguments, void 0, function(_b) {
          var document = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;
          return __generator(this, function(_d) {
            if (document) {
              return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
                return __assign(__assign({}, remoteResult), { data: localResult.result });
              })];
            }
            return [2, remoteResult];
          });
        });
      };
      LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
        this.fragmentMatcher = fragmentMatcher;
      };
      LocalState2.prototype.getFragmentMatcher = function() {
        return this.fragmentMatcher;
      };
      LocalState2.prototype.clientQuery = function(document) {
        if (hasDirectives(["client"], document)) {
          if (this.resolvers) {
            return document;
          }
        }
        return null;
      };
      LocalState2.prototype.serverQuery = function(document) {
        return removeClientSetsFromDocument(document);
      };
      LocalState2.prototype.prepareContext = function(context) {
        var cache2 = this.cache;
        return __assign(__assign({}, context), {
          cache: cache2,
          // Getting an entry's cache key is useful for local state resolvers.
          getCacheKey: function(obj) {
            return cache2.identify(obj);
          }
        });
      };
      LocalState2.prototype.addExportedVariables = function(document_1) {
        return __awaiter(this, arguments, void 0, function(document, variables, context) {
          if (variables === void 0) {
            variables = {};
          }
          if (context === void 0) {
            context = {};
          }
          return __generator(this, function(_a2) {
            if (document) {
              return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function(data) {
                return __assign(__assign({}, variables), data.exportedVariables);
              })];
            }
            return [2, __assign({}, variables)];
          });
        });
      };
      LocalState2.prototype.shouldForceResolvers = function(document) {
        var forceResolvers = false;
        visit(document, {
          Directive: {
            enter: function(node) {
              if (node.name.value === "client" && node.arguments) {
                forceResolvers = node.arguments.some(function(arg) {
                  return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
                });
                if (forceResolvers) {
                  return BREAK;
                }
              }
            }
          }
        });
        return forceResolvers;
      };
      LocalState2.prototype.buildRootValueFromCache = function(document, variables) {
        return this.cache.diff({
          query: buildQueryFromSelectionSet(document),
          variables,
          returnPartialData: true,
          optimistic: false
        }).result;
      };
      LocalState2.prototype.resolveDocument = function(document_1, rootValue_1) {
        return __awaiter(this, arguments, void 0, function(document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
          var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a2, cache2, client, execContext, isClientFieldDescendant;
          if (context === void 0) {
            context = {};
          }
          if (variables === void 0) {
            variables = {};
          }
          if (fragmentMatcher === void 0) {
            fragmentMatcher = function() {
              return true;
            };
          }
          if (onlyRunForcedResolvers === void 0) {
            onlyRunForcedResolvers = false;
          }
          return __generator(this, function(_b) {
            mainDefinition = getMainDefinition(document);
            fragments = getFragmentDefinitions(document);
            fragmentMap = createFragmentMap(fragments);
            selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
            definitionOperation = mainDefinition.operation;
            defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
            _a2 = this, cache2 = _a2.cache, client = _a2.client;
            execContext = {
              fragmentMap,
              context: __assign(__assign({}, context), { cache: cache2, client }),
              variables,
              fragmentMatcher,
              defaultOperationType,
              exportedVariables: {},
              selectionsToResolve,
              onlyRunForcedResolvers
            };
            isClientFieldDescendant = false;
            return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result2) {
              return {
                result: result2,
                exportedVariables: execContext.exportedVariables
              };
            })];
          });
        });
      };
      LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
        return __awaiter(this, void 0, void 0, function() {
          var fragmentMap, context, variables, resultsToMerge, execute3;
          var _this = this;
          return __generator(this, function(_a2) {
            fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
            resultsToMerge = [rootValue];
            execute3 = function(selection) {
              return __awaiter(_this, void 0, void 0, function() {
                var fragment, typeCondition;
                return __generator(this, function(_a3) {
                  if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!shouldInclude(selection, variables)) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (isField(selection)) {
                    return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                      var _a4;
                      if (typeof fieldResult !== "undefined") {
                        resultsToMerge.push((_a4 = {}, _a4[resultKeyNameFromField(selection)] = fieldResult, _a4));
                      }
                    })];
                  }
                  if (isInlineFragment(selection)) {
                    fragment = selection;
                  } else {
                    fragment = fragmentMap[selection.name.value];
                    invariant2(fragment, 18, selection.name.value);
                  }
                  if (fragment && fragment.typeCondition) {
                    typeCondition = fragment.typeCondition.name.value;
                    if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                      return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                        resultsToMerge.push(fragmentResult);
                      })];
                    }
                  }
                  return [
                    2
                    /*return*/
                  ];
                });
              });
            };
            return [2, Promise.all(selectionSet.selections.map(execute3)).then(function() {
              return mergeDeepArray(resultsToMerge);
            })];
          });
        });
      };
      LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
        return __awaiter(this, void 0, void 0, function() {
          var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
          var _this = this;
          return __generator(this, function(_a2) {
            if (!rootValue) {
              return [2, null];
            }
            variables = execContext.variables;
            fieldName = field.name.value;
            aliasedFieldName = resultKeyNameFromField(field);
            aliasUsed = fieldName !== aliasedFieldName;
            defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
            resultPromise = Promise.resolve(defaultResult);
            if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
              resolverType = rootValue.__typename || execContext.defaultOperationType;
              resolverMap = this.resolvers && this.resolvers[resolverType];
              if (resolverMap) {
                resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                if (resolve) {
                  resultPromise = Promise.resolve(
                    // In case the resolve function accesses reactive variables,
                    // set cacheSlot to the current cache instance.
                    cacheSlot.withValue(this.cache, resolve, [
                      rootValue,
                      argumentsObjectFromField(field, variables),
                      execContext.context,
                      { field, fragmentMap: execContext.fragmentMap }
                    ])
                  );
                }
              }
            }
            return [2, resultPromise.then(function(result2) {
              var _a3, _b;
              if (result2 === void 0) {
                result2 = defaultResult;
              }
              if (field.directives) {
                field.directives.forEach(function(directive) {
                  if (directive.name.value === "export" && directive.arguments) {
                    directive.arguments.forEach(function(arg) {
                      if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                        execContext.exportedVariables[arg.value.value] = result2;
                      }
                    });
                  }
                });
              }
              if (!field.selectionSet) {
                return result2;
              }
              if (result2 == null) {
                return result2;
              }
              var isClientField = (_b = (_a3 = field.directives) === null || _a3 === void 0 ? void 0 : _a3.some(function(d) {
                return d.name.value === "client";
              })) !== null && _b !== void 0 ? _b : false;
              if (Array.isArray(result2)) {
                return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result2, execContext);
              }
              if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result2, execContext);
              }
            })];
          });
        });
      };
      LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result2, execContext) {
        var _this = this;
        return Promise.all(result2.map(function(item) {
          if (item === null) {
            return null;
          }
          if (Array.isArray(item)) {
            return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
          }
        }));
      };
      LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
        var isSingleASTNode = function(node) {
          return !Array.isArray(node);
        };
        var selectionsToResolveCache = this.selectionsToResolveCache;
        function collectByDefinition(definitionNode) {
          if (!selectionsToResolveCache.has(definitionNode)) {
            var matches_1 = /* @__PURE__ */ new Set();
            selectionsToResolveCache.set(definitionNode, matches_1);
            visit(definitionNode, {
              Directive: function(node, _, __, ___, ancestors) {
                if (node.name.value === "client") {
                  ancestors.forEach(function(node2) {
                    if (isSingleASTNode(node2) && isSelectionNode(node2)) {
                      matches_1.add(node2);
                    }
                  });
                }
              },
              FragmentSpread: function(spread, _, __, ___, ancestors) {
                var fragment = fragmentMap[spread.name.value];
                invariant2(fragment, 19, spread.name.value);
                var fragmentSelections = collectByDefinition(fragment);
                if (fragmentSelections.size > 0) {
                  ancestors.forEach(function(node) {
                    if (isSingleASTNode(node) && isSelectionNode(node)) {
                      matches_1.add(node);
                    }
                  });
                  matches_1.add(spread);
                  fragmentSelections.forEach(function(selection) {
                    matches_1.add(selection);
                  });
                }
              }
            });
          }
          return selectionsToResolveCache.get(definitionNode);
        }
        return collectByDefinition(mainDefinition);
      };
      return LocalState2;
    }();
  }
});

// ../node_modules/@apollo/client/core/ApolloClient.js
var import_dist715, import_dist716, import_dist717, hasSuggestedDevtools, ApolloClient;
var init_ApolloClient = __esm({
  "../node_modules/@apollo/client/core/ApolloClient.js"() {
    import_dist715 = __toESM(require_dist(), 1);
    import_dist716 = __toESM(require_dist2(), 1);
    import_dist717 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    init_core();
    init_version();
    init_http();
    init_QueryManager();
    init_LocalState();
    init_utilities2();
    init_getMemoryInternals();
    hasSuggestedDevtools = false;
    ApolloClient = /** @class */
    function() {
      function ApolloClient2(options) {
        var _this = this;
        this.resetStoreCallbacks = [];
        this.clearStoreCallbacks = [];
        if (!options.cache) {
          throw newInvariantError(15);
        }
        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache2 = options.cache, documentTransform = options.documentTransform, _a2 = options.ssrMode, ssrMode = _a2 === void 0 ? false : _a2, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions2 = options.defaultOptions, defaultContext = options.defaultContext, _d = options.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? cache2.assumeImmutableResults : _d, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version, devtools = options.devtools;
        var link = options.link;
        if (!link) {
          link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
        }
        this.link = link;
        this.cache = cache2;
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
        this.typeDefs = typeDefs;
        this.devtoolsConfig = __assign(__assign({}, devtools), { enabled: (devtools === null || devtools === void 0 ? void 0 : devtools.enabled) || connectToDevTools });
        if (this.devtoolsConfig.enabled === void 0) {
          this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
        }
        if (ssrForceFetchDelay) {
          setTimeout(function() {
            return _this.disableNetworkFetches = false;
          }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.watchFragment = this.watchFragment.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        this.version = version;
        this.localState = new LocalState({
          cache: cache2,
          client: this,
          resolvers,
          fragmentMatcher
        });
        this.queryManager = new QueryManager({
          cache: this.cache,
          link: this.link,
          defaultOptions: this.defaultOptions,
          defaultContext,
          documentTransform,
          queryDeduplication,
          ssrMode,
          clientAwareness: {
            name: clientAwarenessName,
            version: clientAwarenessVersion
          },
          localState: this.localState,
          assumeImmutableResults,
          onBroadcast: this.devtoolsConfig.enabled ? function() {
            if (_this.devToolsHookCb) {
              _this.devToolsHookCb({
                action: {},
                state: {
                  queries: _this.queryManager.getQueryStore(),
                  mutations: _this.queryManager.mutationStore || {}
                },
                dataWithOptimisticResults: _this.cache.extract(true)
              });
            }
          } : void 0
        });
        if (this.devtoolsConfig.enabled)
          this.connectToDevTools();
      }
      ApolloClient2.prototype.connectToDevTools = function() {
        if (typeof window === "undefined") {
          return;
        }
        var windowWithDevTools = window;
        var devtoolsSymbol = Symbol.for("apollo.devtools");
        (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
        windowWithDevTools.__APOLLO_CLIENT__ = this;
        if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {
          hasSuggestedDevtools = true;
          if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
            setTimeout(function() {
              if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
                var nav = window.navigator;
                var ua = nav && nav.userAgent;
                var url = void 0;
                if (typeof ua === "string") {
                  if (ua.indexOf("Chrome/") > -1) {
                    url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                  } else if (ua.indexOf("Firefox/") > -1) {
                    url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                  }
                }
                if (url) {
                  globalThis.__DEV__ !== false && invariant2.log("Download the Apollo DevTools for a better development experience: %s", url);
                }
              }
            }, 1e4);
          }
        }
      };
      Object.defineProperty(ApolloClient2.prototype, "documentTransform", {
        /**
         * The `DocumentTransform` used to modify GraphQL documents before a request
         * is made. If a custom `DocumentTransform` is not provided, this will be the
         * default document transform.
         */
        get: function() {
          return this.queryManager.documentTransform;
        },
        enumerable: false,
        configurable: true
      });
      ApolloClient2.prototype.stop = function() {
        this.queryManager.stop();
      };
      ApolloClient2.prototype.watchQuery = function(options) {
        if (this.defaultOptions.watchQuery) {
          options = mergeOptions(this.defaultOptions.watchQuery, options);
        }
        if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
          options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.watchQuery(options);
      };
      ApolloClient2.prototype.query = function(options) {
        if (this.defaultOptions.query) {
          options = mergeOptions(this.defaultOptions.query, options);
        }
        invariant2(options.fetchPolicy !== "cache-and-network", 16);
        if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
          options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.query(options);
      };
      ApolloClient2.prototype.mutate = function(options) {
        if (this.defaultOptions.mutate) {
          options = mergeOptions(this.defaultOptions.mutate, options);
        }
        return this.queryManager.mutate(options);
      };
      ApolloClient2.prototype.subscribe = function(options) {
        return this.queryManager.startGraphQLSubscription(options);
      };
      ApolloClient2.prototype.readQuery = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readQuery(options, optimistic);
      };
      ApolloClient2.prototype.watchFragment = function(options) {
        return this.cache.watchFragment(options);
      };
      ApolloClient2.prototype.readFragment = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readFragment(options, optimistic);
      };
      ApolloClient2.prototype.writeQuery = function(options) {
        var ref = this.cache.writeQuery(options);
        if (options.broadcast !== false) {
          this.queryManager.broadcastQueries();
        }
        return ref;
      };
      ApolloClient2.prototype.writeFragment = function(options) {
        var ref = this.cache.writeFragment(options);
        if (options.broadcast !== false) {
          this.queryManager.broadcastQueries();
        }
        return ref;
      };
      ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
        this.devToolsHookCb = cb;
      };
      ApolloClient2.prototype.__requestRaw = function(payload) {
        return execute2(this.link, payload);
      };
      ApolloClient2.prototype.resetStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: false
          });
        }).then(function() {
          return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
            return fn();
          }));
        }).then(function() {
          return _this.reFetchObservableQueries();
        });
      };
      ApolloClient2.prototype.clearStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: true
          });
        }).then(function() {
          return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
            return fn();
          }));
        });
      };
      ApolloClient2.prototype.onResetStore = function(cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function() {
          _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient2.prototype.onClearStore = function(cb) {
        var _this = this;
        this.clearStoreCallbacks.push(cb);
        return function() {
          _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
        return this.queryManager.reFetchObservableQueries(includeStandby);
      };
      ApolloClient2.prototype.refetchQueries = function(options) {
        var map = this.queryManager.refetchQueries(options);
        var queries = [];
        var results = [];
        map.forEach(function(result3, obsQuery) {
          queries.push(obsQuery);
          results.push(result3);
        });
        var result2 = Promise.all(results);
        result2.queries = queries;
        result2.results = results;
        result2.catch(function(error) {
          globalThis.__DEV__ !== false && invariant2.debug(17, error);
        });
        return result2;
      };
      ApolloClient2.prototype.getObservableQueries = function(include) {
        if (include === void 0) {
          include = "active";
        }
        return this.queryManager.getObservableQueries(include);
      };
      ApolloClient2.prototype.extract = function(optimistic) {
        return this.cache.extract(optimistic);
      };
      ApolloClient2.prototype.restore = function(serializedState) {
        return this.cache.restore(serializedState);
      };
      ApolloClient2.prototype.addResolvers = function(resolvers) {
        this.localState.addResolvers(resolvers);
      };
      ApolloClient2.prototype.setResolvers = function(resolvers) {
        this.localState.setResolvers(resolvers);
      };
      ApolloClient2.prototype.getResolvers = function() {
        return this.localState.getResolvers();
      };
      ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
        this.localState.setFragmentMatcher(fragmentMatcher);
      };
      ApolloClient2.prototype.setLink = function(newLink) {
        this.link = this.queryManager.link = newLink;
      };
      Object.defineProperty(ApolloClient2.prototype, "defaultContext", {
        get: function() {
          return this.queryManager.defaultContext;
        },
        enumerable: false,
        configurable: true
      });
      return ApolloClient2;
    }();
    if (globalThis.__DEV__ !== false) {
      ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;
    }
  }
});

// ../node_modules/@apollo/client/core/types.js
var import_dist718, import_dist719, import_dist720;
var init_types3 = __esm({
  "../node_modules/@apollo/client/core/types.js"() {
    import_dist718 = __toESM(require_dist(), 1);
    import_dist719 = __toESM(require_dist2(), 1);
    import_dist720 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/graphql-tag/lib/index.js
var lib_exports5 = {};
__export(lib_exports5, {
  default: () => lib_default2,
  disableExperimentalFragmentVariables: () => disableExperimentalFragmentVariables,
  disableFragmentWarnings: () => disableFragmentWarnings,
  enableExperimentalFragmentVariables: () => enableExperimentalFragmentVariables,
  gql: () => gql,
  resetCaches: () => resetCaches
});
function normalize2(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize2(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize2(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result2 = literals[0];
  args.forEach(function(arg, i) {
    if (arg && arg.kind === "Document") {
      result2 += arg.loc.source.body;
    } else {
      result2 += arg;
    }
    result2 += literals[i + 1];
  });
  return parseDocument(result2);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var import_dist721, import_dist722, import_dist723, docCache, fragmentSourceMap, printFragmentWarnings, experimentalFragmentVariables, extras, lib_default2;
var init_lib7 = __esm({
  "../node_modules/graphql-tag/lib/index.js"() {
    import_dist721 = __toESM(require_dist());
    import_dist722 = __toESM(require_dist2());
    import_dist723 = __toESM(require_dist3());
    init_tslib_es6();
    init_graphql2();
    docCache = /* @__PURE__ */ new Map();
    fragmentSourceMap = /* @__PURE__ */ new Map();
    printFragmentWarnings = true;
    experimentalFragmentVariables = false;
    extras = {
      gql,
      resetCaches,
      disableFragmentWarnings,
      enableExperimentalFragmentVariables,
      disableExperimentalFragmentVariables
    };
    (function(gql_1) {
      gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
    })(gql || (gql = {}));
    gql["default"] = gql;
    lib_default2 = gql;
  }
});

// ../node_modules/@apollo/client/core/index.js
var import_dist724, import_dist725, import_dist726;
var init_core2 = __esm({
  "../node_modules/@apollo/client/core/index.js"() {
    import_dist724 = __toESM(require_dist(), 1);
    import_dist725 = __toESM(require_dist2(), 1);
    import_dist726 = __toESM(require_dist3(), 1);
    init_ApolloClient();
    init_ObservableQuery();
    init_networkStatus();
    init_types3();
    init_errors();
    init_cache2();
    init_types2();
    init_core();
    init_http();
    init_utils();
    init_utilities2();
    init_invariant();
    init_lib7();
    setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");
  }
});

// ../node_modules/rehackt/index.js
var require_rehackt = __commonJS({
  "../node_modules/rehackt/index.js"(exports, module2) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    if (0) {
      module2.exports = null;
    }
    module2.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = void 0;
    module2.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
    module2.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
    Object.assign(module2.exports, require_react());
  }
});

// ../node_modules/@apollo/client/react/context/ApolloContext.js
function getApolloContext() {
  invariant2("createContext" in React, 45);
  var context = React.createContext[contextKey];
  if (!context) {
    Object.defineProperty(React.createContext, contextKey, {
      value: context = React.createContext({}),
      enumerable: false,
      writable: false,
      configurable: true
    });
    context.displayName = "ApolloContext";
  }
  return context;
}
var import_dist727, import_dist728, import_dist729, React, contextKey, resetApolloContext;
var init_ApolloContext = __esm({
  "../node_modules/@apollo/client/react/context/ApolloContext.js"() {
    import_dist727 = __toESM(require_dist(), 1);
    import_dist728 = __toESM(require_dist2(), 1);
    import_dist729 = __toESM(require_dist3(), 1);
    React = __toESM(require_rehackt(), 1);
    init_utilities2();
    init_globals();
    contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
    resetApolloContext = getApolloContext;
  }
});

// ../node_modules/@apollo/client/react/context/ApolloProvider.js
var import_dist730, import_dist731, import_dist732, React2, ApolloProvider;
var init_ApolloProvider = __esm({
  "../node_modules/@apollo/client/react/context/ApolloProvider.js"() {
    import_dist730 = __toESM(require_dist(), 1);
    import_dist731 = __toESM(require_dist2(), 1);
    import_dist732 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    React2 = __toESM(require_rehackt(), 1);
    init_ApolloContext();
    ApolloProvider = function(_a2) {
      var client = _a2.client, children = _a2.children;
      var ApolloContext = getApolloContext();
      var parentContext = React2.useContext(ApolloContext);
      var context = React2.useMemo(function() {
        return __assign(__assign({}, parentContext), { client: client || parentContext.client });
      }, [parentContext, client]);
      invariant2(context.client, 46);
      return React2.createElement(ApolloContext.Provider, { value: context }, children);
    };
  }
});

// ../node_modules/@apollo/client/react/context/ApolloConsumer.js
var import_dist733, import_dist734, import_dist735, React3, ApolloConsumer;
var init_ApolloConsumer = __esm({
  "../node_modules/@apollo/client/react/context/ApolloConsumer.js"() {
    import_dist733 = __toESM(require_dist(), 1);
    import_dist734 = __toESM(require_dist2(), 1);
    import_dist735 = __toESM(require_dist3(), 1);
    init_globals();
    React3 = __toESM(require_rehackt(), 1);
    init_ApolloContext();
    ApolloConsumer = function(props) {
      var ApolloContext = getApolloContext();
      return React3.createElement(ApolloContext.Consumer, null, function(context) {
        invariant2(context && context.client, 44);
        return props.children(context.client);
      });
    };
  }
});

// ../node_modules/@apollo/client/react/context/index.js
var import_dist736, import_dist737, import_dist738;
var init_context2 = __esm({
  "../node_modules/@apollo/client/react/context/index.js"() {
    import_dist736 = __toESM(require_dist(), 1);
    import_dist737 = __toESM(require_dist2(), 1);
    import_dist738 = __toESM(require_dist3(), 1);
    init_globals();
    init_ApolloConsumer();
    init_ApolloContext();
    init_ApolloProvider();
  }
});

// ../node_modules/@apollo/client/react/hooks/useApolloClient.js
function useApolloClient(override) {
  var context = React4.useContext(getApolloContext());
  var client = override || context.client;
  invariant2(!!client, 49);
  return client;
}
var import_dist739, import_dist740, import_dist741, React4;
var init_useApolloClient = __esm({
  "../node_modules/@apollo/client/react/hooks/useApolloClient.js"() {
    import_dist739 = __toESM(require_dist(), 1);
    import_dist740 = __toESM(require_dist2(), 1);
    import_dist741 = __toESM(require_dist3(), 1);
    init_globals();
    React4 = __toESM(require_rehackt(), 1);
    init_context2();
  }
});

// ../node_modules/@apollo/client/react/hooks/useSyncExternalStore.js
function checkIfSnapshotChanged(_a2) {
  var value = _a2.value, getSnapshot = _a2.getSnapshot;
  try {
    return value !== getSnapshot();
  } catch (_b) {
    return true;
  }
}
var import_dist742, import_dist743, import_dist744, React5, didWarnUncachedGetSnapshot, uSESKey, realHook, useSyncExternalStore;
var init_useSyncExternalStore = __esm({
  "../node_modules/@apollo/client/react/hooks/useSyncExternalStore.js"() {
    import_dist742 = __toESM(require_dist(), 1);
    import_dist743 = __toESM(require_dist2(), 1);
    import_dist744 = __toESM(require_dist3(), 1);
    init_globals();
    React5 = __toESM(require_rehackt(), 1);
    init_utilities2();
    didWarnUncachedGetSnapshot = false;
    uSESKey = "useSyncExternalStore";
    realHook = React5[uSESKey];
    useSyncExternalStore = realHook || function(subscribe2, getSnapshot, getServerSnapshot) {
      var value = getSnapshot();
      if (
        // DEVIATION: Using __DEV__
        globalThis.__DEV__ !== false && !didWarnUncachedGetSnapshot && // DEVIATION: Not using Object.is because we know our snapshots will never
        // be exotic primitive values like NaN, which is !== itself.
        value !== getSnapshot()
      ) {
        didWarnUncachedGetSnapshot = true;
        globalThis.__DEV__ !== false && invariant2.error(59);
      }
      var _a2 = React5.useState({
        inst: { value, getSnapshot }
      }), inst = _a2[0].inst, forceUpdate = _a2[1];
      if (canUseLayoutEffect) {
        React5.useLayoutEffect(function() {
          Object.assign(inst, { value, getSnapshot });
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({ inst });
          }
        }, [subscribe2, value, getSnapshot]);
      } else {
        Object.assign(inst, { value, getSnapshot });
      }
      React5.useEffect(function() {
        if (checkIfSnapshotChanged(inst)) {
          forceUpdate({ inst });
        }
        return subscribe2(function handleStoreChange() {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({ inst });
          }
        });
      }, [subscribe2]);
      return value;
    };
  }
});

// ../node_modules/@apollo/client/react/parser/index.js
function operationName(type) {
  var name;
  switch (type) {
    case DocumentType.Query:
      name = "Query";
      break;
    case DocumentType.Mutation:
      name = "Mutation";
      break;
    case DocumentType.Subscription:
      name = "Subscription";
      break;
  }
  return name;
}
function parser(document) {
  if (!cache) {
    cache = new AutoCleanedWeakCache(
      cacheSizes.parser || 1e3
      /* defaultCacheSizes.parser */
    );
  }
  var cached = cache.get(document);
  if (cached)
    return cached;
  var variables, type, name;
  invariant2(!!document && !!document.kind, 61, document);
  var fragments = [];
  var queries = [];
  var mutations = [];
  var subscriptions = [];
  for (var _i = 0, _a2 = document.definitions; _i < _a2.length; _i++) {
    var x = _a2[_i];
    if (x.kind === "FragmentDefinition") {
      fragments.push(x);
      continue;
    }
    if (x.kind === "OperationDefinition") {
      switch (x.operation) {
        case "query":
          queries.push(x);
          break;
        case "mutation":
          mutations.push(x);
          break;
        case "subscription":
          subscriptions.push(x);
          break;
      }
    }
  }
  invariant2(!fragments.length || queries.length || mutations.length || subscriptions.length, 62);
  invariant2(
    queries.length + mutations.length + subscriptions.length <= 1,
    63,
    document,
    queries.length,
    subscriptions.length,
    mutations.length
  );
  type = queries.length ? DocumentType.Query : DocumentType.Mutation;
  if (!queries.length && !mutations.length)
    type = DocumentType.Subscription;
  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
  invariant2(definitions.length === 1, 64, document, definitions.length);
  var definition = definitions[0];
  variables = definition.variableDefinitions || [];
  if (definition.name && definition.name.kind === "Name") {
    name = definition.name.value;
  } else {
    name = "data";
  }
  var payload = { name, type, variables };
  cache.set(document, payload);
  return payload;
}
function verifyDocumentType(document, type) {
  var operation = parser(document);
  var requiredOperationName = operationName(type);
  var usedOperationName = operationName(operation.type);
  invariant2(
    operation.type === type,
    65,
    requiredOperationName,
    requiredOperationName,
    usedOperationName
  );
}
var import_dist745, import_dist746, import_dist747, DocumentType, cache;
var init_parser2 = __esm({
  "../node_modules/@apollo/client/react/parser/index.js"() {
    import_dist745 = __toESM(require_dist(), 1);
    import_dist746 = __toESM(require_dist2(), 1);
    import_dist747 = __toESM(require_dist3(), 1);
    init_globals();
    init_utilities2();
    init_getMemoryInternals();
    (function(DocumentType2) {
      DocumentType2[DocumentType2["Query"] = 0] = "Query";
      DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
      DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
    })(DocumentType || (DocumentType = {}));
    parser.resetCache = function() {
      cache = void 0;
    };
    if (globalThis.__DEV__ !== false) {
      registerGlobalCache("parser", function() {
        return cache ? cache.size : 0;
      });
    }
  }
});

// ../node_modules/@apollo/client/react/hooks/internal/useDeepMemo.js
function useDeepMemo(memoFn, deps) {
  var ref = React6.useRef();
  if (!ref.current || !equal(ref.current.deps, deps)) {
    ref.current = { value: memoFn(), deps };
  }
  return ref.current.value;
}
var import_dist748, import_dist749, import_dist750, React6;
var init_useDeepMemo = __esm({
  "../node_modules/@apollo/client/react/hooks/internal/useDeepMemo.js"() {
    import_dist748 = __toESM(require_dist(), 1);
    import_dist749 = __toESM(require_dist2(), 1);
    import_dist750 = __toESM(require_dist3(), 1);
    React6 = __toESM(require_rehackt(), 1);
    init_lib6();
  }
});

// ../node_modules/@apollo/client/react/hooks/internal/useIsomorphicLayoutEffect.js
var import_dist751, import_dist752, import_dist753, React7, useIsomorphicLayoutEffect;
var init_useIsomorphicLayoutEffect = __esm({
  "../node_modules/@apollo/client/react/hooks/internal/useIsomorphicLayoutEffect.js"() {
    import_dist751 = __toESM(require_dist(), 1);
    import_dist752 = __toESM(require_dist2(), 1);
    import_dist753 = __toESM(require_dist3(), 1);
    React7 = __toESM(require_rehackt(), 1);
    init_utilities2();
    useIsomorphicLayoutEffect = canUseDOM ? React7.useLayoutEffect : React7.useEffect;
  }
});

// ../node_modules/@apollo/client/react/hooks/internal/useRenderGuard.js
function noop2() {
}
function useRenderGuard() {
  if (!Ctx) {
    Ctx = React8.createContext(null);
  }
  return React8.useCallback(
    /**
     * @returns true if the hook was called during render
     */
    function() {
      var orig = console.error;
      try {
        console.error = noop2;
        React8["useContext"](Ctx);
        return true;
      } catch (e) {
        return false;
      } finally {
        console.error = orig;
      }
    },
    []
  );
}
var import_dist754, import_dist755, import_dist756, React8, Ctx;
var init_useRenderGuard = __esm({
  "../node_modules/@apollo/client/react/hooks/internal/useRenderGuard.js"() {
    import_dist754 = __toESM(require_dist(), 1);
    import_dist755 = __toESM(require_dist2(), 1);
    import_dist756 = __toESM(require_dist3(), 1);
    React8 = __toESM(require_rehackt(), 1);
  }
});

// ../node_modules/@apollo/client/react/hooks/internal/useLazyRef.js
function useLazyRef(getInitialValue) {
  var ref = React9.useRef(INIT);
  if (ref.current === INIT) {
    ref.current = getInitialValue();
  }
  return ref;
}
var import_dist757, import_dist758, import_dist759, React9, INIT;
var init_useLazyRef = __esm({
  "../node_modules/@apollo/client/react/hooks/internal/useLazyRef.js"() {
    import_dist757 = __toESM(require_dist(), 1);
    import_dist758 = __toESM(require_dist2(), 1);
    import_dist759 = __toESM(require_dist3(), 1);
    React9 = __toESM(require_rehackt(), 1);
    INIT = {};
  }
});

// ../node_modules/@apollo/client/react/hooks/internal/__use.js
var import_dist760, import_dist761, import_dist762, React10, useKey, realHook2, __use;
var init_use = __esm({
  "../node_modules/@apollo/client/react/hooks/internal/__use.js"() {
    import_dist760 = __toESM(require_dist(), 1);
    import_dist761 = __toESM(require_dist2(), 1);
    import_dist762 = __toESM(require_dist3(), 1);
    init_utilities2();
    React10 = __toESM(require_rehackt(), 1);
    useKey = "use";
    realHook2 = React10[useKey];
    __use = realHook2 || function __use2(promise) {
      var statefulPromise = wrapPromiseWithState(promise);
      switch (statefulPromise.status) {
        case "pending":
          throw statefulPromise;
        case "rejected":
          throw statefulPromise.reason;
        case "fulfilled":
          return statefulPromise.value;
      }
    };
  }
});

// ../node_modules/@apollo/client/react/hooks/internal/wrapHook.js
function wrapHook(hookName, useHook, clientOrObsQuery) {
  var queryManager = clientOrObsQuery["queryManager"];
  var wrappers = queryManager && queryManager[wrapperSymbol];
  var wrapper = wrappers && wrappers[hookName];
  return wrapper ? wrapper(useHook) : useHook;
}
var import_dist763, import_dist764, import_dist765, wrapperSymbol;
var init_wrapHook = __esm({
  "../node_modules/@apollo/client/react/hooks/internal/wrapHook.js"() {
    import_dist763 = __toESM(require_dist(), 1);
    import_dist764 = __toESM(require_dist2(), 1);
    import_dist765 = __toESM(require_dist3(), 1);
    wrapperSymbol = Symbol.for("apollo.hook.wrappers");
  }
});

// ../node_modules/@apollo/client/react/hooks/internal/index.js
var import_dist766, import_dist767, import_dist768;
var init_internal = __esm({
  "../node_modules/@apollo/client/react/hooks/internal/index.js"() {
    import_dist766 = __toESM(require_dist(), 1);
    import_dist767 = __toESM(require_dist2(), 1);
    import_dist768 = __toESM(require_dist3(), 1);
    init_useDeepMemo();
    init_useIsomorphicLayoutEffect();
    init_useRenderGuard();
    init_useLazyRef();
    init_use();
    init_wrapHook();
  }
});

// ../node_modules/@apollo/client/react/hooks/useQuery.js
function noop3() {
}
function useQuery(query, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  return wrapHook("useQuery", _useQuery, useApolloClient(options && options.client))(query, options);
}
function _useQuery(query, options) {
  var _a2 = useQueryInternals(query, options), result2 = _a2.result, obsQueryFields = _a2.obsQueryFields;
  return React11.useMemo(function() {
    return __assign(__assign({}, result2), obsQueryFields);
  }, [result2, obsQueryFields]);
}
function useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {
  function createInternalState(previous) {
    var _a3;
    verifyDocumentType(query, DocumentType.Query);
    var internalState2 = {
      client,
      query,
      observable: (
        // See if there is an existing observable that was used to fetch the same
        // data and if so, use it instead since it will contain the proper queryId
        // to fetch the result set. This is used during SSR.
        renderPromises && renderPromises.getSSRObservable(makeWatchQueryOptions()) || client.watchQuery(getObsQueryOptions(void 0, client, options, makeWatchQueryOptions()))
      ),
      resultData: {
        // Reuse previousData from previous InternalState (if any) to provide
        // continuity of previousData even if/when the query or client changes.
        previousData: (_a3 = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a3 === void 0 ? void 0 : _a3.data
      }
    };
    return internalState2;
  }
  var _a2 = React11.useState(createInternalState), internalState = _a2[0], updateInternalState = _a2[1];
  function onQueryExecuted(watchQueryOptions) {
    var _a3;
    var _b;
    Object.assign(internalState.observable, (_a3 = {}, _a3[lastWatchOptions] = watchQueryOptions, _a3));
    var resultData = internalState.resultData;
    updateInternalState(__assign(__assign({}, internalState), {
      // might be a different query
      query: watchQueryOptions.query,
      resultData: Object.assign(resultData, {
        // We need to modify the previous `resultData` object as we rely on the
        // object reference in other places
        previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,
        current: void 0
      })
    }));
  }
  if (client !== internalState.client || query !== internalState.query) {
    var newInternalState = createInternalState(internalState);
    updateInternalState(newInternalState);
    return [newInternalState, onQueryExecuted];
  }
  return [internalState, onQueryExecuted];
}
function useQueryInternals(query, options) {
  var client = useApolloClient(options.client);
  var renderPromises = React11.useContext(getApolloContext()).renderPromises;
  var isSyncSSR = !!renderPromises;
  var disableNetworkFetches = client.disableNetworkFetches;
  var ssrAllowed = options.ssr !== false && !options.skip;
  var partialRefetch = options.partialRefetch;
  var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options, isSyncSSR);
  var _a2 = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a2[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a2[1];
  var watchQueryOptions = makeWatchQueryOptions(observable);
  useResubscribeIfNecessary(
    resultData,
    // might get mutated during render
    observable,
    // might get mutated during render
    client,
    options,
    watchQueryOptions
  );
  var obsQueryFields = React11.useMemo(function() {
    return bindObservableMethods(observable);
  }, [observable]);
  useRegisterSSRObservable(observable, renderPromises, ssrAllowed);
  var result2 = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {
    onCompleted: options.onCompleted || noop3,
    onError: options.onError || noop3
  });
  return {
    result: result2,
    obsQueryFields,
    observable,
    resultData,
    client,
    onQueryExecuted
  };
}
function useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {
  var callbackRef = React11.useRef(callbacks);
  React11.useEffect(function() {
    callbackRef.current = callbacks;
  });
  var resultOverride = (isSyncSSR || disableNetworkFetches) && options.ssr === false && !options.skip ? (
    // If SSR has been explicitly disabled, and this function has been called
    // on the server side, return the default loading state.
    ssrDisabledResult
  ) : options.skip || watchQueryOptions.fetchPolicy === "standby" ? (
    // When skipping a query (ie. we're not querying for data but still want to
    // render children), make sure the `data` is cleared out and `loading` is
    // set to `false` (since we aren't loading anything).
    //
    // NOTE: We no longer think this is the correct behavior. Skipping should
    // not automatically set `data` to `undefined`, but instead leave the
    // previous data in place. In other words, skipping should not mandate that
    // previously received data is all of a sudden removed. Unfortunately,
    // changing this is breaking, so we'll have to wait until Apollo Client 4.0
    // to address this.
    skipStandbyResult
  ) : void 0;
  var previousData = resultData.previousData;
  var currentResultOverride = React11.useMemo(function() {
    return resultOverride && toQueryResult(resultOverride, previousData, observable, client);
  }, [client, observable, resultOverride, previousData]);
  return useSyncExternalStore(React11.useCallback(function(handleStoreChange) {
    disableNetworkFetches;
    if (isSyncSSR) {
      return function() {
      };
    }
    var onNext = function() {
      var previousResult = resultData.current;
      var result2 = observable.getCurrentResult();
      if (previousResult && previousResult.loading === result2.loading && previousResult.networkStatus === result2.networkStatus && equal(previousResult.data, result2.data)) {
        return;
      }
      setResult(result2, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
    };
    var onError = function(error) {
      subscription.current.unsubscribe();
      subscription.current = observable.resubscribeAfterError(onNext, onError);
      if (!hasOwnProperty10.call(error, "graphQLErrors")) {
        throw error;
      }
      var previousResult = resultData.current;
      if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {
        setResult({
          data: previousResult && previousResult.data,
          error,
          loading: false,
          networkStatus: NetworkStatus.error
        }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
      }
    };
    var subscription = { current: observable.subscribe(onNext, onError) };
    return function() {
      setTimeout(function() {
        return subscription.current.unsubscribe();
      });
    };
  }, [
    disableNetworkFetches,
    isSyncSSR,
    observable,
    resultData,
    partialRefetch,
    client
  ]), function() {
    return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
  }, function() {
    return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
  });
}
function useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {
  if (renderPromises && ssrAllowed) {
    renderPromises.registerSSRObservable(observable);
    if (observable.getCurrentResult().loading) {
      renderPromises.addObservableQueryPromise(observable);
    }
  }
}
function useResubscribeIfNecessary(resultData, observable, client, options, watchQueryOptions) {
  var _a2;
  if (observable[lastWatchOptions] && !equal(observable[lastWatchOptions], watchQueryOptions)) {
    observable.reobserve(getObsQueryOptions(observable, client, options, watchQueryOptions));
    resultData.previousData = ((_a2 = resultData.current) === null || _a2 === void 0 ? void 0 : _a2.data) || resultData.previousData;
    resultData.current = void 0;
  }
  observable[lastWatchOptions] = watchQueryOptions;
}
function createMakeWatchQueryOptions(client, query, _a2, isSyncSSR) {
  if (_a2 === void 0) {
    _a2 = {};
  }
  var skip = _a2.skip, ssr = _a2.ssr, onCompleted = _a2.onCompleted, onError = _a2.onError, defaultOptions2 = _a2.defaultOptions, otherOptions = __rest(_a2, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]);
  return function(observable) {
    var watchQueryOptions = Object.assign(otherOptions, { query });
    if (isSyncSSR && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
      watchQueryOptions.fetchPolicy = "cache-first";
    }
    if (!watchQueryOptions.variables) {
      watchQueryOptions.variables = {};
    }
    if (skip) {
      watchQueryOptions.initialFetchPolicy = watchQueryOptions.initialFetchPolicy || watchQueryOptions.fetchPolicy || getDefaultFetchPolicy(defaultOptions2, client.defaultOptions);
      watchQueryOptions.fetchPolicy = "standby";
    } else if (!watchQueryOptions.fetchPolicy) {
      watchQueryOptions.fetchPolicy = (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) || getDefaultFetchPolicy(defaultOptions2, client.defaultOptions);
    }
    return watchQueryOptions;
  };
}
function getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {
  var toMerge = [];
  var globalDefaults = client.defaultOptions.watchQuery;
  if (globalDefaults)
    toMerge.push(globalDefaults);
  if (queryHookOptions.defaultOptions) {
    toMerge.push(queryHookOptions.defaultOptions);
  }
  toMerge.push(compact(observable && observable.options, watchQueryOptions));
  return toMerge.reduce(mergeOptions);
}
function setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {
  var previousResult = resultData.current;
  if (previousResult && previousResult.data) {
    resultData.previousData = previousResult.data;
  }
  if (!nextResult.error && isNonEmptyArray(nextResult.errors)) {
    nextResult.error = new ApolloError({ graphQLErrors: nextResult.errors });
  }
  resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);
  forceUpdate();
  handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);
}
function handleErrorOrCompleted(result2, previousNetworkStatus, callbacks) {
  if (!result2.loading) {
    var error_1 = toApolloError(result2);
    Promise.resolve().then(function() {
      if (error_1) {
        callbacks.onError(error_1);
      } else if (result2.data && previousNetworkStatus !== result2.networkStatus && result2.networkStatus === NetworkStatus.ready) {
        callbacks.onCompleted(result2.data);
      }
    }).catch(function(error) {
      globalThis.__DEV__ !== false && invariant2.warn(error);
    });
  }
}
function getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {
  if (!resultData.current) {
    setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function() {
    }, callbacks);
  }
  return resultData.current;
}
function getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {
  var _a2;
  return (queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) || ((_a2 = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a2 === void 0 ? void 0 : _a2.fetchPolicy) || "cache-first";
}
function toApolloError(result2) {
  return isNonEmptyArray(result2.errors) ? new ApolloError({ graphQLErrors: result2.errors }) : result2.error;
}
function toQueryResult(result2, previousData, observable, client) {
  var data = result2.data, partial = result2.partial, resultWithoutPartial = __rest(result2, ["data", "partial"]);
  var queryResult = __assign(__assign({ data }, resultWithoutPartial), { client, observable, variables: observable.variables, called: result2 !== ssrDisabledResult && result2 !== skipStandbyResult, previousData });
  return queryResult;
}
function unsafeHandlePartialRefetch(result2, observable, partialRefetch) {
  if (result2.partial && partialRefetch && !result2.loading && (!result2.data || Object.keys(result2.data).length === 0) && observable.options.fetchPolicy !== "cache-only") {
    observable.refetch();
    return __assign(__assign({}, result2), { loading: true, networkStatus: NetworkStatus.refetch });
  }
  return result2;
}
function bindObservableMethods(observable) {
  return {
    refetch: observable.refetch.bind(observable),
    reobserve: observable.reobserve.bind(observable),
    fetchMore: observable.fetchMore.bind(observable),
    updateQuery: observable.updateQuery.bind(observable),
    startPolling: observable.startPolling.bind(observable),
    stopPolling: observable.stopPolling.bind(observable),
    subscribeToMore: observable.subscribeToMore.bind(observable)
  };
}
var import_dist769, import_dist770, import_dist771, React11, hasOwnProperty10, lastWatchOptions, ssrDisabledResult, skipStandbyResult;
var init_useQuery = __esm({
  "../node_modules/@apollo/client/react/hooks/useQuery.js"() {
    import_dist769 = __toESM(require_dist(), 1);
    import_dist770 = __toESM(require_dist2(), 1);
    import_dist771 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    React11 = __toESM(require_rehackt(), 1);
    init_useSyncExternalStore();
    init_lib6();
    init_utilities2();
    init_context2();
    init_errors();
    init_core2();
    init_parser2();
    init_useApolloClient();
    init_utilities2();
    init_internal();
    hasOwnProperty10 = Object.prototype.hasOwnProperty;
    lastWatchOptions = Symbol();
    ssrDisabledResult = maybeDeepFreeze({
      loading: true,
      data: void 0,
      error: void 0,
      networkStatus: NetworkStatus.loading
    });
    skipStandbyResult = maybeDeepFreeze({
      loading: false,
      data: void 0,
      error: void 0,
      networkStatus: NetworkStatus.ready
    });
  }
});

// ../node_modules/@apollo/client/react/hooks/useLazyQuery.js
function useLazyQuery(query, options) {
  var _a2;
  var execOptionsRef = React12.useRef();
  var optionsRef = React12.useRef();
  var queryRef = React12.useRef();
  var merged = mergeOptions(options, execOptionsRef.current || {});
  var document = (_a2 = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a2 !== void 0 ? _a2 : query;
  optionsRef.current = options;
  queryRef.current = document;
  var queryHookOptions = __assign(__assign({}, merged), { skip: !execOptionsRef.current });
  var _b = useQueryInternals(document, queryHookOptions), obsQueryFields = _b.obsQueryFields, useQueryResult = _b.result, client = _b.client, resultData = _b.resultData, observable = _b.observable, onQueryExecuted = _b.onQueryExecuted;
  var initialFetchPolicy = observable.options.initialFetchPolicy || getDefaultFetchPolicy(queryHookOptions.defaultOptions, client.defaultOptions);
  var forceUpdateState = React12.useReducer(function(tick) {
    return tick + 1;
  }, 0)[1];
  var eagerMethods = React12.useMemo(function() {
    var eagerMethods2 = {};
    var _loop_1 = function(key2) {
      var method = obsQueryFields[key2];
      eagerMethods2[key2] = function() {
        if (!execOptionsRef.current) {
          execOptionsRef.current = /* @__PURE__ */ Object.create(null);
          forceUpdateState();
        }
        return method.apply(this, arguments);
      };
    };
    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {
      var key = EAGER_METHODS_1[_i];
      _loop_1(key);
    }
    return eagerMethods2;
  }, [forceUpdateState, obsQueryFields]);
  var called = !!execOptionsRef.current;
  var result2 = React12.useMemo(function() {
    return __assign(__assign(__assign({}, useQueryResult), eagerMethods), { called });
  }, [useQueryResult, eagerMethods, called]);
  var execute3 = React12.useCallback(function(executeOptions) {
    execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {
      fetchPolicy: initialFetchPolicy
    };
    var options2 = mergeOptions(optionsRef.current, __assign({ query: queryRef.current }, execOptionsRef.current));
    var promise = executeQuery(resultData, observable, client, document, __assign(__assign({}, options2), { skip: false }), onQueryExecuted).then(function(queryResult) {
      return Object.assign(queryResult, eagerMethods);
    });
    promise.catch(function() {
    });
    return promise;
  }, [
    client,
    document,
    eagerMethods,
    initialFetchPolicy,
    observable,
    resultData,
    onQueryExecuted
  ]);
  var executeRef = React12.useRef(execute3);
  useIsomorphicLayoutEffect(function() {
    executeRef.current = execute3;
  });
  var stableExecute = React12.useCallback(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return executeRef.current.apply(executeRef, args);
  }, []);
  return [stableExecute, result2];
}
function executeQuery(resultData, observable, client, currentQuery, options, onQueryExecuted) {
  var query = options.query || currentQuery;
  var watchQueryOptions = createMakeWatchQueryOptions(client, query, options, false)(observable);
  var concast = observable.reobserveAsConcast(getObsQueryOptions(observable, client, options, watchQueryOptions));
  onQueryExecuted(watchQueryOptions);
  return new Promise(function(resolve) {
    var result2;
    concast.subscribe({
      next: function(value) {
        result2 = value;
      },
      error: function() {
        resolve(toQueryResult(observable.getCurrentResult(), resultData.previousData, observable, client));
      },
      complete: function() {
        resolve(toQueryResult(result2, resultData.previousData, observable, client));
      }
    });
  });
}
var import_dist772, import_dist773, import_dist774, React12, EAGER_METHODS;
var init_useLazyQuery = __esm({
  "../node_modules/@apollo/client/react/hooks/useLazyQuery.js"() {
    import_dist772 = __toESM(require_dist(), 1);
    import_dist773 = __toESM(require_dist2(), 1);
    import_dist774 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    React12 = __toESM(require_rehackt(), 1);
    init_utilities2();
    init_useQuery();
    init_useIsomorphicLayoutEffect();
    EAGER_METHODS = [
      "refetch",
      "reobserve",
      "fetchMore",
      "updateQuery",
      "startPolling",
      "stopPolling",
      "subscribeToMore"
    ];
  }
});

// ../node_modules/@apollo/client/react/hooks/useMutation.js
function useMutation(mutation, options) {
  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
  verifyDocumentType(mutation, DocumentType.Mutation);
  var _a2 = React13.useState({
    called: false,
    loading: false,
    client
  }), result2 = _a2[0], setResult2 = _a2[1];
  var ref = React13.useRef({
    result: result2,
    mutationId: 0,
    isMounted: true,
    client,
    mutation,
    options
  });
  useIsomorphicLayoutEffect(function() {
    Object.assign(ref.current, { client, options, mutation });
  });
  var execute3 = React13.useCallback(function(executeOptions) {
    if (executeOptions === void 0) {
      executeOptions = {};
    }
    var _a3 = ref.current, options2 = _a3.options, mutation2 = _a3.mutation;
    var baseOptions = __assign(__assign({}, options2), { mutation: mutation2 });
    var client2 = executeOptions.client || ref.current.client;
    if (!ref.current.result.loading && !baseOptions.ignoreResults && ref.current.isMounted) {
      setResult2(ref.current.result = {
        loading: true,
        error: void 0,
        data: void 0,
        called: true,
        client: client2
      });
    }
    var mutationId = ++ref.current.mutationId;
    var clientOptions = mergeOptions(baseOptions, executeOptions);
    return client2.mutate(clientOptions).then(function(response) {
      var _a4, _b;
      var data = response.data, errors = response.errors;
      var error = errors && errors.length > 0 ? new ApolloError({ graphQLErrors: errors }) : void 0;
      var onError = executeOptions.onError || ((_a4 = ref.current.options) === null || _a4 === void 0 ? void 0 : _a4.onError);
      if (error && onError) {
        onError(error, clientOptions);
      }
      if (mutationId === ref.current.mutationId && !clientOptions.ignoreResults) {
        var result_1 = {
          called: true,
          loading: false,
          data,
          error,
          client: client2
        };
        if (ref.current.isMounted && !equal(ref.current.result, result_1)) {
          setResult2(ref.current.result = result_1);
        }
      }
      var onCompleted = executeOptions.onCompleted || ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onCompleted);
      if (!error) {
        onCompleted === null || onCompleted === void 0 ? void 0 : onCompleted(response.data, clientOptions);
      }
      return response;
    }).catch(function(error) {
      var _a4;
      if (mutationId === ref.current.mutationId && ref.current.isMounted) {
        var result_2 = {
          loading: false,
          error,
          data: void 0,
          called: true,
          client: client2
        };
        if (!equal(ref.current.result, result_2)) {
          setResult2(ref.current.result = result_2);
        }
      }
      var onError = executeOptions.onError || ((_a4 = ref.current.options) === null || _a4 === void 0 ? void 0 : _a4.onError);
      if (onError) {
        onError(error, clientOptions);
        return { data: void 0, errors: error };
      }
      throw error;
    });
  }, []);
  var reset = React13.useCallback(function() {
    if (ref.current.isMounted) {
      var result_3 = {
        called: false,
        loading: false,
        client: ref.current.client
      };
      Object.assign(ref.current, { mutationId: 0, result: result_3 });
      setResult2(result_3);
    }
  }, []);
  React13.useEffect(function() {
    var current = ref.current;
    current.isMounted = true;
    return function() {
      current.isMounted = false;
    };
  }, []);
  return [execute3, __assign({ reset }, result2)];
}
var import_dist775, import_dist776, import_dist777, React13;
var init_useMutation = __esm({
  "../node_modules/@apollo/client/react/hooks/useMutation.js"() {
    import_dist775 = __toESM(require_dist(), 1);
    import_dist776 = __toESM(require_dist2(), 1);
    import_dist777 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    React13 = __toESM(require_rehackt(), 1);
    init_utilities2();
    init_lib6();
    init_parser2();
    init_errors();
    init_useApolloClient();
    init_useIsomorphicLayoutEffect();
  }
});

// ../node_modules/@apollo/client/react/hooks/useSubscription.js
function useSubscription(subscription, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  var hasIssuedDeprecationWarningRef = React14.useRef(false);
  var client = useApolloClient(options.client);
  verifyDocumentType(subscription, DocumentType.Subscription);
  if (!hasIssuedDeprecationWarningRef.current) {
    hasIssuedDeprecationWarningRef.current = true;
    if (options.onSubscriptionData) {
      globalThis.__DEV__ !== false && invariant2.warn(options.onData ? 52 : 53);
    }
    if (options.onSubscriptionComplete) {
      globalThis.__DEV__ !== false && invariant2.warn(options.onComplete ? 54 : 55);
    }
  }
  var skip = options.skip, fetchPolicy = options.fetchPolicy, errorPolicy = options.errorPolicy, shouldResubscribe = options.shouldResubscribe, context = options.context, extensions = options.extensions, ignoreResults = options.ignoreResults;
  var variables = useDeepMemo(function() {
    return options.variables;
  }, [options.variables]);
  var recreate = function() {
    return createSubscription(client, subscription, variables, fetchPolicy, errorPolicy, context, extensions);
  };
  var _a2 = React14.useState(options.skip ? null : recreate), observable = _a2[0], setObservable = _a2[1];
  var recreateRef = React14.useRef(recreate);
  useIsomorphicLayoutEffect(function() {
    recreateRef.current = recreate;
  });
  if (skip) {
    if (observable) {
      setObservable(observable = null);
    }
  } else if (!observable || (client !== observable.__.client || subscription !== observable.__.query || fetchPolicy !== observable.__.fetchPolicy || errorPolicy !== observable.__.errorPolicy || !equal(variables, observable.__.variables)) && (typeof shouldResubscribe === "function" ? !!shouldResubscribe(options) : shouldResubscribe) !== false) {
    setObservable(observable = recreate());
  }
  var optionsRef = React14.useRef(options);
  React14.useEffect(function() {
    optionsRef.current = options;
  });
  var fallbackLoading = !skip && !ignoreResults;
  var fallbackResult = React14.useMemo(function() {
    return {
      loading: fallbackLoading,
      error: void 0,
      data: void 0,
      variables
    };
  }, [fallbackLoading, variables]);
  var ignoreResultsRef = React14.useRef(ignoreResults);
  useIsomorphicLayoutEffect(function() {
    ignoreResultsRef.current = ignoreResults;
  });
  var ret = useSyncExternalStore(React14.useCallback(function(update) {
    if (!observable) {
      return function() {
      };
    }
    var subscriptionStopped = false;
    var variables2 = observable.__.variables;
    var client2 = observable.__.client;
    var subscription2 = observable.subscribe({
      next: function(fetchResult) {
        var _a3, _b;
        if (subscriptionStopped) {
          return;
        }
        var result2 = {
          loading: false,
          // TODO: fetchResult.data can be null but SubscriptionResult.data
          // expects TData | undefined only
          data: fetchResult.data,
          error: toApolloError(fetchResult),
          variables: variables2
        };
        observable.__.setResult(result2);
        if (!ignoreResultsRef.current)
          update();
        if (result2.error) {
          (_b = (_a3 = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a3, result2.error);
        } else if (optionsRef.current.onData) {
          optionsRef.current.onData({
            client: client2,
            data: result2
          });
        } else if (optionsRef.current.onSubscriptionData) {
          optionsRef.current.onSubscriptionData({
            client: client2,
            subscriptionData: result2
          });
        }
      },
      error: function(error) {
        var _a3, _b;
        error = error instanceof ApolloError ? error : new ApolloError({ protocolErrors: [error] });
        if (!subscriptionStopped) {
          observable.__.setResult({
            loading: false,
            data: void 0,
            error,
            variables: variables2
          });
          if (!ignoreResultsRef.current)
            update();
          (_b = (_a3 = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a3, error);
        }
      },
      complete: function() {
        if (!subscriptionStopped) {
          if (optionsRef.current.onComplete) {
            optionsRef.current.onComplete();
          } else if (optionsRef.current.onSubscriptionComplete) {
            optionsRef.current.onSubscriptionComplete();
          }
        }
      }
    });
    return function() {
      subscriptionStopped = true;
      setTimeout(function() {
        subscription2.unsubscribe();
      });
    };
  }, [observable]), function() {
    return observable && !skip && !ignoreResults ? observable.__.result : fallbackResult;
  });
  return React14.useMemo(function() {
    return __assign(__assign({}, ret), { restart: function() {
      invariant2(!optionsRef.current.skip, 56);
      setObservable(recreateRef.current());
    } });
  }, [ret]);
}
function createSubscription(client, query, variables, fetchPolicy, errorPolicy, context, extensions) {
  var options = {
    query,
    variables,
    fetchPolicy,
    errorPolicy,
    context,
    extensions
  };
  var __ = __assign(__assign({}, options), { client, result: {
    loading: true,
    data: void 0,
    error: void 0,
    variables
  }, setResult: function(result2) {
    __.result = result2;
  } });
  var observable = null;
  return Object.assign(new Observable(function(observer) {
    if (!observable) {
      observable = client.subscribe(options);
    }
    var sub = observable.subscribe(observer);
    return function() {
      return sub.unsubscribe();
    };
  }), {
    /**
     * A tracking object to store details about the observable and the latest result of the subscription.
     */
    __
  });
}
var import_dist778, import_dist779, import_dist780, React14;
var init_useSubscription = __esm({
  "../node_modules/@apollo/client/react/hooks/useSubscription.js"() {
    import_dist778 = __toESM(require_dist(), 1);
    import_dist779 = __toESM(require_dist2(), 1);
    import_dist780 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_globals();
    React14 = __toESM(require_rehackt(), 1);
    init_lib6();
    init_parser2();
    init_core2();
    init_useApolloClient();
    init_useDeepMemo();
    init_useSyncExternalStore();
    init_useQuery();
    init_useIsomorphicLayoutEffect();
  }
});

// ../node_modules/@apollo/client/react/hooks/useReactiveVar.js
function useReactiveVar(rv) {
  return useSyncExternalStore(React15.useCallback(function(update) {
    return rv.onNextChange(function onNext() {
      update();
      rv.onNextChange(onNext);
    });
  }, [rv]), rv, rv);
}
var import_dist781, import_dist782, import_dist783, React15;
var init_useReactiveVar = __esm({
  "../node_modules/@apollo/client/react/hooks/useReactiveVar.js"() {
    import_dist781 = __toESM(require_dist(), 1);
    import_dist782 = __toESM(require_dist2(), 1);
    import_dist783 = __toESM(require_dist3(), 1);
    React15 = __toESM(require_rehackt(), 1);
    init_useSyncExternalStore();
  }
});

// ../node_modules/@apollo/client/react/hooks/useFragment.js
function useFragment(options) {
  return wrapHook("useFragment", _useFragment, useApolloClient(options.client))(options);
}
function _useFragment(options) {
  var cache2 = useApolloClient(options.client).cache;
  var diffOptions = useDeepMemo(function() {
    var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, rest = __rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
    return __assign(__assign({}, rest), { returnPartialData: true, id: typeof from2 === "string" ? from2 : cache2.identify(from2), query: cache2["getFragmentDoc"](fragment, fragmentName), optimistic });
  }, [options]);
  var resultRef = useLazyRef(function() {
    return diffToResult(cache2.diff(diffOptions));
  });
  var stableOptions = useDeepMemo(function() {
    return options;
  }, [options]);
  React16.useMemo(function() {
    resultRef.current = diffToResult(cache2.diff(diffOptions));
  }, [diffOptions, cache2]);
  var getSnapshot = React16.useCallback(function() {
    return resultRef.current;
  }, []);
  return useSyncExternalStore(React16.useCallback(function(forceUpdate) {
    var lastTimeout = 0;
    var subscription = cache2.watchFragment(stableOptions).subscribe({
      next: function(result2) {
        if (lib_default(result2, resultRef.current))
          return;
        resultRef.current = result2;
        clearTimeout(lastTimeout);
        lastTimeout = setTimeout(forceUpdate);
      }
    });
    return function() {
      subscription.unsubscribe();
      clearTimeout(lastTimeout);
    };
  }, [cache2, stableOptions]), getSnapshot, getSnapshot);
}
function diffToResult(diff2) {
  var result2 = {
    data: diff2.result,
    complete: !!diff2.complete
  };
  if (diff2.missing) {
    result2.missing = mergeDeepArray(diff2.missing.map(function(error) {
      return error.missing;
    }));
  }
  return result2;
}
var import_dist784, import_dist785, import_dist786, React16;
var init_useFragment = __esm({
  "../node_modules/@apollo/client/react/hooks/useFragment.js"() {
    import_dist784 = __toESM(require_dist(), 1);
    import_dist785 = __toESM(require_dist2(), 1);
    import_dist786 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    React16 = __toESM(require_rehackt(), 1);
    init_utilities2();
    init_useApolloClient();
    init_useSyncExternalStore();
    init_internal();
    init_lib6();
  }
});

// ../node_modules/@apollo/client/react/internal/cache/QueryReference.js
function wrapQueryRef(internalQueryRef) {
  var _a2;
  var ref = (_a2 = {
    toPromise: function() {
      return getWrappedPromise(ref).then(function() {
        return ref;
      });
    }
  }, _a2[QUERY_REFERENCE_SYMBOL] = internalQueryRef, _a2[PROMISE_SYMBOL] = internalQueryRef.promise, _a2);
  return ref;
}
function assertWrappedQueryRef(queryRef) {
  invariant2(!queryRef || QUERY_REFERENCE_SYMBOL in queryRef, 60);
}
function getWrappedPromise(queryRef) {
  var internalQueryRef = unwrapQueryRef(queryRef);
  return internalQueryRef.promise.status === "fulfilled" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL];
}
function unwrapQueryRef(queryRef) {
  return queryRef[QUERY_REFERENCE_SYMBOL];
}
function updateWrappedQueryRef(queryRef, promise) {
  queryRef[PROMISE_SYMBOL] = promise;
}
var import_dist787, import_dist788, import_dist789, QUERY_REFERENCE_SYMBOL, PROMISE_SYMBOL, OBSERVED_CHANGED_OPTIONS, InternalQueryReference;
var init_QueryReference = __esm({
  "../node_modules/@apollo/client/react/internal/cache/QueryReference.js"() {
    import_dist787 = __toESM(require_dist(), 1);
    import_dist788 = __toESM(require_dist2(), 1);
    import_dist789 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_lib6();
    init_utilities2();
    init_utilities2();
    init_invariantWrappers();
    QUERY_REFERENCE_SYMBOL = Symbol();
    PROMISE_SYMBOL = Symbol();
    OBSERVED_CHANGED_OPTIONS = [
      "canonizeResults",
      "context",
      "errorPolicy",
      "fetchPolicy",
      "refetchWritePolicy",
      "returnPartialData"
    ];
    InternalQueryReference = /** @class */
    function() {
      function InternalQueryReference2(observable, options) {
        var _this = this;
        this.key = {};
        this.listeners = /* @__PURE__ */ new Set();
        this.references = 0;
        this.softReferences = 0;
        this.handleNext = this.handleNext.bind(this);
        this.handleError = this.handleError.bind(this);
        this.dispose = this.dispose.bind(this);
        this.observable = observable;
        if (options.onDispose) {
          this.onDispose = options.onDispose;
        }
        this.setResult();
        this.subscribeToQuery();
        var startDisposeTimer = function() {
          var _a2;
          if (!_this.references) {
            _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a2 = options.autoDisposeTimeoutMs) !== null && _a2 !== void 0 ? _a2 : 3e4);
          }
        };
        this.promise.then(startDisposeTimer, startDisposeTimer);
      }
      Object.defineProperty(InternalQueryReference2.prototype, "disposed", {
        get: function() {
          return this.subscription.closed;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InternalQueryReference2.prototype, "watchQueryOptions", {
        get: function() {
          return this.observable.options;
        },
        enumerable: false,
        configurable: true
      });
      InternalQueryReference2.prototype.reinitialize = function() {
        var observable = this.observable;
        var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;
        var avoidNetworkRequests = originalFetchPolicy === "no-cache" || originalFetchPolicy === "standby";
        try {
          if (avoidNetworkRequests) {
            observable.silentSetOptions({ fetchPolicy: "standby" });
          } else {
            observable.resetLastResults();
            observable.silentSetOptions({ fetchPolicy: "cache-first" });
          }
          this.subscribeToQuery();
          if (avoidNetworkRequests) {
            return;
          }
          observable.resetDiff();
          this.setResult();
        } finally {
          observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });
        }
      };
      InternalQueryReference2.prototype.retain = function() {
        var _this = this;
        this.references++;
        clearTimeout(this.autoDisposeTimeoutId);
        var disposed = false;
        return function() {
          if (disposed) {
            return;
          }
          disposed = true;
          _this.references--;
          setTimeout(function() {
            if (!_this.references) {
              _this.dispose();
            }
          });
        };
      };
      InternalQueryReference2.prototype.softRetain = function() {
        var _this = this;
        this.softReferences++;
        var disposed = false;
        return function() {
          if (disposed) {
            return;
          }
          disposed = true;
          _this.softReferences--;
          setTimeout(function() {
            if (!_this.softReferences && !_this.references) {
              _this.dispose();
            }
          });
        };
      };
      InternalQueryReference2.prototype.didChangeOptions = function(watchQueryOptions) {
        var _this = this;
        return OBSERVED_CHANGED_OPTIONS.some(function(option) {
          return option in watchQueryOptions && !equal(_this.watchQueryOptions[option], watchQueryOptions[option]);
        });
      };
      InternalQueryReference2.prototype.applyOptions = function(watchQueryOptions) {
        var _a2 = this.watchQueryOptions, currentFetchPolicy = _a2.fetchPolicy, currentCanonizeResults = _a2.canonizeResults;
        if (currentFetchPolicy === "standby" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {
          this.initiateFetch(this.observable.reobserve(watchQueryOptions));
        } else {
          this.observable.silentSetOptions(watchQueryOptions);
          if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {
            this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());
            this.promise = createFulfilledPromise(this.result);
          }
        }
        return this.promise;
      };
      InternalQueryReference2.prototype.listen = function(listener) {
        var _this = this;
        this.listeners.add(listener);
        return function() {
          _this.listeners.delete(listener);
        };
      };
      InternalQueryReference2.prototype.refetch = function(variables) {
        return this.initiateFetch(this.observable.refetch(variables));
      };
      InternalQueryReference2.prototype.fetchMore = function(options) {
        return this.initiateFetch(this.observable.fetchMore(options));
      };
      InternalQueryReference2.prototype.dispose = function() {
        this.subscription.unsubscribe();
        this.onDispose();
      };
      InternalQueryReference2.prototype.onDispose = function() {
      };
      InternalQueryReference2.prototype.handleNext = function(result2) {
        var _a2;
        switch (this.promise.status) {
          case "pending": {
            if (result2.data === void 0) {
              result2.data = this.result.data;
            }
            this.result = result2;
            (_a2 = this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, result2);
            break;
          }
          default: {
            if (result2.data === this.result.data && result2.networkStatus === this.result.networkStatus) {
              return;
            }
            if (result2.data === void 0) {
              result2.data = this.result.data;
            }
            this.result = result2;
            this.promise = createFulfilledPromise(result2);
            this.deliver(this.promise);
            break;
          }
        }
      };
      InternalQueryReference2.prototype.handleError = function(error) {
        var _a2;
        this.subscription.unsubscribe();
        this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);
        switch (this.promise.status) {
          case "pending": {
            (_a2 = this.reject) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
            break;
          }
          default: {
            this.promise = createRejectedPromise(error);
            this.deliver(this.promise);
          }
        }
      };
      InternalQueryReference2.prototype.deliver = function(promise) {
        this.listeners.forEach(function(listener) {
          return listener(promise);
        });
      };
      InternalQueryReference2.prototype.initiateFetch = function(returnedPromise) {
        var _this = this;
        this.promise = this.createPendingPromise();
        this.promise.catch(function() {
        });
        returnedPromise.then(function() {
          setTimeout(function() {
            var _a2;
            if (_this.promise.status === "pending") {
              _this.result = _this.observable.getCurrentResult();
              (_a2 = _this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(_this, _this.result);
            }
          });
        }).catch(function() {
        });
        return returnedPromise;
      };
      InternalQueryReference2.prototype.subscribeToQuery = function() {
        var _this = this;
        this.subscription = this.observable.filter(function(result2) {
          return !equal(result2.data, {}) && !equal(result2, _this.result);
        }).subscribe(this.handleNext, this.handleError);
      };
      InternalQueryReference2.prototype.setResult = function() {
        var result2 = this.observable.getCurrentResult(false);
        if (equal(result2, this.result)) {
          return;
        }
        this.result = result2;
        this.promise = result2.data && (!result2.partial || this.watchQueryOptions.returnPartialData) ? createFulfilledPromise(result2) : this.createPendingPromise();
      };
      InternalQueryReference2.prototype.createPendingPromise = function() {
        var _this = this;
        return wrapPromiseWithState(new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        }));
      };
      return InternalQueryReference2;
    }();
  }
});

// ../node_modules/@apollo/client/react/internal/cache/SuspenseCache.js
var import_dist790, import_dist791, import_dist792, SuspenseCache;
var init_SuspenseCache = __esm({
  "../node_modules/@apollo/client/react/internal/cache/SuspenseCache.js"() {
    import_dist790 = __toESM(require_dist(), 1);
    import_dist791 = __toESM(require_dist2(), 1);
    import_dist792 = __toESM(require_dist3(), 1);
    init_lib();
    init_utilities2();
    init_QueryReference();
    SuspenseCache = /** @class */
    function() {
      function SuspenseCache2(options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        this.queryRefs = new Trie(canUseWeakMap);
        this.options = options;
      }
      SuspenseCache2.prototype.getQueryRef = function(cacheKey, createObservable) {
        var ref = this.queryRefs.lookupArray(cacheKey);
        if (!ref.current) {
          ref.current = new InternalQueryReference(createObservable(), {
            autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,
            onDispose: function() {
              delete ref.current;
            }
          });
        }
        return ref.current;
      };
      SuspenseCache2.prototype.add = function(cacheKey, queryRef) {
        var ref = this.queryRefs.lookupArray(cacheKey);
        ref.current = queryRef;
      };
      return SuspenseCache2;
    }();
  }
});

// ../node_modules/@apollo/client/react/internal/cache/getSuspenseCache.js
function getSuspenseCache(client) {
  var _a2;
  if (!client[suspenseCacheSymbol]) {
    client[suspenseCacheSymbol] = new SuspenseCache((_a2 = client.defaultOptions.react) === null || _a2 === void 0 ? void 0 : _a2.suspense);
  }
  return client[suspenseCacheSymbol];
}
var import_dist793, import_dist794, import_dist795, suspenseCacheSymbol;
var init_getSuspenseCache = __esm({
  "../node_modules/@apollo/client/react/internal/cache/getSuspenseCache.js"() {
    import_dist793 = __toESM(require_dist(), 1);
    import_dist794 = __toESM(require_dist2(), 1);
    import_dist795 = __toESM(require_dist3(), 1);
    init_SuspenseCache();
    suspenseCacheSymbol = Symbol.for("apollo.suspenseCache");
  }
});

// ../node_modules/@apollo/client/react/internal/index.js
var import_dist796, import_dist797, import_dist798;
var init_internal2 = __esm({
  "../node_modules/@apollo/client/react/internal/index.js"() {
    import_dist796 = __toESM(require_dist(), 1);
    import_dist797 = __toESM(require_dist2(), 1);
    import_dist798 = __toESM(require_dist3(), 1);
    init_getSuspenseCache();
    init_QueryReference();
  }
});

// ../node_modules/@apollo/client/react/hooks/constants.js
var import_dist799, import_dist800, import_dist801, skipToken;
var init_constants = __esm({
  "../node_modules/@apollo/client/react/hooks/constants.js"() {
    import_dist799 = __toESM(require_dist(), 1);
    import_dist800 = __toESM(require_dist2(), 1);
    import_dist801 = __toESM(require_dist3(), 1);
    skipToken = Symbol.for("apollo.skipToken");
  }
});

// ../node_modules/@apollo/client/react/hooks/useSuspenseQuery.js
function useSuspenseQuery(query, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  return wrapHook("useSuspenseQuery", _useSuspenseQuery, useApolloClient(typeof options === "object" ? options.client : void 0))(query, options);
}
function _useSuspenseQuery(query, options) {
  var client = useApolloClient(options.client);
  var suspenseCache = getSuspenseCache(client);
  var watchQueryOptions = useWatchQueryOptions({
    client,
    query,
    options
  });
  var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
  var _a2 = options.queryKey, queryKey = _a2 === void 0 ? [] : _a2;
  var cacheKey = __spreadArray([
    query,
    canonicalStringify(variables)
  ], [].concat(queryKey), true);
  var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
    return client.watchQuery(watchQueryOptions);
  });
  var _b = React17.useState([queryRef.key, queryRef.promise]), current = _b[0], setPromise = _b[1];
  if (current[0] !== queryRef.key) {
    current[0] = queryRef.key;
    current[1] = queryRef.promise;
  }
  var promise = current[1];
  if (queryRef.didChangeOptions(watchQueryOptions)) {
    current[1] = promise = queryRef.applyOptions(watchQueryOptions);
  }
  React17.useEffect(function() {
    var dispose = queryRef.retain();
    var removeListener = queryRef.listen(function(promise2) {
      setPromise([queryRef.key, promise2]);
    });
    return function() {
      removeListener();
      dispose();
    };
  }, [queryRef]);
  var skipResult = React17.useMemo(function() {
    var error = toApolloError2(queryRef.result);
    return {
      loading: false,
      data: queryRef.result.data,
      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,
      error
    };
  }, [queryRef.result]);
  var result2 = fetchPolicy === "standby" ? skipResult : __use(promise);
  var fetchMore = React17.useCallback(function(options2) {
    var promise2 = queryRef.fetchMore(options2);
    setPromise([queryRef.key, queryRef.promise]);
    return promise2;
  }, [queryRef]);
  var refetch = React17.useCallback(function(variables2) {
    var promise2 = queryRef.refetch(variables2);
    setPromise([queryRef.key, queryRef.promise]);
    return promise2;
  }, [queryRef]);
  var subscribeToMore = queryRef.observable.subscribeToMore;
  return React17.useMemo(function() {
    return {
      client,
      data: result2.data,
      error: toApolloError2(result2),
      networkStatus: result2.networkStatus,
      fetchMore,
      refetch,
      subscribeToMore
    };
  }, [client, fetchMore, refetch, result2, subscribeToMore]);
}
function validateOptions(options) {
  var query = options.query, fetchPolicy = options.fetchPolicy, returnPartialData = options.returnPartialData;
  verifyDocumentType(query, DocumentType.Query);
  validateFetchPolicy(fetchPolicy);
  validatePartialDataReturn(fetchPolicy, returnPartialData);
}
function validateFetchPolicy(fetchPolicy) {
  if (fetchPolicy === void 0) {
    fetchPolicy = "cache-first";
  }
  var supportedFetchPolicies = [
    "cache-first",
    "network-only",
    "no-cache",
    "cache-and-network"
  ];
  invariant2(supportedFetchPolicies.includes(fetchPolicy), 57, fetchPolicy);
}
function validatePartialDataReturn(fetchPolicy, returnPartialData) {
  if (fetchPolicy === "no-cache" && returnPartialData) {
    globalThis.__DEV__ !== false && invariant2.warn(58);
  }
}
function toApolloError2(result2) {
  return isNonEmptyArray(result2.errors) ? new ApolloError({ graphQLErrors: result2.errors }) : result2.error;
}
function useWatchQueryOptions(_a2) {
  var client = _a2.client, query = _a2.query, options = _a2.options;
  return useDeepMemo(function() {
    var _a3;
    if (options === skipToken) {
      return { query, fetchPolicy: "standby" };
    }
    var fetchPolicy = options.fetchPolicy || ((_a3 = client.defaultOptions.watchQuery) === null || _a3 === void 0 ? void 0 : _a3.fetchPolicy) || "cache-first";
    var watchQueryOptions = __assign(__assign({}, options), { fetchPolicy, query, notifyOnNetworkStatusChange: false, nextFetchPolicy: void 0 });
    if (globalThis.__DEV__ !== false) {
      validateOptions(watchQueryOptions);
    }
    if (options.skip) {
      watchQueryOptions.fetchPolicy = "standby";
    }
    return watchQueryOptions;
  }, [client, options, query]);
}
var import_dist802, import_dist803, import_dist804, React17;
var init_useSuspenseQuery = __esm({
  "../node_modules/@apollo/client/react/hooks/useSuspenseQuery.js"() {
    import_dist802 = __toESM(require_dist(), 1);
    import_dist803 = __toESM(require_dist2(), 1);
    import_dist804 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    React17 = __toESM(require_rehackt(), 1);
    init_globals();
    init_core2();
    init_utilities2();
    init_useApolloClient();
    init_parser2();
    init_internal();
    init_internal2();
    init_cache2();
    init_constants();
  }
});

// ../node_modules/@apollo/client/react/hooks/useBackgroundQuery.js
function useBackgroundQuery(query, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  return wrapHook("useBackgroundQuery", _useBackgroundQuery, useApolloClient(typeof options === "object" ? options.client : void 0))(query, options);
}
function _useBackgroundQuery(query, options) {
  var client = useApolloClient(options.client);
  var suspenseCache = getSuspenseCache(client);
  var watchQueryOptions = useWatchQueryOptions({ client, query, options });
  var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
  var _a2 = options.queryKey, queryKey = _a2 === void 0 ? [] : _a2;
  var didFetchResult = React18.useRef(fetchPolicy !== "standby");
  didFetchResult.current || (didFetchResult.current = fetchPolicy !== "standby");
  var cacheKey = __spreadArray([
    query,
    canonicalStringify(variables)
  ], [].concat(queryKey), true);
  var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
    return client.watchQuery(watchQueryOptions);
  });
  var _b = React18.useState(wrapQueryRef(queryRef)), wrappedQueryRef = _b[0], setWrappedQueryRef = _b[1];
  if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {
    setWrappedQueryRef(wrapQueryRef(queryRef));
  }
  if (queryRef.didChangeOptions(watchQueryOptions)) {
    var promise = queryRef.applyOptions(watchQueryOptions);
    updateWrappedQueryRef(wrappedQueryRef, promise);
  }
  React18.useEffect(function() {
    var id = setTimeout(function() {
      if (queryRef.disposed) {
        suspenseCache.add(cacheKey, queryRef);
      }
    });
    return function() {
      return clearTimeout(id);
    };
  });
  var fetchMore = React18.useCallback(function(options2) {
    var promise2 = queryRef.fetchMore(options2);
    setWrappedQueryRef(wrapQueryRef(queryRef));
    return promise2;
  }, [queryRef]);
  var refetch = React18.useCallback(function(variables2) {
    var promise2 = queryRef.refetch(variables2);
    setWrappedQueryRef(wrapQueryRef(queryRef));
    return promise2;
  }, [queryRef]);
  React18.useEffect(function() {
    return queryRef.softRetain();
  }, [queryRef]);
  return [
    didFetchResult.current ? wrappedQueryRef : void 0,
    {
      fetchMore,
      refetch,
      subscribeToMore: queryRef.observable.subscribeToMore
    }
  ];
}
var import_dist805, import_dist806, import_dist807, React18;
var init_useBackgroundQuery = __esm({
  "../node_modules/@apollo/client/react/hooks/useBackgroundQuery.js"() {
    import_dist805 = __toESM(require_dist(), 1);
    import_dist806 = __toESM(require_dist2(), 1);
    import_dist807 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    React18 = __toESM(require_rehackt(), 1);
    init_useApolloClient();
    init_internal2();
    init_internal();
    init_useSuspenseQuery();
    init_cache2();
  }
});

// ../node_modules/@apollo/client/react/hooks/useLoadableQuery.js
function useLoadableQuery(query, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  var client = useApolloClient(options.client);
  var suspenseCache = getSuspenseCache(client);
  var watchQueryOptions = useWatchQueryOptions({ client, query, options });
  var _a2 = options.queryKey, queryKey = _a2 === void 0 ? [] : _a2;
  var _b = React19.useState(null), queryRef = _b[0], setQueryRef = _b[1];
  assertWrappedQueryRef(queryRef);
  var internalQueryRef = queryRef && unwrapQueryRef(queryRef);
  if (queryRef && (internalQueryRef === null || internalQueryRef === void 0 ? void 0 : internalQueryRef.didChangeOptions(watchQueryOptions))) {
    var promise = internalQueryRef.applyOptions(watchQueryOptions);
    updateWrappedQueryRef(queryRef, promise);
  }
  var calledDuringRender = useRenderGuard();
  var fetchMore = React19.useCallback(function(options2) {
    if (!internalQueryRef) {
      throw new Error("The query has not been loaded. Please load the query.");
    }
    var promise2 = internalQueryRef.fetchMore(options2);
    setQueryRef(wrapQueryRef(internalQueryRef));
    return promise2;
  }, [internalQueryRef]);
  var refetch = React19.useCallback(function(options2) {
    if (!internalQueryRef) {
      throw new Error("The query has not been loaded. Please load the query.");
    }
    var promise2 = internalQueryRef.refetch(options2);
    setQueryRef(wrapQueryRef(internalQueryRef));
    return promise2;
  }, [internalQueryRef]);
  var loadQuery = React19.useCallback(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    invariant2(!calledDuringRender(), 50);
    var variables = args[0];
    var cacheKey = __spreadArray([
      query,
      canonicalStringify(variables)
    ], [].concat(queryKey), true);
    var queryRef2 = suspenseCache.getQueryRef(cacheKey, function() {
      return client.watchQuery(__assign(__assign({}, watchQueryOptions), { variables }));
    });
    setQueryRef(wrapQueryRef(queryRef2));
  }, [
    query,
    queryKey,
    suspenseCache,
    watchQueryOptions,
    calledDuringRender,
    client
  ]);
  var subscribeToMore = React19.useCallback(function(options2) {
    invariant2(internalQueryRef, 51);
    return internalQueryRef.observable.subscribeToMore(options2);
  }, [internalQueryRef]);
  var reset = React19.useCallback(function() {
    setQueryRef(null);
  }, []);
  return [loadQuery, queryRef, { fetchMore, refetch, reset, subscribeToMore }];
}
var import_dist808, import_dist809, import_dist810, React19;
var init_useLoadableQuery = __esm({
  "../node_modules/@apollo/client/react/hooks/useLoadableQuery.js"() {
    import_dist808 = __toESM(require_dist(), 1);
    import_dist809 = __toESM(require_dist2(), 1);
    import_dist810 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    React19 = __toESM(require_rehackt(), 1);
    init_useApolloClient();
    init_internal2();
    init_internal();
    init_useSuspenseQuery();
    init_cache2();
    init_globals();
  }
});

// ../node_modules/@apollo/client/react/hooks/useQueryRefHandlers.js
function useQueryRefHandlers(queryRef) {
  var unwrapped = unwrapQueryRef(queryRef);
  return wrapHook("useQueryRefHandlers", _useQueryRefHandlers, unwrapped ? unwrapped["observable"] : useApolloClient())(queryRef);
}
function _useQueryRefHandlers(queryRef) {
  assertWrappedQueryRef(queryRef);
  var _a2 = React20.useState(queryRef), previousQueryRef = _a2[0], setPreviousQueryRef = _a2[1];
  var _b = React20.useState(queryRef), wrappedQueryRef = _b[0], setWrappedQueryRef = _b[1];
  var internalQueryRef = unwrapQueryRef(queryRef);
  if (previousQueryRef !== queryRef) {
    setPreviousQueryRef(queryRef);
    setWrappedQueryRef(queryRef);
  } else {
    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));
  }
  var refetch = React20.useCallback(function(variables) {
    var promise = internalQueryRef.refetch(variables);
    setWrappedQueryRef(wrapQueryRef(internalQueryRef));
    return promise;
  }, [internalQueryRef]);
  var fetchMore = React20.useCallback(function(options) {
    var promise = internalQueryRef.fetchMore(options);
    setWrappedQueryRef(wrapQueryRef(internalQueryRef));
    return promise;
  }, [internalQueryRef]);
  return {
    refetch,
    fetchMore,
    subscribeToMore: internalQueryRef.observable.subscribeToMore
  };
}
var import_dist811, import_dist812, import_dist813, React20;
var init_useQueryRefHandlers = __esm({
  "../node_modules/@apollo/client/react/hooks/useQueryRefHandlers.js"() {
    import_dist811 = __toESM(require_dist(), 1);
    import_dist812 = __toESM(require_dist2(), 1);
    import_dist813 = __toESM(require_dist3(), 1);
    React20 = __toESM(require_rehackt(), 1);
    init_internal2();
    init_useApolloClient();
    init_internal();
  }
});

// ../node_modules/@apollo/client/react/hooks/useReadQuery.js
function useReadQuery(queryRef) {
  var unwrapped = unwrapQueryRef(queryRef);
  return wrapHook("useReadQuery", _useReadQuery, unwrapped ? unwrapped["observable"] : useApolloClient())(queryRef);
}
function _useReadQuery(queryRef) {
  assertWrappedQueryRef(queryRef);
  var internalQueryRef = React21.useMemo(function() {
    return unwrapQueryRef(queryRef);
  }, [queryRef]);
  var getPromise = React21.useCallback(function() {
    return getWrappedPromise(queryRef);
  }, [queryRef]);
  if (internalQueryRef.disposed) {
    internalQueryRef.reinitialize();
    updateWrappedQueryRef(queryRef, internalQueryRef.promise);
  }
  React21.useEffect(function() {
    return internalQueryRef.retain();
  }, [internalQueryRef]);
  var promise = useSyncExternalStore(React21.useCallback(function(forceUpdate) {
    return internalQueryRef.listen(function(promise2) {
      updateWrappedQueryRef(queryRef, promise2);
      forceUpdate();
    });
  }, [internalQueryRef, queryRef]), getPromise, getPromise);
  var result2 = __use(promise);
  return React21.useMemo(function() {
    return {
      data: result2.data,
      networkStatus: result2.networkStatus,
      error: toApolloError2(result2)
    };
  }, [result2]);
}
var import_dist814, import_dist815, import_dist816, React21;
var init_useReadQuery = __esm({
  "../node_modules/@apollo/client/react/hooks/useReadQuery.js"() {
    import_dist814 = __toESM(require_dist(), 1);
    import_dist815 = __toESM(require_dist2(), 1);
    import_dist816 = __toESM(require_dist3(), 1);
    React21 = __toESM(require_rehackt(), 1);
    init_internal2();
    init_internal();
    init_useSuspenseQuery();
    init_useSyncExternalStore();
    init_useApolloClient();
  }
});

// ../node_modules/@apollo/client/react/hooks/index.js
var import_dist817, import_dist818, import_dist819;
var init_hooks = __esm({
  "../node_modules/@apollo/client/react/hooks/index.js"() {
    import_dist817 = __toESM(require_dist(), 1);
    import_dist818 = __toESM(require_dist2(), 1);
    import_dist819 = __toESM(require_dist3(), 1);
    init_globals();
    init_useApolloClient();
    init_useLazyQuery();
    init_useMutation();
    init_useQuery();
    init_useSubscription();
    init_useReactiveVar();
    init_useFragment();
    init_useSuspenseQuery();
    init_useBackgroundQuery();
    init_useLoadableQuery();
    init_useQueryRefHandlers();
    init_useReadQuery();
    init_constants();
  }
});

// ../node_modules/@apollo/client/react/query-preloader/createQueryPreloader.js
function createQueryPreloader(client) {
  return wrapHook("createQueryPreloader", _createQueryPreloader, client)(client);
}
var import_dist820, import_dist821, import_dist822, _createQueryPreloader;
var init_createQueryPreloader = __esm({
  "../node_modules/@apollo/client/react/query-preloader/createQueryPreloader.js"() {
    import_dist820 = __toESM(require_dist(), 1);
    import_dist821 = __toESM(require_dist2(), 1);
    import_dist822 = __toESM(require_dist3(), 1);
    init_tslib_es6();
    init_internal2();
    init_internal();
    _createQueryPreloader = function(client) {
      return function preloadQuery(query, options) {
        var _a2, _b;
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        var queryRef = new InternalQueryReference(client.watchQuery(__assign(__assign({}, options), { query })), {
          autoDisposeTimeoutMs: (_b = (_a2 = client.defaultOptions.react) === null || _a2 === void 0 ? void 0 : _a2.suspense) === null || _b === void 0 ? void 0 : _b.autoDisposeTimeoutMs
        });
        return wrapQueryRef(queryRef);
      };
    };
  }
});

// ../node_modules/@apollo/client/react/types/types.js
var import_dist823, import_dist824, import_dist825;
var init_types4 = __esm({
  "../node_modules/@apollo/client/react/types/types.js"() {
    import_dist823 = __toESM(require_dist(), 1);
    import_dist824 = __toESM(require_dist2(), 1);
    import_dist825 = __toESM(require_dist3(), 1);
  }
});

// ../node_modules/@apollo/client/react/index.js
var import_dist826, import_dist827, import_dist828;
var init_react = __esm({
  "../node_modules/@apollo/client/react/index.js"() {
    import_dist826 = __toESM(require_dist(), 1);
    import_dist827 = __toESM(require_dist2(), 1);
    import_dist828 = __toESM(require_dist3(), 1);
    init_globals();
    init_context2();
    init_hooks();
    init_parser2();
    init_createQueryPreloader();
    init_types4();
  }
});

// ../node_modules/@apollo/client/index.js
var client_exports = {};
__export(client_exports, {
  ApolloCache: () => ApolloCache,
  ApolloClient: () => ApolloClient,
  ApolloConsumer: () => ApolloConsumer,
  ApolloError: () => ApolloError,
  ApolloLink: () => ApolloLink,
  ApolloProvider: () => ApolloProvider,
  Cache: () => Cache,
  DocumentTransform: () => DocumentTransform,
  DocumentType: () => DocumentType,
  HttpLink: () => HttpLink,
  InMemoryCache: () => InMemoryCache,
  MissingFieldError: () => MissingFieldError,
  NetworkStatus: () => NetworkStatus,
  Observable: () => Observable,
  ObservableQuery: () => ObservableQuery,
  checkFetcher: () => checkFetcher,
  concat: () => concat,
  createHttpLink: () => createHttpLink,
  createQueryPreloader: () => createQueryPreloader,
  createSignalIfSupported: () => createSignalIfSupported,
  defaultDataIdFromObject: () => defaultDataIdFromObject,
  defaultPrinter: () => defaultPrinter,
  disableExperimentalFragmentVariables: () => disableExperimentalFragmentVariables,
  disableFragmentWarnings: () => disableFragmentWarnings,
  empty: () => empty,
  enableExperimentalFragmentVariables: () => enableExperimentalFragmentVariables,
  execute: () => execute2,
  fallbackHttpConfig: () => fallbackHttpConfig,
  from: () => from,
  fromError: () => fromError,
  fromPromise: () => fromPromise,
  getApolloContext: () => getApolloContext,
  gql: () => gql,
  isApolloError: () => isApolloError,
  isNetworkRequestSettled: () => isNetworkRequestSettled,
  isReference: () => isReference,
  makeReference: () => makeReference,
  makeVar: () => makeVar,
  mergeOptions: () => mergeOptions,
  operationName: () => operationName,
  parseAndCheckHttpResponse: () => parseAndCheckHttpResponse,
  parser: () => parser,
  resetApolloContext: () => resetApolloContext,
  resetCaches: () => resetCaches,
  rewriteURIForGET: () => rewriteURIForGET,
  selectHttpOptionsAndBody: () => selectHttpOptionsAndBody,
  selectHttpOptionsAndBodyInternal: () => selectHttpOptionsAndBodyInternal,
  selectURI: () => selectURI,
  serializeFetchParameter: () => serializeFetchParameter,
  setLogVerbosity: () => setVerbosity,
  skipToken: () => skipToken,
  split: () => split,
  throwServerError: () => throwServerError,
  toPromise: () => toPromise,
  useApolloClient: () => useApolloClient,
  useBackgroundQuery: () => useBackgroundQuery,
  useFragment: () => useFragment,
  useLazyQuery: () => useLazyQuery,
  useLoadableQuery: () => useLoadableQuery,
  useMutation: () => useMutation,
  useQuery: () => useQuery,
  useQueryRefHandlers: () => useQueryRefHandlers,
  useReactiveVar: () => useReactiveVar,
  useReadQuery: () => useReadQuery,
  useSubscription: () => useSubscription,
  useSuspenseQuery: () => useSuspenseQuery
});
var import_dist829, import_dist830, import_dist831;
var init_client = __esm({
  "../node_modules/@apollo/client/index.js"() {
    import_dist829 = __toESM(require_dist());
    import_dist830 = __toESM(require_dist2());
    import_dist831 = __toESM(require_dist3());
    init_core2();
    init_react();
  }
});

// ../node_modules/@apollo/client/utilities/globals/globals.cjs
var require_globals = __commonJS({
  "../node_modules/@apollo/client/utilities/globals/globals.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tsInvariant = (init_invariant(), __toCommonJS(invariant_exports));
    var version3 = "3.11.1";
    function maybe3(thunk) {
      try {
        return thunk();
      } catch (_a2) {
      }
    }
    var global$1 = maybe3(function() {
      return globalThis;
    }) || maybe3(function() {
      return window;
    }) || maybe3(function() {
      return self;
    }) || maybe3(function() {
      return global;
    }) || maybe3(function() {
      return maybe3.constructor("return this")();
    });
    var prefixCounts2 = /* @__PURE__ */ new Map();
    function makeUniqueId2(prefix) {
      var count = prefixCounts2.get(prefix) || 1;
      prefixCounts2.set(prefix, count + 1);
      return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
    }
    function stringifyForDisplay2(value, space) {
      if (space === void 0) {
        space = 0;
      }
      var undefId = makeUniqueId2("stringifyForDisplay");
      return JSON.stringify(value, function(key, value2) {
        return value2 === void 0 ? undefId : value2;
      }, space).split(JSON.stringify(undefId)).join("<undefined>");
    }
    function wrap4(fn) {
      return function(message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (typeof message === "number") {
          var arg0 = message;
          message = getHandledErrorMsg2(arg0);
          if (!message) {
            message = getFallbackErrorMsg2(arg0, args);
            args = [];
          }
        }
        fn.apply(void 0, [message].concat(args));
      };
    }
    var invariant5 = Object.assign(function invariant6(condition, message) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (!condition) {
        tsInvariant.invariant(condition, getHandledErrorMsg2(message, args) || getFallbackErrorMsg2(message, args));
      }
    }, {
      debug: wrap4(tsInvariant.invariant.debug),
      log: wrap4(tsInvariant.invariant.log),
      warn: wrap4(tsInvariant.invariant.warn),
      error: wrap4(tsInvariant.invariant.error)
    });
    function newInvariantError2(message) {
      var optionalParams = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
      }
      return new tsInvariant.InvariantError(getHandledErrorMsg2(message, optionalParams) || getFallbackErrorMsg2(message, optionalParams));
    }
    var ApolloErrorMessageHandler2 = Symbol.for("ApolloErrorMessageHandler_" + version3);
    function stringify2(arg) {
      if (typeof arg == "string") {
        return arg;
      }
      try {
        return stringifyForDisplay2(arg, 2).slice(0, 1e3);
      } catch (_a2) {
        return "<non-serializable>";
      }
    }
    function getHandledErrorMsg2(message, messageArgs) {
      if (messageArgs === void 0) {
        messageArgs = [];
      }
      if (!message)
        return;
      return global$1[ApolloErrorMessageHandler2] && global$1[ApolloErrorMessageHandler2](message, messageArgs.map(stringify2));
    }
    function getFallbackErrorMsg2(message, messageArgs) {
      if (messageArgs === void 0) {
        messageArgs = [];
      }
      if (!message)
        return;
      return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
        version: version3,
        message,
        args: messageArgs.map(stringify2)
      })));
    }
    var DEV2 = globalThis.__DEV__ !== false;
    exports.InvariantError = tsInvariant.InvariantError;
    exports.DEV = DEV2;
    exports.__DEV__ = DEV2;
    exports.global = global$1;
    exports.invariant = invariant5;
    exports.maybe = maybe3;
    exports.newInvariantError = newInvariantError2;
  }
});

// ../node_modules/@apollo/client/utilities/utilities.cjs
var require_utilities = __commonJS({
  "../node_modules/@apollo/client/utilities/utilities.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var graphql2 = (init_graphql2(), __toCommonJS(graphql_exports));
    var trie = (init_lib(), __toCommonJS(lib_exports));
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var caches2 = (init_lib2(), __toCommonJS(lib_exports2));
    var optimism = (init_lib5(), __toCommonJS(lib_exports3));
    var zenObservableTs = (init_module(), __toCommonJS(module_exports));
    init_es();
    function shouldInclude2(_a2, variables) {
      var directives = _a2.directives;
      if (!directives || !directives.length) {
        return true;
      }
      return getInclusionDirectives2(directives).every(function(_a3) {
        var directive = _a3.directive, ifArgument = _a3.ifArgument;
        var evaledValue = false;
        if (ifArgument.value.kind === "Variable") {
          evaledValue = variables && variables[ifArgument.value.name.value];
          globals.invariant(evaledValue !== void 0, 69, directive.name.value);
        } else {
          evaledValue = ifArgument.value.value;
        }
        return directive.name.value === "skip" ? !evaledValue : evaledValue;
      });
    }
    function getDirectiveNames2(root2) {
      var names = [];
      graphql2.visit(root2, {
        Directive: function(node) {
          names.push(node.name.value);
        }
      });
      return names;
    }
    var hasAnyDirectives2 = function(names, root2) {
      return hasDirectives2(names, root2, false);
    };
    var hasAllDirectives2 = function(names, root2) {
      return hasDirectives2(names, root2, true);
    };
    function hasDirectives2(names, root2, all) {
      var nameSet = new Set(names);
      var uniqueCount = nameSet.size;
      graphql2.visit(root2, {
        Directive: function(node) {
          if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
            return graphql2.BREAK;
          }
        }
      });
      return all ? !nameSet.size : nameSet.size < uniqueCount;
    }
    function hasClientExports2(document) {
      return document && hasDirectives2(["client", "export"], document, true);
    }
    function isInclusionDirective2(_a2) {
      var value = _a2.name.value;
      return value === "skip" || value === "include";
    }
    function getInclusionDirectives2(directives) {
      var result2 = [];
      if (directives && directives.length) {
        directives.forEach(function(directive) {
          if (!isInclusionDirective2(directive))
            return;
          var directiveArguments = directive.arguments;
          var directiveName = directive.name.value;
          globals.invariant(directiveArguments && directiveArguments.length === 1, 70, directiveName);
          var ifArgument = directiveArguments[0];
          globals.invariant(ifArgument.name && ifArgument.name.value === "if", 71, directiveName);
          var ifValue = ifArgument.value;
          globals.invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 72, directiveName);
          result2.push({ directive, ifArgument });
        });
      }
      return result2;
    }
    var isReactNative2 = globals.maybe(function() {
      return navigator.product;
    }) == "ReactNative";
    var canUseWeakMap2 = typeof WeakMap === "function" && !(isReactNative2 && !global.HermesInternal);
    var canUseWeakSet2 = typeof WeakSet === "function";
    var canUseSymbol2 = typeof Symbol === "function" && typeof Symbol.for === "function";
    var canUseAsyncIteratorSymbol2 = canUseSymbol2 && Symbol.asyncIterator;
    var canUseDOM2 = typeof globals.maybe(function() {
      return window.document.createElement;
    }) === "function";
    var usingJSDOM2 = globals.maybe(function() {
      return navigator.userAgent.indexOf("jsdom") >= 0;
    }) || false;
    var canUseLayoutEffect2 = (canUseDOM2 || isReactNative2) && !usingJSDOM2;
    function isNonNullObject2(obj) {
      return obj !== null && typeof obj === "object";
    }
    function isPlainObject2(obj) {
      return obj !== null && typeof obj === "object" && (Object.getPrototypeOf(obj) === Object.prototype || Object.getPrototypeOf(obj) === null);
    }
    function getFragmentQueryDocument2(document, fragmentName) {
      var actualFragmentName = fragmentName;
      var fragments = [];
      document.definitions.forEach(function(definition) {
        if (definition.kind === "OperationDefinition") {
          throw globals.newInvariantError(
            73,
            definition.operation,
            definition.name ? " named '".concat(definition.name.value, "'") : ""
          );
        }
        if (definition.kind === "FragmentDefinition") {
          fragments.push(definition);
        }
      });
      if (typeof actualFragmentName === "undefined") {
        globals.invariant(fragments.length === 1, 74, fragments.length);
        actualFragmentName = fragments[0].name.value;
      }
      var query = tslib.__assign(tslib.__assign({}, document), { definitions: tslib.__spreadArray([
        {
          kind: "OperationDefinition",
          operation: "query",
          selectionSet: {
            kind: "SelectionSet",
            selections: [
              {
                kind: "FragmentSpread",
                name: {
                  kind: "Name",
                  value: actualFragmentName
                }
              }
            ]
          }
        }
      ], document.definitions, true) });
      return query;
    }
    function createFragmentMap2(fragments) {
      if (fragments === void 0) {
        fragments = [];
      }
      var symTable = {};
      fragments.forEach(function(fragment) {
        symTable[fragment.name.value] = fragment;
      });
      return symTable;
    }
    function getFragmentFromSelection2(selection, fragmentMap) {
      switch (selection.kind) {
        case "InlineFragment":
          return selection;
        case "FragmentSpread": {
          var fragmentName = selection.name.value;
          if (typeof fragmentMap === "function") {
            return fragmentMap(fragmentName);
          }
          var fragment = fragmentMap && fragmentMap[fragmentName];
          globals.invariant(fragment, 75, fragmentName);
          return fragment || null;
        }
        default:
          return null;
      }
    }
    var scheduledCleanup2 = /* @__PURE__ */ new WeakSet();
    function schedule2(cache2) {
      if (cache2.size <= (cache2.max || -1)) {
        return;
      }
      if (!scheduledCleanup2.has(cache2)) {
        scheduledCleanup2.add(cache2);
        setTimeout(function() {
          cache2.clean();
          scheduledCleanup2.delete(cache2);
        }, 100);
      }
    }
    var AutoCleanedWeakCache2 = function(max, dispose) {
      var cache2 = new caches2.WeakCache(max, dispose);
      cache2.set = function(key, value) {
        var ret = caches2.WeakCache.prototype.set.call(this, key, value);
        schedule2(this);
        return ret;
      };
      return cache2;
    };
    var AutoCleanedStrongCache2 = function(max, dispose) {
      var cache2 = new caches2.StrongCache(max, dispose);
      cache2.set = function(key, value) {
        var ret = caches2.StrongCache.prototype.set.call(this, key, value);
        schedule2(this);
        return ret;
      };
      return cache2;
    };
    var cacheSizeSymbol2 = Symbol.for("apollo.cacheSize");
    var cacheSizes2 = tslib.__assign({}, globals.global[cacheSizeSymbol2]);
    var globalCaches2 = {};
    function registerGlobalCache2(name, getSize) {
      globalCaches2[name] = getSize;
    }
    var canonicalStringify3 = Object.assign(function canonicalStringify4(value) {
      return JSON.stringify(value, stableObjectReplacer2);
    }, {
      reset: function() {
        sortingMap2 = new AutoCleanedStrongCache2(cacheSizes2.canonicalStringify || 1e3);
      }
    });
    if (globalThis.__DEV__ !== false) {
      registerGlobalCache2("canonicalStringify", function() {
        return sortingMap2.size;
      });
    }
    var sortingMap2;
    canonicalStringify3.reset();
    function stableObjectReplacer2(key, value) {
      if (value && typeof value === "object") {
        var proto = Object.getPrototypeOf(value);
        if (proto === Object.prototype || proto === null) {
          var keys = Object.keys(value);
          if (keys.every(everyKeyInOrder2))
            return value;
          var unsortedKey = JSON.stringify(keys);
          var sortedKeys = sortingMap2.get(unsortedKey);
          if (!sortedKeys) {
            keys.sort();
            var sortedKey = JSON.stringify(keys);
            sortedKeys = sortingMap2.get(sortedKey) || keys;
            sortingMap2.set(unsortedKey, sortedKeys);
            sortingMap2.set(sortedKey, sortedKeys);
          }
          var sortedObject_1 = Object.create(proto);
          sortedKeys.forEach(function(key2) {
            sortedObject_1[key2] = value[key2];
          });
          return sortedObject_1;
        }
      }
      return value;
    }
    function everyKeyInOrder2(key, i, keys) {
      return i === 0 || keys[i - 1] <= key;
    }
    function makeReference2(id) {
      return { __ref: String(id) };
    }
    function isReference2(obj) {
      return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
    }
    function isDocumentNode2(value) {
      return isNonNullObject2(value) && value.kind === "Document" && Array.isArray(value.definitions);
    }
    function isStringValue2(value) {
      return value.kind === "StringValue";
    }
    function isBooleanValue2(value) {
      return value.kind === "BooleanValue";
    }
    function isIntValue2(value) {
      return value.kind === "IntValue";
    }
    function isFloatValue2(value) {
      return value.kind === "FloatValue";
    }
    function isVariable2(value) {
      return value.kind === "Variable";
    }
    function isObjectValue2(value) {
      return value.kind === "ObjectValue";
    }
    function isListValue2(value) {
      return value.kind === "ListValue";
    }
    function isEnumValue2(value) {
      return value.kind === "EnumValue";
    }
    function isNullValue2(value) {
      return value.kind === "NullValue";
    }
    function valueToObjectRepresentation2(argObj, name, value, variables) {
      if (isIntValue2(value) || isFloatValue2(value)) {
        argObj[name.value] = Number(value.value);
      } else if (isBooleanValue2(value) || isStringValue2(value)) {
        argObj[name.value] = value.value;
      } else if (isObjectValue2(value)) {
        var nestedArgObj_1 = {};
        value.fields.map(function(obj) {
          return valueToObjectRepresentation2(nestedArgObj_1, obj.name, obj.value, variables);
        });
        argObj[name.value] = nestedArgObj_1;
      } else if (isVariable2(value)) {
        var variableValue = (variables || {})[value.name.value];
        argObj[name.value] = variableValue;
      } else if (isListValue2(value)) {
        argObj[name.value] = value.values.map(function(listValue) {
          var nestedArgArrayObj = {};
          valueToObjectRepresentation2(nestedArgArrayObj, name, listValue, variables);
          return nestedArgArrayObj[name.value];
        });
      } else if (isEnumValue2(value)) {
        argObj[name.value] = value.value;
      } else if (isNullValue2(value)) {
        argObj[name.value] = null;
      } else {
        throw globals.newInvariantError(84, name.value, value.kind);
      }
    }
    function storeKeyNameFromField2(field, variables) {
      var directivesObj = null;
      if (field.directives) {
        directivesObj = {};
        field.directives.forEach(function(directive) {
          directivesObj[directive.name.value] = {};
          if (directive.arguments) {
            directive.arguments.forEach(function(_a2) {
              var name = _a2.name, value = _a2.value;
              return valueToObjectRepresentation2(directivesObj[directive.name.value], name, value, variables);
            });
          }
        });
      }
      var argObj = null;
      if (field.arguments && field.arguments.length) {
        argObj = {};
        field.arguments.forEach(function(_a2) {
          var name = _a2.name, value = _a2.value;
          return valueToObjectRepresentation2(argObj, name, value, variables);
        });
      }
      return getStoreKeyName2(field.name.value, argObj, directivesObj);
    }
    var KNOWN_DIRECTIVES2 = [
      "connection",
      "include",
      "skip",
      "client",
      "rest",
      "export",
      "nonreactive"
    ];
    var storeKeyNameStringify2 = canonicalStringify3;
    var getStoreKeyName2 = Object.assign(function(fieldName, args, directives) {
      if (args && directives && directives["connection"] && directives["connection"]["key"]) {
        if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
          var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
          filterKeys.sort();
          var filteredArgs_1 = {};
          filterKeys.forEach(function(key) {
            filteredArgs_1[key] = args[key];
          });
          return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify2(filteredArgs_1), ")");
        } else {
          return directives["connection"]["key"];
        }
      }
      var completeFieldName = fieldName;
      if (args) {
        var stringifiedArgs = storeKeyNameStringify2(args);
        completeFieldName += "(".concat(stringifiedArgs, ")");
      }
      if (directives) {
        Object.keys(directives).forEach(function(key) {
          if (KNOWN_DIRECTIVES2.indexOf(key) !== -1)
            return;
          if (directives[key] && Object.keys(directives[key]).length) {
            completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify2(directives[key]), ")");
          } else {
            completeFieldName += "@".concat(key);
          }
        });
      }
      return completeFieldName;
    }, {
      setStringify: function(s) {
        var previous = storeKeyNameStringify2;
        storeKeyNameStringify2 = s;
        return previous;
      }
    });
    function argumentsObjectFromField2(field, variables) {
      if (field.arguments && field.arguments.length) {
        var argObj_1 = {};
        field.arguments.forEach(function(_a2) {
          var name = _a2.name, value = _a2.value;
          return valueToObjectRepresentation2(argObj_1, name, value, variables);
        });
        return argObj_1;
      }
      return null;
    }
    function resultKeyNameFromField2(field) {
      return field.alias ? field.alias.value : field.name.value;
    }
    function getTypenameFromResult2(result2, selectionSet, fragmentMap) {
      var fragments;
      for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
        var selection = _a2[_i];
        if (isField2(selection)) {
          if (selection.name.value === "__typename") {
            return result2[resultKeyNameFromField2(selection)];
          }
        } else if (fragments) {
          fragments.push(selection);
        } else {
          fragments = [selection];
        }
      }
      if (typeof result2.__typename === "string") {
        return result2.__typename;
      }
      if (fragments) {
        for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
          var selection = fragments_1[_b];
          var typename = getTypenameFromResult2(result2, getFragmentFromSelection2(selection, fragmentMap).selectionSet, fragmentMap);
          if (typeof typename === "string") {
            return typename;
          }
        }
      }
    }
    function isField2(selection) {
      return selection.kind === "Field";
    }
    function isInlineFragment2(selection) {
      return selection.kind === "InlineFragment";
    }
    function checkDocument2(doc) {
      globals.invariant(doc && doc.kind === "Document", 76);
      var operations = doc.definitions.filter(function(d) {
        return d.kind !== "FragmentDefinition";
      }).map(function(definition) {
        if (definition.kind !== "OperationDefinition") {
          throw globals.newInvariantError(77, definition.kind);
        }
        return definition;
      });
      globals.invariant(operations.length <= 1, 78, operations.length);
      return doc;
    }
    function getOperationDefinition2(doc) {
      checkDocument2(doc);
      return doc.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition";
      })[0];
    }
    function getOperationName2(doc) {
      return doc.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition" && !!definition.name;
      }).map(function(x) {
        return x.name.value;
      })[0] || null;
    }
    function getFragmentDefinitions2(doc) {
      return doc.definitions.filter(function(definition) {
        return definition.kind === "FragmentDefinition";
      });
    }
    function getQueryDefinition2(doc) {
      var queryDef = getOperationDefinition2(doc);
      globals.invariant(queryDef && queryDef.operation === "query", 79);
      return queryDef;
    }
    function getFragmentDefinition2(doc) {
      globals.invariant(doc.kind === "Document", 80);
      globals.invariant(doc.definitions.length <= 1, 81);
      var fragmentDef = doc.definitions[0];
      globals.invariant(fragmentDef.kind === "FragmentDefinition", 82);
      return fragmentDef;
    }
    function getMainDefinition2(queryDoc) {
      checkDocument2(queryDoc);
      var fragmentDefinition;
      for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
        var definition = _a2[_i];
        if (definition.kind === "OperationDefinition") {
          var operation = definition.operation;
          if (operation === "query" || operation === "mutation" || operation === "subscription") {
            return definition;
          }
        }
        if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
          fragmentDefinition = definition;
        }
      }
      if (fragmentDefinition) {
        return fragmentDefinition;
      }
      throw globals.newInvariantError(83);
    }
    function getDefaultValues2(definition) {
      var defaultValues = /* @__PURE__ */ Object.create(null);
      var defs = definition && definition.variableDefinitions;
      if (defs && defs.length) {
        defs.forEach(function(def) {
          if (def.defaultValue) {
            valueToObjectRepresentation2(defaultValues, def.variable.name, def.defaultValue);
          }
        });
      }
      return defaultValues;
    }
    function identity2(document) {
      return document;
    }
    var DocumentTransform2 = function() {
      function DocumentTransform3(transform, options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        this.resultCache = canUseWeakSet2 ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
        this.transform = transform;
        if (options.getCacheKey) {
          this.getCacheKey = options.getCacheKey;
        }
        this.cached = options.cache !== false;
        this.resetCache();
      }
      DocumentTransform3.prototype.getCacheKey = function(document) {
        return [document];
      };
      DocumentTransform3.identity = function() {
        return new DocumentTransform3(identity2, { cache: false });
      };
      DocumentTransform3.split = function(predicate, left, right) {
        if (right === void 0) {
          right = DocumentTransform3.identity();
        }
        return Object.assign(new DocumentTransform3(
          function(document) {
            var documentTransform = predicate(document) ? left : right;
            return documentTransform.transformDocument(document);
          },
          { cache: false }
        ), { left, right });
      };
      DocumentTransform3.prototype.resetCache = function() {
        var _this = this;
        if (this.cached) {
          var stableCacheKeys_1 = new trie.Trie(canUseWeakMap2);
          this.performWork = optimism.wrap(DocumentTransform3.prototype.performWork.bind(this), {
            makeCacheKey: function(document) {
              var cacheKeys = _this.getCacheKey(document);
              if (cacheKeys) {
                globals.invariant(Array.isArray(cacheKeys), 68);
                return stableCacheKeys_1.lookupArray(cacheKeys);
              }
            },
            max: cacheSizes2["documentTransform.cache"],
            cache: caches2.WeakCache
          });
        }
      };
      DocumentTransform3.prototype.performWork = function(document) {
        checkDocument2(document);
        return this.transform(document);
      };
      DocumentTransform3.prototype.transformDocument = function(document) {
        if (this.resultCache.has(document)) {
          return document;
        }
        var transformedDocument = this.performWork(document);
        this.resultCache.add(transformedDocument);
        return transformedDocument;
      };
      DocumentTransform3.prototype.concat = function(otherTransform) {
        var _this = this;
        return Object.assign(new DocumentTransform3(
          function(document) {
            return otherTransform.transformDocument(_this.transformDocument(document));
          },
          { cache: false }
        ), {
          left: this,
          right: otherTransform
        });
      };
      return DocumentTransform3;
    }();
    var printCache2;
    var print3 = Object.assign(function(ast) {
      var result2 = printCache2.get(ast);
      if (!result2) {
        result2 = graphql2.print(ast);
        printCache2.set(ast, result2);
      }
      return result2;
    }, {
      reset: function() {
        printCache2 = new AutoCleanedWeakCache2(cacheSizes2.print || 2e3);
      }
    });
    print3.reset();
    if (globalThis.__DEV__ !== false) {
      registerGlobalCache2("print", function() {
        return printCache2 ? printCache2.size : 0;
      });
    }
    var isArray2 = Array.isArray;
    function isNonEmptyArray2(value) {
      return Array.isArray(value) && value.length > 0;
    }
    var TYPENAME_FIELD2 = {
      kind: graphql2.Kind.FIELD,
      name: {
        kind: graphql2.Kind.NAME,
        value: "__typename"
      }
    };
    function isEmpty2(op, fragmentMap) {
      return !op || op.selectionSet.selections.every(function(selection) {
        return selection.kind === graphql2.Kind.FRAGMENT_SPREAD && isEmpty2(fragmentMap[selection.name.value], fragmentMap);
      });
    }
    function nullIfDocIsEmpty2(doc) {
      return isEmpty2(getOperationDefinition2(doc) || getFragmentDefinition2(doc), createFragmentMap2(getFragmentDefinitions2(doc))) ? null : doc;
    }
    function getDirectiveMatcher2(configs) {
      var names = /* @__PURE__ */ new Map();
      var tests = /* @__PURE__ */ new Map();
      configs.forEach(function(directive) {
        if (directive) {
          if (directive.name) {
            names.set(directive.name, directive);
          } else if (directive.test) {
            tests.set(directive.test, directive);
          }
        }
      });
      return function(directive) {
        var config = names.get(directive.name.value);
        if (!config && tests.size) {
          tests.forEach(function(testConfig, test) {
            if (test(directive)) {
              config = testConfig;
            }
          });
        }
        return config;
      };
    }
    function makeInUseGetterFunction2(defaultKey) {
      var map = /* @__PURE__ */ new Map();
      return function inUseGetterFunction(key) {
        if (key === void 0) {
          key = defaultKey;
        }
        var inUse = map.get(key);
        if (!inUse) {
          map.set(key, inUse = {
            variables: /* @__PURE__ */ new Set(),
            fragmentSpreads: /* @__PURE__ */ new Set()
          });
        }
        return inUse;
      };
    }
    function removeDirectivesFromDocument2(directives, doc) {
      checkDocument2(doc);
      var getInUseByOperationName = makeInUseGetterFunction2("");
      var getInUseByFragmentName = makeInUseGetterFunction2("");
      var getInUse = function(ancestors) {
        for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
          if (isArray2(ancestor))
            continue;
          if (ancestor.kind === graphql2.Kind.OPERATION_DEFINITION) {
            return getInUseByOperationName(ancestor.name && ancestor.name.value);
          }
          if (ancestor.kind === graphql2.Kind.FRAGMENT_DEFINITION) {
            return getInUseByFragmentName(ancestor.name.value);
          }
        }
        globalThis.__DEV__ !== false && globals.invariant.error(85);
        return null;
      };
      var operationCount = 0;
      for (var i = doc.definitions.length - 1; i >= 0; --i) {
        if (doc.definitions[i].kind === graphql2.Kind.OPERATION_DEFINITION) {
          ++operationCount;
        }
      }
      var directiveMatcher = getDirectiveMatcher2(directives);
      var shouldRemoveField = function(nodeDirectives) {
        return isNonEmptyArray2(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
          return config && config.remove;
        });
      };
      var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
      var firstVisitMadeChanges = false;
      var fieldOrInlineFragmentVisitor = {
        enter: function(node) {
          if (shouldRemoveField(node.directives)) {
            firstVisitMadeChanges = true;
            return null;
          }
        }
      };
      var docWithoutDirectiveSubtrees = graphql2.visit(doc, {
        Field: fieldOrInlineFragmentVisitor,
        InlineFragment: fieldOrInlineFragmentVisitor,
        VariableDefinition: {
          enter: function() {
            return false;
          }
        },
        Variable: {
          enter: function(node, _key, _parent, _path, ancestors) {
            var inUse = getInUse(ancestors);
            if (inUse) {
              inUse.variables.add(node.name.value);
            }
          }
        },
        FragmentSpread: {
          enter: function(node, _key, _parent, _path, ancestors) {
            if (shouldRemoveField(node.directives)) {
              firstVisitMadeChanges = true;
              return null;
            }
            var inUse = getInUse(ancestors);
            if (inUse) {
              inUse.fragmentSpreads.add(node.name.value);
            }
          }
        },
        FragmentDefinition: {
          enter: function(node, _key, _parent, path) {
            originalFragmentDefsByPath.set(JSON.stringify(path), node);
          },
          leave: function(node, _key, _parent, path) {
            var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
            if (node === originalNode) {
              return node;
            }
            if (operationCount > 0 && node.selectionSet.selections.every(function(selection) {
              return selection.kind === graphql2.Kind.FIELD && selection.name.value === "__typename";
            })) {
              getInUseByFragmentName(node.name.value).removed = true;
              firstVisitMadeChanges = true;
              return null;
            }
          }
        },
        Directive: {
          leave: function(node) {
            if (directiveMatcher(node)) {
              firstVisitMadeChanges = true;
              return null;
            }
          }
        }
      });
      if (!firstVisitMadeChanges) {
        return doc;
      }
      var populateTransitiveVars = function(inUse) {
        if (!inUse.transitiveVars) {
          inUse.transitiveVars = new Set(inUse.variables);
          if (!inUse.removed) {
            inUse.fragmentSpreads.forEach(function(childFragmentName) {
              populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
                inUse.transitiveVars.add(varName);
              });
            });
          }
        }
        return inUse;
      };
      var allFragmentNamesUsed = /* @__PURE__ */ new Set();
      docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
        if (def.kind === graphql2.Kind.OPERATION_DEFINITION) {
          populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
            allFragmentNamesUsed.add(childFragmentName);
          });
        } else if (def.kind === graphql2.Kind.FRAGMENT_DEFINITION && operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
          allFragmentNamesUsed.add(def.name.value);
        }
      });
      allFragmentNamesUsed.forEach(function(fragmentName) {
        populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
          allFragmentNamesUsed.add(childFragmentName);
        });
      });
      var fragmentWillBeRemoved = function(fragmentName) {
        return !!(!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
      };
      var enterVisitor = {
        enter: function(node) {
          if (fragmentWillBeRemoved(node.name.value)) {
            return null;
          }
        }
      };
      return nullIfDocIsEmpty2(graphql2.visit(docWithoutDirectiveSubtrees, {
        FragmentSpread: enterVisitor,
        FragmentDefinition: enterVisitor,
        OperationDefinition: {
          leave: function(node) {
            if (node.variableDefinitions) {
              var usedVariableNames_1 = populateTransitiveVars(
                getInUseByOperationName(node.name && node.name.value)
              ).transitiveVars;
              if (usedVariableNames_1.size < node.variableDefinitions.length) {
                return tslib.__assign(tslib.__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
                  return usedVariableNames_1.has(varDef.variable.name.value);
                }) });
              }
            }
          }
        }
      }));
    }
    var addTypenameToDocument2 = Object.assign(function(doc) {
      return graphql2.visit(doc, {
        SelectionSet: {
          enter: function(node, _key, parent) {
            if (parent && parent.kind === graphql2.Kind.OPERATION_DEFINITION) {
              return;
            }
            var selections = node.selections;
            if (!selections) {
              return;
            }
            var skip = selections.some(function(selection) {
              return isField2(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
            });
            if (skip) {
              return;
            }
            var field = parent;
            if (isField2(field) && field.directives && field.directives.some(function(d) {
              return d.name.value === "export";
            })) {
              return;
            }
            return tslib.__assign(tslib.__assign({}, node), { selections: tslib.__spreadArray(tslib.__spreadArray([], selections, true), [TYPENAME_FIELD2], false) });
          }
        }
      });
    }, {
      added: function(field) {
        return field === TYPENAME_FIELD2;
      }
    });
    var connectionRemoveConfig = {
      test: function(directive) {
        var willRemove = directive.name.value === "connection";
        if (willRemove) {
          if (!directive.arguments || !directive.arguments.some(function(arg) {
            return arg.name.value === "key";
          })) {
            globalThis.__DEV__ !== false && globals.invariant.warn(86);
          }
        }
        return willRemove;
      }
    };
    function removeConnectionDirectiveFromDocument2(doc) {
      return removeDirectivesFromDocument2([connectionRemoveConfig], checkDocument2(doc));
    }
    function getArgumentMatcher(config) {
      return function argumentMatcher(argument) {
        return config.some(function(aConfig) {
          return argument.value && argument.value.kind === graphql2.Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
        });
      };
    }
    function removeArgumentsFromDocument2(config, doc) {
      var argMatcher = getArgumentMatcher(config);
      return nullIfDocIsEmpty2(graphql2.visit(doc, {
        OperationDefinition: {
          enter: function(node) {
            return tslib.__assign(tslib.__assign({}, node), {
              variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
                return !config.some(function(arg) {
                  return arg.name === varDef.variable.name.value;
                });
              }) : []
            });
          }
        },
        Field: {
          enter: function(node) {
            var shouldRemoveField = config.some(function(argConfig) {
              return argConfig.remove;
            });
            if (shouldRemoveField) {
              var argMatchCount_1 = 0;
              if (node.arguments) {
                node.arguments.forEach(function(arg) {
                  if (argMatcher(arg)) {
                    argMatchCount_1 += 1;
                  }
                });
              }
              if (argMatchCount_1 === 1) {
                return null;
              }
            }
          }
        },
        Argument: {
          enter: function(node) {
            if (argMatcher(node)) {
              return null;
            }
          }
        }
      }));
    }
    function removeFragmentSpreadFromDocument2(config, doc) {
      function enter(node) {
        if (config.some(function(def) {
          return def.name === node.name.value;
        })) {
          return null;
        }
      }
      return nullIfDocIsEmpty2(graphql2.visit(doc, {
        FragmentSpread: { enter },
        FragmentDefinition: { enter }
      }));
    }
    function buildQueryFromSelectionSet2(document) {
      var definition = getMainDefinition2(document);
      var definitionOperation = definition.operation;
      if (definitionOperation === "query") {
        return document;
      }
      var modifiedDoc = graphql2.visit(document, {
        OperationDefinition: {
          enter: function(node) {
            return tslib.__assign(tslib.__assign({}, node), { operation: "query" });
          }
        }
      });
      return modifiedDoc;
    }
    function removeClientSetsFromDocument2(document) {
      checkDocument2(document);
      var modifiedDoc = removeDirectivesFromDocument2([
        {
          test: function(directive) {
            return directive.name.value === "client";
          },
          remove: true
        }
      ], document);
      return modifiedDoc;
    }
    function isOperation(document, operation) {
      var _a2;
      return ((_a2 = getOperationDefinition2(document)) === null || _a2 === void 0 ? void 0 : _a2.operation) === operation;
    }
    function isMutationOperation2(document) {
      return isOperation(document, "mutation");
    }
    function isQueryOperation2(document) {
      return isOperation(document, "query");
    }
    function isSubscriptionOperation2(document) {
      return isOperation(document, "subscription");
    }
    var hasOwnProperty11 = Object.prototype.hasOwnProperty;
    function mergeDeep2() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return mergeDeepArray2(sources);
    }
    function mergeDeepArray2(sources) {
      var target = sources[0] || {};
      var count = sources.length;
      if (count > 1) {
        var merger = new DeepMerger2();
        for (var i = 1; i < count; ++i) {
          target = merger.merge(target, sources[i]);
        }
      }
      return target;
    }
    var defaultReconciler2 = function(target, source, property) {
      return this.merge(target[property], source[property]);
    };
    var DeepMerger2 = function() {
      function DeepMerger3(reconciler) {
        if (reconciler === void 0) {
          reconciler = defaultReconciler2;
        }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject2;
        this.pastCopies = /* @__PURE__ */ new Set();
      }
      DeepMerger3.prototype.merge = function(target, source) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject2(source) && isNonNullObject2(target)) {
          Object.keys(source).forEach(function(sourceKey) {
            if (hasOwnProperty11.call(target, sourceKey)) {
              var targetValue = target[sourceKey];
              if (source[sourceKey] !== targetValue) {
                var result2 = _this.reconciler.apply(_this, tslib.__spreadArray([
                  target,
                  source,
                  sourceKey
                ], context, false));
                if (result2 !== targetValue) {
                  target = _this.shallowCopyForMerge(target);
                  target[sourceKey] = result2;
                }
              }
            } else {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = source[sourceKey];
            }
          });
          return target;
        }
        return source;
      };
      DeepMerger3.prototype.shallowCopyForMerge = function(value) {
        if (isNonNullObject2(value)) {
          if (!this.pastCopies.has(value)) {
            if (Array.isArray(value)) {
              value = value.slice(0);
            } else {
              value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
            }
            this.pastCopies.add(value);
          }
        }
        return value;
      };
      return DeepMerger3;
    }();
    function concatPagination2(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        merge: function(existing, incoming) {
          return existing ? tslib.__spreadArray(tslib.__spreadArray([], existing, true), incoming, true) : incoming;
        }
      };
    }
    function offsetLimitPagination2(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        merge: function(existing, incoming, _a2) {
          var args = _a2.args;
          var merged = existing ? existing.slice(0) : [];
          if (incoming) {
            if (args) {
              var _b = args.offset, offset = _b === void 0 ? 0 : _b;
              for (var i = 0; i < incoming.length; ++i) {
                merged[offset + i] = incoming[i];
              }
            } else {
              merged.push.apply(merged, incoming);
            }
          }
          return merged;
        }
      };
    }
    function relayStylePagination2(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        read: function(existing, _a2) {
          var canRead = _a2.canRead, readField = _a2.readField;
          if (!existing)
            return existing;
          var edges = [];
          var firstEdgeCursor = "";
          var lastEdgeCursor = "";
          existing.edges.forEach(function(edge) {
            if (canRead(readField("node", edge))) {
              edges.push(edge);
              if (edge.cursor) {
                firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
                lastEdgeCursor = edge.cursor || lastEdgeCursor;
              }
            }
          });
          if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {
            firstEdgeCursor = "";
          }
          var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;
          return tslib.__assign(tslib.__assign({}, getExtras(existing)), { edges, pageInfo: tslib.__assign(tslib.__assign({}, existing.pageInfo), {
            startCursor: startCursor || firstEdgeCursor,
            endCursor: endCursor || lastEdgeCursor
          }) });
        },
        merge: function(existing, incoming, _a2) {
          var args = _a2.args, isReference3 = _a2.isReference, readField = _a2.readField;
          if (!existing) {
            existing = makeEmptyData();
          }
          if (!incoming) {
            return existing;
          }
          var incomingEdges = incoming.edges ? incoming.edges.map(function(edge) {
            if (isReference3(edge = tslib.__assign({}, edge))) {
              edge.cursor = readField("cursor", edge);
            }
            return edge;
          }) : [];
          if (incoming.pageInfo) {
            var pageInfo_1 = incoming.pageInfo;
            var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
            var firstEdge = incomingEdges[0];
            var lastEdge = incomingEdges[incomingEdges.length - 1];
            if (firstEdge && startCursor) {
              firstEdge.cursor = startCursor;
            }
            if (lastEdge && endCursor) {
              lastEdge.cursor = endCursor;
            }
            var firstCursor = firstEdge && firstEdge.cursor;
            if (firstCursor && !startCursor) {
              incoming = mergeDeep2(incoming, {
                pageInfo: {
                  startCursor: firstCursor
                }
              });
            }
            var lastCursor = lastEdge && lastEdge.cursor;
            if (lastCursor && !endCursor) {
              incoming = mergeDeep2(incoming, {
                pageInfo: {
                  endCursor: lastCursor
                }
              });
            }
          }
          var prefix = existing.edges;
          var suffix = [];
          if (args && args.after) {
            var index = prefix.findIndex(function(edge) {
              return edge.cursor === args.after;
            });
            if (index >= 0) {
              prefix = prefix.slice(0, index + 1);
            }
          } else if (args && args.before) {
            var index = prefix.findIndex(function(edge) {
              return edge.cursor === args.before;
            });
            suffix = index < 0 ? prefix : prefix.slice(index);
            prefix = [];
          } else if (incoming.edges) {
            prefix = [];
          }
          var edges = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], prefix, true), incomingEdges, true), suffix, true);
          var pageInfo = tslib.__assign(tslib.__assign({}, incoming.pageInfo), existing.pageInfo);
          if (incoming.pageInfo) {
            var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras2 = tslib.__rest(_b, ["hasPreviousPage", "hasNextPage", "startCursor", "endCursor"]);
            Object.assign(pageInfo, extras2);
            if (!prefix.length) {
              if (void 0 !== hasPreviousPage)
                pageInfo.hasPreviousPage = hasPreviousPage;
              if (void 0 !== startCursor)
                pageInfo.startCursor = startCursor;
            }
            if (!suffix.length) {
              if (void 0 !== hasNextPage)
                pageInfo.hasNextPage = hasNextPage;
              if (void 0 !== endCursor)
                pageInfo.endCursor = endCursor;
            }
          }
          return tslib.__assign(tslib.__assign(tslib.__assign({}, getExtras(existing)), getExtras(incoming)), { edges, pageInfo });
        }
      };
    }
    var getExtras = function(obj) {
      return tslib.__rest(obj, notExtras);
    };
    var notExtras = ["edges", "pageInfo"];
    function makeEmptyData() {
      return {
        edges: [],
        pageInfo: {
          hasPreviousPage: false,
          hasNextPage: true,
          startCursor: "",
          endCursor: ""
        }
      };
    }
    function createFulfilledPromise2(value) {
      var promise = Promise.resolve(value);
      promise.status = "fulfilled";
      promise.value = value;
      return promise;
    }
    function createRejectedPromise2(reason) {
      var promise = Promise.reject(reason);
      promise.catch(function() {
      });
      promise.status = "rejected";
      promise.reason = reason;
      return promise;
    }
    function isStatefulPromise2(promise) {
      return "status" in promise;
    }
    function wrapPromiseWithState2(promise) {
      if (isStatefulPromise2(promise)) {
        return promise;
      }
      var pendingPromise = promise;
      pendingPromise.status = "pending";
      pendingPromise.then(function(value) {
        if (pendingPromise.status === "pending") {
          var fulfilledPromise = pendingPromise;
          fulfilledPromise.status = "fulfilled";
          fulfilledPromise.value = value;
        }
      }, function(reason) {
        if (pendingPromise.status === "pending") {
          var rejectedPromise = pendingPromise;
          rejectedPromise.status = "rejected";
          rejectedPromise.reason = reason;
        }
      });
      return promise;
    }
    var toString3 = Object.prototype.toString;
    function cloneDeep2(value) {
      return cloneDeepHelper2(value);
    }
    function cloneDeepHelper2(val, seen) {
      switch (toString3.call(val)) {
        case "[object Array]": {
          seen = seen || /* @__PURE__ */ new Map();
          if (seen.has(val))
            return seen.get(val);
          var copy_1 = val.slice(0);
          seen.set(val, copy_1);
          copy_1.forEach(function(child, i) {
            copy_1[i] = cloneDeepHelper2(child, seen);
          });
          return copy_1;
        }
        case "[object Object]": {
          seen = seen || /* @__PURE__ */ new Map();
          if (seen.has(val))
            return seen.get(val);
          var copy_2 = Object.create(Object.getPrototypeOf(val));
          seen.set(val, copy_2);
          Object.keys(val).forEach(function(key) {
            copy_2[key] = cloneDeepHelper2(val[key], seen);
          });
          return copy_2;
        }
        default:
          return val;
      }
    }
    function deepFreeze2(value) {
      var workSet = /* @__PURE__ */ new Set([value]);
      workSet.forEach(function(obj) {
        if (isNonNullObject2(obj) && shallowFreeze2(obj) === obj) {
          Object.getOwnPropertyNames(obj).forEach(function(name) {
            if (isNonNullObject2(obj[name]))
              workSet.add(obj[name]);
          });
        }
      });
      return value;
    }
    function shallowFreeze2(obj) {
      if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
        try {
          Object.freeze(obj);
        } catch (e) {
          if (e instanceof TypeError)
            return null;
          throw e;
        }
      }
      return obj;
    }
    function maybeDeepFreeze2(obj) {
      if (globalThis.__DEV__ !== false) {
        deepFreeze2(obj);
      }
      return obj;
    }
    function iterateObserversSafely2(observers, method, argument) {
      var observersWithMethod = [];
      observers.forEach(function(obs) {
        return obs[method] && observersWithMethod.push(obs);
      });
      observersWithMethod.forEach(function(obs) {
        return obs[method](argument);
      });
    }
    function asyncMap2(observable, mapFn, catchFn) {
      return new zenObservableTs.Observable(function(observer) {
        var promiseQueue = {
          then: function(callback) {
            return new Promise(function(resolve) {
              return resolve(callback());
            });
          }
        };
        function makeCallback(examiner, key) {
          return function(arg) {
            if (examiner) {
              var both = function() {
                return observer.closed ? 0 : examiner(arg);
              };
              promiseQueue = promiseQueue.then(both, both).then(function(result2) {
                return observer.next(result2);
              }, function(error) {
                return observer.error(error);
              });
            } else {
              observer[key](arg);
            }
          };
        }
        var handler = {
          next: makeCallback(mapFn, "next"),
          error: makeCallback(catchFn, "error"),
          complete: function() {
            promiseQueue.then(function() {
              return observer.complete();
            });
          }
        };
        var sub = observable.subscribe(handler);
        return function() {
          return sub.unsubscribe();
        };
      });
    }
    function fixObservableSubclass2(subclass) {
      function set(key) {
        Object.defineProperty(subclass, key, { value: zenObservableTs.Observable });
      }
      if (canUseSymbol2 && Symbol.species) {
        set(Symbol.species);
      }
      set("@@species");
      return subclass;
    }
    function isPromiseLike3(value) {
      return value && typeof value.then === "function";
    }
    var Concast2 = function(_super) {
      tslib.__extends(Concast3, _super);
      function Concast3(sources) {
        var _this = _super.call(this, function(observer) {
          _this.addObserver(observer);
          return function() {
            return _this.removeObserver(observer);
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.promise = new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        });
        _this.handlers = {
          next: function(result2) {
            if (_this.sub !== null) {
              _this.latest = ["next", result2];
              _this.notify("next", result2);
              iterateObserversSafely2(_this.observers, "next", result2);
            }
          },
          error: function(error) {
            var sub = _this.sub;
            if (sub !== null) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              _this.latest = ["error", error];
              _this.reject(error);
              _this.notify("error", error);
              iterateObserversSafely2(_this.observers, "error", error);
            }
          },
          complete: function() {
            var _a2 = _this, sub = _a2.sub, _b = _a2.sources, sources2 = _b === void 0 ? [] : _b;
            if (sub !== null) {
              var value = sources2.shift();
              if (!value) {
                if (sub)
                  setTimeout(function() {
                    return sub.unsubscribe();
                  });
                _this.sub = null;
                if (_this.latest && _this.latest[0] === "next") {
                  _this.resolve(_this.latest[1]);
                } else {
                  _this.resolve();
                }
                _this.notify("complete");
                iterateObserversSafely2(_this.observers, "complete");
              } else if (isPromiseLike3(value)) {
                value.then(function(obs) {
                  return _this.sub = obs.subscribe(_this.handlers);
                }, _this.handlers.error);
              } else {
                _this.sub = value.subscribe(_this.handlers);
              }
            }
          }
        };
        _this.nextResultListeners = /* @__PURE__ */ new Set();
        _this.cancel = function(reason) {
          _this.reject(reason);
          _this.sources = [];
          _this.handlers.complete();
        };
        _this.promise.catch(function(_) {
        });
        if (typeof sources === "function") {
          sources = [new zenObservableTs.Observable(sources)];
        }
        if (isPromiseLike3(sources)) {
          sources.then(function(iterable) {
            return _this.start(iterable);
          }, _this.handlers.error);
        } else {
          _this.start(sources);
        }
        return _this;
      }
      Concast3.prototype.start = function(sources) {
        if (this.sub !== void 0)
          return;
        this.sources = Array.from(sources);
        this.handlers.complete();
      };
      Concast3.prototype.deliverLastMessage = function(observer) {
        if (this.latest) {
          var nextOrError = this.latest[0];
          var method = observer[nextOrError];
          if (method) {
            method.call(observer, this.latest[1]);
          }
          if (this.sub === null && nextOrError === "next" && observer.complete) {
            observer.complete();
          }
        }
      };
      Concast3.prototype.addObserver = function(observer) {
        if (!this.observers.has(observer)) {
          this.deliverLastMessage(observer);
          this.observers.add(observer);
        }
      };
      Concast3.prototype.removeObserver = function(observer) {
        if (this.observers.delete(observer) && this.observers.size < 1) {
          this.handlers.complete();
        }
      };
      Concast3.prototype.notify = function(method, arg) {
        var nextResultListeners = this.nextResultListeners;
        if (nextResultListeners.size) {
          this.nextResultListeners = /* @__PURE__ */ new Set();
          nextResultListeners.forEach(function(listener) {
            return listener(method, arg);
          });
        }
      };
      Concast3.prototype.beforeNext = function(callback) {
        var called = false;
        this.nextResultListeners.add(function(method, arg) {
          if (!called) {
            called = true;
            callback(method, arg);
          }
        });
      };
      return Concast3;
    }(zenObservableTs.Observable);
    fixObservableSubclass2(Concast2);
    function isExecutionPatchIncrementalResult2(value) {
      return "incremental" in value;
    }
    function isExecutionPatchInitialResult2(value) {
      return "hasNext" in value && "data" in value;
    }
    function isExecutionPatchResult2(value) {
      return isExecutionPatchIncrementalResult2(value) || isExecutionPatchInitialResult2(value);
    }
    function isApolloPayloadResult2(value) {
      return isNonNullObject2(value) && "payload" in value;
    }
    function mergeIncrementalData2(prevResult, result2) {
      var mergedData = prevResult;
      var merger = new DeepMerger2();
      if (isExecutionPatchIncrementalResult2(result2) && isNonEmptyArray2(result2.incremental)) {
        result2.incremental.forEach(function(_a2) {
          var data = _a2.data, path = _a2.path;
          for (var i = path.length - 1; i >= 0; --i) {
            var key = path[i];
            var isNumericKey = !isNaN(+key);
            var parent_1 = isNumericKey ? [] : {};
            parent_1[key] = data;
            data = parent_1;
          }
          mergedData = merger.merge(mergedData, data);
        });
      }
      return mergedData;
    }
    function graphQLResultHasError2(result2) {
      var errors = getGraphQLErrorsFromResult2(result2);
      return isNonEmptyArray2(errors);
    }
    function getGraphQLErrorsFromResult2(result2) {
      var graphQLErrors = isNonEmptyArray2(result2.errors) ? result2.errors.slice(0) : [];
      if (isExecutionPatchIncrementalResult2(result2) && isNonEmptyArray2(result2.incremental)) {
        result2.incremental.forEach(function(incrementalResult) {
          if (incrementalResult.errors) {
            graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
          }
        });
      }
      return graphQLErrors;
    }
    function compact2() {
      var objects = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
      }
      var result2 = /* @__PURE__ */ Object.create(null);
      objects.forEach(function(obj) {
        if (!obj)
          return;
        Object.keys(obj).forEach(function(key) {
          var value = obj[key];
          if (value !== void 0) {
            result2[key] = value;
          }
        });
      });
      return result2;
    }
    var prefixCounts2 = /* @__PURE__ */ new Map();
    function makeUniqueId2(prefix) {
      var count = prefixCounts2.get(prefix) || 1;
      prefixCounts2.set(prefix, count + 1);
      return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
    }
    function stringifyForDisplay2(value, space) {
      if (space === void 0) {
        space = 0;
      }
      var undefId = makeUniqueId2("stringifyForDisplay");
      return JSON.stringify(value, function(key, value2) {
        return value2 === void 0 ? undefId : value2;
      }, space).split(JSON.stringify(undefId)).join("<undefined>");
    }
    function mergeOptions2(defaults, options) {
      return compact2(defaults, options, options.variables && {
        variables: compact2(tslib.__assign(tslib.__assign({}, defaults && defaults.variables), options.variables))
      });
    }
    function omitDeep2(value, key) {
      return __omitDeep(value, key);
    }
    function __omitDeep(value, key, known) {
      if (known === void 0) {
        known = /* @__PURE__ */ new Map();
      }
      if (known.has(value)) {
        return known.get(value);
      }
      var modified = false;
      if (Array.isArray(value)) {
        var array_1 = [];
        known.set(value, array_1);
        value.forEach(function(value2, index) {
          var result2 = __omitDeep(value2, key, known);
          modified || (modified = result2 !== value2);
          array_1[index] = result2;
        });
        if (modified) {
          return array_1;
        }
      } else if (isPlainObject2(value)) {
        var obj_1 = Object.create(Object.getPrototypeOf(value));
        known.set(value, obj_1);
        Object.keys(value).forEach(function(k) {
          if (k === key) {
            modified = true;
            return;
          }
          var result2 = __omitDeep(value[k], key, known);
          modified || (modified = result2 !== value[k]);
          obj_1[k] = result2;
        });
        if (modified) {
          return obj_1;
        }
      }
      return value;
    }
    function stripTypename2(value) {
      return omitDeep2(value, "__typename");
    }
    exports.DEV = globals.DEV;
    exports.maybe = globals.maybe;
    exports.Observable = zenObservableTs.Observable;
    exports.AutoCleanedStrongCache = AutoCleanedStrongCache2;
    exports.AutoCleanedWeakCache = AutoCleanedWeakCache2;
    exports.Concast = Concast2;
    exports.DeepMerger = DeepMerger2;
    exports.DocumentTransform = DocumentTransform2;
    exports.addTypenameToDocument = addTypenameToDocument2;
    exports.argumentsObjectFromField = argumentsObjectFromField2;
    exports.asyncMap = asyncMap2;
    exports.buildQueryFromSelectionSet = buildQueryFromSelectionSet2;
    exports.cacheSizes = cacheSizes2;
    exports.canUseAsyncIteratorSymbol = canUseAsyncIteratorSymbol2;
    exports.canUseDOM = canUseDOM2;
    exports.canUseLayoutEffect = canUseLayoutEffect2;
    exports.canUseSymbol = canUseSymbol2;
    exports.canUseWeakMap = canUseWeakMap2;
    exports.canUseWeakSet = canUseWeakSet2;
    exports.canonicalStringify = canonicalStringify3;
    exports.checkDocument = checkDocument2;
    exports.cloneDeep = cloneDeep2;
    exports.compact = compact2;
    exports.concatPagination = concatPagination2;
    exports.createFragmentMap = createFragmentMap2;
    exports.createFulfilledPromise = createFulfilledPromise2;
    exports.createRejectedPromise = createRejectedPromise2;
    exports.fixObservableSubclass = fixObservableSubclass2;
    exports.getDefaultValues = getDefaultValues2;
    exports.getDirectiveNames = getDirectiveNames2;
    exports.getFragmentDefinition = getFragmentDefinition2;
    exports.getFragmentDefinitions = getFragmentDefinitions2;
    exports.getFragmentFromSelection = getFragmentFromSelection2;
    exports.getFragmentQueryDocument = getFragmentQueryDocument2;
    exports.getGraphQLErrorsFromResult = getGraphQLErrorsFromResult2;
    exports.getInclusionDirectives = getInclusionDirectives2;
    exports.getMainDefinition = getMainDefinition2;
    exports.getOperationDefinition = getOperationDefinition2;
    exports.getOperationName = getOperationName2;
    exports.getQueryDefinition = getQueryDefinition2;
    exports.getStoreKeyName = getStoreKeyName2;
    exports.getTypenameFromResult = getTypenameFromResult2;
    exports.graphQLResultHasError = graphQLResultHasError2;
    exports.hasAllDirectives = hasAllDirectives2;
    exports.hasAnyDirectives = hasAnyDirectives2;
    exports.hasClientExports = hasClientExports2;
    exports.hasDirectives = hasDirectives2;
    exports.isApolloPayloadResult = isApolloPayloadResult2;
    exports.isArray = isArray2;
    exports.isDocumentNode = isDocumentNode2;
    exports.isExecutionPatchIncrementalResult = isExecutionPatchIncrementalResult2;
    exports.isExecutionPatchInitialResult = isExecutionPatchInitialResult2;
    exports.isExecutionPatchResult = isExecutionPatchResult2;
    exports.isField = isField2;
    exports.isInlineFragment = isInlineFragment2;
    exports.isMutationOperation = isMutationOperation2;
    exports.isNonEmptyArray = isNonEmptyArray2;
    exports.isNonNullObject = isNonNullObject2;
    exports.isPlainObject = isPlainObject2;
    exports.isQueryOperation = isQueryOperation2;
    exports.isReference = isReference2;
    exports.isStatefulPromise = isStatefulPromise2;
    exports.isSubscriptionOperation = isSubscriptionOperation2;
    exports.iterateObserversSafely = iterateObserversSafely2;
    exports.makeReference = makeReference2;
    exports.makeUniqueId = makeUniqueId2;
    exports.maybeDeepFreeze = maybeDeepFreeze2;
    exports.mergeDeep = mergeDeep2;
    exports.mergeDeepArray = mergeDeepArray2;
    exports.mergeIncrementalData = mergeIncrementalData2;
    exports.mergeOptions = mergeOptions2;
    exports.offsetLimitPagination = offsetLimitPagination2;
    exports.omitDeep = omitDeep2;
    exports.print = print3;
    exports.relayStylePagination = relayStylePagination2;
    exports.removeArgumentsFromDocument = removeArgumentsFromDocument2;
    exports.removeClientSetsFromDocument = removeClientSetsFromDocument2;
    exports.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument2;
    exports.removeDirectivesFromDocument = removeDirectivesFromDocument2;
    exports.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument2;
    exports.resultKeyNameFromField = resultKeyNameFromField2;
    exports.shouldInclude = shouldInclude2;
    exports.storeKeyNameFromField = storeKeyNameFromField2;
    exports.stringifyForDisplay = stringifyForDisplay2;
    exports.stripTypename = stripTypename2;
    exports.valueToObjectRepresentation = valueToObjectRepresentation2;
    exports.wrapPromiseWithState = wrapPromiseWithState2;
  }
});

// ../node_modules/@apollo/client/link/utils/utils.cjs
var require_utils = __commonJS({
  "../node_modules/@apollo/client/link/utils/utils.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var utilities = require_utilities();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var graphql2 = (init_graphql2(), __toCommonJS(graphql_exports));
    function fromError2(errorValue) {
      return new utilities.Observable(function(observer) {
        observer.error(errorValue);
      });
    }
    function toPromise2(observable) {
      var completed = false;
      return new Promise(function(resolve, reject) {
        observable.subscribe({
          next: function(data) {
            if (completed) {
              globalThis.__DEV__ !== false && globals.invariant.warn(42);
            } else {
              completed = true;
              resolve(data);
            }
          },
          error: reject
        });
      });
    }
    function fromPromise2(promise) {
      return new utilities.Observable(function(observer) {
        promise.then(function(value) {
          observer.next(value);
          observer.complete();
        }).catch(observer.error.bind(observer));
      });
    }
    var throwServerError2 = function(response, result2, message) {
      var error = new Error(message);
      error.name = "ServerError";
      error.response = response;
      error.statusCode = response.status;
      error.result = result2;
      throw error;
    };
    function validateOperation2(operation) {
      var OPERATION_FIELDS = [
        "query",
        "operationName",
        "variables",
        "extensions",
        "context"
      ];
      for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
        var key = _a2[_i];
        if (OPERATION_FIELDS.indexOf(key) < 0) {
          throw globals.newInvariantError(43, key);
        }
      }
      return operation;
    }
    function createOperation2(starting, operation) {
      var context = tslib.__assign({}, starting);
      var setContext = function(next) {
        if (typeof next === "function") {
          context = tslib.__assign(tslib.__assign({}, context), next(context));
        } else {
          context = tslib.__assign(tslib.__assign({}, context), next);
        }
      };
      var getContext = function() {
        return tslib.__assign({}, context);
      };
      Object.defineProperty(operation, "setContext", {
        enumerable: false,
        value: setContext
      });
      Object.defineProperty(operation, "getContext", {
        enumerable: false,
        value: getContext
      });
      return operation;
    }
    function transformOperation2(operation) {
      var transformedOperation = {
        variables: operation.variables || {},
        extensions: operation.extensions || {},
        operationName: operation.operationName,
        query: operation.query
      };
      if (!transformedOperation.operationName) {
        transformedOperation.operationName = typeof transformedOperation.query !== "string" ? utilities.getOperationName(transformedOperation.query) || void 0 : "";
      }
      return transformedOperation;
    }
    function filterOperationVariables2(variables, query) {
      var result2 = tslib.__assign({}, variables);
      var unusedNames = new Set(Object.keys(variables));
      graphql2.visit(query, {
        Variable: function(node, _key, parent) {
          if (parent && parent.kind !== "VariableDefinition") {
            unusedNames.delete(node.name.value);
          }
        }
      });
      unusedNames.forEach(function(name) {
        delete result2[name];
      });
      return result2;
    }
    exports.createOperation = createOperation2;
    exports.filterOperationVariables = filterOperationVariables2;
    exports.fromError = fromError2;
    exports.fromPromise = fromPromise2;
    exports.throwServerError = throwServerError2;
    exports.toPromise = toPromise2;
    exports.transformOperation = transformOperation2;
    exports.validateOperation = validateOperation2;
  }
});

// ../node_modules/@apollo/client/link/core/core.cjs
var require_core = __commonJS({
  "../node_modules/@apollo/client/link/core/core.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var utilities = require_utilities();
    var utils = require_utils();
    function passthrough2(op, forward) {
      return forward ? forward(op) : utilities.Observable.of();
    }
    function toLink2(handler) {
      return typeof handler === "function" ? new ApolloLink2(handler) : handler;
    }
    function isTerminating2(link) {
      return link.request.length <= 1;
    }
    var ApolloLink2 = function() {
      function ApolloLink3(request) {
        if (request)
          this.request = request;
      }
      ApolloLink3.empty = function() {
        return new ApolloLink3(function() {
          return utilities.Observable.of();
        });
      };
      ApolloLink3.from = function(links) {
        if (links.length === 0)
          return ApolloLink3.empty();
        return links.map(toLink2).reduce(function(x, y) {
          return x.concat(y);
        });
      };
      ApolloLink3.split = function(test, left, right) {
        var leftLink = toLink2(left);
        var rightLink = toLink2(right || new ApolloLink3(passthrough2));
        var ret;
        if (isTerminating2(leftLink) && isTerminating2(rightLink)) {
          ret = new ApolloLink3(function(operation) {
            return test(operation) ? leftLink.request(operation) || utilities.Observable.of() : rightLink.request(operation) || utilities.Observable.of();
          });
        } else {
          ret = new ApolloLink3(function(operation, forward) {
            return test(operation) ? leftLink.request(operation, forward) || utilities.Observable.of() : rightLink.request(operation, forward) || utilities.Observable.of();
          });
        }
        return Object.assign(ret, { left: leftLink, right: rightLink });
      };
      ApolloLink3.execute = function(link, operation) {
        return link.request(utils.createOperation(operation.context, utils.transformOperation(utils.validateOperation(operation)))) || utilities.Observable.of();
      };
      ApolloLink3.concat = function(first, second) {
        var firstLink = toLink2(first);
        if (isTerminating2(firstLink)) {
          globalThis.__DEV__ !== false && globals.invariant.warn(35, firstLink);
          return firstLink;
        }
        var nextLink = toLink2(second);
        var ret;
        if (isTerminating2(nextLink)) {
          ret = new ApolloLink3(function(operation) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op) || utilities.Observable.of();
            }) || utilities.Observable.of();
          });
        } else {
          ret = new ApolloLink3(function(operation, forward) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op, forward) || utilities.Observable.of();
            }) || utilities.Observable.of();
          });
        }
        return Object.assign(ret, { left: firstLink, right: nextLink });
      };
      ApolloLink3.prototype.split = function(test, left, right) {
        return this.concat(ApolloLink3.split(test, left, right || new ApolloLink3(passthrough2)));
      };
      ApolloLink3.prototype.concat = function(next) {
        return ApolloLink3.concat(this, next);
      };
      ApolloLink3.prototype.request = function(operation, forward) {
        throw globals.newInvariantError(36);
      };
      ApolloLink3.prototype.onError = function(error, observer) {
        if (observer && observer.error) {
          observer.error(error);
          return false;
        }
        throw error;
      };
      ApolloLink3.prototype.setOnError = function(fn) {
        this.onError = fn;
        return this;
      };
      return ApolloLink3;
    }();
    var empty2 = ApolloLink2.empty;
    var from2 = ApolloLink2.from;
    var split2 = ApolloLink2.split;
    var concat2 = ApolloLink2.concat;
    var execute3 = ApolloLink2.execute;
    exports.ApolloLink = ApolloLink2;
    exports.concat = concat2;
    exports.empty = empty2;
    exports.execute = execute3;
    exports.from = from2;
    exports.split = split2;
  }
});

// ../node_modules/@apollo/client/errors/errors.cjs
var require_errors = __commonJS({
  "../node_modules/@apollo/client/errors/errors.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    require_globals();
    var utilities = require_utilities();
    var PROTOCOL_ERRORS_SYMBOL2 = Symbol();
    function graphQLResultHasProtocolErrors2(result2) {
      if (result2.extensions) {
        return Array.isArray(result2.extensions[PROTOCOL_ERRORS_SYMBOL2]);
      }
      return false;
    }
    function isApolloError2(err) {
      return err.hasOwnProperty("graphQLErrors");
    }
    var generateErrorMessage2 = function(err) {
      var errors = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
      if (err.networkError)
        errors.push(err.networkError);
      return errors.map(function(err2) {
        return utilities.isNonNullObject(err2) && err2.message || "Error message not found.";
      }).join("\n");
    };
    var ApolloError2 = function(_super) {
      tslib.__extends(ApolloError3, _super);
      function ApolloError3(_a2) {
        var graphQLErrors = _a2.graphQLErrors, protocolErrors = _a2.protocolErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.name = "ApolloError";
        _this.graphQLErrors = graphQLErrors || [];
        _this.protocolErrors = protocolErrors || [];
        _this.clientErrors = clientErrors || [];
        _this.networkError = networkError || null;
        _this.message = errorMessage || generateErrorMessage2(_this);
        _this.extraInfo = extraInfo;
        _this.cause = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([
          networkError
        ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e) {
          return !!e;
        }) || null;
        _this.__proto__ = ApolloError3.prototype;
        return _this;
      }
      return ApolloError3;
    }(Error);
    exports.ApolloError = ApolloError2;
    exports.PROTOCOL_ERRORS_SYMBOL = PROTOCOL_ERRORS_SYMBOL2;
    exports.graphQLResultHasProtocolErrors = graphQLResultHasProtocolErrors2;
    exports.isApolloError = isApolloError2;
  }
});

// ../node_modules/@apollo/client/link/http/http.cjs
var require_http = __commonJS({
  "../node_modules/@apollo/client/link/http/http.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var utilities = require_utilities();
    var utils = require_utils();
    var errors = require_errors();
    var core = require_core();
    function asyncIterator2(source) {
      var _a2;
      var iterator = source[Symbol.asyncIterator]();
      return _a2 = {
        next: function() {
          return iterator.next();
        }
      }, _a2[Symbol.asyncIterator] = function() {
        return this;
      }, _a2;
    }
    function nodeStreamIterator2(stream) {
      var cleanup = null;
      var error = null;
      var done = false;
      var data = [];
      var waiting = [];
      function onData(chunk) {
        if (error)
          return;
        if (waiting.length) {
          var shiftedArr = waiting.shift();
          if (Array.isArray(shiftedArr) && shiftedArr[0]) {
            return shiftedArr[0]({ value: chunk, done: false });
          }
        }
        data.push(chunk);
      }
      function onError(err) {
        error = err;
        var all = waiting.slice();
        all.forEach(function(pair) {
          pair[1](err);
        });
        !cleanup || cleanup();
      }
      function onEnd() {
        done = true;
        var all = waiting.slice();
        all.forEach(function(pair) {
          pair[0]({ value: void 0, done: true });
        });
        !cleanup || cleanup();
      }
      cleanup = function() {
        cleanup = null;
        stream.removeListener("data", onData);
        stream.removeListener("error", onError);
        stream.removeListener("end", onEnd);
        stream.removeListener("finish", onEnd);
        stream.removeListener("close", onEnd);
      };
      stream.on("data", onData);
      stream.on("error", onError);
      stream.on("end", onEnd);
      stream.on("finish", onEnd);
      stream.on("close", onEnd);
      function getNext() {
        return new Promise(function(resolve, reject) {
          if (error)
            return reject(error);
          if (data.length)
            return resolve({ value: data.shift(), done: false });
          if (done)
            return resolve({ value: void 0, done: true });
          waiting.push([resolve, reject]);
        });
      }
      var iterator = {
        next: function() {
          return getNext();
        }
      };
      if (utilities.canUseAsyncIteratorSymbol) {
        iterator[Symbol.asyncIterator] = function() {
          return this;
        };
      }
      return iterator;
    }
    function promiseIterator2(promise) {
      var resolved = false;
      var iterator = {
        next: function() {
          if (resolved)
            return Promise.resolve({
              value: void 0,
              done: true
            });
          resolved = true;
          return new Promise(function(resolve, reject) {
            promise.then(function(value) {
              resolve({ value, done: false });
            }).catch(reject);
          });
        }
      };
      if (utilities.canUseAsyncIteratorSymbol) {
        iterator[Symbol.asyncIterator] = function() {
          return this;
        };
      }
      return iterator;
    }
    function readerIterator2(reader) {
      var iterator = {
        next: function() {
          return reader.read();
        }
      };
      if (utilities.canUseAsyncIteratorSymbol) {
        iterator[Symbol.asyncIterator] = function() {
          return this;
        };
      }
      return iterator;
    }
    function isNodeResponse2(value) {
      return !!value.body;
    }
    function isReadableStream2(value) {
      return !!value.getReader;
    }
    function isAsyncIterableIterator2(value) {
      return !!(utilities.canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
    }
    function isStreamableBlob2(value) {
      return !!value.stream;
    }
    function isBlob2(value) {
      return !!value.arrayBuffer;
    }
    function isNodeReadableStream2(value) {
      return !!value.pipe;
    }
    function responseIterator2(response) {
      var body = response;
      if (isNodeResponse2(response))
        body = response.body;
      if (isAsyncIterableIterator2(body))
        return asyncIterator2(body);
      if (isReadableStream2(body))
        return readerIterator2(body.getReader());
      if (isStreamableBlob2(body)) {
        return readerIterator2(body.stream().getReader());
      }
      if (isBlob2(body))
        return promiseIterator2(body.arrayBuffer());
      if (isNodeReadableStream2(body))
        return nodeStreamIterator2(body);
      throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
    }
    function isNonNullObject2(obj) {
      return obj !== null && typeof obj === "object";
    }
    function isApolloPayloadResult2(value) {
      return isNonNullObject2(value) && "payload" in value;
    }
    var hasOwnProperty11 = Object.prototype.hasOwnProperty;
    function readMultipartBody2(response, nextValue) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a2, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result2, next;
        var _b, _c;
        var _d;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              if (TextDecoder === void 0) {
                throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
              }
              decoder = new TextDecoder("utf-8");
              contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
              delimiter = "boundary=";
              boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
              boundary = "\r\n--".concat(boundaryVal);
              buffer = "";
              iterator = responseIterator2(response);
              running = true;
              _e.label = 1;
            case 1:
              if (!running) return [3, 3];
              return [4, iterator.next()];
            case 2:
              _a2 = _e.sent(), value = _a2.value, done = _a2.done;
              chunk = typeof value === "string" ? value : decoder.decode(value);
              searchFrom = buffer.length - boundary.length + 1;
              running = !done;
              buffer += chunk;
              bi = buffer.indexOf(boundary, searchFrom);
              while (bi > -1) {
                message = void 0;
                _b = [
                  buffer.slice(0, bi),
                  buffer.slice(bi + boundary.length)
                ], message = _b[0], buffer = _b[1];
                i = message.indexOf("\r\n\r\n");
                headers = parseHeaders2(message.slice(0, i));
                contentType_1 = headers["content-type"];
                if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
                  throw new Error("Unsupported patch content type: application/json is required.");
                }
                body = message.slice(i);
                if (body) {
                  result2 = parseJsonBody2(response, body);
                  if (Object.keys(result2).length > 1 || "data" in result2 || "incremental" in result2 || "errors" in result2 || "payload" in result2) {
                    if (isApolloPayloadResult2(result2)) {
                      next = {};
                      if ("payload" in result2) {
                        if (Object.keys(result2).length === 1 && result2.payload === null) {
                          return [2];
                        }
                        next = tslib.__assign({}, result2.payload);
                      }
                      if ("errors" in result2) {
                        next = tslib.__assign(tslib.__assign({}, next), { extensions: tslib.__assign(tslib.__assign({}, "extensions" in next ? next.extensions : null), (_c = {}, _c[errors.PROTOCOL_ERRORS_SYMBOL] = result2.errors, _c)) });
                      }
                      nextValue(next);
                    } else {
                      nextValue(result2);
                    }
                  } else if (Object.keys(result2).length === 1 && "hasNext" in result2 && !result2.hasNext) {
                    return [2];
                  }
                }
                bi = buffer.indexOf(boundary);
              }
              return [3, 1];
            case 3:
              return [2];
          }
        });
      });
    }
    function parseHeaders2(headerText) {
      var headersInit = {};
      headerText.split("\n").forEach(function(line) {
        var i = line.indexOf(":");
        if (i > -1) {
          var name_1 = line.slice(0, i).trim().toLowerCase();
          var value = line.slice(i + 1).trim();
          headersInit[name_1] = value;
        }
      });
      return headersInit;
    }
    function parseJsonBody2(response, bodyText) {
      if (response.status >= 300) {
        var getResult = function() {
          try {
            return JSON.parse(bodyText);
          } catch (err) {
            return bodyText;
          }
        };
        utils.throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
      }
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        var parseError = err;
        parseError.name = "ServerParseError";
        parseError.response = response;
        parseError.statusCode = response.status;
        parseError.bodyText = bodyText;
        throw parseError;
      }
    }
    function handleError2(err, observer) {
      if (err.result && err.result.errors && err.result.data) {
        observer.next(err.result);
      }
      observer.error(err);
    }
    function parseAndCheckHttpResponse2(operations) {
      return function(response) {
        return response.text().then(function(bodyText) {
          return parseJsonBody2(response, bodyText);
        }).then(function(result2) {
          if (!Array.isArray(result2) && !hasOwnProperty11.call(result2, "data") && !hasOwnProperty11.call(result2, "errors")) {
            utils.throwServerError(response, result2, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
              return op.operationName;
            }) : operations.operationName, "'."));
          }
          return result2;
        });
      };
    }
    var serializeFetchParameter2 = function(p, label) {
      var serialized;
      try {
        serialized = JSON.stringify(p);
      } catch (e) {
        var parseError = globals.newInvariantError(39, label, e.message);
        parseError.parseError = e;
        throw parseError;
      }
      return serialized;
    };
    var defaultHttpOptions2 = {
      includeQuery: true,
      includeExtensions: false,
      preserveHeaderCase: false
    };
    var defaultHeaders2 = {
      accept: "*/*",
      "content-type": "application/json"
    };
    var defaultOptions2 = {
      method: "POST"
    };
    var fallbackHttpConfig2 = {
      http: defaultHttpOptions2,
      headers: defaultHeaders2,
      options: defaultOptions2
    };
    var defaultPrinter2 = function(ast, printer) {
      return printer(ast);
    };
    function selectHttpOptionsAndBody2(operation, fallbackConfig) {
      var configs = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
      }
      configs.unshift(fallbackConfig);
      return selectHttpOptionsAndBodyInternal2.apply(void 0, tslib.__spreadArray([
        operation,
        defaultPrinter2
      ], configs, false));
    }
    function selectHttpOptionsAndBodyInternal2(operation, printer) {
      var configs = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
      }
      var options = {};
      var http = {};
      configs.forEach(function(config) {
        options = tslib.__assign(tslib.__assign(tslib.__assign({}, options), config.options), { headers: tslib.__assign(tslib.__assign({}, options.headers), config.headers) });
        if (config.credentials) {
          options.credentials = config.credentials;
        }
        http = tslib.__assign(tslib.__assign({}, http), config.http);
      });
      if (options.headers) {
        options.headers = removeDuplicateHeaders2(options.headers, http.preserveHeaderCase);
      }
      var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
      var body = { operationName: operationName2, variables };
      if (http.includeExtensions)
        body.extensions = extensions;
      if (http.includeQuery)
        body.query = printer(query, utilities.print);
      return {
        options,
        body
      };
    }
    function removeDuplicateHeaders2(headers, preserveHeaderCase) {
      if (!preserveHeaderCase) {
        var normalizedHeaders_1 = /* @__PURE__ */ Object.create(null);
        Object.keys(Object(headers)).forEach(function(name) {
          normalizedHeaders_1[name.toLowerCase()] = headers[name];
        });
        return normalizedHeaders_1;
      }
      var headerData = /* @__PURE__ */ Object.create(null);
      Object.keys(Object(headers)).forEach(function(name) {
        headerData[name.toLowerCase()] = {
          originalName: name,
          value: headers[name]
        };
      });
      var normalizedHeaders = /* @__PURE__ */ Object.create(null);
      Object.keys(headerData).forEach(function(name) {
        normalizedHeaders[headerData[name].originalName] = headerData[name].value;
      });
      return normalizedHeaders;
    }
    var checkFetcher2 = function(fetcher) {
      if (!fetcher && typeof fetch === "undefined") {
        throw globals.newInvariantError(37);
      }
    };
    var createSignalIfSupported2 = function() {
      if (typeof AbortController === "undefined")
        return { controller: false, signal: false };
      var controller = new AbortController();
      var signal = controller.signal;
      return { controller, signal };
    };
    var selectURI2 = function(operation, fallbackURI) {
      var context = operation.getContext();
      var contextURI = context.uri;
      if (contextURI) {
        return contextURI;
      } else if (typeof fallbackURI === "function") {
        return fallbackURI(operation);
      } else {
        return fallbackURI || "/graphql";
      }
    };
    function rewriteURIForGET2(chosenURI, body) {
      var queryParams = [];
      var addQueryParam = function(key, value) {
        queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
      };
      if ("query" in body) {
        addQueryParam("query", body.query);
      }
      if (body.operationName) {
        addQueryParam("operationName", body.operationName);
      }
      if (body.variables) {
        var serializedVariables = void 0;
        try {
          serializedVariables = serializeFetchParameter2(body.variables, "Variables map");
        } catch (parseError) {
          return { parseError };
        }
        addQueryParam("variables", serializedVariables);
      }
      if (body.extensions) {
        var serializedExtensions = void 0;
        try {
          serializedExtensions = serializeFetchParameter2(body.extensions, "Extensions map");
        } catch (parseError) {
          return { parseError };
        }
        addQueryParam("extensions", serializedExtensions);
      }
      var fragment = "", preFragment = chosenURI;
      var fragmentStart = chosenURI.indexOf("#");
      if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
      }
      var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
      var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
      return { newURI };
    }
    var backupFetch2 = utilities.maybe(function() {
      return fetch;
    });
    var createHttpLink2 = function(linkOptions) {
      if (linkOptions === void 0) {
        linkOptions = {};
      }
      var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print3 = _b === void 0 ? defaultPrinter2 : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = tslib.__rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
      if (globalThis.__DEV__ !== false) {
        checkFetcher2(preferredFetch || backupFetch2);
      }
      var linkConfig = {
        http: { includeExtensions, preserveHeaderCase },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers
      };
      return new core.ApolloLink(function(operation) {
        var chosenURI = selectURI2(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
          var _a3 = context.clientAwareness, name_1 = _a3.name, version3 = _a3.version;
          if (name_1) {
            clientAwarenessHeaders["apollographql-client-name"] = name_1;
          }
          if (version3) {
            clientAwarenessHeaders["apollographql-client-version"] = version3;
          }
        }
        var contextHeaders = tslib.__assign(tslib.__assign({}, clientAwarenessHeaders), context.headers);
        var contextConfig = {
          http: context.http,
          options: context.fetchOptions,
          credentials: context.credentials,
          headers: contextHeaders
        };
        if (utilities.hasDirectives(["client"], operation.query)) {
          var transformedQuery = utilities.removeClientSetsFromDocument(operation.query);
          if (!transformedQuery) {
            return utils.fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
          }
          operation.query = transformedQuery;
        }
        var _b2 = selectHttpOptionsAndBodyInternal2(operation, print3, fallbackHttpConfig2, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
        if (body.variables && !includeUnusedVariables) {
          body.variables = utils.filterOperationVariables(body.variables, operation.query);
        }
        var controller;
        if (!options.signal && typeof AbortController !== "undefined") {
          controller = new AbortController();
          options.signal = controller.signal;
        }
        var definitionIsMutation = function(d) {
          return d.kind === "OperationDefinition" && d.operation === "mutation";
        };
        var definitionIsSubscription = function(d) {
          return d.kind === "OperationDefinition" && d.operation === "subscription";
        };
        var isSubscription = definitionIsSubscription(utilities.getMainDefinition(operation.query));
        var hasDefer = utilities.hasDirectives(["defer"], operation.query);
        if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
          options.method = "GET";
        }
        if (hasDefer || isSubscription) {
          options.headers = options.headers || {};
          var acceptHeader = "multipart/mixed;";
          if (isSubscription && hasDefer) {
            globalThis.__DEV__ !== false && globals.invariant.warn(38);
          }
          if (isSubscription) {
            acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
          } else if (hasDefer) {
            acceptHeader += "deferSpec=20220824,application/json";
          }
          options.headers.accept = acceptHeader;
        }
        if (options.method === "GET") {
          var _c2 = rewriteURIForGET2(chosenURI, body), newURI = _c2.newURI, parseError = _c2.parseError;
          if (parseError) {
            return utils.fromError(parseError);
          }
          chosenURI = newURI;
        } else {
          try {
            options.body = serializeFetchParameter2(body, "Payload");
          } catch (parseError2) {
            return utils.fromError(parseError2);
          }
        }
        return new utilities.Observable(function(observer) {
          var currentFetch = preferredFetch || utilities.maybe(function() {
            return fetch;
          }) || backupFetch2;
          var observerNext = observer.next.bind(observer);
          currentFetch(chosenURI, options).then(function(response) {
            var _a4;
            operation.setContext({ response });
            var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
            if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
              return readMultipartBody2(response, observerNext);
            } else {
              return parseAndCheckHttpResponse2(operation)(response).then(observerNext);
            }
          }).then(function() {
            controller = void 0;
            observer.complete();
          }).catch(function(err) {
            controller = void 0;
            handleError2(err, observer);
          });
          return function() {
            if (controller)
              controller.abort();
          };
        });
      });
    };
    var HttpLink2 = function(_super) {
      tslib.__extends(HttpLink3, _super);
      function HttpLink3(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this, createHttpLink2(options).request) || this;
        _this.options = options;
        return _this;
      }
      return HttpLink3;
    }(core.ApolloLink);
    exports.HttpLink = HttpLink2;
    exports.checkFetcher = checkFetcher2;
    exports.createHttpLink = createHttpLink2;
    exports.createSignalIfSupported = createSignalIfSupported2;
    exports.defaultPrinter = defaultPrinter2;
    exports.fallbackHttpConfig = fallbackHttpConfig2;
    exports.parseAndCheckHttpResponse = parseAndCheckHttpResponse2;
    exports.rewriteURIForGET = rewriteURIForGET2;
    exports.selectHttpOptionsAndBody = selectHttpOptionsAndBody2;
    exports.selectHttpOptionsAndBodyInternal = selectHttpOptionsAndBodyInternal2;
    exports.selectURI = selectURI2;
    exports.serializeFetchParameter = serializeFetchParameter2;
  }
});

// ../node_modules/@apollo/client/cache/cache.cjs
var require_cache = __commonJS({
  "../node_modules/@apollo/client/cache/cache.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var optimism = (init_lib5(), __toCommonJS(lib_exports3));
    var utilities = require_utilities();
    var caches2 = (init_lib2(), __toCommonJS(lib_exports2));
    var equal2 = (init_lib6(), __toCommonJS(lib_exports4));
    var trie = (init_lib(), __toCommonJS(lib_exports));
    var graphql2 = (init_graphql2(), __toCommonJS(graphql_exports));
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e["default"] : e;
    }
    var equal__default = _interopDefaultLegacy(equal2);
    var getInMemoryCacheMemoryInternals2 = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals2 : void 0;
    var getApolloCacheMemoryInternals2 = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals2 : void 0;
    function _getApolloCacheMemoryInternals2() {
      return {
        cache: {
          fragmentQueryDocuments: getWrapperInformation2(this["getFragmentDoc"])
        }
      };
    }
    function _getInMemoryCacheMemoryInternals2() {
      var fragments = this.config.fragments;
      return tslib.__assign(tslib.__assign({}, _getApolloCacheMemoryInternals2.apply(this)), { addTypenameDocumentTransform: transformInfo2(this["addTypenameTransform"]), inMemoryCache: {
        executeSelectionSet: getWrapperInformation2(this["storeReader"]["executeSelectionSet"]),
        executeSubSelectedArray: getWrapperInformation2(this["storeReader"]["executeSubSelectedArray"]),
        maybeBroadcastWatch: getWrapperInformation2(this["maybeBroadcastWatch"])
      }, fragmentRegistry: {
        findFragmentSpreads: getWrapperInformation2(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
        lookup: getWrapperInformation2(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
        transform: getWrapperInformation2(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
      } });
    }
    function isWrapper2(f) {
      return !!f && "dirtyKey" in f;
    }
    function getWrapperInformation2(f) {
      return isWrapper2(f) ? f.size : void 0;
    }
    function isDefined2(value) {
      return value != null;
    }
    function transformInfo2(transform) {
      return recurseTransformInfo2(transform).map(function(cache2) {
        return { cache: cache2 };
      });
    }
    function recurseTransformInfo2(transform) {
      return transform ? tslib.__spreadArray(tslib.__spreadArray([
        getWrapperInformation2(transform === null || transform === void 0 ? void 0 : transform["performWork"])
      ], recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined2) : [];
    }
    function equalByQuery2(query, _a2, _b, variables) {
      var aData = _a2.data, aRest = tslib.__rest(_a2, ["data"]);
      var bData = _b.data, bRest = tslib.__rest(_b, ["data"]);
      return equal__default(aRest, bRest) && equalBySelectionSet2(utilities.getMainDefinition(query).selectionSet, aData, bData, {
        fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
        variables
      });
    }
    function equalBySelectionSet2(selectionSet, aResult, bResult, context) {
      if (aResult === bResult) {
        return true;
      }
      var seenSelections = /* @__PURE__ */ new Set();
      return selectionSet.selections.every(function(selection) {
        if (seenSelections.has(selection))
          return true;
        seenSelections.add(selection);
        if (!utilities.shouldInclude(selection, context.variables))
          return true;
        if (selectionHasNonreactiveDirective2(selection))
          return true;
        if (utilities.isField(selection)) {
          var resultKey = utilities.resultKeyNameFromField(selection);
          var aResultChild = aResult && aResult[resultKey];
          var bResultChild = bResult && bResult[resultKey];
          var childSelectionSet = selection.selectionSet;
          if (!childSelectionSet) {
            return equal__default(aResultChild, bResultChild);
          }
          var aChildIsArray = Array.isArray(aResultChild);
          var bChildIsArray = Array.isArray(bResultChild);
          if (aChildIsArray !== bChildIsArray)
            return false;
          if (aChildIsArray && bChildIsArray) {
            var length_1 = aResultChild.length;
            if (bResultChild.length !== length_1) {
              return false;
            }
            for (var i = 0; i < length_1; ++i) {
              if (!equalBySelectionSet2(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
                return false;
              }
            }
            return true;
          }
          return equalBySelectionSet2(childSelectionSet, aResultChild, bResultChild, context);
        } else {
          var fragment = utilities.getFragmentFromSelection(selection, context.fragmentMap);
          if (fragment) {
            if (selectionHasNonreactiveDirective2(fragment))
              return true;
            return equalBySelectionSet2(
              fragment.selectionSet,
              aResult,
              bResult,
              context
            );
          }
        }
      });
    }
    function selectionHasNonreactiveDirective2(selection) {
      return !!selection.directives && selection.directives.some(directiveIsNonreactive2);
    }
    function directiveIsNonreactive2(dir) {
      return dir.name.value === "nonreactive";
    }
    var ApolloCache2 = function() {
      function ApolloCache3() {
        this.assumeImmutableResults = false;
        this.getFragmentDoc = optimism.wrap(utilities.getFragmentQueryDocument, {
          max: utilities.cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
          cache: caches2.WeakCache
        });
      }
      ApolloCache3.prototype.batch = function(options) {
        var _this = this;
        var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
        var updateResult;
        this.performTransaction(function() {
          return updateResult = options.update(_this);
        }, optimisticId);
        return updateResult;
      };
      ApolloCache3.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
        this.performTransaction(transaction, optimisticId);
      };
      ApolloCache3.prototype.transformDocument = function(document) {
        return document;
      };
      ApolloCache3.prototype.transformForLink = function(document) {
        return document;
      };
      ApolloCache3.prototype.identify = function(object) {
        return;
      };
      ApolloCache3.prototype.gc = function() {
        return [];
      };
      ApolloCache3.prototype.modify = function(options) {
        return false;
      };
      ApolloCache3.prototype.readQuery = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options.optimistic;
        }
        return this.read(tslib.__assign(tslib.__assign({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
      };
      ApolloCache3.prototype.watchFragment = function(options) {
        var _this = this;
        var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, otherOptions = tslib.__rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
        var query = this.getFragmentDoc(fragment, fragmentName);
        var diffOptions = tslib.__assign(tslib.__assign({}, otherOptions), { returnPartialData: true, id: typeof from2 === "string" ? from2 : this.identify(from2), query, optimistic });
        var latestDiff;
        return new utilities.Observable(function(observer) {
          return _this.watch(tslib.__assign(tslib.__assign({}, diffOptions), { immediate: true, callback: function(diff2) {
            if (latestDiff && equalByQuery2(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data: diff2.result })) {
              return;
            }
            var result2 = {
              data: diff2.result,
              complete: !!diff2.complete
            };
            if (diff2.missing) {
              result2.missing = utilities.mergeDeepArray(diff2.missing.map(function(error) {
                return error.missing;
              }));
            }
            latestDiff = diff2;
            observer.next(result2);
          } }));
        });
      };
      ApolloCache3.prototype.readFragment = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options.optimistic;
        }
        return this.read(tslib.__assign(tslib.__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
      };
      ApolloCache3.prototype.writeQuery = function(_a2) {
        var id = _a2.id, data = _a2.data, options = tslib.__rest(_a2, ["id", "data"]);
        return this.write(Object.assign(options, {
          dataId: id || "ROOT_QUERY",
          result: data
        }));
      };
      ApolloCache3.prototype.writeFragment = function(_a2) {
        var id = _a2.id, data = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = tslib.__rest(_a2, ["id", "data", "fragment", "fragmentName"]);
        return this.write(Object.assign(options, {
          query: this.getFragmentDoc(fragment, fragmentName),
          dataId: id,
          result: data
        }));
      };
      ApolloCache3.prototype.updateQuery = function(options, update) {
        return this.batch({
          update: function(cache2) {
            var value = cache2.readQuery(options);
            var data = update(value);
            if (data === void 0 || data === null)
              return value;
            cache2.writeQuery(tslib.__assign(tslib.__assign({}, options), { data }));
            return data;
          }
        });
      };
      ApolloCache3.prototype.updateFragment = function(options, update) {
        return this.batch({
          update: function(cache2) {
            var value = cache2.readFragment(options);
            var data = update(value);
            if (data === void 0 || data === null)
              return value;
            cache2.writeFragment(tslib.__assign(tslib.__assign({}, options), { data }));
            return data;
          }
        });
      };
      return ApolloCache3;
    }();
    if (globalThis.__DEV__ !== false) {
      ApolloCache2.prototype.getMemoryInternals = getApolloCacheMemoryInternals2;
    }
    exports.Cache = void 0;
    /* @__PURE__ */ (function(Cache2) {
    })(exports.Cache || (exports.Cache = {}));
    var MissingFieldError2 = function(_super) {
      tslib.__extends(MissingFieldError3, _super);
      function MissingFieldError3(message, path, query, variables) {
        var _a2;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.path = path;
        _this.query = query;
        _this.variables = variables;
        if (Array.isArray(_this.path)) {
          _this.missing = _this.message;
          for (var i = _this.path.length - 1; i >= 0; --i) {
            _this.missing = (_a2 = {}, _a2[_this.path[i]] = _this.missing, _a2);
          }
        } else {
          _this.missing = _this.path;
        }
        _this.__proto__ = MissingFieldError3.prototype;
        return _this;
      }
      return MissingFieldError3;
    }(Error);
    var hasOwn2 = Object.prototype.hasOwnProperty;
    function isNullish2(value) {
      return value === null || value === void 0;
    }
    function defaultDataIdFromObject2(_a2, context) {
      var __typename = _a2.__typename, id = _a2.id, _id = _a2._id;
      if (typeof __typename === "string") {
        if (context) {
          context.keyObject = !isNullish2(id) ? { id } : !isNullish2(_id) ? { _id } : void 0;
        }
        if (isNullish2(id) && !isNullish2(_id)) {
          id = _id;
        }
        if (!isNullish2(id)) {
          return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
        }
      }
    }
    var defaultConfig2 = {
      dataIdFromObject: defaultDataIdFromObject2,
      addTypename: true,
      resultCaching: true,
      canonizeResults: false
    };
    function normalizeConfig2(config) {
      return utilities.compact(defaultConfig2, config);
    }
    function shouldCanonizeResults2(config) {
      var value = config.canonizeResults;
      return value === void 0 ? defaultConfig2.canonizeResults : value;
    }
    function getTypenameFromStoreObject2(store, objectOrReference) {
      return utilities.isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
    }
    var TypeOrFieldNameRegExp2 = /^[_a-z][_0-9a-z]*/i;
    function fieldNameFromStoreName2(storeFieldName) {
      var match = storeFieldName.match(TypeOrFieldNameRegExp2);
      return match ? match[0] : storeFieldName;
    }
    function selectionSetMatchesResult2(selectionSet, result2, variables) {
      if (utilities.isNonNullObject(result2)) {
        return utilities.isArray(result2) ? result2.every(function(item) {
          return selectionSetMatchesResult2(selectionSet, item, variables);
        }) : selectionSet.selections.every(function(field) {
          if (utilities.isField(field) && utilities.shouldInclude(field, variables)) {
            var key = utilities.resultKeyNameFromField(field);
            return hasOwn2.call(result2, key) && (!field.selectionSet || selectionSetMatchesResult2(field.selectionSet, result2[key], variables));
          }
          return true;
        });
      }
      return false;
    }
    function storeValueIsStoreObject2(value) {
      return utilities.isNonNullObject(value) && !utilities.isReference(value) && !utilities.isArray(value);
    }
    function makeProcessedFieldsMerger2() {
      return new utilities.DeepMerger();
    }
    function extractFragmentContext2(document, fragments) {
      var fragmentMap = utilities.createFragmentMap(utilities.getFragmentDefinitions(document));
      return {
        fragmentMap,
        lookupFragment: function(name) {
          var def = fragmentMap[name];
          if (!def && fragments) {
            def = fragments.lookup(name);
          }
          return def || null;
        }
      };
    }
    var DELETE2 = /* @__PURE__ */ Object.create(null);
    var delModifier2 = function() {
      return DELETE2;
    };
    var INVALIDATE2 = /* @__PURE__ */ Object.create(null);
    exports.EntityStore = function() {
      function EntityStore2(policies, group) {
        var _this = this;
        this.policies = policies;
        this.group = group;
        this.data = /* @__PURE__ */ Object.create(null);
        this.rootIds = /* @__PURE__ */ Object.create(null);
        this.refs = /* @__PURE__ */ Object.create(null);
        this.getFieldValue = function(objectOrReference, storeFieldName) {
          return utilities.maybeDeepFreeze(utilities.isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
        };
        this.canRead = function(objOrRef) {
          return utilities.isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
        };
        this.toReference = function(objOrIdOrRef, mergeIntoStore) {
          if (typeof objOrIdOrRef === "string") {
            return utilities.makeReference(objOrIdOrRef);
          }
          if (utilities.isReference(objOrIdOrRef)) {
            return objOrIdOrRef;
          }
          var id = _this.policies.identify(objOrIdOrRef)[0];
          if (id) {
            var ref = utilities.makeReference(id);
            if (mergeIntoStore) {
              _this.merge(id, objOrIdOrRef);
            }
            return ref;
          }
        };
      }
      EntityStore2.prototype.toObject = function() {
        return tslib.__assign({}, this.data);
      };
      EntityStore2.prototype.has = function(dataId) {
        return this.lookup(dataId, true) !== void 0;
      };
      EntityStore2.prototype.get = function(dataId, fieldName) {
        this.group.depend(dataId, fieldName);
        if (hasOwn2.call(this.data, dataId)) {
          var storeObject = this.data[dataId];
          if (storeObject && hasOwn2.call(storeObject, fieldName)) {
            return storeObject[fieldName];
          }
        }
        if (fieldName === "__typename" && hasOwn2.call(this.policies.rootTypenamesById, dataId)) {
          return this.policies.rootTypenamesById[dataId];
        }
        if (this instanceof Layer2) {
          return this.parent.get(dataId, fieldName);
        }
      };
      EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
        if (dependOnExistence)
          this.group.depend(dataId, "__exists");
        if (hasOwn2.call(this.data, dataId)) {
          return this.data[dataId];
        }
        if (this instanceof Layer2) {
          return this.parent.lookup(dataId, dependOnExistence);
        }
        if (this.policies.rootTypenamesById[dataId]) {
          return /* @__PURE__ */ Object.create(null);
        }
      };
      EntityStore2.prototype.merge = function(older, newer) {
        var _this = this;
        var dataId;
        if (utilities.isReference(older))
          older = older.__ref;
        if (utilities.isReference(newer))
          newer = newer.__ref;
        var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
        var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
        if (!incoming)
          return;
        globals.invariant(typeof dataId === "string", 1);
        var merged = new utilities.DeepMerger(storeObjectReconciler2).merge(existing, incoming);
        this.data[dataId] = merged;
        if (merged !== existing) {
          delete this.refs[dataId];
          if (this.group.caching) {
            var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
            if (!existing)
              fieldsToDirty_1.__exists = 1;
            Object.keys(incoming).forEach(function(storeFieldName) {
              if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                fieldsToDirty_1[storeFieldName] = 1;
                var fieldName = fieldNameFromStoreName2(storeFieldName);
                if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                  fieldsToDirty_1[fieldName] = 1;
                }
                if (merged[storeFieldName] === void 0 && !(_this instanceof Layer2)) {
                  delete merged[storeFieldName];
                }
              }
            });
            if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
              delete fieldsToDirty_1.__typename;
            }
            Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
              return _this.group.dirty(dataId, fieldName);
            });
          }
        }
      };
      EntityStore2.prototype.modify = function(dataId, fields) {
        var _this = this;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var changedFields_1 = /* @__PURE__ */ Object.create(null);
          var needToMerge_1 = false;
          var allDeleted_1 = true;
          var sharedDetails_1 = {
            DELETE: DELETE2,
            INVALIDATE: INVALIDATE2,
            isReference: utilities.isReference,
            toReference: this.toReference,
            canRead: this.canRead,
            readField: function(fieldNameOrOptions, from2) {
              return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                fieldName: fieldNameOrOptions,
                from: from2 || utilities.makeReference(dataId)
              } : fieldNameOrOptions, { store: _this });
            }
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            var fieldName = fieldNameFromStoreName2(storeFieldName);
            var fieldValue = storeObject[storeFieldName];
            if (fieldValue === void 0)
              return;
            var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
            if (modify) {
              var newValue = modify === delModifier2 ? DELETE2 : modify(utilities.maybeDeepFreeze(fieldValue), tslib.__assign(tslib.__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
              if (newValue === INVALIDATE2) {
                _this.group.dirty(dataId, storeFieldName);
              } else {
                if (newValue === DELETE2)
                  newValue = void 0;
                if (newValue !== fieldValue) {
                  changedFields_1[storeFieldName] = newValue;
                  needToMerge_1 = true;
                  fieldValue = newValue;
                  if (globalThis.__DEV__ !== false) {
                    var checkReference = function(ref) {
                      if (_this.lookup(ref.__ref) === void 0) {
                        globalThis.__DEV__ !== false && globals.invariant.warn(2, ref);
                        return true;
                      }
                    };
                    if (utilities.isReference(newValue)) {
                      checkReference(newValue);
                    } else if (Array.isArray(newValue)) {
                      var seenReference = false;
                      var someNonReference = void 0;
                      for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {
                        var value = newValue_1[_i];
                        if (utilities.isReference(value)) {
                          seenReference = true;
                          if (checkReference(value))
                            break;
                        } else {
                          if (typeof value === "object" && !!value) {
                            var id = _this.policies.identify(value)[0];
                            if (id) {
                              someNonReference = value;
                            }
                          }
                        }
                        if (seenReference && someNonReference !== void 0) {
                          globalThis.__DEV__ !== false && globals.invariant.warn(3, someNonReference);
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (fieldValue !== void 0) {
              allDeleted_1 = false;
            }
          });
          if (needToMerge_1) {
            this.merge(dataId, changedFields_1);
            if (allDeleted_1) {
              if (this instanceof Layer2) {
                this.data[dataId] = void 0;
              } else {
                delete this.data[dataId];
              }
              this.group.dirty(dataId, "__exists");
            }
            return true;
          }
        }
        return false;
      };
      EntityStore2.prototype.delete = function(dataId, fieldName, args) {
        var _a2;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var typename = this.getFieldValue(storeObject, "__typename");
          var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
          return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier2, _a2) : delModifier2);
        }
        return false;
      };
      EntityStore2.prototype.evict = function(options, limit) {
        var evicted = false;
        if (options.id) {
          if (hasOwn2.call(this.data, options.id)) {
            evicted = this.delete(options.id, options.fieldName, options.args);
          }
          if (this instanceof Layer2 && this !== limit) {
            evicted = this.parent.evict(options, limit) || evicted;
          }
          if (options.fieldName || evicted) {
            this.group.dirty(options.id, options.fieldName || "__exists");
          }
        }
        return evicted;
      };
      EntityStore2.prototype.clear = function() {
        this.replace(null);
      };
      EntityStore2.prototype.extract = function() {
        var _this = this;
        var obj = this.toObject();
        var extraRootIds = [];
        this.getRootIdSet().forEach(function(id) {
          if (!hasOwn2.call(_this.policies.rootTypenamesById, id)) {
            extraRootIds.push(id);
          }
        });
        if (extraRootIds.length) {
          obj.__META = { extraRootIds: extraRootIds.sort() };
        }
        return obj;
      };
      EntityStore2.prototype.replace = function(newData) {
        var _this = this;
        Object.keys(this.data).forEach(function(dataId) {
          if (!(newData && hasOwn2.call(newData, dataId))) {
            _this.delete(dataId);
          }
        });
        if (newData) {
          var __META = newData.__META, rest_1 = tslib.__rest(newData, ["__META"]);
          Object.keys(rest_1).forEach(function(dataId) {
            _this.merge(dataId, rest_1[dataId]);
          });
          if (__META) {
            __META.extraRootIds.forEach(this.retain, this);
          }
        }
      };
      EntityStore2.prototype.retain = function(rootId) {
        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
      };
      EntityStore2.prototype.release = function(rootId) {
        if (this.rootIds[rootId] > 0) {
          var count = --this.rootIds[rootId];
          if (!count)
            delete this.rootIds[rootId];
          return count;
        }
        return 0;
      };
      EntityStore2.prototype.getRootIdSet = function(ids) {
        if (ids === void 0) {
          ids = /* @__PURE__ */ new Set();
        }
        Object.keys(this.rootIds).forEach(ids.add, ids);
        if (this instanceof Layer2) {
          this.parent.getRootIdSet(ids);
        } else {
          Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
        }
        return ids;
      };
      EntityStore2.prototype.gc = function() {
        var _this = this;
        var ids = this.getRootIdSet();
        var snapshot = this.toObject();
        ids.forEach(function(id) {
          if (hasOwn2.call(snapshot, id)) {
            Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
            delete snapshot[id];
          }
        });
        var idsToRemove = Object.keys(snapshot);
        if (idsToRemove.length) {
          var root_1 = this;
          while (root_1 instanceof Layer2)
            root_1 = root_1.parent;
          idsToRemove.forEach(function(id) {
            return root_1.delete(id);
          });
        }
        return idsToRemove;
      };
      EntityStore2.prototype.findChildRefIds = function(dataId) {
        if (!hasOwn2.call(this.refs, dataId)) {
          var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
          var root2 = this.data[dataId];
          if (!root2)
            return found_1;
          var workSet_1 = /* @__PURE__ */ new Set([root2]);
          workSet_1.forEach(function(obj) {
            if (utilities.isReference(obj)) {
              found_1[obj.__ref] = true;
            }
            if (utilities.isNonNullObject(obj)) {
              Object.keys(obj).forEach(function(key) {
                var child = obj[key];
                if (utilities.isNonNullObject(child)) {
                  workSet_1.add(child);
                }
              });
            }
          });
        }
        return this.refs[dataId];
      };
      EntityStore2.prototype.makeCacheKey = function() {
        return this.group.keyMaker.lookupArray(arguments);
      };
      return EntityStore2;
    }();
    var CacheGroup2 = function() {
      function CacheGroup3(caching, parent) {
        if (parent === void 0) {
          parent = null;
        }
        this.caching = caching;
        this.parent = parent;
        this.d = null;
        this.resetCaching();
      }
      CacheGroup3.prototype.resetCaching = function() {
        this.d = this.caching ? optimism.dep() : null;
        this.keyMaker = new trie.Trie(utilities.canUseWeakMap);
      };
      CacheGroup3.prototype.depend = function(dataId, storeFieldName) {
        if (this.d) {
          this.d(makeDepKey2(dataId, storeFieldName));
          var fieldName = fieldNameFromStoreName2(storeFieldName);
          if (fieldName !== storeFieldName) {
            this.d(makeDepKey2(dataId, fieldName));
          }
          if (this.parent) {
            this.parent.depend(dataId, storeFieldName);
          }
        }
      };
      CacheGroup3.prototype.dirty = function(dataId, storeFieldName) {
        if (this.d) {
          this.d.dirty(
            makeDepKey2(dataId, storeFieldName),
            storeFieldName === "__exists" ? "forget" : "setDirty"
          );
        }
      };
      return CacheGroup3;
    }();
    function makeDepKey2(dataId, storeFieldName) {
      return storeFieldName + "#" + dataId;
    }
    function maybeDependOnExistenceOfEntity2(store, entityId) {
      if (supportsResultCaching2(store)) {
        store.group.depend(entityId, "__exists");
      }
    }
    (function(EntityStore2) {
      var Root = function(_super) {
        tslib.__extends(Root2, _super);
        function Root2(_a2) {
          var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
          var _this = _super.call(this, policies, new CacheGroup2(resultCaching)) || this;
          _this.stump = new Stump2(_this);
          _this.storageTrie = new trie.Trie(utilities.canUseWeakMap);
          if (seed)
            _this.replace(seed);
          return _this;
        }
        Root2.prototype.addLayer = function(layerId, replay) {
          return this.stump.addLayer(layerId, replay);
        };
        Root2.prototype.removeLayer = function() {
          return this;
        };
        Root2.prototype.getStorage = function() {
          return this.storageTrie.lookupArray(arguments);
        };
        return Root2;
      }(EntityStore2);
      EntityStore2.Root = Root;
    })(exports.EntityStore || (exports.EntityStore = {}));
    var Layer2 = function(_super) {
      tslib.__extends(Layer3, _super);
      function Layer3(id, parent, replay, group) {
        var _this = _super.call(this, parent.policies, group) || this;
        _this.id = id;
        _this.parent = parent;
        _this.replay = replay;
        _this.group = group;
        replay(_this);
        return _this;
      }
      Layer3.prototype.addLayer = function(layerId, replay) {
        return new Layer3(layerId, this, replay, this.group);
      };
      Layer3.prototype.removeLayer = function(layerId) {
        var _this = this;
        var parent = this.parent.removeLayer(layerId);
        if (layerId === this.id) {
          if (this.group.caching) {
            Object.keys(this.data).forEach(function(dataId) {
              var ownStoreObject = _this.data[dataId];
              var parentStoreObject = parent["lookup"](dataId);
              if (!parentStoreObject) {
                _this.delete(dataId);
              } else if (!ownStoreObject) {
                _this.group.dirty(dataId, "__exists");
                Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                  _this.group.dirty(dataId, storeFieldName);
                });
              } else if (ownStoreObject !== parentStoreObject) {
                Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                  if (!equal2.equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                    _this.group.dirty(dataId, storeFieldName);
                  }
                });
              }
            });
          }
          return parent;
        }
        if (parent === this.parent)
          return this;
        return parent.addLayer(this.id, this.replay);
      };
      Layer3.prototype.toObject = function() {
        return tslib.__assign(tslib.__assign({}, this.parent.toObject()), this.data);
      };
      Layer3.prototype.findChildRefIds = function(dataId) {
        var fromParent = this.parent.findChildRefIds(dataId);
        return hasOwn2.call(this.data, dataId) ? tslib.__assign(tslib.__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
      };
      Layer3.prototype.getStorage = function() {
        var p = this.parent;
        while (p.parent)
          p = p.parent;
        return p.getStorage.apply(
          p,
          arguments
        );
      };
      return Layer3;
    }(exports.EntityStore);
    var Stump2 = function(_super) {
      tslib.__extends(Stump3, _super);
      function Stump3(root2) {
        return _super.call(this, "EntityStore.Stump", root2, function() {
        }, new CacheGroup2(root2.group.caching, root2.group)) || this;
      }
      Stump3.prototype.removeLayer = function() {
        return this;
      };
      Stump3.prototype.merge = function(older, newer) {
        return this.parent.merge(older, newer);
      };
      return Stump3;
    }(Layer2);
    function storeObjectReconciler2(existingObject, incomingObject, property) {
      var existingValue = existingObject[property];
      var incomingValue = incomingObject[property];
      return equal2.equal(existingValue, incomingValue) ? existingValue : incomingValue;
    }
    function supportsResultCaching2(store) {
      return !!(store instanceof exports.EntityStore && store.group.caching);
    }
    function shallowCopy2(value) {
      if (utilities.isNonNullObject(value)) {
        return utilities.isArray(value) ? value.slice(0) : tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
      }
      return value;
    }
    var ObjectCanon2 = function() {
      function ObjectCanon3() {
        this.known = new (utilities.canUseWeakSet ? WeakSet : Set)();
        this.pool = new trie.Trie(utilities.canUseWeakMap);
        this.passes = /* @__PURE__ */ new WeakMap();
        this.keysByJSON = /* @__PURE__ */ new Map();
        this.empty = this.admit({});
      }
      ObjectCanon3.prototype.isKnown = function(value) {
        return utilities.isNonNullObject(value) && this.known.has(value);
      };
      ObjectCanon3.prototype.pass = function(value) {
        if (utilities.isNonNullObject(value)) {
          var copy = shallowCopy2(value);
          this.passes.set(copy, value);
          return copy;
        }
        return value;
      };
      ObjectCanon3.prototype.admit = function(value) {
        var _this = this;
        if (utilities.isNonNullObject(value)) {
          var original = this.passes.get(value);
          if (original)
            return original;
          var proto = Object.getPrototypeOf(value);
          switch (proto) {
            case Array.prototype: {
              if (this.known.has(value))
                return value;
              var array = value.map(this.admit, this);
              var node = this.pool.lookupArray(array);
              if (!node.array) {
                this.known.add(node.array = array);
                if (globalThis.__DEV__ !== false) {
                  Object.freeze(array);
                }
              }
              return node.array;
            }
            case null:
            case Object.prototype: {
              if (this.known.has(value))
                return value;
              var proto_1 = Object.getPrototypeOf(value);
              var array_1 = [proto_1];
              var keys = this.sortedKeys(value);
              array_1.push(keys.json);
              var firstValueIndex_1 = array_1.length;
              keys.sorted.forEach(function(key) {
                array_1.push(_this.admit(value[key]));
              });
              var node = this.pool.lookupArray(array_1);
              if (!node.object) {
                var obj_1 = node.object = Object.create(proto_1);
                this.known.add(obj_1);
                keys.sorted.forEach(function(key, i) {
                  obj_1[key] = array_1[firstValueIndex_1 + i];
                });
                if (globalThis.__DEV__ !== false) {
                  Object.freeze(obj_1);
                }
              }
              return node.object;
            }
          }
        }
        return value;
      };
      ObjectCanon3.prototype.sortedKeys = function(obj) {
        var keys = Object.keys(obj);
        var node = this.pool.lookupArray(keys);
        if (!node.keys) {
          keys.sort();
          var json = JSON.stringify(keys);
          if (!(node.keys = this.keysByJSON.get(json))) {
            this.keysByJSON.set(json, node.keys = { sorted: keys, json });
          }
        }
        return node.keys;
      };
      return ObjectCanon3;
    }();
    function execSelectionSetKeyArgs2(options) {
      return [
        options.selectionSet,
        options.objectOrReference,
        options.context,
        options.context.canonizeResults
      ];
    }
    var StoreReader2 = function() {
      function StoreReader3(config) {
        var _this = this;
        this.knownResults = new (utilities.canUseWeakMap ? WeakMap : Map)();
        this.config = utilities.compact(config, {
          addTypename: config.addTypename !== false,
          canonizeResults: shouldCanonizeResults2(config)
        });
        this.canon = config.canon || new ObjectCanon2();
        this.executeSelectionSet = optimism.wrap(function(options) {
          var _a2;
          var canonizeResults = options.context.canonizeResults;
          var peekArgs = execSelectionSetKeyArgs2(options);
          peekArgs[3] = !canonizeResults;
          var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
          if (other) {
            if (canonizeResults) {
              return tslib.__assign(tslib.__assign({}, other), {
                result: _this.canon.admit(other.result)
              });
            }
            return other;
          }
          maybeDependOnExistenceOfEntity2(options.context.store, options.enclosingRef.__ref);
          return _this.execSelectionSetImpl(options);
        }, {
          max: this.config.resultCacheMaxSize || utilities.cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
          keyArgs: execSelectionSetKeyArgs2,
          makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
            if (supportsResultCaching2(context.store)) {
              return context.store.makeCacheKey(selectionSet, utilities.isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
            }
          }
        });
        this.executeSubSelectedArray = optimism.wrap(function(options) {
          maybeDependOnExistenceOfEntity2(options.context.store, options.enclosingRef.__ref);
          return _this.execSubSelectedArrayImpl(options);
        }, {
          max: this.config.resultCacheMaxSize || utilities.cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
          makeCacheKey: function(_a2) {
            var field = _a2.field, array = _a2.array, context = _a2.context;
            if (supportsResultCaching2(context.store)) {
              return context.store.makeCacheKey(field, array, context.varString);
            }
          }
        });
      }
      StoreReader3.prototype.resetCanon = function() {
        this.canon = new ObjectCanon2();
      };
      StoreReader3.prototype.diffQueryAgainstStore = function(_a2) {
        var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
        var policies = this.config.cache.policies;
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(utilities.getQueryDefinition(query))), variables);
        var rootRef = utilities.makeReference(rootId);
        var execResult = this.executeSelectionSet({
          selectionSet: utilities.getMainDefinition(query).selectionSet,
          objectOrReference: rootRef,
          enclosingRef: rootRef,
          context: tslib.__assign({ store, query, policies, variables, varString: utilities.canonicalStringify(variables), canonizeResults }, extractFragmentContext2(query, this.config.fragments))
        });
        var missing;
        if (execResult.missing) {
          missing = [
            new MissingFieldError2(firstMissing2(execResult.missing), execResult.missing, query, variables)
          ];
          if (!returnPartialData) {
            throw missing[0];
          }
        }
        return {
          result: execResult.result,
          complete: !missing,
          missing
        };
      };
      StoreReader3.prototype.isFresh = function(result2, parent, selectionSet, context) {
        if (supportsResultCaching2(context.store) && this.knownResults.get(result2) === selectionSet) {
          var latest = this.executeSelectionSet.peek(
            selectionSet,
            parent,
            context,
            this.canon.isKnown(result2)
          );
          if (latest && result2 === latest.result) {
            return true;
          }
        }
        return false;
      };
      StoreReader3.prototype.execSelectionSetImpl = function(_a2) {
        var _this = this;
        var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context = _a2.context;
        if (utilities.isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
          return {
            result: this.canon.empty,
            missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
          };
        }
        var variables = context.variables, policies = context.policies, store = context.store;
        var typename = store.getFieldValue(objectOrReference, "__typename");
        var objectsToMerge = [];
        var missing;
        var missingMerger = new utilities.DeepMerger();
        if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
          objectsToMerge.push({ __typename: typename });
        }
        function handleMissing(result3, resultName) {
          var _a3;
          if (result3.missing) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result3.missing, _a3));
          }
          return result3.result;
        }
        var workSet = new Set(selectionSet.selections);
        workSet.forEach(function(selection) {
          var _a3, _b;
          if (!utilities.shouldInclude(selection, variables))
            return;
          if (utilities.isField(selection)) {
            var fieldValue = policies.readField({
              fieldName: selection.name.value,
              field: selection,
              variables: context.variables,
              from: objectOrReference
            }, context);
            var resultName = utilities.resultKeyNameFromField(selection);
            if (fieldValue === void 0) {
              if (!utilities.addTypenameToDocument.added(selection)) {
                missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(utilities.isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
              }
            } else if (utilities.isArray(fieldValue)) {
              if (fieldValue.length > 0) {
                fieldValue = handleMissing(_this.executeSubSelectedArray({
                  field: selection,
                  array: fieldValue,
                  enclosingRef,
                  context
                }), resultName);
              }
            } else if (!selection.selectionSet) {
              if (context.canonizeResults) {
                fieldValue = _this.canon.pass(fieldValue);
              }
            } else if (fieldValue != null) {
              fieldValue = handleMissing(_this.executeSelectionSet({
                selectionSet: selection.selectionSet,
                objectOrReference: fieldValue,
                enclosingRef: utilities.isReference(fieldValue) ? fieldValue : enclosingRef,
                context
              }), resultName);
            }
            if (fieldValue !== void 0) {
              objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
            }
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, context.lookupFragment);
            if (!fragment && selection.kind === graphql2.Kind.FRAGMENT_SPREAD) {
              throw globals.newInvariantError(9, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename)) {
              fragment.selectionSet.selections.forEach(workSet.add, workSet);
            }
          }
        });
        var result2 = utilities.mergeDeepArray(objectsToMerge);
        var finalResult = { result: result2, missing };
        var frozen = context.canonizeResults ? this.canon.admit(finalResult) : utilities.maybeDeepFreeze(finalResult);
        if (frozen.result) {
          this.knownResults.set(frozen.result, selectionSet);
        }
        return frozen;
      };
      StoreReader3.prototype.execSubSelectedArrayImpl = function(_a2) {
        var _this = this;
        var field = _a2.field, array = _a2.array, enclosingRef = _a2.enclosingRef, context = _a2.context;
        var missing;
        var missingMerger = new utilities.DeepMerger();
        function handleMissing(childResult, i) {
          var _a3;
          if (childResult.missing) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[i] = childResult.missing, _a3));
          }
          return childResult.result;
        }
        if (field.selectionSet) {
          array = array.filter(context.store.canRead);
        }
        array = array.map(function(item, i) {
          if (item === null) {
            return null;
          }
          if (utilities.isArray(item)) {
            return handleMissing(_this.executeSubSelectedArray({
              field,
              array: item,
              enclosingRef,
              context
            }), i);
          }
          if (field.selectionSet) {
            return handleMissing(_this.executeSelectionSet({
              selectionSet: field.selectionSet,
              objectOrReference: item,
              enclosingRef: utilities.isReference(item) ? item : enclosingRef,
              context
            }), i);
          }
          if (globalThis.__DEV__ !== false) {
            assertSelectionSetForIdValue2(context.store, field, item);
          }
          return item;
        });
        return {
          result: context.canonizeResults ? this.canon.admit(array) : array,
          missing
        };
      };
      return StoreReader3;
    }();
    function firstMissing2(tree) {
      try {
        JSON.stringify(tree, function(_, value) {
          if (typeof value === "string")
            throw value;
          return value;
        });
      } catch (result2) {
        return result2;
      }
    }
    function assertSelectionSetForIdValue2(store, field, fieldValue) {
      if (!field.selectionSet) {
        var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
        workSet_1.forEach(function(value) {
          if (utilities.isNonNullObject(value)) {
            globals.invariant(
              !utilities.isReference(value),
              10,
              getTypenameFromStoreObject2(store, value),
              field.name.value
            );
            Object.values(value).forEach(workSet_1.add, workSet_1);
          }
        });
      }
    }
    var cacheSlot2 = new optimism.Slot();
    var cacheInfoMap2 = /* @__PURE__ */ new WeakMap();
    function getCacheInfo2(cache2) {
      var info = cacheInfoMap2.get(cache2);
      if (!info) {
        cacheInfoMap2.set(cache2, info = {
          vars: /* @__PURE__ */ new Set(),
          dep: optimism.dep()
        });
      }
      return info;
    }
    function forgetCache2(cache2) {
      getCacheInfo2(cache2).vars.forEach(function(rv) {
        return rv.forgetCache(cache2);
      });
    }
    function recallCache2(cache2) {
      getCacheInfo2(cache2).vars.forEach(function(rv) {
        return rv.attachCache(cache2);
      });
    }
    function makeVar2(value) {
      var caches3 = /* @__PURE__ */ new Set();
      var listeners = /* @__PURE__ */ new Set();
      var rv = function(newValue) {
        if (arguments.length > 0) {
          if (value !== newValue) {
            value = newValue;
            caches3.forEach(function(cache3) {
              getCacheInfo2(cache3).dep.dirty(rv);
              broadcast2(cache3);
            });
            var oldListeners = Array.from(listeners);
            listeners.clear();
            oldListeners.forEach(function(listener) {
              return listener(value);
            });
          }
        } else {
          var cache2 = cacheSlot2.getValue();
          if (cache2) {
            attach(cache2);
            getCacheInfo2(cache2).dep(rv);
          }
        }
        return value;
      };
      rv.onNextChange = function(listener) {
        listeners.add(listener);
        return function() {
          listeners.delete(listener);
        };
      };
      var attach = rv.attachCache = function(cache2) {
        caches3.add(cache2);
        getCacheInfo2(cache2).vars.add(rv);
        return rv;
      };
      rv.forgetCache = function(cache2) {
        return caches3.delete(cache2);
      };
      return rv;
    }
    function broadcast2(cache2) {
      if (cache2.broadcastWatches) {
        cache2.broadcastWatches();
      }
    }
    var specifierInfoCache2 = /* @__PURE__ */ Object.create(null);
    function lookupSpecifierInfo2(spec) {
      var cacheKey = JSON.stringify(spec);
      return specifierInfoCache2[cacheKey] || (specifierInfoCache2[cacheKey] = /* @__PURE__ */ Object.create(null));
    }
    function keyFieldsFnFromSpecifier2(specifier) {
      var info = lookupSpecifierInfo2(specifier);
      return info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {
        var extract = function(from2, key) {
          return context.readField(key, from2);
        };
        var keyObject = context.keyObject = collectSpecifierPaths2(specifier, function(schemaKeyPath) {
          var extracted = extractKeyPath2(
            context.storeObject,
            schemaKeyPath,
            extract
          );
          if (extracted === void 0 && object !== context.storeObject && hasOwn2.call(object, schemaKeyPath[0])) {
            extracted = extractKeyPath2(object, schemaKeyPath, extractKey2);
          }
          globals.invariant(extracted !== void 0, 4, schemaKeyPath.join("."), object);
          return extracted;
        });
        return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
      });
    }
    function keyArgsFnFromSpecifier2(specifier) {
      var info = lookupSpecifierInfo2(specifier);
      return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
        var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
        var collected = collectSpecifierPaths2(specifier, function(keyPath) {
          var firstKey = keyPath[0];
          var firstChar = firstKey.charAt(0);
          if (firstChar === "@") {
            if (field && utilities.isNonEmptyArray(field.directives)) {
              var directiveName_1 = firstKey.slice(1);
              var d = field.directives.find(function(d2) {
                return d2.name.value === directiveName_1;
              });
              var directiveArgs = d && utilities.argumentsObjectFromField(d, variables);
              return directiveArgs && extractKeyPath2(
                directiveArgs,
                keyPath.slice(1)
              );
            }
            return;
          }
          if (firstChar === "$") {
            var variableName = firstKey.slice(1);
            if (variables && hasOwn2.call(variables, variableName)) {
              var varKeyPath = keyPath.slice(0);
              varKeyPath[0] = variableName;
              return extractKeyPath2(variables, varKeyPath);
            }
            return;
          }
          if (args) {
            return extractKeyPath2(args, keyPath);
          }
        });
        var suffix = JSON.stringify(collected);
        if (args || suffix !== "{}") {
          fieldName += ":" + suffix;
        }
        return fieldName;
      });
    }
    function collectSpecifierPaths2(specifier, extractor) {
      var merger = new utilities.DeepMerger();
      return getSpecifierPaths2(specifier).reduce(function(collected, path) {
        var _a2;
        var toMerge = extractor(path);
        if (toMerge !== void 0) {
          for (var i = path.length - 1; i >= 0; --i) {
            toMerge = (_a2 = {}, _a2[path[i]] = toMerge, _a2);
          }
          collected = merger.merge(collected, toMerge);
        }
        return collected;
      }, /* @__PURE__ */ Object.create(null));
    }
    function getSpecifierPaths2(spec) {
      var info = lookupSpecifierInfo2(spec);
      if (!info.paths) {
        var paths_1 = info.paths = [];
        var currentPath_1 = [];
        spec.forEach(function(s, i) {
          if (utilities.isArray(s)) {
            getSpecifierPaths2(s).forEach(function(p) {
              return paths_1.push(currentPath_1.concat(p));
            });
            currentPath_1.length = 0;
          } else {
            currentPath_1.push(s);
            if (!utilities.isArray(spec[i + 1])) {
              paths_1.push(currentPath_1.slice(0));
              currentPath_1.length = 0;
            }
          }
        });
      }
      return info.paths;
    }
    function extractKey2(object, key) {
      return object[key];
    }
    function extractKeyPath2(object, path, extract) {
      extract = extract || extractKey2;
      return normalize3(path.reduce(function reducer(obj, key) {
        return utilities.isArray(obj) ? obj.map(function(child) {
          return reducer(child, key);
        }) : obj && extract(obj, key);
      }, object));
    }
    function normalize3(value) {
      if (utilities.isNonNullObject(value)) {
        if (utilities.isArray(value)) {
          return value.map(normalize3);
        }
        return collectSpecifierPaths2(Object.keys(value).sort(), function(path) {
          return extractKeyPath2(value, path);
        });
      }
      return value;
    }
    function argsFromFieldSpecifier2(spec) {
      return spec.args !== void 0 ? spec.args : spec.field ? utilities.argumentsObjectFromField(spec.field, spec.variables) : null;
    }
    var nullKeyFieldsFn2 = function() {
      return void 0;
    };
    var simpleKeyArgsFn2 = function(_args, context) {
      return context.fieldName;
    };
    var mergeTrueFn2 = function(existing, incoming, _a2) {
      var mergeObjects = _a2.mergeObjects;
      return mergeObjects(existing, incoming);
    };
    var mergeFalseFn2 = function(_, incoming) {
      return incoming;
    };
    var Policies2 = function() {
      function Policies3(config) {
        this.config = config;
        this.typePolicies = /* @__PURE__ */ Object.create(null);
        this.toBeAdded = /* @__PURE__ */ Object.create(null);
        this.supertypeMap = /* @__PURE__ */ new Map();
        this.fuzzySubtypes = /* @__PURE__ */ new Map();
        this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
        this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
        this.usingPossibleTypes = false;
        this.config = tslib.__assign({ dataIdFromObject: defaultDataIdFromObject2 }, config);
        this.cache = this.config.cache;
        this.setRootTypename("Query");
        this.setRootTypename("Mutation");
        this.setRootTypename("Subscription");
        if (config.possibleTypes) {
          this.addPossibleTypes(config.possibleTypes);
        }
        if (config.typePolicies) {
          this.addTypePolicies(config.typePolicies);
        }
      }
      Policies3.prototype.identify = function(object, partialContext) {
        var _a2;
        var policies = this;
        var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object.__typename;
        if (typename === this.rootTypenamesById.ROOT_QUERY) {
          return ["ROOT_QUERY"];
        }
        var storeObject = partialContext && partialContext.storeObject || object;
        var context = tslib.__assign(tslib.__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
          var options = normalizeReadFieldOptions2(arguments, storeObject);
          return policies.readField(options, {
            store: policies.cache["data"],
            variables: options.variables
          });
        } });
        var id;
        var policy = typename && this.getTypePolicy(typename);
        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
        while (keyFn) {
          var specifierOrId = keyFn(tslib.__assign(tslib.__assign({}, object), storeObject), context);
          if (utilities.isArray(specifierOrId)) {
            keyFn = keyFieldsFnFromSpecifier2(specifierOrId);
          } else {
            id = specifierOrId;
            break;
          }
        }
        id = id ? String(id) : void 0;
        return context.keyObject ? [id, context.keyObject] : [id];
      };
      Policies3.prototype.addTypePolicies = function(typePolicies) {
        var _this = this;
        Object.keys(typePolicies).forEach(function(typename) {
          var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = tslib.__rest(_a2, ["queryType", "mutationType", "subscriptionType"]);
          if (queryType)
            _this.setRootTypename("Query", typename);
          if (mutationType)
            _this.setRootTypename("Mutation", typename);
          if (subscriptionType)
            _this.setRootTypename("Subscription", typename);
          if (hasOwn2.call(_this.toBeAdded, typename)) {
            _this.toBeAdded[typename].push(incoming);
          } else {
            _this.toBeAdded[typename] = [incoming];
          }
        });
      };
      Policies3.prototype.updateTypePolicy = function(typename, incoming) {
        var _this = this;
        var existing = this.getTypePolicy(typename);
        var keyFields = incoming.keyFields, fields = incoming.fields;
        function setMerge(existing2, merge) {
          existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn2 : merge === false ? mergeFalseFn2 : existing2.merge;
        }
        setMerge(existing, incoming.merge);
        existing.keyFn = keyFields === false ? nullKeyFieldsFn2 : utilities.isArray(keyFields) ? keyFieldsFnFromSpecifier2(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
        if (fields) {
          Object.keys(fields).forEach(function(fieldName) {
            var existing2 = _this.getFieldPolicy(typename, fieldName, true);
            var incoming2 = fields[fieldName];
            if (typeof incoming2 === "function") {
              existing2.read = incoming2;
            } else {
              var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;
              existing2.keyFn = keyArgs === false ? simpleKeyArgsFn2 : utilities.isArray(keyArgs) ? keyArgsFnFromSpecifier2(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
              if (typeof read === "function") {
                existing2.read = read;
              }
              setMerge(existing2, merge);
            }
            if (existing2.read && existing2.merge) {
              existing2.keyFn = existing2.keyFn || simpleKeyArgsFn2;
            }
          });
        }
      };
      Policies3.prototype.setRootTypename = function(which, typename) {
        if (typename === void 0) {
          typename = which;
        }
        var rootId = "ROOT_" + which.toUpperCase();
        var old = this.rootTypenamesById[rootId];
        if (typename !== old) {
          globals.invariant(!old || old === which, 5, which);
          if (old)
            delete this.rootIdsByTypename[old];
          this.rootIdsByTypename[typename] = rootId;
          this.rootTypenamesById[rootId] = typename;
        }
      };
      Policies3.prototype.addPossibleTypes = function(possibleTypes) {
        var _this = this;
        this.usingPossibleTypes = true;
        Object.keys(possibleTypes).forEach(function(supertype) {
          _this.getSupertypeSet(supertype, true);
          possibleTypes[supertype].forEach(function(subtype) {
            _this.getSupertypeSet(subtype, true).add(supertype);
            var match = subtype.match(TypeOrFieldNameRegExp2);
            if (!match || match[0] !== subtype) {
              _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
            }
          });
        });
      };
      Policies3.prototype.getTypePolicy = function(typename) {
        var _this = this;
        if (!hasOwn2.call(this.typePolicies, typename)) {
          var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
          policy_1.fields = /* @__PURE__ */ Object.create(null);
          var supertypes_1 = this.supertypeMap.get(typename);
          if (!supertypes_1 && this.fuzzySubtypes.size) {
            supertypes_1 = this.getSupertypeSet(typename, true);
            this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
              if (regExp.test(typename)) {
                var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
                if (fuzzySupertypes) {
                  fuzzySupertypes.forEach(function(supertype) {
                    return supertypes_1.add(supertype);
                  });
                }
              }
            });
          }
          if (supertypes_1 && supertypes_1.size) {
            supertypes_1.forEach(function(supertype) {
              var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = tslib.__rest(_a2, ["fields"]);
              Object.assign(policy_1, rest);
              Object.assign(policy_1.fields, fields);
            });
          }
        }
        var inbox = this.toBeAdded[typename];
        if (inbox && inbox.length) {
          inbox.splice(0).forEach(function(policy) {
            _this.updateTypePolicy(typename, policy);
          });
        }
        return this.typePolicies[typename];
      };
      Policies3.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
        if (typename) {
          var fieldPolicies = this.getTypePolicy(typename).fields;
          return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
        }
      };
      Policies3.prototype.getSupertypeSet = function(subtype, createIfMissing) {
        var supertypeSet = this.supertypeMap.get(subtype);
        if (!supertypeSet && createIfMissing) {
          this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
        }
        return supertypeSet;
      };
      Policies3.prototype.fragmentMatches = function(fragment, typename, result2, variables) {
        var _this = this;
        if (!fragment.typeCondition)
          return true;
        if (!typename)
          return false;
        var supertype = fragment.typeCondition.name.value;
        if (typename === supertype)
          return true;
        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
          var typenameSupertypeSet = this.getSupertypeSet(typename, true);
          var workQueue_1 = [typenameSupertypeSet];
          var maybeEnqueue_1 = function(subtype) {
            var supertypeSet2 = _this.getSupertypeSet(subtype, false);
            if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
              workQueue_1.push(supertypeSet2);
            }
          };
          var needToCheckFuzzySubtypes = !!(result2 && this.fuzzySubtypes.size);
          var checkingFuzzySubtypes = false;
          for (var i = 0; i < workQueue_1.length; ++i) {
            var supertypeSet = workQueue_1[i];
            if (supertypeSet.has(supertype)) {
              if (!typenameSupertypeSet.has(supertype)) {
                if (checkingFuzzySubtypes) {
                  globalThis.__DEV__ !== false && globals.invariant.warn(6, typename, supertype);
                }
                typenameSupertypeSet.add(supertype);
              }
              return true;
            }
            supertypeSet.forEach(maybeEnqueue_1);
            if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult2(fragment.selectionSet, result2, variables)) {
              needToCheckFuzzySubtypes = false;
              checkingFuzzySubtypes = true;
              this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
                var match = typename.match(regExp);
                if (match && match[0] === typename) {
                  maybeEnqueue_1(fuzzyString);
                }
              });
            }
          }
        }
        return false;
      };
      Policies3.prototype.hasKeyArgs = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return !!(policy && policy.keyFn);
      };
      Policies3.prototype.getStoreFieldName = function(fieldSpec) {
        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
        var policy = this.getFieldPolicy(typename, fieldName, false);
        var storeFieldName;
        var keyFn = policy && policy.keyFn;
        if (keyFn && typename) {
          var context = {
            typename,
            fieldName,
            field: fieldSpec.field || null,
            variables: fieldSpec.variables
          };
          var args = argsFromFieldSpecifier2(fieldSpec);
          while (keyFn) {
            var specifierOrString = keyFn(args, context);
            if (utilities.isArray(specifierOrString)) {
              keyFn = keyArgsFnFromSpecifier2(specifierOrString);
            } else {
              storeFieldName = specifierOrString || fieldName;
              break;
            }
          }
        }
        if (storeFieldName === void 0) {
          storeFieldName = fieldSpec.field ? utilities.storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : utilities.getStoreKeyName(fieldName, argsFromFieldSpecifier2(fieldSpec));
        }
        if (storeFieldName === false) {
          return fieldName;
        }
        return fieldName === fieldNameFromStoreName2(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
      };
      Policies3.prototype.readField = function(options, context) {
        var objectOrReference = options.from;
        if (!objectOrReference)
          return;
        var nameOrField = options.field || options.fieldName;
        if (!nameOrField)
          return;
        if (options.typename === void 0) {
          var typename = context.store.getFieldValue(objectOrReference, "__typename");
          if (typename)
            options.typename = typename;
        }
        var storeFieldName = this.getStoreFieldName(options);
        var fieldName = fieldNameFromStoreName2(storeFieldName);
        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
        var policy = this.getFieldPolicy(options.typename, fieldName, false);
        var read = policy && policy.read;
        if (read) {
          var readOptions = makeFieldFunctionOptions2(this, objectOrReference, options, context, context.store.getStorage(utilities.isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
          return cacheSlot2.withValue(this.cache, read, [
            existing,
            readOptions
          ]);
        }
        return existing;
      };
      Policies3.prototype.getReadFunction = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return policy && policy.read;
      };
      Policies3.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
        var policy = this.getFieldPolicy(parentTypename, fieldName, false);
        var merge = policy && policy.merge;
        if (!merge && childTypename) {
          policy = this.getTypePolicy(childTypename);
          merge = policy && policy.merge;
        }
        return merge;
      };
      Policies3.prototype.runMergeFunction = function(existing, incoming, _a2, context, storage) {
        var field = _a2.field, typename = _a2.typename, merge = _a2.merge;
        if (merge === mergeTrueFn2) {
          return makeMergeObjectsFunction2(context.store)(existing, incoming);
        }
        if (merge === mergeFalseFn2) {
          return incoming;
        }
        if (context.overwrite) {
          existing = void 0;
        }
        return merge(existing, incoming, makeFieldFunctionOptions2(
          this,
          void 0,
          {
            typename,
            fieldName: field.name.value,
            field,
            variables: context.variables
          },
          context,
          storage || /* @__PURE__ */ Object.create(null)
        ));
      };
      return Policies3;
    }();
    function makeFieldFunctionOptions2(policies, objectOrReference, fieldSpec, context, storage) {
      var storeFieldName = policies.getStoreFieldName(fieldSpec);
      var fieldName = fieldNameFromStoreName2(storeFieldName);
      var variables = fieldSpec.variables || context.variables;
      var _a2 = context.store, toReference = _a2.toReference, canRead = _a2.canRead;
      return {
        args: argsFromFieldSpecifier2(fieldSpec),
        field: fieldSpec.field || null,
        fieldName,
        storeFieldName,
        variables,
        isReference: utilities.isReference,
        toReference,
        storage,
        cache: policies.cache,
        canRead,
        readField: function() {
          return policies.readField(normalizeReadFieldOptions2(arguments, objectOrReference, variables), context);
        },
        mergeObjects: makeMergeObjectsFunction2(context.store)
      };
    }
    function normalizeReadFieldOptions2(readFieldArgs, objectOrReference, variables) {
      var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
      var options;
      if (typeof fieldNameOrOptions === "string") {
        options = {
          fieldName: fieldNameOrOptions,
          from: argc > 1 ? from2 : objectOrReference
        };
      } else {
        options = tslib.__assign({}, fieldNameOrOptions);
        if (!hasOwn2.call(options, "from")) {
          options.from = objectOrReference;
        }
      }
      if (globalThis.__DEV__ !== false && options.from === void 0) {
        globalThis.__DEV__ !== false && globals.invariant.warn(7, utilities.stringifyForDisplay(Array.from(readFieldArgs)));
      }
      if (void 0 === options.variables) {
        options.variables = variables;
      }
      return options;
    }
    function makeMergeObjectsFunction2(store) {
      return function mergeObjects(existing, incoming) {
        if (utilities.isArray(existing) || utilities.isArray(incoming)) {
          throw globals.newInvariantError(8);
        }
        if (utilities.isNonNullObject(existing) && utilities.isNonNullObject(incoming)) {
          var eType = store.getFieldValue(existing, "__typename");
          var iType = store.getFieldValue(incoming, "__typename");
          var typesDiffer = eType && iType && eType !== iType;
          if (typesDiffer) {
            return incoming;
          }
          if (utilities.isReference(existing) && storeValueIsStoreObject2(incoming)) {
            store.merge(existing.__ref, incoming);
            return existing;
          }
          if (storeValueIsStoreObject2(existing) && utilities.isReference(incoming)) {
            store.merge(existing, incoming.__ref);
            return incoming;
          }
          if (storeValueIsStoreObject2(existing) && storeValueIsStoreObject2(incoming)) {
            return tslib.__assign(tslib.__assign({}, existing), incoming);
          }
        }
        return incoming;
      };
    }
    function getContextFlavor2(context, clientOnly, deferred) {
      var key = "".concat(clientOnly).concat(deferred);
      var flavored = context.flavors.get(key);
      if (!flavored) {
        context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : tslib.__assign(tslib.__assign({}, context), { clientOnly, deferred }));
      }
      return flavored;
    }
    var StoreWriter2 = function() {
      function StoreWriter3(cache2, reader, fragments) {
        this.cache = cache2;
        this.reader = reader;
        this.fragments = fragments;
      }
      StoreWriter3.prototype.writeToStore = function(store, _a2) {
        var _this = this;
        var query = _a2.query, result2 = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
        var operationDefinition = utilities.getOperationDefinition(query);
        var merger = makeProcessedFieldsMerger2();
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(operationDefinition)), variables);
        var context = tslib.__assign(tslib.__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
          return merger.merge(existing, incoming);
        }, variables, varString: utilities.canonicalStringify(variables) }, extractFragmentContext2(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
        var ref = this.processSelectionSet({
          result: result2 || /* @__PURE__ */ Object.create(null),
          dataId,
          selectionSet: operationDefinition.selectionSet,
          mergeTree: { map: /* @__PURE__ */ new Map() },
          context
        });
        if (!utilities.isReference(ref)) {
          throw globals.newInvariantError(11, result2);
        }
        context.incomingById.forEach(function(_a3, dataId2) {
          var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
          var entityRef = utilities.makeReference(dataId2);
          if (mergeTree && mergeTree.map.size) {
            var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
            if (utilities.isReference(applied)) {
              return;
            }
            storeObject = applied;
          }
          if (globalThis.__DEV__ !== false && !context.overwrite) {
            var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
            fieldNodeSet.forEach(function(field) {
              if (field.selectionSet) {
                fieldsWithSelectionSets_1[field.name.value] = true;
              }
            });
            var hasSelectionSet_1 = function(storeFieldName) {
              return fieldsWithSelectionSets_1[fieldNameFromStoreName2(storeFieldName)] === true;
            };
            var hasMergeFunction_1 = function(storeFieldName) {
              var childTree = mergeTree && mergeTree.map.get(storeFieldName);
              return Boolean(childTree && childTree.info && childTree.info.merge);
            };
            Object.keys(storeObject).forEach(function(storeFieldName) {
              if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
                warnAboutDataLoss2(entityRef, storeObject, storeFieldName, context.store);
              }
            });
          }
          store.merge(dataId2, storeObject);
        });
        store.retain(ref.__ref);
        return ref;
      };
      StoreWriter3.prototype.processSelectionSet = function(_a2) {
        var _this = this;
        var dataId = _a2.dataId, result2 = _a2.result, selectionSet = _a2.selectionSet, context = _a2.context, mergeTree = _a2.mergeTree;
        var policies = this.cache.policies;
        var incoming = /* @__PURE__ */ Object.create(null);
        var typename = dataId && policies.rootTypenamesById[dataId] || utilities.getTypenameFromResult(result2, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
        if ("string" === typeof typename) {
          incoming.__typename = typename;
        }
        var readField = function() {
          var options = normalizeReadFieldOptions2(arguments, incoming, context.variables);
          if (utilities.isReference(options.from)) {
            var info = context.incomingById.get(options.from.__ref);
            if (info) {
              var result_1 = policies.readField(tslib.__assign(tslib.__assign({}, options), { from: info.storeObject }), context);
              if (result_1 !== void 0) {
                return result_1;
              }
            }
          }
          return policies.readField(options, context);
        };
        var fieldNodeSet = /* @__PURE__ */ new Set();
        this.flattenFields(
          selectionSet,
          result2,
          context,
          typename
        ).forEach(function(context2, field) {
          var _a3;
          var resultFieldKey = utilities.resultKeyNameFromField(field);
          var value = result2[resultFieldKey];
          fieldNodeSet.add(field);
          if (value !== void 0) {
            var storeFieldName = policies.getStoreFieldName({
              typename,
              fieldName: field.name.value,
              field,
              variables: context2.variables
            });
            var childTree = getChildMergeTree2(mergeTree, storeFieldName);
            var incomingValue = _this.processFieldValue(
              value,
              field,
              field.selectionSet ? getContextFlavor2(context2, false, false) : context2,
              childTree
            );
            var childTypename = void 0;
            if (field.selectionSet && (utilities.isReference(incomingValue) || storeValueIsStoreObject2(incomingValue))) {
              childTypename = readField("__typename", incomingValue);
            }
            var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
            if (merge) {
              childTree.info = {
                field,
                typename,
                merge
              };
            } else {
              maybeRecycleChildMergeTree2(mergeTree, storeFieldName);
            }
            incoming = context2.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
          } else if (globalThis.__DEV__ !== false && !context2.clientOnly && !context2.deferred && !utilities.addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {
            globalThis.__DEV__ !== false && globals.invariant.error(12, utilities.resultKeyNameFromField(field), result2);
          }
        });
        try {
          var _b = policies.identify(result2, {
            typename,
            selectionSet,
            fragmentMap: context.fragmentMap,
            storeObject: incoming,
            readField
          }), id = _b[0], keyObject = _b[1];
          dataId = dataId || id;
          if (keyObject) {
            incoming = context.merge(incoming, keyObject);
          }
        } catch (e) {
          if (!dataId)
            throw e;
        }
        if ("string" === typeof dataId) {
          var dataRef = utilities.makeReference(dataId);
          var sets = context.written[dataId] || (context.written[dataId] = []);
          if (sets.indexOf(selectionSet) >= 0)
            return dataRef;
          sets.push(selectionSet);
          if (this.reader && this.reader.isFresh(result2, dataRef, selectionSet, context)) {
            return dataRef;
          }
          var previous_1 = context.incomingById.get(dataId);
          if (previous_1) {
            previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
            previous_1.mergeTree = mergeMergeTrees2(previous_1.mergeTree, mergeTree);
            fieldNodeSet.forEach(function(field) {
              return previous_1.fieldNodeSet.add(field);
            });
          } else {
            context.incomingById.set(dataId, {
              storeObject: incoming,
              mergeTree: mergeTreeIsEmpty2(mergeTree) ? void 0 : mergeTree,
              fieldNodeSet
            });
          }
          return dataRef;
        }
        return incoming;
      };
      StoreWriter3.prototype.processFieldValue = function(value, field, context, mergeTree) {
        var _this = this;
        if (!field.selectionSet || value === null) {
          return globalThis.__DEV__ !== false ? utilities.cloneDeep(value) : value;
        }
        if (utilities.isArray(value)) {
          return value.map(function(item, i) {
            var value2 = _this.processFieldValue(item, field, context, getChildMergeTree2(mergeTree, i));
            maybeRecycleChildMergeTree2(mergeTree, i);
            return value2;
          });
        }
        return this.processSelectionSet({
          result: value,
          selectionSet: field.selectionSet,
          context,
          mergeTree
        });
      };
      StoreWriter3.prototype.flattenFields = function(selectionSet, result2, context, typename) {
        if (typename === void 0) {
          typename = utilities.getTypenameFromResult(result2, selectionSet, context.fragmentMap);
        }
        var fieldMap = /* @__PURE__ */ new Map();
        var policies = this.cache.policies;
        var limitingTrie = new trie.Trie(false);
        (function flatten(selectionSet2, inheritedContext) {
          var visitedNode = limitingTrie.lookup(
            selectionSet2,
            inheritedContext.clientOnly,
            inheritedContext.deferred
          );
          if (visitedNode.visited)
            return;
          visitedNode.visited = true;
          selectionSet2.selections.forEach(function(selection) {
            if (!utilities.shouldInclude(selection, context.variables))
              return;
            var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
            if (!(clientOnly && deferred) && utilities.isNonEmptyArray(selection.directives)) {
              selection.directives.forEach(function(dir) {
                var name = dir.name.value;
                if (name === "client")
                  clientOnly = true;
                if (name === "defer") {
                  var args = utilities.argumentsObjectFromField(dir, context.variables);
                  if (!args || args.if !== false) {
                    deferred = true;
                  }
                }
              });
            }
            if (utilities.isField(selection)) {
              var existing = fieldMap.get(selection);
              if (existing) {
                clientOnly = clientOnly && existing.clientOnly;
                deferred = deferred && existing.deferred;
              }
              fieldMap.set(selection, getContextFlavor2(context, clientOnly, deferred));
            } else {
              var fragment = utilities.getFragmentFromSelection(selection, context.lookupFragment);
              if (!fragment && selection.kind === graphql2.Kind.FRAGMENT_SPREAD) {
                throw globals.newInvariantError(13, selection.name.value);
              }
              if (fragment && policies.fragmentMatches(fragment, typename, result2, context.variables)) {
                flatten(fragment.selectionSet, getContextFlavor2(context, clientOnly, deferred));
              }
            }
          });
        })(selectionSet, context);
        return fieldMap;
      };
      StoreWriter3.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
        var _a2;
        var _this = this;
        if (mergeTree.map.size && !utilities.isReference(incoming)) {
          var e_1 = !utilities.isArray(incoming) && (utilities.isReference(existing) || storeValueIsStoreObject2(existing)) ? existing : void 0;
          var i_1 = incoming;
          if (e_1 && !getStorageArgs) {
            getStorageArgs = [utilities.isReference(e_1) ? e_1.__ref : e_1];
          }
          var changedFields_1;
          var getValue_1 = function(from2, name) {
            return utilities.isArray(from2) ? typeof name === "number" ? from2[name] : void 0 : context.store.getFieldValue(from2, String(name));
          };
          mergeTree.map.forEach(function(childTree, storeFieldName) {
            var eVal = getValue_1(e_1, storeFieldName);
            var iVal = getValue_1(i_1, storeFieldName);
            if (void 0 === iVal)
              return;
            if (getStorageArgs) {
              getStorageArgs.push(storeFieldName);
            }
            var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
            if (aVal !== iVal) {
              changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
              changedFields_1.set(storeFieldName, aVal);
            }
            if (getStorageArgs) {
              globals.invariant(getStorageArgs.pop() === storeFieldName);
            }
          });
          if (changedFields_1) {
            incoming = utilities.isArray(i_1) ? i_1.slice(0) : tslib.__assign({}, i_1);
            changedFields_1.forEach(function(value, name) {
              incoming[name] = value;
            });
          }
        }
        if (mergeTree.info) {
          return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a2 = context.store).getStorage.apply(_a2, getStorageArgs));
        }
        return incoming;
      };
      return StoreWriter3;
    }();
    var emptyMergeTreePool2 = [];
    function getChildMergeTree2(_a2, name) {
      var map = _a2.map;
      if (!map.has(name)) {
        map.set(name, emptyMergeTreePool2.pop() || { map: /* @__PURE__ */ new Map() });
      }
      return map.get(name);
    }
    function mergeMergeTrees2(left, right) {
      if (left === right || !right || mergeTreeIsEmpty2(right))
        return left;
      if (!left || mergeTreeIsEmpty2(left))
        return right;
      var info = left.info && right.info ? tslib.__assign(tslib.__assign({}, left.info), right.info) : left.info || right.info;
      var needToMergeMaps = left.map.size && right.map.size;
      var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
      var merged = { info, map };
      if (needToMergeMaps) {
        var remainingRightKeys_1 = new Set(right.map.keys());
        left.map.forEach(function(leftTree, key) {
          merged.map.set(key, mergeMergeTrees2(leftTree, right.map.get(key)));
          remainingRightKeys_1.delete(key);
        });
        remainingRightKeys_1.forEach(function(key) {
          merged.map.set(key, mergeMergeTrees2(right.map.get(key), left.map.get(key)));
        });
      }
      return merged;
    }
    function mergeTreeIsEmpty2(tree) {
      return !tree || !(tree.info || tree.map.size);
    }
    function maybeRecycleChildMergeTree2(_a2, name) {
      var map = _a2.map;
      var childTree = map.get(name);
      if (childTree && mergeTreeIsEmpty2(childTree)) {
        emptyMergeTreePool2.push(childTree);
        map.delete(name);
      }
    }
    var warnings2 = /* @__PURE__ */ new Set();
    function warnAboutDataLoss2(existingRef, incomingObj, storeFieldName, store) {
      var getChild = function(objOrRef) {
        var child = store.getFieldValue(objOrRef, storeFieldName);
        return typeof child === "object" && child;
      };
      var existing = getChild(existingRef);
      if (!existing)
        return;
      var incoming = getChild(incomingObj);
      if (!incoming)
        return;
      if (utilities.isReference(existing))
        return;
      if (equal2.equal(existing, incoming))
        return;
      if (Object.keys(existing).every(function(key) {
        return store.getFieldValue(incoming, key) !== void 0;
      })) {
        return;
      }
      var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
      var fieldName = fieldNameFromStoreName2(storeFieldName);
      var typeDotName = "".concat(parentType, ".").concat(fieldName);
      if (warnings2.has(typeDotName))
        return;
      warnings2.add(typeDotName);
      var childTypenames = [];
      if (!utilities.isArray(existing) && !utilities.isArray(incoming)) {
        [existing, incoming].forEach(function(child) {
          var typename = store.getFieldValue(child, "__typename");
          if (typeof typename === "string" && !childTypenames.includes(typename)) {
            childTypenames.push(typename);
          }
        });
      }
      globalThis.__DEV__ !== false && globals.invariant.warn(14, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, tslib.__assign({}, existing), tslib.__assign({}, incoming));
    }
    var InMemoryCache2 = function(_super) {
      tslib.__extends(InMemoryCache3, _super);
      function InMemoryCache3(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this) || this;
        _this.watches = /* @__PURE__ */ new Set();
        _this.addTypenameTransform = new utilities.DocumentTransform(utilities.addTypenameToDocument);
        _this.assumeImmutableResults = true;
        _this.makeVar = makeVar2;
        _this.txCount = 0;
        _this.config = normalizeConfig2(config);
        _this.addTypename = !!_this.config.addTypename;
        _this.policies = new Policies2({
          cache: _this,
          dataIdFromObject: _this.config.dataIdFromObject,
          possibleTypes: _this.config.possibleTypes,
          typePolicies: _this.config.typePolicies
        });
        _this.init();
        return _this;
      }
      InMemoryCache3.prototype.init = function() {
        var rootStore = this.data = new exports.EntityStore.Root({
          policies: this.policies,
          resultCaching: this.config.resultCaching
        });
        this.optimisticData = rootStore.stump;
        this.resetResultCache();
      };
      InMemoryCache3.prototype.resetResultCache = function(resetResultIdentities) {
        var _this = this;
        var previousReader = this.storeReader;
        var fragments = this.config.fragments;
        this.storeWriter = new StoreWriter2(this, this.storeReader = new StoreReader2({
          cache: this,
          addTypename: this.addTypename,
          resultCacheMaxSize: this.config.resultCacheMaxSize,
          canonizeResults: shouldCanonizeResults2(this.config),
          canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
          fragments
        }), fragments);
        this.maybeBroadcastWatch = optimism.wrap(function(c, options) {
          return _this.broadcastWatch(c, options);
        }, {
          max: this.config.resultCacheMaxSize || utilities.cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
          makeCacheKey: function(c) {
            var store = c.optimistic ? _this.optimisticData : _this.data;
            if (supportsResultCaching2(store)) {
              var optimistic = c.optimistic, id = c.id, variables = c.variables;
              return store.makeCacheKey(
                c.query,
                c.callback,
                utilities.canonicalStringify({ optimistic, id, variables })
              );
            }
          }
        });
        (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
          return group.resetCaching();
        });
      };
      InMemoryCache3.prototype.restore = function(data) {
        this.init();
        if (data)
          this.data.replace(data);
        return this;
      };
      InMemoryCache3.prototype.extract = function(optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return (optimistic ? this.optimisticData : this.data).extract();
      };
      InMemoryCache3.prototype.read = function(options) {
        var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
        try {
          return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
        } catch (e) {
          if (e instanceof MissingFieldError2) {
            return null;
          }
          throw e;
        }
      };
      InMemoryCache3.prototype.write = function(options) {
        try {
          ++this.txCount;
          return this.storeWriter.writeToStore(this.data, options);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache3.prototype.modify = function(options) {
        if (hasOwn2.call(options, "id") && !options.id) {
          return false;
        }
        var store = options.optimistic ? this.optimisticData : this.data;
        try {
          ++this.txCount;
          return store.modify(options.id || "ROOT_QUERY", options.fields);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache3.prototype.diff = function(options) {
        return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
      };
      InMemoryCache3.prototype.watch = function(watch) {
        var _this = this;
        if (!this.watches.size) {
          recallCache2(this);
        }
        this.watches.add(watch);
        if (watch.immediate) {
          this.maybeBroadcastWatch(watch);
        }
        return function() {
          if (_this.watches.delete(watch) && !_this.watches.size) {
            forgetCache2(_this);
          }
          _this.maybeBroadcastWatch.forget(watch);
        };
      };
      InMemoryCache3.prototype.gc = function(options) {
        var _a2;
        utilities.canonicalStringify.reset();
        utilities.print.reset();
        this.addTypenameTransform.resetCache();
        (_a2 = this.config.fragments) === null || _a2 === void 0 ? void 0 : _a2.resetCaches();
        var ids = this.optimisticData.gc();
        if (options && !this.txCount) {
          if (options.resetResultCache) {
            this.resetResultCache(options.resetResultIdentities);
          } else if (options.resetResultIdentities) {
            this.storeReader.resetCanon();
          }
        }
        return ids;
      };
      InMemoryCache3.prototype.retain = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).retain(rootId);
      };
      InMemoryCache3.prototype.release = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).release(rootId);
      };
      InMemoryCache3.prototype.identify = function(object) {
        if (utilities.isReference(object))
          return object.__ref;
        try {
          return this.policies.identify(object)[0];
        } catch (e) {
          globalThis.__DEV__ !== false && globals.invariant.warn(e);
        }
      };
      InMemoryCache3.prototype.evict = function(options) {
        if (!options.id) {
          if (hasOwn2.call(options, "id")) {
            return false;
          }
          options = tslib.__assign(tslib.__assign({}, options), { id: "ROOT_QUERY" });
        }
        try {
          ++this.txCount;
          return this.optimisticData.evict(options, this.data);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache3.prototype.reset = function(options) {
        var _this = this;
        this.init();
        utilities.canonicalStringify.reset();
        if (options && options.discardWatches) {
          this.watches.forEach(function(watch) {
            return _this.maybeBroadcastWatch.forget(watch);
          });
          this.watches.clear();
          forgetCache2(this);
        } else {
          this.broadcastWatches();
        }
        return Promise.resolve();
      };
      InMemoryCache3.prototype.removeOptimistic = function(idToRemove) {
        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
        if (newOptimisticData !== this.optimisticData) {
          this.optimisticData = newOptimisticData;
          this.broadcastWatches();
        }
      };
      InMemoryCache3.prototype.batch = function(options) {
        var _this = this;
        var update = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
        var updateResult;
        var perform = function(layer) {
          var _a3 = _this, data = _a3.data, optimisticData = _a3.optimisticData;
          ++_this.txCount;
          if (layer) {
            _this.data = _this.optimisticData = layer;
          }
          try {
            return updateResult = update(_this);
          } finally {
            --_this.txCount;
            _this.data = data;
            _this.optimisticData = optimisticData;
          }
        };
        var alreadyDirty = /* @__PURE__ */ new Set();
        if (onWatchUpdated && !this.txCount) {
          this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function(watch) {
            alreadyDirty.add(watch);
            return false;
          } }));
        }
        if (typeof optimistic === "string") {
          this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
        } else if (optimistic === false) {
          perform(this.data);
        } else {
          perform();
        }
        if (typeof removeOptimistic === "string") {
          this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
        }
        if (onWatchUpdated && alreadyDirty.size) {
          this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function(watch, diff2) {
            var result2 = onWatchUpdated.call(this, watch, diff2);
            if (result2 !== false) {
              alreadyDirty.delete(watch);
            }
            return result2;
          } }));
          if (alreadyDirty.size) {
            alreadyDirty.forEach(function(watch) {
              return _this.maybeBroadcastWatch.dirty(watch);
            });
          }
        } else {
          this.broadcastWatches(options);
        }
        return updateResult;
      };
      InMemoryCache3.prototype.performTransaction = function(update, optimisticId) {
        return this.batch({
          update,
          optimistic: optimisticId || optimisticId !== null
        });
      };
      InMemoryCache3.prototype.transformDocument = function(document) {
        return this.addTypenameToDocument(this.addFragmentsToDocument(document));
      };
      InMemoryCache3.prototype.broadcastWatches = function(options) {
        var _this = this;
        if (!this.txCount) {
          this.watches.forEach(function(c) {
            return _this.maybeBroadcastWatch(c, options);
          });
        }
      };
      InMemoryCache3.prototype.addFragmentsToDocument = function(document) {
        var fragments = this.config.fragments;
        return fragments ? fragments.transform(document) : document;
      };
      InMemoryCache3.prototype.addTypenameToDocument = function(document) {
        if (this.addTypename) {
          return this.addTypenameTransform.transformDocument(document);
        }
        return document;
      };
      InMemoryCache3.prototype.broadcastWatch = function(c, options) {
        var lastDiff = c.lastDiff;
        var diff2 = this.diff(c);
        if (options) {
          if (c.optimistic && typeof options.optimistic === "string") {
            diff2.fromOptimisticTransaction = true;
          }
          if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff2, lastDiff) === false) {
            return;
          }
        }
        if (!lastDiff || !equal2.equal(lastDiff.result, diff2.result)) {
          c.callback(c.lastDiff = diff2, lastDiff);
        }
      };
      return InMemoryCache3;
    }(ApolloCache2);
    if (globalThis.__DEV__ !== false) {
      InMemoryCache2.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals2;
    }
    function createFragmentRegistry2() {
      var fragments = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fragments[_i] = arguments[_i];
      }
      return new (FragmentRegistry2.bind.apply(FragmentRegistry2, tslib.__spreadArray([void 0], fragments, false)))();
    }
    var FragmentRegistry2 = function() {
      function FragmentRegistry3() {
        var fragments = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fragments[_i] = arguments[_i];
        }
        this.registry = /* @__PURE__ */ Object.create(null);
        this.resetCaches();
        if (fragments.length) {
          this.register.apply(this, fragments);
        }
      }
      FragmentRegistry3.prototype.register = function() {
        var _this = this;
        var fragments = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fragments[_i] = arguments[_i];
        }
        var definitions = /* @__PURE__ */ new Map();
        fragments.forEach(function(doc) {
          utilities.getFragmentDefinitions(doc).forEach(function(node) {
            definitions.set(node.name.value, node);
          });
        });
        definitions.forEach(function(node, name) {
          if (node !== _this.registry[name]) {
            _this.registry[name] = node;
            _this.invalidate(name);
          }
        });
        return this;
      };
      FragmentRegistry3.prototype.invalidate = function(name) {
      };
      FragmentRegistry3.prototype.resetCaches = function() {
        var proto = FragmentRegistry3.prototype;
        this.invalidate = (this.lookup = optimism.wrap(proto.lookup.bind(this), {
          makeCacheKey: function(arg) {
            return arg;
          },
          max: utilities.cacheSizes["fragmentRegistry.lookup"] || 1e3
        })).dirty;
        this.transform = optimism.wrap(proto.transform.bind(this), {
          cache: caches2.WeakCache,
          max: utilities.cacheSizes["fragmentRegistry.transform"] || 2e3
        });
        this.findFragmentSpreads = optimism.wrap(proto.findFragmentSpreads.bind(this), {
          cache: caches2.WeakCache,
          max: utilities.cacheSizes["fragmentRegistry.findFragmentSpreads"] || 4e3
        });
      };
      FragmentRegistry3.prototype.lookup = function(fragmentName) {
        return this.registry[fragmentName] || null;
      };
      FragmentRegistry3.prototype.transform = function(document) {
        var _this = this;
        var defined = /* @__PURE__ */ new Map();
        utilities.getFragmentDefinitions(document).forEach(function(def) {
          defined.set(def.name.value, def);
        });
        var unbound = /* @__PURE__ */ new Set();
        var enqueue2 = function(spreadName) {
          if (!defined.has(spreadName)) {
            unbound.add(spreadName);
          }
        };
        var enqueueChildSpreads = function(node) {
          return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue2);
        };
        enqueueChildSpreads(document);
        var missing = [];
        var map = /* @__PURE__ */ Object.create(null);
        unbound.forEach(function(fragmentName) {
          var knownFragmentDef = defined.get(fragmentName);
          if (knownFragmentDef) {
            enqueueChildSpreads(map[fragmentName] = knownFragmentDef);
          } else {
            missing.push(fragmentName);
            var def = _this.lookup(fragmentName);
            if (def) {
              enqueueChildSpreads(map[fragmentName] = def);
            }
          }
        });
        if (missing.length) {
          var defsToAppend_1 = [];
          missing.forEach(function(name) {
            var def = map[name];
            if (def) {
              defsToAppend_1.push(def);
            }
          });
          if (defsToAppend_1.length) {
            document = tslib.__assign(tslib.__assign({}, document), { definitions: document.definitions.concat(defsToAppend_1) });
          }
        }
        return document;
      };
      FragmentRegistry3.prototype.findFragmentSpreads = function(root2) {
        var spreads = /* @__PURE__ */ Object.create(null);
        graphql2.visit(root2, {
          FragmentSpread: function(node) {
            spreads[node.name.value] = node;
          }
        });
        return spreads;
      };
      return FragmentRegistry3;
    }();
    exports.canonicalStringify = utilities.canonicalStringify;
    exports.isReference = utilities.isReference;
    exports.makeReference = utilities.makeReference;
    exports.ApolloCache = ApolloCache2;
    exports.InMemoryCache = InMemoryCache2;
    exports.MissingFieldError = MissingFieldError2;
    exports.Policies = Policies2;
    exports.cacheSlot = cacheSlot2;
    exports.createFragmentRegistry = createFragmentRegistry2;
    exports.defaultDataIdFromObject = defaultDataIdFromObject2;
    exports.fieldNameFromStoreName = fieldNameFromStoreName2;
    exports.makeVar = makeVar2;
  }
});

// ../node_modules/@apollo/client/core/core.cjs
var require_core2 = __commonJS({
  "../node_modules/@apollo/client/core/core.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var globals = require_globals();
    var core = require_core();
    var http = require_http();
    var equal2 = (init_lib6(), __toCommonJS(lib_exports4));
    var utilities = require_utilities();
    var cache2 = require_cache();
    var errors = require_errors();
    var trie = (init_lib(), __toCommonJS(lib_exports));
    var graphql2 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils = require_utils();
    var tsInvariant = (init_invariant(), __toCommonJS(invariant_exports));
    var graphqlTag = (init_lib7(), __toCommonJS(lib_exports5));
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e["default"] : e;
    }
    var equal__default = _interopDefaultLegacy(equal2);
    var version3 = "3.11.1";
    function isNonNullObject2(obj) {
      return obj !== null && typeof obj === "object";
    }
    function isNonEmptyArray2(value) {
      return Array.isArray(value) && value.length > 0;
    }
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var defaultReconciler2 = function(target, source, property) {
      return this.merge(target[property], source[property]);
    };
    var DeepMerger2 = function() {
      function DeepMerger3(reconciler) {
        if (reconciler === void 0) {
          reconciler = defaultReconciler2;
        }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject2;
        this.pastCopies = /* @__PURE__ */ new Set();
      }
      DeepMerger3.prototype.merge = function(target, source) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject2(source) && isNonNullObject2(target)) {
          Object.keys(source).forEach(function(sourceKey) {
            if (hasOwnProperty$2.call(target, sourceKey)) {
              var targetValue = target[sourceKey];
              if (source[sourceKey] !== targetValue) {
                var result2 = _this.reconciler.apply(_this, tslib.__spreadArray([
                  target,
                  source,
                  sourceKey
                ], context, false));
                if (result2 !== targetValue) {
                  target = _this.shallowCopyForMerge(target);
                  target[sourceKey] = result2;
                }
              }
            } else {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = source[sourceKey];
            }
          });
          return target;
        }
        return source;
      };
      DeepMerger3.prototype.shallowCopyForMerge = function(value) {
        if (isNonNullObject2(value)) {
          if (!this.pastCopies.has(value)) {
            if (Array.isArray(value)) {
              value = value.slice(0);
            } else {
              value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
            }
            this.pastCopies.add(value);
          }
        }
        return value;
      };
      return DeepMerger3;
    }();
    function isExecutionPatchIncrementalResult2(value) {
      return "incremental" in value;
    }
    function mergeIncrementalData2(prevResult, result2) {
      var mergedData = prevResult;
      var merger = new DeepMerger2();
      if (isExecutionPatchIncrementalResult2(result2) && isNonEmptyArray2(result2.incremental)) {
        result2.incremental.forEach(function(_a2) {
          var data = _a2.data, path = _a2.path;
          for (var i = path.length - 1; i >= 0; --i) {
            var key = path[i];
            var isNumericKey = !isNaN(+key);
            var parent_1 = isNumericKey ? [] : {};
            parent_1[key] = data;
            data = parent_1;
          }
          mergedData = merger.merge(mergedData, data);
        });
      }
      return mergedData;
    }
    exports.NetworkStatus = void 0;
    (function(NetworkStatus2) {
      NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
      NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
      NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
      NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
      NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
      NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
      NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
    })(exports.NetworkStatus || (exports.NetworkStatus = {}));
    function isNetworkRequestInFlight2(networkStatus) {
      return networkStatus ? networkStatus < 7 : false;
    }
    function isNetworkRequestSettled2(networkStatus) {
      return networkStatus === 7 || networkStatus === 8;
    }
    function equalByQuery2(query, _a2, _b, variables) {
      var aData = _a2.data, aRest = tslib.__rest(_a2, ["data"]);
      var bData = _b.data, bRest = tslib.__rest(_b, ["data"]);
      return equal__default(aRest, bRest) && equalBySelectionSet2(utilities.getMainDefinition(query).selectionSet, aData, bData, {
        fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
        variables
      });
    }
    function equalBySelectionSet2(selectionSet, aResult, bResult, context) {
      if (aResult === bResult) {
        return true;
      }
      var seenSelections = /* @__PURE__ */ new Set();
      return selectionSet.selections.every(function(selection) {
        if (seenSelections.has(selection))
          return true;
        seenSelections.add(selection);
        if (!utilities.shouldInclude(selection, context.variables))
          return true;
        if (selectionHasNonreactiveDirective2(selection))
          return true;
        if (utilities.isField(selection)) {
          var resultKey = utilities.resultKeyNameFromField(selection);
          var aResultChild = aResult && aResult[resultKey];
          var bResultChild = bResult && bResult[resultKey];
          var childSelectionSet = selection.selectionSet;
          if (!childSelectionSet) {
            return equal__default(aResultChild, bResultChild);
          }
          var aChildIsArray = Array.isArray(aResultChild);
          var bChildIsArray = Array.isArray(bResultChild);
          if (aChildIsArray !== bChildIsArray)
            return false;
          if (aChildIsArray && bChildIsArray) {
            var length_1 = aResultChild.length;
            if (bResultChild.length !== length_1) {
              return false;
            }
            for (var i = 0; i < length_1; ++i) {
              if (!equalBySelectionSet2(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
                return false;
              }
            }
            return true;
          }
          return equalBySelectionSet2(childSelectionSet, aResultChild, bResultChild, context);
        } else {
          var fragment = utilities.getFragmentFromSelection(selection, context.fragmentMap);
          if (fragment) {
            if (selectionHasNonreactiveDirective2(fragment))
              return true;
            return equalBySelectionSet2(
              fragment.selectionSet,
              aResult,
              bResult,
              context
            );
          }
        }
      });
    }
    function selectionHasNonreactiveDirective2(selection) {
      return !!selection.directives && selection.directives.some(directiveIsNonreactive2);
    }
    function directiveIsNonreactive2(dir) {
      return dir.name.value === "nonreactive";
    }
    var assign2 = Object.assign;
    var hasOwnProperty$1 = Object.hasOwnProperty;
    var ObservableQuery2 = function(_super) {
      tslib.__extends(ObservableQuery3, _super);
      function ObservableQuery3(_a2) {
        var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
        var _this = _super.call(this, function(observer) {
          try {
            var subObserver = observer._subscription._observer;
            if (subObserver && !subObserver.error) {
              subObserver.error = defaultSubscriptionObserverErrorCallback2;
            }
          } catch (_a3) {
          }
          var first = !_this.observers.size;
          _this.observers.add(observer);
          var last = _this.last;
          if (last && last.error) {
            observer.error && observer.error(last.error);
          } else if (last && last.result) {
            observer.next && observer.next(last.result);
          }
          if (first) {
            _this.reobserve().catch(function() {
            });
          }
          return function() {
            if (_this.observers.delete(observer) && !_this.observers.size) {
              _this.tearDownQuery();
            }
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.subscriptions = /* @__PURE__ */ new Set();
        _this.queryInfo = queryInfo;
        _this.queryManager = queryManager;
        _this.waitForOwnResult = skipCacheDataFor2(options.fetchPolicy);
        _this.isTornDown = false;
        _this.subscribeToMore = _this.subscribeToMore.bind(_this);
        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
        _this.options = tslib.__assign(tslib.__assign({}, options), {
          initialFetchPolicy,
          fetchPolicy
        });
        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
        var opDef = utilities.getOperationDefinition(_this.query);
        _this.queryName = opDef && opDef.name && opDef.name.value;
        return _this;
      }
      Object.defineProperty(ObservableQuery3.prototype, "query", {
        get: function() {
          return this.lastQuery || this.options.query;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObservableQuery3.prototype, "variables", {
        get: function() {
          return this.options.variables;
        },
        enumerable: false,
        configurable: true
      });
      ObservableQuery3.prototype.result = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var observer = {
            next: function(result2) {
              resolve(result2);
              _this.observers.delete(observer);
              if (!_this.observers.size) {
                _this.queryManager.removeQuery(_this.queryId);
              }
              setTimeout(function() {
                subscription.unsubscribe();
              }, 0);
            },
            error: reject
          };
          var subscription = _this.subscribe(observer);
        });
      };
      ObservableQuery3.prototype.resetDiff = function() {
        this.queryInfo.resetDiff();
      };
      ObservableQuery3.prototype.getCurrentResult = function(saveAsLastResult) {
        if (saveAsLastResult === void 0) {
          saveAsLastResult = true;
        }
        var lastResult = this.getLastResult(true);
        var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || exports.NetworkStatus.ready;
        var result2 = tslib.__assign(tslib.__assign({}, lastResult), { loading: isNetworkRequestInFlight2(networkStatus), networkStatus });
        var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
        if (skipCacheDataFor2(fetchPolicy) || this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) ;
        else if (this.waitForOwnResult) {
          this.queryInfo["updateWatch"]();
        } else {
          var diff2 = this.queryInfo.getDiff();
          if (diff2.complete || this.options.returnPartialData) {
            result2.data = diff2.result;
          }
          if (equal2.equal(result2.data, {})) {
            result2.data = void 0;
          }
          if (diff2.complete) {
            delete result2.partial;
            if (diff2.complete && result2.networkStatus === exports.NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
              result2.networkStatus = exports.NetworkStatus.ready;
              result2.loading = false;
            }
          } else {
            result2.partial = true;
          }
          if (globalThis.__DEV__ !== false && !diff2.complete && !this.options.partialRefetch && !result2.loading && !result2.data && !result2.error) {
            logMissingFieldErrors2(diff2.missing);
          }
        }
        if (saveAsLastResult) {
          this.updateLastResult(result2);
        }
        return result2;
      };
      ObservableQuery3.prototype.isDifferentFromLastResult = function(newResult, variables) {
        if (!this.last) {
          return true;
        }
        var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !equalByQuery2(this.query, this.last.result, newResult, this.variables) : !equal2.equal(this.last.result, newResult);
        return resultIsDifferent || variables && !equal2.equal(this.last.variables, variables);
      };
      ObservableQuery3.prototype.getLast = function(key, variablesMustMatch) {
        var last = this.last;
        if (last && last[key] && (!variablesMustMatch || equal2.equal(last.variables, this.variables))) {
          return last[key];
        }
      };
      ObservableQuery3.prototype.getLastResult = function(variablesMustMatch) {
        return this.getLast("result", variablesMustMatch);
      };
      ObservableQuery3.prototype.getLastError = function(variablesMustMatch) {
        return this.getLast("error", variablesMustMatch);
      };
      ObservableQuery3.prototype.resetLastResults = function() {
        delete this.last;
        this.isTornDown = false;
      };
      ObservableQuery3.prototype.resetQueryStoreErrors = function() {
        this.queryManager.resetErrors(this.queryId);
      };
      ObservableQuery3.prototype.refetch = function(variables) {
        var _a2;
        var reobserveOptions = {
          pollInterval: 0
        };
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === "cache-and-network") {
          reobserveOptions.fetchPolicy = fetchPolicy;
        } else if (fetchPolicy === "no-cache") {
          reobserveOptions.fetchPolicy = "no-cache";
        } else {
          reobserveOptions.fetchPolicy = "network-only";
        }
        if (globalThis.__DEV__ !== false && variables && hasOwnProperty$1.call(variables, "variables")) {
          var queryDef = utilities.getQueryDefinition(this.query);
          var vars = queryDef.variableDefinitions;
          if (!vars || !vars.some(function(v) {
            return v.variable.name.value === "variables";
          })) {
            globalThis.__DEV__ !== false && globals.invariant.warn(
              20,
              variables,
              ((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || queryDef
            );
          }
        }
        if (variables && !equal2.equal(this.options.variables, variables)) {
          reobserveOptions.variables = this.options.variables = tslib.__assign(tslib.__assign({}, this.options.variables), variables);
        }
        this.queryInfo.resetLastWrite();
        return this.reobserve(reobserveOptions, exports.NetworkStatus.refetch);
      };
      ObservableQuery3.prototype.fetchMore = function(fetchMoreOptions) {
        var _this = this;
        var combinedOptions = tslib.__assign(tslib.__assign({}, fetchMoreOptions.query ? fetchMoreOptions : tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: tslib.__assign(tslib.__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
          fetchPolicy: "no-cache"
        });
        combinedOptions.query = this.transformDocument(combinedOptions.query);
        var qid = this.queryManager.generateQueryId();
        this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
        var queryInfo = this.queryInfo;
        var originalNetworkStatus = queryInfo.networkStatus;
        queryInfo.networkStatus = exports.NetworkStatus.fetchMore;
        if (combinedOptions.notifyOnNetworkStatusChange) {
          this.observe();
        }
        var updatedQuerySet = /* @__PURE__ */ new Set();
        return this.queryManager.fetchQuery(qid, combinedOptions, exports.NetworkStatus.fetchMore).then(function(fetchMoreResult) {
          _this.queryManager.removeQuery(qid);
          if (queryInfo.networkStatus === exports.NetworkStatus.fetchMore) {
            queryInfo.networkStatus = originalNetworkStatus;
          }
          _this.queryManager.cache.batch({
            update: function(cache3) {
              var updateQuery = fetchMoreOptions.updateQuery;
              if (updateQuery) {
                cache3.updateQuery({
                  query: _this.query,
                  variables: _this.variables,
                  returnPartialData: true,
                  optimistic: false
                }, function(previous) {
                  return updateQuery(previous, {
                    fetchMoreResult: fetchMoreResult.data,
                    variables: combinedOptions.variables
                  });
                });
              } else {
                cache3.writeQuery({
                  query: combinedOptions.query,
                  variables: combinedOptions.variables,
                  data: fetchMoreResult.data
                });
              }
            },
            onWatchUpdated: function(watch) {
              updatedQuerySet.add(watch.query);
            }
          });
          return fetchMoreResult;
        }).finally(function() {
          if (!updatedQuerySet.has(_this.query)) {
            reobserveCacheFirst2(_this);
          }
        });
      };
      ObservableQuery3.prototype.subscribeToMore = function(options) {
        var _this = this;
        var subscription = this.queryManager.startGraphQLSubscription({
          query: options.document,
          variables: options.variables,
          context: options.context
        }).subscribe({
          next: function(subscriptionData) {
            var updateQuery = options.updateQuery;
            if (updateQuery) {
              _this.updateQuery(function(previous, _a2) {
                var variables = _a2.variables;
                return updateQuery(previous, {
                  subscriptionData,
                  variables
                });
              });
            }
          },
          error: function(err) {
            if (options.onError) {
              options.onError(err);
              return;
            }
            globalThis.__DEV__ !== false && globals.invariant.error(21, err);
          }
        });
        this.subscriptions.add(subscription);
        return function() {
          if (_this.subscriptions.delete(subscription)) {
            subscription.unsubscribe();
          }
        };
      };
      ObservableQuery3.prototype.setOptions = function(newOptions) {
        return this.reobserve(newOptions);
      };
      ObservableQuery3.prototype.silentSetOptions = function(newOptions) {
        var mergedOptions = utilities.compact(this.options, newOptions || {});
        assign2(this.options, mergedOptions);
      };
      ObservableQuery3.prototype.setVariables = function(variables) {
        if (equal2.equal(this.variables, variables)) {
          return this.observers.size ? this.result() : Promise.resolve();
        }
        this.options.variables = variables;
        if (!this.observers.size) {
          return Promise.resolve();
        }
        return this.reobserve({
          fetchPolicy: this.options.initialFetchPolicy,
          variables
        }, exports.NetworkStatus.setVariables);
      };
      ObservableQuery3.prototype.updateQuery = function(mapFn) {
        var queryManager = this.queryManager;
        var result2 = queryManager.cache.diff({
          query: this.options.query,
          variables: this.variables,
          returnPartialData: true,
          optimistic: false
        }).result;
        var newResult = mapFn(result2, {
          variables: this.variables
        });
        if (newResult) {
          queryManager.cache.writeQuery({
            query: this.options.query,
            data: newResult,
            variables: this.variables
          });
          queryManager.broadcastQueries();
        }
      };
      ObservableQuery3.prototype.startPolling = function(pollInterval) {
        this.options.pollInterval = pollInterval;
        this.updatePolling();
      };
      ObservableQuery3.prototype.stopPolling = function() {
        this.options.pollInterval = 0;
        this.updatePolling();
      };
      ObservableQuery3.prototype.applyNextFetchPolicy = function(reason, options) {
        if (options.nextFetchPolicy) {
          var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
          if (fetchPolicy === "standby") ;
          else if (typeof options.nextFetchPolicy === "function") {
            options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
              reason,
              options,
              observable: this,
              initialFetchPolicy
            });
          } else if (reason === "variables-changed") {
            options.fetchPolicy = initialFetchPolicy;
          } else {
            options.fetchPolicy = options.nextFetchPolicy;
          }
        }
        return options.fetchPolicy;
      };
      ObservableQuery3.prototype.fetch = function(options, newNetworkStatus, query) {
        this.queryManager.setObservableQuery(this);
        return this.queryManager["fetchConcastWithInfo"](this.queryId, options, newNetworkStatus, query);
      };
      ObservableQuery3.prototype.updatePolling = function() {
        var _this = this;
        if (this.queryManager.ssrMode) {
          return;
        }
        var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
        if (!pollInterval || !this.hasObservers()) {
          if (pollingInfo) {
            clearTimeout(pollingInfo.timeout);
            delete this.pollingInfo;
          }
          return;
        }
        if (pollingInfo && pollingInfo.interval === pollInterval) {
          return;
        }
        globals.invariant(pollInterval, 22);
        var info = pollingInfo || (this.pollingInfo = {});
        info.interval = pollInterval;
        var maybeFetch = function() {
          var _a3, _b;
          if (_this.pollingInfo) {
            if (!isNetworkRequestInFlight2(_this.queryInfo.networkStatus) && !((_b = (_a3 = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a3))) {
              _this.reobserve({
                fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
              }, exports.NetworkStatus.poll).then(poll, poll);
            } else {
              poll();
            }
          }
        };
        var poll = function() {
          var info2 = _this.pollingInfo;
          if (info2) {
            clearTimeout(info2.timeout);
            info2.timeout = setTimeout(maybeFetch, info2.interval);
          }
        };
        poll();
      };
      ObservableQuery3.prototype.updateLastResult = function(newResult, variables) {
        if (variables === void 0) {
          variables = this.variables;
        }
        var error = this.getLastError();
        if (error && this.last && !equal2.equal(variables, this.last.variables)) {
          error = void 0;
        }
        return this.last = tslib.__assign({ result: this.queryManager.assumeImmutableResults ? newResult : utilities.cloneDeep(newResult), variables }, error ? { error } : null);
      };
      ObservableQuery3.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
        var _this = this;
        this.isTornDown = false;
        var useDisposableConcast = newNetworkStatus === exports.NetworkStatus.refetch || newNetworkStatus === exports.NetworkStatus.fetchMore || newNetworkStatus === exports.NetworkStatus.poll;
        var oldVariables = this.options.variables;
        var oldFetchPolicy = this.options.fetchPolicy;
        var mergedOptions = utilities.compact(this.options, newOptions || {});
        var options = useDisposableConcast ? mergedOptions : assign2(this.options, mergedOptions);
        var query = this.transformDocument(options.query);
        this.lastQuery = query;
        if (!useDisposableConcast) {
          this.updatePolling();
          if (newOptions && newOptions.variables && !equal2.equal(newOptions.variables, oldVariables) && options.fetchPolicy !== "standby" && (options.fetchPolicy === oldFetchPolicy || typeof options.nextFetchPolicy === "function")) {
            this.applyNextFetchPolicy("variables-changed", options);
            if (newNetworkStatus === void 0) {
              newNetworkStatus = exports.NetworkStatus.setVariables;
            }
          }
        }
        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor2(options.fetchPolicy));
        var finishWaitingForOwnResult = function() {
          if (_this.concast === concast) {
            _this.waitForOwnResult = false;
          }
        };
        var variables = options.variables && tslib.__assign({}, options.variables);
        var _a2 = this.fetch(options, newNetworkStatus, query), concast = _a2.concast, fromLink = _a2.fromLink;
        var observer = {
          next: function(result2) {
            if (equal2.equal(_this.variables, variables)) {
              finishWaitingForOwnResult();
              _this.reportResult(result2, variables);
            }
          },
          error: function(error) {
            if (equal2.equal(_this.variables, variables)) {
              finishWaitingForOwnResult();
              _this.reportError(error, variables);
            }
          }
        };
        if (!useDisposableConcast && (fromLink || !this.concast)) {
          if (this.concast && this.observer) {
            this.concast.removeObserver(this.observer);
          }
          this.concast = concast;
          this.observer = observer;
        }
        concast.addObserver(observer);
        return concast;
      };
      ObservableQuery3.prototype.reobserve = function(newOptions, newNetworkStatus) {
        return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;
      };
      ObservableQuery3.prototype.resubscribeAfterError = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var last = this.last;
        this.resetLastResults();
        var subscription = this.subscribe.apply(this, args);
        this.last = last;
        return subscription;
      };
      ObservableQuery3.prototype.observe = function() {
        this.reportResult(
          this.getCurrentResult(false),
          this.variables
        );
      };
      ObservableQuery3.prototype.reportResult = function(result2, variables) {
        var lastError = this.getLastError();
        var isDifferent = this.isDifferentFromLastResult(result2, variables);
        if (lastError || !result2.partial || this.options.returnPartialData) {
          this.updateLastResult(result2, variables);
        }
        if (lastError || isDifferent) {
          utilities.iterateObserversSafely(this.observers, "next", result2);
        }
      };
      ObservableQuery3.prototype.reportError = function(error, variables) {
        var errorResult = tslib.__assign(tslib.__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: exports.NetworkStatus.error, loading: false });
        this.updateLastResult(errorResult, variables);
        utilities.iterateObserversSafely(this.observers, "error", this.last.error = error);
      };
      ObservableQuery3.prototype.hasObservers = function() {
        return this.observers.size > 0;
      };
      ObservableQuery3.prototype.tearDownQuery = function() {
        if (this.isTornDown)
          return;
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
          delete this.concast;
          delete this.observer;
        }
        this.stopPolling();
        this.subscriptions.forEach(function(sub) {
          return sub.unsubscribe();
        });
        this.subscriptions.clear();
        this.queryManager.stopQuery(this.queryId);
        this.observers.clear();
        this.isTornDown = true;
      };
      ObservableQuery3.prototype.transformDocument = function(document) {
        return this.queryManager.transform(document);
      };
      return ObservableQuery3;
    }(utilities.Observable);
    utilities.fixObservableSubclass(ObservableQuery2);
    function reobserveCacheFirst2(obsQuery) {
      var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
      if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
        return obsQuery.reobserve({
          fetchPolicy: "cache-first",
          nextFetchPolicy: function(currentFetchPolicy, context) {
            this.nextFetchPolicy = nextFetchPolicy;
            if (typeof this.nextFetchPolicy === "function") {
              return this.nextFetchPolicy(currentFetchPolicy, context);
            }
            return fetchPolicy;
          }
        });
      }
      return obsQuery.reobserve();
    }
    function defaultSubscriptionObserverErrorCallback2(error) {
      globalThis.__DEV__ !== false && globals.invariant.error(23, error.message, error.stack);
    }
    function logMissingFieldErrors2(missing) {
      if (globalThis.__DEV__ !== false && missing) {
        globalThis.__DEV__ !== false && globals.invariant.debug(24, missing);
      }
    }
    function skipCacheDataFor2(fetchPolicy) {
      return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
    }
    var destructiveMethodCounts2 = new (utilities.canUseWeakMap ? WeakMap : Map)();
    function wrapDestructiveCacheMethod2(cache3, methodName) {
      var original = cache3[methodName];
      if (typeof original === "function") {
        cache3[methodName] = function() {
          destructiveMethodCounts2.set(
            cache3,
            (destructiveMethodCounts2.get(cache3) + 1) % 1e15
          );
          return original.apply(this, arguments);
        };
      }
    }
    function cancelNotifyTimeout2(info) {
      if (info["notifyTimeout"]) {
        clearTimeout(info["notifyTimeout"]);
        info["notifyTimeout"] = void 0;
      }
    }
    var QueryInfo2 = function() {
      function QueryInfo3(queryManager, queryId) {
        if (queryId === void 0) {
          queryId = queryManager.generateQueryId();
        }
        this.queryId = queryId;
        this.listeners = /* @__PURE__ */ new Set();
        this.document = null;
        this.lastRequestId = 1;
        this.stopped = false;
        this.dirty = false;
        this.observableQuery = null;
        var cache3 = this.cache = queryManager.cache;
        if (!destructiveMethodCounts2.has(cache3)) {
          destructiveMethodCounts2.set(cache3, 0);
          wrapDestructiveCacheMethod2(cache3, "evict");
          wrapDestructiveCacheMethod2(cache3, "modify");
          wrapDestructiveCacheMethod2(cache3, "reset");
        }
      }
      QueryInfo3.prototype.init = function(query) {
        var networkStatus = query.networkStatus || exports.NetworkStatus.loading;
        if (this.variables && this.networkStatus !== exports.NetworkStatus.loading && !equal2.equal(this.variables, query.variables)) {
          networkStatus = exports.NetworkStatus.setVariables;
        }
        if (!equal2.equal(query.variables, this.variables)) {
          this.lastDiff = void 0;
        }
        Object.assign(this, {
          document: query.document,
          variables: query.variables,
          networkError: null,
          graphQLErrors: this.graphQLErrors || [],
          networkStatus
        });
        if (query.observableQuery) {
          this.setObservableQuery(query.observableQuery);
        }
        if (query.lastRequestId) {
          this.lastRequestId = query.lastRequestId;
        }
        return this;
      };
      QueryInfo3.prototype.reset = function() {
        cancelNotifyTimeout2(this);
        this.dirty = false;
      };
      QueryInfo3.prototype.resetDiff = function() {
        this.lastDiff = void 0;
      };
      QueryInfo3.prototype.getDiff = function() {
        var options = this.getDiffOptions();
        if (this.lastDiff && equal2.equal(options, this.lastDiff.options)) {
          return this.lastDiff.diff;
        }
        this.updateWatch(this.variables);
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return { complete: false };
        }
        var diff2 = this.cache.diff(options);
        this.updateLastDiff(diff2, options);
        return diff2;
      };
      QueryInfo3.prototype.updateLastDiff = function(diff2, options) {
        this.lastDiff = diff2 ? {
          diff: diff2,
          options: options || this.getDiffOptions()
        } : void 0;
      };
      QueryInfo3.prototype.getDiffOptions = function(variables) {
        var _a2;
        if (variables === void 0) {
          variables = this.variables;
        }
        return {
          query: this.document,
          variables,
          returnPartialData: true,
          optimistic: true,
          canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
        };
      };
      QueryInfo3.prototype.setDiff = function(diff2) {
        var _this = this;
        var _a2;
        var oldDiff = this.lastDiff && this.lastDiff.diff;
        if (diff2 && !diff2.complete && ((_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.getLastError())) {
          return;
        }
        this.updateLastDiff(diff2);
        if (!this.dirty && !equal2.equal(oldDiff && oldDiff.result, diff2 && diff2.result)) {
          this.dirty = true;
          if (!this.notifyTimeout) {
            this.notifyTimeout = setTimeout(function() {
              return _this.notify();
            }, 0);
          }
        }
      };
      QueryInfo3.prototype.setObservableQuery = function(oq) {
        var _this = this;
        if (oq === this.observableQuery)
          return;
        if (this.oqListener) {
          this.listeners.delete(this.oqListener);
        }
        this.observableQuery = oq;
        if (oq) {
          oq["queryInfo"] = this;
          this.listeners.add(this.oqListener = function() {
            var diff2 = _this.getDiff();
            if (diff2.fromOptimisticTransaction) {
              oq["observe"]();
            } else {
              reobserveCacheFirst2(oq);
            }
          });
        } else {
          delete this.oqListener;
        }
      };
      QueryInfo3.prototype.notify = function() {
        var _this = this;
        cancelNotifyTimeout2(this);
        if (this.shouldNotify()) {
          this.listeners.forEach(function(listener) {
            return listener(_this);
          });
        }
        this.dirty = false;
      };
      QueryInfo3.prototype.shouldNotify = function() {
        if (!this.dirty || !this.listeners.size) {
          return false;
        }
        if (isNetworkRequestInFlight2(this.networkStatus) && this.observableQuery) {
          var fetchPolicy = this.observableQuery.options.fetchPolicy;
          if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
            return false;
          }
        }
        return true;
      };
      QueryInfo3.prototype.stop = function() {
        if (!this.stopped) {
          this.stopped = true;
          this.reset();
          this.cancel();
          this.cancel = QueryInfo3.prototype.cancel;
          var oq = this.observableQuery;
          if (oq)
            oq.stopPolling();
        }
      };
      QueryInfo3.prototype.cancel = function() {
      };
      QueryInfo3.prototype.updateWatch = function(variables) {
        var _this = this;
        if (variables === void 0) {
          variables = this.variables;
        }
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return;
        }
        var watchOptions = tslib.__assign(tslib.__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff2) {
          return _this.setDiff(diff2);
        } });
        if (!this.lastWatch || !equal2.equal(watchOptions, this.lastWatch)) {
          this.cancel();
          this.cancel = this.cache.watch(this.lastWatch = watchOptions);
        }
      };
      QueryInfo3.prototype.resetLastWrite = function() {
        this.lastWrite = void 0;
      };
      QueryInfo3.prototype.shouldWrite = function(result2, variables) {
        var lastWrite = this.lastWrite;
        return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts2.get(this.cache) && equal2.equal(variables, lastWrite.variables) && equal2.equal(result2.data, lastWrite.result.data));
      };
      QueryInfo3.prototype.markResult = function(result2, document, options, cacheWriteBehavior) {
        var _this = this;
        var merger = new utilities.DeepMerger();
        var graphQLErrors = utilities.isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
        this.reset();
        if ("incremental" in result2 && utilities.isNonEmptyArray(result2.incremental)) {
          var mergedData = utilities.mergeIncrementalData(this.getDiff().result, result2);
          result2.data = mergedData;
        } else if ("hasNext" in result2 && result2.hasNext) {
          var diff2 = this.getDiff();
          result2.data = merger.merge(diff2.result, result2.data);
        }
        this.graphQLErrors = graphQLErrors;
        if (options.fetchPolicy === "no-cache") {
          this.updateLastDiff({ result: result2.data, complete: true }, this.getDiffOptions(options.variables));
        } else if (cacheWriteBehavior !== 0) {
          if (shouldWriteResult2(result2, options.errorPolicy)) {
            this.cache.performTransaction(function(cache3) {
              if (_this.shouldWrite(result2, options.variables)) {
                cache3.writeQuery({
                  query: document,
                  data: result2.data,
                  variables: options.variables,
                  overwrite: cacheWriteBehavior === 1
                });
                _this.lastWrite = {
                  result: result2,
                  variables: options.variables,
                  dmCount: destructiveMethodCounts2.get(_this.cache)
                };
              } else {
                if (_this.lastDiff && _this.lastDiff.diff.complete) {
                  result2.data = _this.lastDiff.diff.result;
                  return;
                }
              }
              var diffOptions = _this.getDiffOptions(options.variables);
              var diff3 = cache3.diff(diffOptions);
              if (!_this.stopped && equal2.equal(_this.variables, options.variables)) {
                _this.updateWatch(options.variables);
              }
              _this.updateLastDiff(diff3, diffOptions);
              if (diff3.complete) {
                result2.data = diff3.result;
              }
            });
          } else {
            this.lastWrite = void 0;
          }
        }
      };
      QueryInfo3.prototype.markReady = function() {
        this.networkError = null;
        return this.networkStatus = exports.NetworkStatus.ready;
      };
      QueryInfo3.prototype.markError = function(error) {
        this.networkStatus = exports.NetworkStatus.error;
        this.lastWrite = void 0;
        this.reset();
        if (error.graphQLErrors) {
          this.graphQLErrors = error.graphQLErrors;
        }
        if (error.networkError) {
          this.networkError = error.networkError;
        }
        return error;
      };
      return QueryInfo3;
    }();
    function shouldWriteResult2(result2, errorPolicy) {
      if (errorPolicy === void 0) {
        errorPolicy = "none";
      }
      var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
      var writeWithErrors = !utilities.graphQLResultHasError(result2);
      if (!writeWithErrors && ignoreErrors && result2.data) {
        writeWithErrors = true;
      }
      return writeWithErrors;
    }
    var hasOwnProperty11 = Object.prototype.hasOwnProperty;
    var IGNORE2 = /* @__PURE__ */ Object.create(null);
    var QueryManager2 = function() {
      function QueryManager3(options) {
        var _this = this;
        this.clientAwareness = {};
        this.queries = /* @__PURE__ */ new Map();
        this.fetchCancelFns = /* @__PURE__ */ new Map();
        this.transformCache = new utilities.AutoCleanedWeakCache(utilities.cacheSizes["queryManager.getDocumentInfo"] || 2e3);
        this.queryIdCounter = 1;
        this.requestIdCounter = 1;
        this.mutationIdCounter = 1;
        this.inFlightLinkObservables = new trie.Trie(false);
        var defaultDocumentTransform = new utilities.DocumentTransform(
          function(document) {
            return _this.cache.transformDocument(document);
          },
          { cache: false }
        );
        this.cache = options.cache;
        this.link = options.link;
        this.defaultOptions = options.defaultOptions;
        this.queryDeduplication = options.queryDeduplication;
        this.clientAwareness = options.clientAwareness;
        this.localState = options.localState;
        this.ssrMode = options.ssrMode;
        this.assumeImmutableResults = options.assumeImmutableResults;
        var documentTransform = options.documentTransform;
        this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
        this.defaultContext = options.defaultContext || /* @__PURE__ */ Object.create(null);
        if (this.onBroadcast = options.onBroadcast) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
      }
      QueryManager3.prototype.stop = function() {
        var _this = this;
        this.queries.forEach(function(_info, queryId) {
          _this.stopQueryNoBroadcast(queryId);
        });
        this.cancelPendingFetches(globals.newInvariantError(25));
      };
      QueryManager3.prototype.cancelPendingFetches = function(error) {
        this.fetchCancelFns.forEach(function(cancel) {
          return cancel(error);
        });
        this.fetchCancelFns.clear();
      };
      QueryManager3.prototype.mutate = function(_a2) {
        return tslib.__awaiter(this, arguments, void 0, function(_b) {
          var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self2;
          var _c, _d;
          var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || "network-only" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b.keepRootFields, context = _b.context;
          return tslib.__generator(this, function(_j) {
            switch (_j.label) {
              case 0:
                globals.invariant(mutation, 26);
                globals.invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 27);
                mutationId = this.generateMutationId();
                mutation = this.cache.transformForLink(this.transform(mutation));
                hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
                variables = this.getVariables(mutation, variables);
                if (!hasClientExports2) return [3, 2];
                return [4, this.localState.addExportedVariables(mutation, variables, context)];
              case 1:
                variables = _j.sent();
                _j.label = 2;
              case 2:
                mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                  mutation,
                  variables,
                  loading: true,
                  error: null
                });
                isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                  mutationId,
                  document: mutation,
                  variables,
                  fetchPolicy,
                  errorPolicy,
                  context,
                  updateQueries,
                  update: updateWithProxyFn,
                  keepRootFields
                });
                this.broadcastQueries();
                self2 = this;
                return [2, new Promise(function(resolve, reject) {
                  return utilities.asyncMap(self2.getObservableFromLink(mutation, tslib.__assign(tslib.__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result2) {
                    if (utilities.graphQLResultHasError(result2) && errorPolicy === "none") {
                      throw new errors.ApolloError({
                        graphQLErrors: utilities.getGraphQLErrorsFromResult(result2)
                      });
                    }
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = null;
                    }
                    var storeResult = tslib.__assign({}, result2);
                    if (typeof refetchQueries === "function") {
                      refetchQueries = refetchQueries(storeResult);
                    }
                    if (errorPolicy === "ignore" && utilities.graphQLResultHasError(storeResult)) {
                      delete storeResult.errors;
                    }
                    return self2.markMutationResult({
                      mutationId,
                      result: storeResult,
                      document: mutation,
                      variables,
                      fetchPolicy,
                      errorPolicy,
                      context,
                      update: updateWithProxyFn,
                      updateQueries,
                      awaitRefetchQueries,
                      refetchQueries,
                      removeOptimistic: isOptimistic ? mutationId : void 0,
                      onQueryUpdated,
                      keepRootFields
                    });
                  }).subscribe({
                    next: function(storeResult) {
                      self2.broadcastQueries();
                      if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                        resolve(storeResult);
                      }
                    },
                    error: function(err) {
                      if (mutationStoreValue) {
                        mutationStoreValue.loading = false;
                        mutationStoreValue.error = err;
                      }
                      if (isOptimistic) {
                        self2.cache.removeOptimistic(mutationId);
                      }
                      self2.broadcastQueries();
                      reject(err instanceof errors.ApolloError ? err : new errors.ApolloError({
                        networkError: err
                      }));
                    }
                  });
                })];
            }
          });
        });
      };
      QueryManager3.prototype.markMutationResult = function(mutation, cache3) {
        var _this = this;
        if (cache3 === void 0) {
          cache3 = this.cache;
        }
        var result2 = mutation.result;
        var cacheWrites = [];
        var skipCache = mutation.fetchPolicy === "no-cache";
        if (!skipCache && shouldWriteResult2(result2, mutation.errorPolicy)) {
          if (!utilities.isExecutionPatchIncrementalResult(result2)) {
            cacheWrites.push({
              result: result2.data,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
          if (utilities.isExecutionPatchIncrementalResult(result2) && utilities.isNonEmptyArray(result2.incremental)) {
            var diff2 = cache3.diff({
              id: "ROOT_MUTATION",
              query: this.getDocumentInfo(mutation.document).asQuery,
              variables: mutation.variables,
              optimistic: false,
              returnPartialData: true
            });
            var mergedData = void 0;
            if (diff2.result) {
              mergedData = mergeIncrementalData2(diff2.result, result2);
            }
            if (typeof mergedData !== "undefined") {
              result2.data = mergedData;
              cacheWrites.push({
                result: mergedData,
                dataId: "ROOT_MUTATION",
                query: mutation.document,
                variables: mutation.variables
              });
            }
          }
          var updateQueries_1 = mutation.updateQueries;
          if (updateQueries_1) {
            this.queries.forEach(function(_a2, queryId) {
              var observableQuery = _a2.observableQuery;
              var queryName = observableQuery && observableQuery.queryName;
              if (!queryName || !hasOwnProperty11.call(updateQueries_1, queryName)) {
                return;
              }
              var updater = updateQueries_1[queryName];
              var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;
              var _c = cache3.diff({
                query: document,
                variables,
                returnPartialData: true,
                optimistic: false
              }), currentQueryResult = _c.result, complete = _c.complete;
              if (complete && currentQueryResult) {
                var nextQueryResult = updater(currentQueryResult, {
                  mutationResult: result2,
                  queryName: document && utilities.getOperationName(document) || void 0,
                  queryVariables: variables
                });
                if (nextQueryResult) {
                  cacheWrites.push({
                    result: nextQueryResult,
                    dataId: "ROOT_QUERY",
                    query: document,
                    variables
                  });
                }
              }
            });
          }
        }
        if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
          var results_1 = [];
          this.refetchQueries({
            updateCache: function(cache4) {
              if (!skipCache) {
                cacheWrites.forEach(function(write) {
                  return cache4.write(write);
                });
              }
              var update = mutation.update;
              var isFinalResult = !utilities.isExecutionPatchResult(result2) || utilities.isExecutionPatchIncrementalResult(result2) && !result2.hasNext;
              if (update) {
                if (!skipCache) {
                  var diff3 = cache4.diff({
                    id: "ROOT_MUTATION",
                    query: _this.getDocumentInfo(mutation.document).asQuery,
                    variables: mutation.variables,
                    optimistic: false,
                    returnPartialData: true
                  });
                  if (diff3.complete) {
                    result2 = tslib.__assign(tslib.__assign({}, result2), { data: diff3.result });
                    if ("incremental" in result2) {
                      delete result2.incremental;
                    }
                    if ("hasNext" in result2) {
                      delete result2.hasNext;
                    }
                  }
                }
                if (isFinalResult) {
                  update(cache4, result2, {
                    context: mutation.context,
                    variables: mutation.variables
                  });
                }
              }
              if (!skipCache && !mutation.keepRootFields && isFinalResult) {
                cache4.modify({
                  id: "ROOT_MUTATION",
                  fields: function(value, _a2) {
                    var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                    return fieldName === "__typename" ? value : DELETE2;
                  }
                });
              }
            },
            include: mutation.refetchQueries,
            optimistic: false,
            removeOptimistic: mutation.removeOptimistic,
            onQueryUpdated: mutation.onQueryUpdated || null
          }).forEach(function(result3) {
            return results_1.push(result3);
          });
          if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
            return Promise.all(results_1).then(function() {
              return result2;
            });
          }
        }
        return Promise.resolve(result2);
      };
      QueryManager3.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
        var _this = this;
        var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE: IGNORE2 }) : optimisticResponse;
        if (data === IGNORE2) {
          return false;
        }
        this.cache.recordOptimisticTransaction(function(cache3) {
          try {
            _this.markMutationResult(tslib.__assign(tslib.__assign({}, mutation), { result: { data } }), cache3);
          } catch (error) {
            globalThis.__DEV__ !== false && globals.invariant.error(error);
          }
        }, mutation.mutationId);
        return true;
      };
      QueryManager3.prototype.fetchQuery = function(queryId, options, networkStatus) {
        return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;
      };
      QueryManager3.prototype.getQueryStore = function() {
        var store = /* @__PURE__ */ Object.create(null);
        this.queries.forEach(function(info, queryId) {
          store[queryId] = {
            variables: info.variables,
            networkStatus: info.networkStatus,
            networkError: info.networkError,
            graphQLErrors: info.graphQLErrors
          };
        });
        return store;
      };
      QueryManager3.prototype.resetErrors = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo) {
          queryInfo.networkError = void 0;
          queryInfo.graphQLErrors = [];
        }
      };
      QueryManager3.prototype.transform = function(document) {
        return this.documentTransform.transformDocument(document);
      };
      QueryManager3.prototype.getDocumentInfo = function(document) {
        var transformCache = this.transformCache;
        if (!transformCache.has(document)) {
          var cacheEntry = {
            hasClientExports: utilities.hasClientExports(document),
            hasForcedResolvers: this.localState.shouldForceResolvers(document),
            hasNonreactiveDirective: utilities.hasDirectives(["nonreactive"], document),
            clientQuery: this.localState.clientQuery(document),
            serverQuery: utilities.removeDirectivesFromDocument([
              { name: "client", remove: true },
              { name: "connection" },
              { name: "nonreactive" }
            ], document),
            defaultVars: utilities.getDefaultValues(utilities.getOperationDefinition(document)),
            asQuery: tslib.__assign(tslib.__assign({}, document), { definitions: document.definitions.map(function(def) {
              if (def.kind === "OperationDefinition" && def.operation !== "query") {
                return tslib.__assign(tslib.__assign({}, def), { operation: "query" });
              }
              return def;
            }) })
          };
          transformCache.set(document, cacheEntry);
        }
        return transformCache.get(document);
      };
      QueryManager3.prototype.getVariables = function(document, variables) {
        return tslib.__assign(tslib.__assign({}, this.getDocumentInfo(document).defaultVars), variables);
      };
      QueryManager3.prototype.watchQuery = function(options) {
        var query = this.transform(options.query);
        options = tslib.__assign(tslib.__assign({}, options), { variables: this.getVariables(query, options.variables) });
        if (typeof options.notifyOnNetworkStatusChange === "undefined") {
          options.notifyOnNetworkStatusChange = false;
        }
        var queryInfo = new QueryInfo2(this);
        var observable = new ObservableQuery2({
          queryManager: this,
          queryInfo,
          options
        });
        observable["lastQuery"] = query;
        this.queries.set(observable.queryId, queryInfo);
        queryInfo.init({
          document: query,
          observableQuery: observable,
          variables: observable.variables
        });
        return observable;
      };
      QueryManager3.prototype.query = function(options, queryId) {
        var _this = this;
        if (queryId === void 0) {
          queryId = this.generateQueryId();
        }
        globals.invariant(options.query, 28);
        globals.invariant(options.query.kind === "Document", 29);
        globals.invariant(!options.returnPartialData, 30);
        globals.invariant(!options.pollInterval, 31);
        return this.fetchQuery(queryId, tslib.__assign(tslib.__assign({}, options), { query: this.transform(options.query) })).finally(function() {
          return _this.stopQuery(queryId);
        });
      };
      QueryManager3.prototype.generateQueryId = function() {
        return String(this.queryIdCounter++);
      };
      QueryManager3.prototype.generateRequestId = function() {
        return this.requestIdCounter++;
      };
      QueryManager3.prototype.generateMutationId = function() {
        return String(this.mutationIdCounter++);
      };
      QueryManager3.prototype.stopQueryInStore = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager3.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo)
          queryInfo.stop();
      };
      QueryManager3.prototype.clearStore = function(options) {
        if (options === void 0) {
          options = {
            discardWatches: true
          };
        }
        this.cancelPendingFetches(globals.newInvariantError(32));
        this.queries.forEach(function(queryInfo) {
          if (queryInfo.observableQuery) {
            queryInfo.networkStatus = exports.NetworkStatus.loading;
          } else {
            queryInfo.stop();
          }
        });
        if (this.mutationStore) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
        return this.cache.reset(options);
      };
      QueryManager3.prototype.getObservableQueries = function(include) {
        var _this = this;
        if (include === void 0) {
          include = "active";
        }
        var queries = /* @__PURE__ */ new Map();
        var queryNamesAndDocs = /* @__PURE__ */ new Map();
        var legacyQueryOptions = /* @__PURE__ */ new Set();
        if (Array.isArray(include)) {
          include.forEach(function(desc) {
            if (typeof desc === "string") {
              queryNamesAndDocs.set(desc, false);
            } else if (utilities.isDocumentNode(desc)) {
              queryNamesAndDocs.set(_this.transform(desc), false);
            } else if (utilities.isNonNullObject(desc) && desc.query) {
              legacyQueryOptions.add(desc);
            }
          });
        }
        this.queries.forEach(function(_a2, queryId) {
          var oq = _a2.observableQuery, document = _a2.document;
          if (oq) {
            if (include === "all") {
              queries.set(queryId, oq);
              return;
            }
            var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
            if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
              return;
            }
            if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {
              queries.set(queryId, oq);
              if (queryName)
                queryNamesAndDocs.set(queryName, true);
              if (document)
                queryNamesAndDocs.set(document, true);
            }
          }
        });
        if (legacyQueryOptions.size) {
          legacyQueryOptions.forEach(function(options) {
            var queryId = utilities.makeUniqueId("legacyOneTimeQuery");
            var queryInfo = _this.getQuery(queryId).init({
              document: options.query,
              variables: options.variables
            });
            var oq = new ObservableQuery2({
              queryManager: _this,
              queryInfo,
              options: tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "network-only" })
            });
            globals.invariant(oq.queryId === queryId);
            queryInfo.setObservableQuery(oq);
            queries.set(queryId, oq);
          });
        }
        if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {
          queryNamesAndDocs.forEach(function(included, nameOrDoc) {
            if (!included) {
              globalThis.__DEV__ !== false && globals.invariant.warn(typeof nameOrDoc === "string" ? 33 : 34, nameOrDoc);
            }
          });
        }
        return queries;
      };
      QueryManager3.prototype.reFetchObservableQueries = function(includeStandby) {
        var _this = this;
        if (includeStandby === void 0) {
          includeStandby = false;
        }
        var observableQueryPromises = [];
        this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
          var fetchPolicy = observableQuery.options.fetchPolicy;
          observableQuery.resetLastResults();
          if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
            observableQueryPromises.push(observableQuery.refetch());
          }
          _this.getQuery(queryId).setDiff(null);
        });
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
      };
      QueryManager3.prototype.setObservableQuery = function(observableQuery) {
        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
      };
      QueryManager3.prototype.startGraphQLSubscription = function(_a2) {
        var _this = this;
        var query = _a2.query, fetchPolicy = _a2.fetchPolicy, _b = _a2.errorPolicy, errorPolicy = _b === void 0 ? "none" : _b, variables = _a2.variables, _c = _a2.context, context = _c === void 0 ? {} : _c, _d = _a2.extensions, extensions = _d === void 0 ? {} : _d;
        query = this.transform(query);
        variables = this.getVariables(query, variables);
        var makeObservable = function(variables2) {
          return _this.getObservableFromLink(query, context, variables2, extensions).map(function(result2) {
            if (fetchPolicy !== "no-cache") {
              if (shouldWriteResult2(result2, errorPolicy)) {
                _this.cache.write({
                  query,
                  result: result2.data,
                  dataId: "ROOT_SUBSCRIPTION",
                  variables: variables2
                });
              }
              _this.broadcastQueries();
            }
            var hasErrors = utilities.graphQLResultHasError(result2);
            var hasProtocolErrors = errors.graphQLResultHasProtocolErrors(result2);
            if (hasErrors || hasProtocolErrors) {
              var errors$1 = {};
              if (hasErrors) {
                errors$1.graphQLErrors = result2.errors;
              }
              if (hasProtocolErrors) {
                errors$1.protocolErrors = result2.extensions[errors.PROTOCOL_ERRORS_SYMBOL];
              }
              if (errorPolicy === "none" || hasProtocolErrors) {
                throw new errors.ApolloError(errors$1);
              }
            }
            if (errorPolicy === "ignore") {
              delete result2.errors;
            }
            return result2;
          });
        };
        if (this.getDocumentInfo(query).hasClientExports) {
          var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
          return new utilities.Observable(function(observer) {
            var sub = null;
            observablePromise_1.then(function(observable) {
              return sub = observable.subscribe(observer);
            }, observer.error);
            return function() {
              return sub && sub.unsubscribe();
            };
          });
        }
        return makeObservable(variables);
      };
      QueryManager3.prototype.stopQuery = function(queryId) {
        this.stopQueryNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager3.prototype.stopQueryNoBroadcast = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.removeQuery(queryId);
      };
      QueryManager3.prototype.removeQuery = function(queryId) {
        this.fetchCancelFns.delete(queryId);
        if (this.queries.has(queryId)) {
          this.getQuery(queryId).stop();
          this.queries.delete(queryId);
        }
      };
      QueryManager3.prototype.broadcastQueries = function() {
        if (this.onBroadcast)
          this.onBroadcast();
        this.queries.forEach(function(info) {
          return info.notify();
        });
      };
      QueryManager3.prototype.getLocalState = function() {
        return this.localState;
      };
      QueryManager3.prototype.getObservableFromLink = function(query, context, variables, extensions, deduplication) {
        var _this = this;
        var _a2;
        if (deduplication === void 0) {
          deduplication = (_a2 = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
        }
        var observable;
        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
        if (serverQuery) {
          var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
          var operation = {
            query: serverQuery,
            variables,
            operationName: utilities.getOperationName(serverQuery) || void 0,
            context: this.prepareContext(tslib.__assign(tslib.__assign({}, context), { forceFetch: !deduplication })),
            extensions
          };
          context = operation.context;
          if (deduplication) {
            var printedServerQuery_1 = utilities.print(serverQuery);
            var varJson_1 = cache2.canonicalStringify(variables);
            var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
            observable = entry.observable;
            if (!observable) {
              var concast = new utilities.Concast([
                core.execute(link, operation)
              ]);
              observable = entry.observable = concast;
              concast.beforeNext(function() {
                inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
              });
            }
          } else {
            observable = new utilities.Concast([
              core.execute(link, operation)
            ]);
          }
        } else {
          observable = new utilities.Concast([utilities.Observable.of({ data: {} })]);
          context = this.prepareContext(context);
        }
        if (clientQuery) {
          observable = utilities.asyncMap(observable, function(result2) {
            return _this.localState.runResolvers({
              document: clientQuery,
              remoteResult: result2,
              context,
              variables
            });
          });
        }
        return observable;
      };
      QueryManager3.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
        var requestId = queryInfo.lastRequestId = this.generateRequestId();
        var linkDocument = this.cache.transformForLink(options.query);
        return utilities.asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result2) {
          var graphQLErrors = utilities.getGraphQLErrorsFromResult(result2);
          var hasErrors = graphQLErrors.length > 0;
          if (requestId >= queryInfo.lastRequestId) {
            if (hasErrors && options.errorPolicy === "none") {
              throw queryInfo.markError(new errors.ApolloError({
                graphQLErrors
              }));
            }
            queryInfo.markResult(result2, linkDocument, options, cacheWriteBehavior);
            queryInfo.markReady();
          }
          var aqr = {
            data: result2.data,
            loading: false,
            networkStatus: exports.NetworkStatus.ready
          };
          if (hasErrors && options.errorPolicy !== "ignore") {
            aqr.errors = graphQLErrors;
            aqr.networkStatus = exports.NetworkStatus.error;
          }
          return aqr;
        }, function(networkError) {
          var error = errors.isApolloError(networkError) ? networkError : new errors.ApolloError({ networkError });
          if (requestId >= queryInfo.lastRequestId) {
            queryInfo.markError(error);
          }
          throw error;
        });
      };
      QueryManager3.prototype.fetchConcastWithInfo = function(queryId, options, networkStatus, query) {
        var _this = this;
        if (networkStatus === void 0) {
          networkStatus = exports.NetworkStatus.loading;
        }
        if (query === void 0) {
          query = options.query;
        }
        var variables = this.getVariables(query, options.variables);
        var queryInfo = this.getQuery(queryId);
        var defaults = this.defaultOptions.watchQuery;
        var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
        var normalized = Object.assign({}, options, {
          query,
          variables,
          fetchPolicy,
          errorPolicy,
          returnPartialData,
          notifyOnNetworkStatusChange,
          context
        });
        var fromVariables = function(variables2) {
          normalized.variables = variables2;
          var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
          if (normalized.fetchPolicy !== "standby" && sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery) {
            queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
          }
          return sourcesWithInfo2;
        };
        var cleanupCancelFn = function() {
          return _this.fetchCancelFns.delete(queryId);
        };
        this.fetchCancelFns.set(queryId, function(reason) {
          cleanupCancelFn();
          setTimeout(function() {
            return concast.cancel(reason);
          });
        });
        var concast, containsDataFromLink;
        if (this.getDocumentInfo(normalized.query).hasClientExports) {
          concast = new utilities.Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
            return sourcesWithInfo2.sources;
          }));
          containsDataFromLink = true;
        } else {
          var sourcesWithInfo = fromVariables(normalized.variables);
          containsDataFromLink = sourcesWithInfo.fromLink;
          concast = new utilities.Concast(sourcesWithInfo.sources);
        }
        concast.promise.then(cleanupCancelFn, cleanupCancelFn);
        return {
          concast,
          fromLink: containsDataFromLink
        };
      };
      QueryManager3.prototype.refetchQueries = function(_a2) {
        var _this = this;
        var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? utilities.makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
        var includedQueriesById = /* @__PURE__ */ new Map();
        if (include) {
          this.getObservableQueries(include).forEach(function(oq, queryId) {
            includedQueriesById.set(queryId, {
              oq,
              lastDiff: _this.getQuery(queryId).getDiff()
            });
          });
        }
        var results = /* @__PURE__ */ new Map();
        if (updateCache) {
          this.cache.batch({
            update: updateCache,
            optimistic: optimistic && removeOptimistic || false,
            removeOptimistic,
            onWatchUpdated: function(watch, diff2, lastDiff) {
              var oq = watch.watcher instanceof QueryInfo2 && watch.watcher.observableQuery;
              if (oq) {
                if (onQueryUpdated) {
                  includedQueriesById.delete(oq.queryId);
                  var result2 = onQueryUpdated(oq, diff2, lastDiff);
                  if (result2 === true) {
                    result2 = oq.refetch();
                  }
                  if (result2 !== false) {
                    results.set(oq, result2);
                  }
                  return result2;
                }
                if (onQueryUpdated !== null) {
                  includedQueriesById.set(oq.queryId, { oq, lastDiff, diff: diff2 });
                }
              }
            }
          });
        }
        if (includedQueriesById.size) {
          includedQueriesById.forEach(function(_a3, queryId) {
            var oq = _a3.oq, lastDiff = _a3.lastDiff, diff2 = _a3.diff;
            var result2;
            if (onQueryUpdated) {
              if (!diff2) {
                var info = oq["queryInfo"];
                info.reset();
                diff2 = info.getDiff();
              }
              result2 = onQueryUpdated(oq, diff2, lastDiff);
            }
            if (!onQueryUpdated || result2 === true) {
              result2 = oq.refetch();
            }
            if (result2 !== false) {
              results.set(oq, result2);
            }
            if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
              _this.stopQueryNoBroadcast(queryId);
            }
          });
        }
        if (removeOptimistic) {
          this.cache.removeOptimistic(removeOptimistic);
        }
        return results;
      };
      QueryManager3.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
        var _this = this;
        var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
        var oldNetworkStatus = queryInfo.networkStatus;
        queryInfo.init({
          document: query,
          variables,
          networkStatus
        });
        var readCache = function() {
          return queryInfo.getDiff();
        };
        var resultsFromCache = function(diff3, networkStatus2) {
          if (networkStatus2 === void 0) {
            networkStatus2 = queryInfo.networkStatus || exports.NetworkStatus.loading;
          }
          var data = diff3.result;
          if (globalThis.__DEV__ !== false && !returnPartialData && !equal2.equal(data, {})) {
            logMissingFieldErrors2(diff3.missing);
          }
          var fromData = function(data2) {
            return utilities.Observable.of(tslib.__assign({ data: data2, loading: isNetworkRequestInFlight2(networkStatus2), networkStatus: networkStatus2 }, diff3.complete ? null : { partial: true }));
          };
          if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
            return _this.localState.runResolvers({
              document: query,
              remoteResult: { data },
              context,
              variables,
              onlyRunForcedResolvers: true
            }).then(function(resolved) {
              return fromData(resolved.data || void 0);
            });
          }
          if (errorPolicy === "none" && networkStatus2 === exports.NetworkStatus.refetch && Array.isArray(diff3.missing)) {
            return fromData(void 0);
          }
          return fromData(data);
        };
        var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === exports.NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
        var resultsFromLink = function() {
          return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
            query,
            variables,
            context,
            fetchPolicy,
            errorPolicy
          });
        };
        var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight2(networkStatus);
        switch (fetchPolicy) {
          default:
          case "cache-first": {
            var diff2 = readCache();
            if (diff2.complete) {
              return {
                fromLink: false,
                sources: [resultsFromCache(diff2, queryInfo.markReady())]
              };
            }
            if (returnPartialData || shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(diff2), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          }
          case "cache-and-network": {
            var diff2 = readCache();
            if (diff2.complete || returnPartialData || shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(diff2), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          }
          case "cache-only":
            return {
              fromLink: false,
              sources: [resultsFromCache(readCache(), queryInfo.markReady())]
            };
          case "network-only":
            if (shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(readCache()), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          case "no-cache":
            if (shouldNotify) {
              return {
                fromLink: true,
                sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
              };
            }
            return { fromLink: true, sources: [resultsFromLink()] };
          case "standby":
            return { fromLink: false, sources: [] };
        }
      };
      QueryManager3.prototype.getQuery = function(queryId) {
        if (queryId && !this.queries.has(queryId)) {
          this.queries.set(queryId, new QueryInfo2(this, queryId));
        }
        return this.queries.get(queryId);
      };
      QueryManager3.prototype.prepareContext = function(context) {
        if (context === void 0) {
          context = {};
        }
        var newContext = this.localState.prepareContext(context);
        return tslib.__assign(tslib.__assign(tslib.__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
      };
      return QueryManager3;
    }();
    var LocalState2 = function() {
      function LocalState3(_a2) {
        var cache3 = _a2.cache, client = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
        this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
        this.cache = cache3;
        if (client) {
          this.client = client;
        }
        if (resolvers) {
          this.addResolvers(resolvers);
        }
        if (fragmentMatcher) {
          this.setFragmentMatcher(fragmentMatcher);
        }
      }
      LocalState3.prototype.addResolvers = function(resolvers) {
        var _this = this;
        this.resolvers = this.resolvers || {};
        if (Array.isArray(resolvers)) {
          resolvers.forEach(function(resolverGroup) {
            _this.resolvers = utilities.mergeDeep(_this.resolvers, resolverGroup);
          });
        } else {
          this.resolvers = utilities.mergeDeep(this.resolvers, resolvers);
        }
      };
      LocalState3.prototype.setResolvers = function(resolvers) {
        this.resolvers = {};
        this.addResolvers(resolvers);
      };
      LocalState3.prototype.getResolvers = function() {
        return this.resolvers || {};
      };
      LocalState3.prototype.runResolvers = function(_a2) {
        return tslib.__awaiter(this, arguments, void 0, function(_b) {
          var document = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;
          return tslib.__generator(this, function(_d) {
            if (document) {
              return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
                return tslib.__assign(tslib.__assign({}, remoteResult), { data: localResult.result });
              })];
            }
            return [2, remoteResult];
          });
        });
      };
      LocalState3.prototype.setFragmentMatcher = function(fragmentMatcher) {
        this.fragmentMatcher = fragmentMatcher;
      };
      LocalState3.prototype.getFragmentMatcher = function() {
        return this.fragmentMatcher;
      };
      LocalState3.prototype.clientQuery = function(document) {
        if (utilities.hasDirectives(["client"], document)) {
          if (this.resolvers) {
            return document;
          }
        }
        return null;
      };
      LocalState3.prototype.serverQuery = function(document) {
        return utilities.removeClientSetsFromDocument(document);
      };
      LocalState3.prototype.prepareContext = function(context) {
        var cache3 = this.cache;
        return tslib.__assign(tslib.__assign({}, context), {
          cache: cache3,
          getCacheKey: function(obj) {
            return cache3.identify(obj);
          }
        });
      };
      LocalState3.prototype.addExportedVariables = function(document_1) {
        return tslib.__awaiter(this, arguments, void 0, function(document, variables, context) {
          if (variables === void 0) {
            variables = {};
          }
          if (context === void 0) {
            context = {};
          }
          return tslib.__generator(this, function(_a2) {
            if (document) {
              return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function(data) {
                return tslib.__assign(tslib.__assign({}, variables), data.exportedVariables);
              })];
            }
            return [2, tslib.__assign({}, variables)];
          });
        });
      };
      LocalState3.prototype.shouldForceResolvers = function(document) {
        var forceResolvers = false;
        graphql2.visit(document, {
          Directive: {
            enter: function(node) {
              if (node.name.value === "client" && node.arguments) {
                forceResolvers = node.arguments.some(function(arg) {
                  return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
                });
                if (forceResolvers) {
                  return graphql2.BREAK;
                }
              }
            }
          }
        });
        return forceResolvers;
      };
      LocalState3.prototype.buildRootValueFromCache = function(document, variables) {
        return this.cache.diff({
          query: utilities.buildQueryFromSelectionSet(document),
          variables,
          returnPartialData: true,
          optimistic: false
        }).result;
      };
      LocalState3.prototype.resolveDocument = function(document_1, rootValue_1) {
        return tslib.__awaiter(this, arguments, void 0, function(document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
          var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a2, cache3, client, execContext, isClientFieldDescendant;
          if (context === void 0) {
            context = {};
          }
          if (variables === void 0) {
            variables = {};
          }
          if (fragmentMatcher === void 0) {
            fragmentMatcher = function() {
              return true;
            };
          }
          if (onlyRunForcedResolvers === void 0) {
            onlyRunForcedResolvers = false;
          }
          return tslib.__generator(this, function(_b) {
            mainDefinition = utilities.getMainDefinition(document);
            fragments = utilities.getFragmentDefinitions(document);
            fragmentMap = utilities.createFragmentMap(fragments);
            selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
            definitionOperation = mainDefinition.operation;
            defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
            _a2 = this, cache3 = _a2.cache, client = _a2.client;
            execContext = {
              fragmentMap,
              context: tslib.__assign(tslib.__assign({}, context), { cache: cache3, client }),
              variables,
              fragmentMatcher,
              defaultOperationType,
              exportedVariables: {},
              selectionsToResolve,
              onlyRunForcedResolvers
            };
            isClientFieldDescendant = false;
            return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result2) {
              return {
                result: result2,
                exportedVariables: execContext.exportedVariables
              };
            })];
          });
        });
      };
      LocalState3.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var fragmentMap, context, variables, resultsToMerge, execute3;
          var _this = this;
          return tslib.__generator(this, function(_a2) {
            fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
            resultsToMerge = [rootValue];
            execute3 = function(selection) {
              return tslib.__awaiter(_this, void 0, void 0, function() {
                var fragment, typeCondition;
                return tslib.__generator(this, function(_a3) {
                  if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                    return [2];
                  }
                  if (!utilities.shouldInclude(selection, variables)) {
                    return [2];
                  }
                  if (utilities.isField(selection)) {
                    return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                      var _a4;
                      if (typeof fieldResult !== "undefined") {
                        resultsToMerge.push((_a4 = {}, _a4[utilities.resultKeyNameFromField(selection)] = fieldResult, _a4));
                      }
                    })];
                  }
                  if (utilities.isInlineFragment(selection)) {
                    fragment = selection;
                  } else {
                    fragment = fragmentMap[selection.name.value];
                    globals.invariant(fragment, 18, selection.name.value);
                  }
                  if (fragment && fragment.typeCondition) {
                    typeCondition = fragment.typeCondition.name.value;
                    if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                      return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                        resultsToMerge.push(fragmentResult);
                      })];
                    }
                  }
                  return [2];
                });
              });
            };
            return [2, Promise.all(selectionSet.selections.map(execute3)).then(function() {
              return utilities.mergeDeepArray(resultsToMerge);
            })];
          });
        });
      };
      LocalState3.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
          var _this = this;
          return tslib.__generator(this, function(_a2) {
            if (!rootValue) {
              return [2, null];
            }
            variables = execContext.variables;
            fieldName = field.name.value;
            aliasedFieldName = utilities.resultKeyNameFromField(field);
            aliasUsed = fieldName !== aliasedFieldName;
            defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
            resultPromise = Promise.resolve(defaultResult);
            if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
              resolverType = rootValue.__typename || execContext.defaultOperationType;
              resolverMap = this.resolvers && this.resolvers[resolverType];
              if (resolverMap) {
                resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                if (resolve) {
                  resultPromise = Promise.resolve(
                    cache2.cacheSlot.withValue(this.cache, resolve, [
                      rootValue,
                      utilities.argumentsObjectFromField(field, variables),
                      execContext.context,
                      { field, fragmentMap: execContext.fragmentMap }
                    ])
                  );
                }
              }
            }
            return [2, resultPromise.then(function(result2) {
              var _a3, _b;
              if (result2 === void 0) {
                result2 = defaultResult;
              }
              if (field.directives) {
                field.directives.forEach(function(directive) {
                  if (directive.name.value === "export" && directive.arguments) {
                    directive.arguments.forEach(function(arg) {
                      if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                        execContext.exportedVariables[arg.value.value] = result2;
                      }
                    });
                  }
                });
              }
              if (!field.selectionSet) {
                return result2;
              }
              if (result2 == null) {
                return result2;
              }
              var isClientField = (_b = (_a3 = field.directives) === null || _a3 === void 0 ? void 0 : _a3.some(function(d) {
                return d.name.value === "client";
              })) !== null && _b !== void 0 ? _b : false;
              if (Array.isArray(result2)) {
                return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result2, execContext);
              }
              if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result2, execContext);
              }
            })];
          });
        });
      };
      LocalState3.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result2, execContext) {
        var _this = this;
        return Promise.all(result2.map(function(item) {
          if (item === null) {
            return null;
          }
          if (Array.isArray(item)) {
            return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
          }
        }));
      };
      LocalState3.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
        var isSingleASTNode = function(node) {
          return !Array.isArray(node);
        };
        var selectionsToResolveCache = this.selectionsToResolveCache;
        function collectByDefinition(definitionNode) {
          if (!selectionsToResolveCache.has(definitionNode)) {
            var matches_1 = /* @__PURE__ */ new Set();
            selectionsToResolveCache.set(definitionNode, matches_1);
            graphql2.visit(definitionNode, {
              Directive: function(node, _, __, ___, ancestors) {
                if (node.name.value === "client") {
                  ancestors.forEach(function(node2) {
                    if (isSingleASTNode(node2) && graphql2.isSelectionNode(node2)) {
                      matches_1.add(node2);
                    }
                  });
                }
              },
              FragmentSpread: function(spread, _, __, ___, ancestors) {
                var fragment = fragmentMap[spread.name.value];
                globals.invariant(fragment, 19, spread.name.value);
                var fragmentSelections = collectByDefinition(fragment);
                if (fragmentSelections.size > 0) {
                  ancestors.forEach(function(node) {
                    if (isSingleASTNode(node) && graphql2.isSelectionNode(node)) {
                      matches_1.add(node);
                    }
                  });
                  matches_1.add(spread);
                  fragmentSelections.forEach(function(selection) {
                    matches_1.add(selection);
                  });
                }
              }
            });
          }
          return selectionsToResolveCache.get(definitionNode);
        }
        return collectByDefinition(mainDefinition);
      };
      return LocalState3;
    }();
    var cacheSizeSymbol2 = Symbol.for("apollo.cacheSize");
    var cacheSizes2 = tslib.__assign({}, globals.global[cacheSizeSymbol2]);
    var globalCaches2 = {};
    var getApolloClientMemoryInternals2 = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals2 : void 0;
    function getCurrentCacheSizes2() {
      var defaults = {
        parser: 1e3,
        canonicalStringify: 1e3,
        print: 2e3,
        "documentTransform.cache": 2e3,
        "queryManager.getDocumentInfo": 2e3,
        "PersistedQueryLink.persistedQueryHashes": 2e3,
        "fragmentRegistry.transform": 2e3,
        "fragmentRegistry.lookup": 1e3,
        "fragmentRegistry.findFragmentSpreads": 4e3,
        "cache.fragmentQueryDocuments": 1e3,
        "removeTypenameFromVariables.getVariableDefinitions": 2e3,
        "inMemoryCache.maybeBroadcastWatch": 5e3,
        "inMemoryCache.executeSelectionSet": 5e4,
        "inMemoryCache.executeSubSelectedArray": 1e4
      };
      return Object.fromEntries(Object.entries(defaults).map(function(_a2) {
        var k2 = _a2[0], v = _a2[1];
        return [
          k2,
          cacheSizes2[k2] || v
        ];
      }));
    }
    function _getApolloClientMemoryInternals2() {
      var _a2, _b, _c, _d, _e;
      if (!(globalThis.__DEV__ !== false))
        throw new Error("only supported in development mode");
      return {
        limits: getCurrentCacheSizes2(),
        sizes: tslib.__assign({ print: (_a2 = globalCaches2.print) === null || _a2 === void 0 ? void 0 : _a2.call(globalCaches2), parser: (_b = globalCaches2.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches2), canonicalStringify: (_c = globalCaches2.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches2), links: linkInfo2(this.link), queryManager: {
          getDocumentInfo: this["queryManager"]["transformCache"].size,
          documentTransforms: transformInfo2(this["queryManager"].documentTransform)
        } }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))
      };
    }
    function isWrapper2(f) {
      return !!f && "dirtyKey" in f;
    }
    function getWrapperInformation2(f) {
      return isWrapper2(f) ? f.size : void 0;
    }
    function isDefined2(value) {
      return value != null;
    }
    function transformInfo2(transform) {
      return recurseTransformInfo2(transform).map(function(cache3) {
        return { cache: cache3 };
      });
    }
    function recurseTransformInfo2(transform) {
      return transform ? tslib.__spreadArray(tslib.__spreadArray([
        getWrapperInformation2(transform === null || transform === void 0 ? void 0 : transform["performWork"])
      ], recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined2) : [];
    }
    function linkInfo2(link) {
      var _a2;
      return link ? tslib.__spreadArray(tslib.__spreadArray([
        (_a2 = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a2 === void 0 ? void 0 : _a2.call(link)
      ], linkInfo2(link === null || link === void 0 ? void 0 : link.left), true), linkInfo2(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined2) : [];
    }
    var hasSuggestedDevtools2 = false;
    var ApolloClient2 = function() {
      function ApolloClient3(options) {
        var _this = this;
        this.resetStoreCallbacks = [];
        this.clearStoreCallbacks = [];
        if (!options.cache) {
          throw globals.newInvariantError(15);
        }
        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache3 = options.cache, documentTransform = options.documentTransform, _a2 = options.ssrMode, ssrMode = _a2 === void 0 ? false : _a2, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions2 = options.defaultOptions, defaultContext = options.defaultContext, _d = options.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? cache3.assumeImmutableResults : _d, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version, devtools = options.devtools;
        var link = options.link;
        if (!link) {
          link = uri ? new http.HttpLink({ uri, credentials, headers }) : core.ApolloLink.empty();
        }
        this.link = link;
        this.cache = cache3;
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
        this.typeDefs = typeDefs;
        this.devtoolsConfig = tslib.__assign(tslib.__assign({}, devtools), { enabled: (devtools === null || devtools === void 0 ? void 0 : devtools.enabled) || connectToDevTools });
        if (this.devtoolsConfig.enabled === void 0) {
          this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
        }
        if (ssrForceFetchDelay) {
          setTimeout(function() {
            return _this.disableNetworkFetches = false;
          }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.watchFragment = this.watchFragment.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        this.version = version3;
        this.localState = new LocalState2({
          cache: cache3,
          client: this,
          resolvers,
          fragmentMatcher
        });
        this.queryManager = new QueryManager2({
          cache: this.cache,
          link: this.link,
          defaultOptions: this.defaultOptions,
          defaultContext,
          documentTransform,
          queryDeduplication,
          ssrMode,
          clientAwareness: {
            name: clientAwarenessName,
            version: clientAwarenessVersion
          },
          localState: this.localState,
          assumeImmutableResults,
          onBroadcast: this.devtoolsConfig.enabled ? function() {
            if (_this.devToolsHookCb) {
              _this.devToolsHookCb({
                action: {},
                state: {
                  queries: _this.queryManager.getQueryStore(),
                  mutations: _this.queryManager.mutationStore || {}
                },
                dataWithOptimisticResults: _this.cache.extract(true)
              });
            }
          } : void 0
        });
        if (this.devtoolsConfig.enabled)
          this.connectToDevTools();
      }
      ApolloClient3.prototype.connectToDevTools = function() {
        if (typeof window === "undefined") {
          return;
        }
        var windowWithDevTools = window;
        var devtoolsSymbol = Symbol.for("apollo.devtools");
        (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
        windowWithDevTools.__APOLLO_CLIENT__ = this;
        if (!hasSuggestedDevtools2 && globalThis.__DEV__ !== false) {
          hasSuggestedDevtools2 = true;
          if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
            setTimeout(function() {
              if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
                var nav = window.navigator;
                var ua = nav && nav.userAgent;
                var url = void 0;
                if (typeof ua === "string") {
                  if (ua.indexOf("Chrome/") > -1) {
                    url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                  } else if (ua.indexOf("Firefox/") > -1) {
                    url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                  }
                }
                if (url) {
                  globalThis.__DEV__ !== false && globals.invariant.log("Download the Apollo DevTools for a better development experience: %s", url);
                }
              }
            }, 1e4);
          }
        }
      };
      Object.defineProperty(ApolloClient3.prototype, "documentTransform", {
        get: function() {
          return this.queryManager.documentTransform;
        },
        enumerable: false,
        configurable: true
      });
      ApolloClient3.prototype.stop = function() {
        this.queryManager.stop();
      };
      ApolloClient3.prototype.watchQuery = function(options) {
        if (this.defaultOptions.watchQuery) {
          options = utilities.mergeOptions(this.defaultOptions.watchQuery, options);
        }
        if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
          options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.watchQuery(options);
      };
      ApolloClient3.prototype.query = function(options) {
        if (this.defaultOptions.query) {
          options = utilities.mergeOptions(this.defaultOptions.query, options);
        }
        globals.invariant(options.fetchPolicy !== "cache-and-network", 16);
        if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
          options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.query(options);
      };
      ApolloClient3.prototype.mutate = function(options) {
        if (this.defaultOptions.mutate) {
          options = utilities.mergeOptions(this.defaultOptions.mutate, options);
        }
        return this.queryManager.mutate(options);
      };
      ApolloClient3.prototype.subscribe = function(options) {
        return this.queryManager.startGraphQLSubscription(options);
      };
      ApolloClient3.prototype.readQuery = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readQuery(options, optimistic);
      };
      ApolloClient3.prototype.watchFragment = function(options) {
        return this.cache.watchFragment(options);
      };
      ApolloClient3.prototype.readFragment = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readFragment(options, optimistic);
      };
      ApolloClient3.prototype.writeQuery = function(options) {
        var ref = this.cache.writeQuery(options);
        if (options.broadcast !== false) {
          this.queryManager.broadcastQueries();
        }
        return ref;
      };
      ApolloClient3.prototype.writeFragment = function(options) {
        var ref = this.cache.writeFragment(options);
        if (options.broadcast !== false) {
          this.queryManager.broadcastQueries();
        }
        return ref;
      };
      ApolloClient3.prototype.__actionHookForDevTools = function(cb) {
        this.devToolsHookCb = cb;
      };
      ApolloClient3.prototype.__requestRaw = function(payload) {
        return core.execute(this.link, payload);
      };
      ApolloClient3.prototype.resetStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: false
          });
        }).then(function() {
          return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
            return fn();
          }));
        }).then(function() {
          return _this.reFetchObservableQueries();
        });
      };
      ApolloClient3.prototype.clearStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: true
          });
        }).then(function() {
          return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
            return fn();
          }));
        });
      };
      ApolloClient3.prototype.onResetStore = function(cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function() {
          _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient3.prototype.onClearStore = function(cb) {
        var _this = this;
        this.clearStoreCallbacks.push(cb);
        return function() {
          _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient3.prototype.reFetchObservableQueries = function(includeStandby) {
        return this.queryManager.reFetchObservableQueries(includeStandby);
      };
      ApolloClient3.prototype.refetchQueries = function(options) {
        var map = this.queryManager.refetchQueries(options);
        var queries = [];
        var results = [];
        map.forEach(function(result3, obsQuery) {
          queries.push(obsQuery);
          results.push(result3);
        });
        var result2 = Promise.all(results);
        result2.queries = queries;
        result2.results = results;
        result2.catch(function(error) {
          globalThis.__DEV__ !== false && globals.invariant.debug(17, error);
        });
        return result2;
      };
      ApolloClient3.prototype.getObservableQueries = function(include) {
        if (include === void 0) {
          include = "active";
        }
        return this.queryManager.getObservableQueries(include);
      };
      ApolloClient3.prototype.extract = function(optimistic) {
        return this.cache.extract(optimistic);
      };
      ApolloClient3.prototype.restore = function(serializedState) {
        return this.cache.restore(serializedState);
      };
      ApolloClient3.prototype.addResolvers = function(resolvers) {
        this.localState.addResolvers(resolvers);
      };
      ApolloClient3.prototype.setResolvers = function(resolvers) {
        this.localState.setResolvers(resolvers);
      };
      ApolloClient3.prototype.getResolvers = function() {
        return this.localState.getResolvers();
      };
      ApolloClient3.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
        this.localState.setFragmentMatcher(fragmentMatcher);
      };
      ApolloClient3.prototype.setLink = function(newLink) {
        this.link = this.queryManager.link = newLink;
      };
      Object.defineProperty(ApolloClient3.prototype, "defaultContext", {
        get: function() {
          return this.queryManager.defaultContext;
        },
        enumerable: false,
        configurable: true
      });
      return ApolloClient3;
    }();
    if (globalThis.__DEV__ !== false) {
      ApolloClient2.prototype.getMemoryInternals = getApolloClientMemoryInternals2;
    }
    tsInvariant.setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");
    exports.DocumentTransform = utilities.DocumentTransform;
    exports.Observable = utilities.Observable;
    exports.isReference = utilities.isReference;
    exports.makeReference = utilities.makeReference;
    exports.mergeOptions = utilities.mergeOptions;
    exports.ApolloCache = cache2.ApolloCache;
    exports.Cache = cache2.Cache;
    exports.InMemoryCache = cache2.InMemoryCache;
    exports.MissingFieldError = cache2.MissingFieldError;
    exports.defaultDataIdFromObject = cache2.defaultDataIdFromObject;
    exports.makeVar = cache2.makeVar;
    exports.ApolloError = errors.ApolloError;
    exports.isApolloError = errors.isApolloError;
    exports.fromError = utils.fromError;
    exports.fromPromise = utils.fromPromise;
    exports.throwServerError = utils.throwServerError;
    exports.toPromise = utils.toPromise;
    exports.setLogVerbosity = tsInvariant.setVerbosity;
    exports.disableExperimentalFragmentVariables = graphqlTag.disableExperimentalFragmentVariables;
    exports.disableFragmentWarnings = graphqlTag.disableFragmentWarnings;
    exports.enableExperimentalFragmentVariables = graphqlTag.enableExperimentalFragmentVariables;
    exports.gql = graphqlTag.gql;
    exports.resetCaches = graphqlTag.resetCaches;
    exports.ApolloClient = ApolloClient2;
    exports.ObservableQuery = ObservableQuery2;
    exports.isNetworkRequestSettled = isNetworkRequestSettled2;
    for (k in core) {
      if (k !== "default" && !exports.hasOwnProperty(k)) exports[k] = core[k];
    }
    var k;
    for (k in http) {
      if (k !== "default" && !exports.hasOwnProperty(k)) exports[k] = http[k];
    }
    var k;
  }
});

// ../node_modules/@apollo/client/react/context/context.cjs
var require_context = __commonJS({
  "../node_modules/@apollo/client/react/context/context.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var React22 = require_rehackt();
    var utilities = require_utilities();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React22);
    var contextKey2 = utilities.canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
    function getApolloContext2() {
      globals.invariant("createContext" in React__namespace, 45);
      var context = React__namespace.createContext[contextKey2];
      if (!context) {
        Object.defineProperty(React__namespace.createContext, contextKey2, {
          value: context = React__namespace.createContext({}),
          enumerable: false,
          writable: false,
          configurable: true
        });
        context.displayName = "ApolloContext";
      }
      return context;
    }
    var resetApolloContext2 = getApolloContext2;
    var ApolloConsumer2 = function(props) {
      var ApolloContext = getApolloContext2();
      return React__namespace.createElement(ApolloContext.Consumer, null, function(context) {
        globals.invariant(context && context.client, 44);
        return props.children(context.client);
      });
    };
    var ApolloProvider2 = function(_a2) {
      var client = _a2.client, children = _a2.children;
      var ApolloContext = getApolloContext2();
      var parentContext = React__namespace.useContext(ApolloContext);
      var context = React__namespace.useMemo(function() {
        return tslib.__assign(tslib.__assign({}, parentContext), { client: client || parentContext.client });
      }, [parentContext, client]);
      globals.invariant(context.client, 46);
      return React__namespace.createElement(ApolloContext.Provider, { value: context }, children);
    };
    exports.ApolloConsumer = ApolloConsumer2;
    exports.ApolloProvider = ApolloProvider2;
    exports.getApolloContext = getApolloContext2;
    exports.resetApolloContext = resetApolloContext2;
  }
});

// ../node_modules/@apollo/client/react/parser/parser.cjs
var require_parser = __commonJS({
  "../node_modules/@apollo/client/react/parser/parser.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var utilities = require_utilities();
    init_tslib_es6();
    var globalCaches2 = {};
    function registerGlobalCache2(name, getSize) {
      globalCaches2[name] = getSize;
    }
    exports.DocumentType = void 0;
    (function(DocumentType2) {
      DocumentType2[DocumentType2["Query"] = 0] = "Query";
      DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
      DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
    })(exports.DocumentType || (exports.DocumentType = {}));
    var cache2;
    function operationName2(type) {
      var name;
      switch (type) {
        case exports.DocumentType.Query:
          name = "Query";
          break;
        case exports.DocumentType.Mutation:
          name = "Mutation";
          break;
        case exports.DocumentType.Subscription:
          name = "Subscription";
          break;
      }
      return name;
    }
    function parser2(document) {
      if (!cache2) {
        cache2 = new utilities.AutoCleanedWeakCache(utilities.cacheSizes.parser || 1e3);
      }
      var cached = cache2.get(document);
      if (cached)
        return cached;
      var variables, type, name;
      globals.invariant(!!document && !!document.kind, 61, document);
      var fragments = [];
      var queries = [];
      var mutations = [];
      var subscriptions = [];
      for (var _i = 0, _a2 = document.definitions; _i < _a2.length; _i++) {
        var x = _a2[_i];
        if (x.kind === "FragmentDefinition") {
          fragments.push(x);
          continue;
        }
        if (x.kind === "OperationDefinition") {
          switch (x.operation) {
            case "query":
              queries.push(x);
              break;
            case "mutation":
              mutations.push(x);
              break;
            case "subscription":
              subscriptions.push(x);
              break;
          }
        }
      }
      globals.invariant(!fragments.length || queries.length || mutations.length || subscriptions.length, 62);
      globals.invariant(
        queries.length + mutations.length + subscriptions.length <= 1,
        63,
        document,
        queries.length,
        subscriptions.length,
        mutations.length
      );
      type = queries.length ? exports.DocumentType.Query : exports.DocumentType.Mutation;
      if (!queries.length && !mutations.length)
        type = exports.DocumentType.Subscription;
      var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
      globals.invariant(definitions.length === 1, 64, document, definitions.length);
      var definition = definitions[0];
      variables = definition.variableDefinitions || [];
      if (definition.name && definition.name.kind === "Name") {
        name = definition.name.value;
      } else {
        name = "data";
      }
      var payload = { name, type, variables };
      cache2.set(document, payload);
      return payload;
    }
    parser2.resetCache = function() {
      cache2 = void 0;
    };
    if (globalThis.__DEV__ !== false) {
      registerGlobalCache2("parser", function() {
        return cache2 ? cache2.size : 0;
      });
    }
    function verifyDocumentType2(document, type) {
      var operation = parser2(document);
      var requiredOperationName = operationName2(type);
      var usedOperationName = operationName2(operation.type);
      globals.invariant(
        operation.type === type,
        65,
        requiredOperationName,
        requiredOperationName,
        usedOperationName
      );
    }
    exports.operationName = operationName2;
    exports.parser = parser2;
    exports.verifyDocumentType = verifyDocumentType2;
  }
});

// ../node_modules/@apollo/client/react/internal/internal.cjs
var require_internal = __commonJS({
  "../node_modules/@apollo/client/react/internal/internal.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var trie = (init_lib(), __toCommonJS(lib_exports));
    var utilities = require_utilities();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var equality = (init_lib6(), __toCommonJS(lib_exports4));
    var tsInvariant = (init_invariant(), __toCommonJS(invariant_exports));
    var version3 = "3.11.1";
    function maybe3(thunk) {
      try {
        return thunk();
      } catch (_a2) {
      }
    }
    var global$1 = maybe3(function() {
      return globalThis;
    }) || maybe3(function() {
      return window;
    }) || maybe3(function() {
      return self;
    }) || maybe3(function() {
      return global;
    }) || maybe3(function() {
      return maybe3.constructor("return this")();
    });
    var prefixCounts2 = /* @__PURE__ */ new Map();
    function makeUniqueId2(prefix) {
      var count = prefixCounts2.get(prefix) || 1;
      prefixCounts2.set(prefix, count + 1);
      return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
    }
    function stringifyForDisplay2(value, space) {
      if (space === void 0) {
        space = 0;
      }
      var undefId = makeUniqueId2("stringifyForDisplay");
      return JSON.stringify(value, function(key, value2) {
        return value2 === void 0 ? undefId : value2;
      }, space).split(JSON.stringify(undefId)).join("<undefined>");
    }
    function wrap4(fn) {
      return function(message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (typeof message === "number") {
          var arg0 = message;
          message = getHandledErrorMsg2(arg0);
          if (!message) {
            message = getFallbackErrorMsg2(arg0, args);
            args = [];
          }
        }
        fn.apply(void 0, [message].concat(args));
      };
    }
    var invariant5 = Object.assign(function invariant6(condition, message) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (!condition) {
        tsInvariant.invariant(condition, getHandledErrorMsg2(message, args) || getFallbackErrorMsg2(message, args));
      }
    }, {
      debug: wrap4(tsInvariant.invariant.debug),
      log: wrap4(tsInvariant.invariant.log),
      warn: wrap4(tsInvariant.invariant.warn),
      error: wrap4(tsInvariant.invariant.error)
    });
    var ApolloErrorMessageHandler2 = Symbol.for("ApolloErrorMessageHandler_" + version3);
    function stringify2(arg) {
      if (typeof arg == "string") {
        return arg;
      }
      try {
        return stringifyForDisplay2(arg, 2).slice(0, 1e3);
      } catch (_a2) {
        return "<non-serializable>";
      }
    }
    function getHandledErrorMsg2(message, messageArgs) {
      if (messageArgs === void 0) {
        messageArgs = [];
      }
      if (!message)
        return;
      return global$1[ApolloErrorMessageHandler2] && global$1[ApolloErrorMessageHandler2](message, messageArgs.map(stringify2));
    }
    function getFallbackErrorMsg2(message, messageArgs) {
      if (messageArgs === void 0) {
        messageArgs = [];
      }
      if (!message)
        return;
      return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
        version: version3,
        message,
        args: messageArgs.map(stringify2)
      })));
    }
    var QUERY_REFERENCE_SYMBOL2 = Symbol();
    var PROMISE_SYMBOL2 = Symbol();
    function wrapQueryRef2(internalQueryRef) {
      var _a2;
      var ref = (_a2 = {
        toPromise: function() {
          return getWrappedPromise2(ref).then(function() {
            return ref;
          });
        }
      }, _a2[QUERY_REFERENCE_SYMBOL2] = internalQueryRef, _a2[PROMISE_SYMBOL2] = internalQueryRef.promise, _a2);
      return ref;
    }
    function assertWrappedQueryRef2(queryRef) {
      invariant5(!queryRef || QUERY_REFERENCE_SYMBOL2 in queryRef, 60);
    }
    function getWrappedPromise2(queryRef) {
      var internalQueryRef = unwrapQueryRef2(queryRef);
      return internalQueryRef.promise.status === "fulfilled" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL2];
    }
    function unwrapQueryRef2(queryRef) {
      return queryRef[QUERY_REFERENCE_SYMBOL2];
    }
    function updateWrappedQueryRef2(queryRef, promise) {
      queryRef[PROMISE_SYMBOL2] = promise;
    }
    var OBSERVED_CHANGED_OPTIONS2 = [
      "canonizeResults",
      "context",
      "errorPolicy",
      "fetchPolicy",
      "refetchWritePolicy",
      "returnPartialData"
    ];
    var InternalQueryReference2 = function() {
      function InternalQueryReference3(observable, options) {
        var _this = this;
        this.key = {};
        this.listeners = /* @__PURE__ */ new Set();
        this.references = 0;
        this.softReferences = 0;
        this.handleNext = this.handleNext.bind(this);
        this.handleError = this.handleError.bind(this);
        this.dispose = this.dispose.bind(this);
        this.observable = observable;
        if (options.onDispose) {
          this.onDispose = options.onDispose;
        }
        this.setResult();
        this.subscribeToQuery();
        var startDisposeTimer = function() {
          var _a2;
          if (!_this.references) {
            _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a2 = options.autoDisposeTimeoutMs) !== null && _a2 !== void 0 ? _a2 : 3e4);
          }
        };
        this.promise.then(startDisposeTimer, startDisposeTimer);
      }
      Object.defineProperty(InternalQueryReference3.prototype, "disposed", {
        get: function() {
          return this.subscription.closed;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InternalQueryReference3.prototype, "watchQueryOptions", {
        get: function() {
          return this.observable.options;
        },
        enumerable: false,
        configurable: true
      });
      InternalQueryReference3.prototype.reinitialize = function() {
        var observable = this.observable;
        var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;
        var avoidNetworkRequests = originalFetchPolicy === "no-cache" || originalFetchPolicy === "standby";
        try {
          if (avoidNetworkRequests) {
            observable.silentSetOptions({ fetchPolicy: "standby" });
          } else {
            observable.resetLastResults();
            observable.silentSetOptions({ fetchPolicy: "cache-first" });
          }
          this.subscribeToQuery();
          if (avoidNetworkRequests) {
            return;
          }
          observable.resetDiff();
          this.setResult();
        } finally {
          observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });
        }
      };
      InternalQueryReference3.prototype.retain = function() {
        var _this = this;
        this.references++;
        clearTimeout(this.autoDisposeTimeoutId);
        var disposed = false;
        return function() {
          if (disposed) {
            return;
          }
          disposed = true;
          _this.references--;
          setTimeout(function() {
            if (!_this.references) {
              _this.dispose();
            }
          });
        };
      };
      InternalQueryReference3.prototype.softRetain = function() {
        var _this = this;
        this.softReferences++;
        var disposed = false;
        return function() {
          if (disposed) {
            return;
          }
          disposed = true;
          _this.softReferences--;
          setTimeout(function() {
            if (!_this.softReferences && !_this.references) {
              _this.dispose();
            }
          });
        };
      };
      InternalQueryReference3.prototype.didChangeOptions = function(watchQueryOptions) {
        var _this = this;
        return OBSERVED_CHANGED_OPTIONS2.some(function(option) {
          return option in watchQueryOptions && !equality.equal(_this.watchQueryOptions[option], watchQueryOptions[option]);
        });
      };
      InternalQueryReference3.prototype.applyOptions = function(watchQueryOptions) {
        var _a2 = this.watchQueryOptions, currentFetchPolicy = _a2.fetchPolicy, currentCanonizeResults = _a2.canonizeResults;
        if (currentFetchPolicy === "standby" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {
          this.initiateFetch(this.observable.reobserve(watchQueryOptions));
        } else {
          this.observable.silentSetOptions(watchQueryOptions);
          if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {
            this.result = tslib.__assign(tslib.__assign({}, this.result), this.observable.getCurrentResult());
            this.promise = utilities.createFulfilledPromise(this.result);
          }
        }
        return this.promise;
      };
      InternalQueryReference3.prototype.listen = function(listener) {
        var _this = this;
        this.listeners.add(listener);
        return function() {
          _this.listeners.delete(listener);
        };
      };
      InternalQueryReference3.prototype.refetch = function(variables) {
        return this.initiateFetch(this.observable.refetch(variables));
      };
      InternalQueryReference3.prototype.fetchMore = function(options) {
        return this.initiateFetch(this.observable.fetchMore(options));
      };
      InternalQueryReference3.prototype.dispose = function() {
        this.subscription.unsubscribe();
        this.onDispose();
      };
      InternalQueryReference3.prototype.onDispose = function() {
      };
      InternalQueryReference3.prototype.handleNext = function(result2) {
        var _a2;
        switch (this.promise.status) {
          case "pending": {
            if (result2.data === void 0) {
              result2.data = this.result.data;
            }
            this.result = result2;
            (_a2 = this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, result2);
            break;
          }
          default: {
            if (result2.data === this.result.data && result2.networkStatus === this.result.networkStatus) {
              return;
            }
            if (result2.data === void 0) {
              result2.data = this.result.data;
            }
            this.result = result2;
            this.promise = utilities.createFulfilledPromise(result2);
            this.deliver(this.promise);
            break;
          }
        }
      };
      InternalQueryReference3.prototype.handleError = function(error) {
        var _a2;
        this.subscription.unsubscribe();
        this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);
        switch (this.promise.status) {
          case "pending": {
            (_a2 = this.reject) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
            break;
          }
          default: {
            this.promise = utilities.createRejectedPromise(error);
            this.deliver(this.promise);
          }
        }
      };
      InternalQueryReference3.prototype.deliver = function(promise) {
        this.listeners.forEach(function(listener) {
          return listener(promise);
        });
      };
      InternalQueryReference3.prototype.initiateFetch = function(returnedPromise) {
        var _this = this;
        this.promise = this.createPendingPromise();
        this.promise.catch(function() {
        });
        returnedPromise.then(function() {
          setTimeout(function() {
            var _a2;
            if (_this.promise.status === "pending") {
              _this.result = _this.observable.getCurrentResult();
              (_a2 = _this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(_this, _this.result);
            }
          });
        }).catch(function() {
        });
        return returnedPromise;
      };
      InternalQueryReference3.prototype.subscribeToQuery = function() {
        var _this = this;
        this.subscription = this.observable.filter(function(result2) {
          return !equality.equal(result2.data, {}) && !equality.equal(result2, _this.result);
        }).subscribe(this.handleNext, this.handleError);
      };
      InternalQueryReference3.prototype.setResult = function() {
        var result2 = this.observable.getCurrentResult(false);
        if (equality.equal(result2, this.result)) {
          return;
        }
        this.result = result2;
        this.promise = result2.data && (!result2.partial || this.watchQueryOptions.returnPartialData) ? utilities.createFulfilledPromise(result2) : this.createPendingPromise();
      };
      InternalQueryReference3.prototype.createPendingPromise = function() {
        var _this = this;
        return utilities.wrapPromiseWithState(new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        }));
      };
      return InternalQueryReference3;
    }();
    var SuspenseCache2 = function() {
      function SuspenseCache3(options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        this.queryRefs = new trie.Trie(utilities.canUseWeakMap);
        this.options = options;
      }
      SuspenseCache3.prototype.getQueryRef = function(cacheKey, createObservable) {
        var ref = this.queryRefs.lookupArray(cacheKey);
        if (!ref.current) {
          ref.current = new InternalQueryReference2(createObservable(), {
            autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,
            onDispose: function() {
              delete ref.current;
            }
          });
        }
        return ref.current;
      };
      SuspenseCache3.prototype.add = function(cacheKey, queryRef) {
        var ref = this.queryRefs.lookupArray(cacheKey);
        ref.current = queryRef;
      };
      return SuspenseCache3;
    }();
    var suspenseCacheSymbol2 = Symbol.for("apollo.suspenseCache");
    function getSuspenseCache2(client) {
      var _a2;
      if (!client[suspenseCacheSymbol2]) {
        client[suspenseCacheSymbol2] = new SuspenseCache2((_a2 = client.defaultOptions.react) === null || _a2 === void 0 ? void 0 : _a2.suspense);
      }
      return client[suspenseCacheSymbol2];
    }
    exports.InternalQueryReference = InternalQueryReference2;
    exports.assertWrappedQueryRef = assertWrappedQueryRef2;
    exports.getSuspenseCache = getSuspenseCache2;
    exports.getWrappedPromise = getWrappedPromise2;
    exports.unwrapQueryRef = unwrapQueryRef2;
    exports.updateWrappedQueryRef = updateWrappedQueryRef2;
    exports.wrapQueryRef = wrapQueryRef2;
  }
});

// ../node_modules/@apollo/client/react/hooks/hooks.cjs
var require_hooks = __commonJS({
  "../node_modules/@apollo/client/react/hooks/hooks.cjs"(exports) {
    "use strict";
    var import_dist832 = __toESM(require_dist());
    var import_dist833 = __toESM(require_dist2());
    var import_dist834 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals();
    var React22 = require_rehackt();
    var context = require_context();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var utilities = require_utilities();
    var equal2 = (init_lib6(), __toCommonJS(lib_exports4));
    var errors = require_errors();
    var core = require_core2();
    var parser2 = require_parser();
    var internal = require_internal();
    var cache2 = require_cache();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e["default"] : e;
    }
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React22);
    var equal__default = _interopDefaultLegacy(equal2);
    function useApolloClient2(override) {
      var context$1 = React__namespace.useContext(context.getApolloContext());
      var client = override || context$1.client;
      globals.invariant(!!client, 49);
      return client;
    }
    var didWarnUncachedGetSnapshot2 = false;
    var uSESKey2 = "useSyncExternalStore";
    var realHook$1 = React__namespace[uSESKey2];
    var useSyncExternalStore2 = realHook$1 || function(subscribe2, getSnapshot, getServerSnapshot) {
      var value = getSnapshot();
      if (globalThis.__DEV__ !== false && !didWarnUncachedGetSnapshot2 && value !== getSnapshot()) {
        didWarnUncachedGetSnapshot2 = true;
        globalThis.__DEV__ !== false && globals.invariant.error(59);
      }
      var _a2 = React__namespace.useState({
        inst: { value, getSnapshot }
      }), inst = _a2[0].inst, forceUpdate = _a2[1];
      if (utilities.canUseLayoutEffect) {
        React__namespace.useLayoutEffect(function() {
          Object.assign(inst, { value, getSnapshot });
          if (checkIfSnapshotChanged2(inst)) {
            forceUpdate({ inst });
          }
        }, [subscribe2, value, getSnapshot]);
      } else {
        Object.assign(inst, { value, getSnapshot });
      }
      React__namespace.useEffect(function() {
        if (checkIfSnapshotChanged2(inst)) {
          forceUpdate({ inst });
        }
        return subscribe2(function handleStoreChange() {
          if (checkIfSnapshotChanged2(inst)) {
            forceUpdate({ inst });
          }
        });
      }, [subscribe2]);
      return value;
    };
    function checkIfSnapshotChanged2(_a2) {
      var value = _a2.value, getSnapshot = _a2.getSnapshot;
      try {
        return value !== getSnapshot();
      } catch (_b) {
        return true;
      }
    }
    function useDeepMemo2(memoFn, deps) {
      var ref = React__namespace.useRef();
      if (!ref.current || !equal2.equal(ref.current.deps, deps)) {
        ref.current = { value: memoFn(), deps };
      }
      return ref.current.value;
    }
    var useIsomorphicLayoutEffect2 = utilities.canUseDOM ? React__namespace.useLayoutEffect : React__namespace.useEffect;
    var Ctx2;
    function noop$1() {
    }
    function useRenderGuard2() {
      if (!Ctx2) {
        Ctx2 = React__namespace.createContext(null);
      }
      return React__namespace.useCallback(
        function() {
          var orig = console.error;
          try {
            console.error = noop$1;
            React__namespace["useContext"](Ctx2);
            return true;
          } catch (e) {
            return false;
          } finally {
            console.error = orig;
          }
        },
        []
      );
    }
    var INIT2 = {};
    function useLazyRef2(getInitialValue) {
      var ref = React__namespace.useRef(INIT2);
      if (ref.current === INIT2) {
        ref.current = getInitialValue();
      }
      return ref;
    }
    var useKey2 = "use";
    var realHook3 = React__namespace[useKey2];
    var __use3 = realHook3 || function __use4(promise) {
      var statefulPromise = utilities.wrapPromiseWithState(promise);
      switch (statefulPromise.status) {
        case "pending":
          throw statefulPromise;
        case "rejected":
          throw statefulPromise.reason;
        case "fulfilled":
          return statefulPromise.value;
      }
    };
    var wrapperSymbol2 = Symbol.for("apollo.hook.wrappers");
    function wrapHook2(hookName, useHook, clientOrObsQuery) {
      var queryManager = clientOrObsQuery["queryManager"];
      var wrappers = queryManager && queryManager[wrapperSymbol2];
      var wrapper = wrappers && wrappers[hookName];
      return wrapper ? wrapper(useHook) : useHook;
    }
    var hasOwnProperty11 = Object.prototype.hasOwnProperty;
    function noop4() {
    }
    var lastWatchOptions2 = Symbol();
    function useQuery2(query, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      return wrapHook2("useQuery", _useQuery2, useApolloClient2(options && options.client))(query, options);
    }
    function _useQuery2(query, options) {
      var _a2 = useQueryInternals2(query, options), result2 = _a2.result, obsQueryFields = _a2.obsQueryFields;
      return React__namespace.useMemo(function() {
        return tslib.__assign(tslib.__assign({}, result2), obsQueryFields);
      }, [result2, obsQueryFields]);
    }
    function useInternalState2(client, query, options, renderPromises, makeWatchQueryOptions) {
      function createInternalState(previous) {
        var _a3;
        parser2.verifyDocumentType(query, parser2.DocumentType.Query);
        var internalState2 = {
          client,
          query,
          observable: renderPromises && renderPromises.getSSRObservable(makeWatchQueryOptions()) || client.watchQuery(getObsQueryOptions2(void 0, client, options, makeWatchQueryOptions())),
          resultData: {
            previousData: (_a3 = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a3 === void 0 ? void 0 : _a3.data
          }
        };
        return internalState2;
      }
      var _a2 = React__namespace.useState(createInternalState), internalState = _a2[0], updateInternalState = _a2[1];
      function onQueryExecuted(watchQueryOptions) {
        var _a3;
        var _b;
        Object.assign(internalState.observable, (_a3 = {}, _a3[lastWatchOptions2] = watchQueryOptions, _a3));
        var resultData = internalState.resultData;
        updateInternalState(tslib.__assign(tslib.__assign({}, internalState), {
          query: watchQueryOptions.query,
          resultData: Object.assign(resultData, {
            previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,
            current: void 0
          })
        }));
      }
      if (client !== internalState.client || query !== internalState.query) {
        var newInternalState = createInternalState(internalState);
        updateInternalState(newInternalState);
        return [newInternalState, onQueryExecuted];
      }
      return [internalState, onQueryExecuted];
    }
    function useQueryInternals2(query, options) {
      var client = useApolloClient2(options.client);
      var renderPromises = React__namespace.useContext(context.getApolloContext()).renderPromises;
      var isSyncSSR = !!renderPromises;
      var disableNetworkFetches = client.disableNetworkFetches;
      var ssrAllowed = options.ssr !== false && !options.skip;
      var partialRefetch = options.partialRefetch;
      var makeWatchQueryOptions = createMakeWatchQueryOptions2(client, query, options, isSyncSSR);
      var _a2 = useInternalState2(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a2[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a2[1];
      var watchQueryOptions = makeWatchQueryOptions(observable);
      useResubscribeIfNecessary2(
        resultData,
        observable,
        client,
        options,
        watchQueryOptions
      );
      var obsQueryFields = React__namespace.useMemo(function() {
        return bindObservableMethods2(observable);
      }, [observable]);
      useRegisterSSRObservable2(observable, renderPromises, ssrAllowed);
      var result2 = useObservableSubscriptionResult2(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {
        onCompleted: options.onCompleted || noop4,
        onError: options.onError || noop4
      });
      return {
        result: result2,
        obsQueryFields,
        observable,
        resultData,
        client,
        onQueryExecuted
      };
    }
    function useObservableSubscriptionResult2(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {
      var callbackRef = React__namespace.useRef(callbacks);
      React__namespace.useEffect(function() {
        callbackRef.current = callbacks;
      });
      var resultOverride = (isSyncSSR || disableNetworkFetches) && options.ssr === false && !options.skip ? ssrDisabledResult2 : options.skip || watchQueryOptions.fetchPolicy === "standby" ? skipStandbyResult2 : void 0;
      var previousData = resultData.previousData;
      var currentResultOverride = React__namespace.useMemo(function() {
        return resultOverride && toQueryResult2(resultOverride, previousData, observable, client);
      }, [client, observable, resultOverride, previousData]);
      return useSyncExternalStore2(React__namespace.useCallback(function(handleStoreChange) {
        if (isSyncSSR) {
          return function() {
          };
        }
        var onNext = function() {
          var previousResult = resultData.current;
          var result2 = observable.getCurrentResult();
          if (previousResult && previousResult.loading === result2.loading && previousResult.networkStatus === result2.networkStatus && equal2.equal(previousResult.data, result2.data)) {
            return;
          }
          setResult2(result2, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
        };
        var onError = function(error) {
          subscription.current.unsubscribe();
          subscription.current = observable.resubscribeAfterError(onNext, onError);
          if (!hasOwnProperty11.call(error, "graphQLErrors")) {
            throw error;
          }
          var previousResult = resultData.current;
          if (!previousResult || previousResult && previousResult.loading || !equal2.equal(error, previousResult.error)) {
            setResult2({
              data: previousResult && previousResult.data,
              error,
              loading: false,
              networkStatus: core.NetworkStatus.error
            }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
          }
        };
        var subscription = { current: observable.subscribe(onNext, onError) };
        return function() {
          setTimeout(function() {
            return subscription.current.unsubscribe();
          });
        };
      }, [
        disableNetworkFetches,
        isSyncSSR,
        observable,
        resultData,
        partialRefetch,
        client
      ]), function() {
        return currentResultOverride || getCurrentResult2(resultData, observable, callbackRef.current, partialRefetch, client);
      }, function() {
        return currentResultOverride || getCurrentResult2(resultData, observable, callbackRef.current, partialRefetch, client);
      });
    }
    function useRegisterSSRObservable2(observable, renderPromises, ssrAllowed) {
      if (renderPromises && ssrAllowed) {
        renderPromises.registerSSRObservable(observable);
        if (observable.getCurrentResult().loading) {
          renderPromises.addObservableQueryPromise(observable);
        }
      }
    }
    function useResubscribeIfNecessary2(resultData, observable, client, options, watchQueryOptions) {
      var _a2;
      if (observable[lastWatchOptions2] && !equal2.equal(observable[lastWatchOptions2], watchQueryOptions)) {
        observable.reobserve(getObsQueryOptions2(observable, client, options, watchQueryOptions));
        resultData.previousData = ((_a2 = resultData.current) === null || _a2 === void 0 ? void 0 : _a2.data) || resultData.previousData;
        resultData.current = void 0;
      }
      observable[lastWatchOptions2] = watchQueryOptions;
    }
    function createMakeWatchQueryOptions2(client, query, _a2, isSyncSSR) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var skip = _a2.skip;
      _a2.ssr;
      _a2.onCompleted;
      _a2.onError;
      var defaultOptions2 = _a2.defaultOptions, otherOptions = tslib.__rest(_a2, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]);
      return function(observable) {
        var watchQueryOptions = Object.assign(otherOptions, { query });
        if (isSyncSSR && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
          watchQueryOptions.fetchPolicy = "cache-first";
        }
        if (!watchQueryOptions.variables) {
          watchQueryOptions.variables = {};
        }
        if (skip) {
          watchQueryOptions.initialFetchPolicy = watchQueryOptions.initialFetchPolicy || watchQueryOptions.fetchPolicy || getDefaultFetchPolicy2(defaultOptions2, client.defaultOptions);
          watchQueryOptions.fetchPolicy = "standby";
        } else if (!watchQueryOptions.fetchPolicy) {
          watchQueryOptions.fetchPolicy = (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) || getDefaultFetchPolicy2(defaultOptions2, client.defaultOptions);
        }
        return watchQueryOptions;
      };
    }
    function getObsQueryOptions2(observable, client, queryHookOptions, watchQueryOptions) {
      var toMerge = [];
      var globalDefaults = client.defaultOptions.watchQuery;
      if (globalDefaults)
        toMerge.push(globalDefaults);
      if (queryHookOptions.defaultOptions) {
        toMerge.push(queryHookOptions.defaultOptions);
      }
      toMerge.push(utilities.compact(observable && observable.options, watchQueryOptions));
      return toMerge.reduce(utilities.mergeOptions);
    }
    function setResult2(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {
      var previousResult = resultData.current;
      if (previousResult && previousResult.data) {
        resultData.previousData = previousResult.data;
      }
      if (!nextResult.error && utilities.isNonEmptyArray(nextResult.errors)) {
        nextResult.error = new errors.ApolloError({ graphQLErrors: nextResult.errors });
      }
      resultData.current = toQueryResult2(unsafeHandlePartialRefetch2(nextResult, observable, partialRefetch), resultData.previousData, observable, client);
      forceUpdate();
      handleErrorOrCompleted2(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);
    }
    function handleErrorOrCompleted2(result2, previousNetworkStatus, callbacks) {
      if (!result2.loading) {
        var error_1 = toApolloError$1(result2);
        Promise.resolve().then(function() {
          if (error_1) {
            callbacks.onError(error_1);
          } else if (result2.data && previousNetworkStatus !== result2.networkStatus && result2.networkStatus === core.NetworkStatus.ready) {
            callbacks.onCompleted(result2.data);
          }
        }).catch(function(error) {
          globalThis.__DEV__ !== false && globals.invariant.warn(error);
        });
      }
    }
    function getCurrentResult2(resultData, observable, callbacks, partialRefetch, client) {
      if (!resultData.current) {
        setResult2(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function() {
        }, callbacks);
      }
      return resultData.current;
    }
    function getDefaultFetchPolicy2(queryHookDefaultOptions, clientDefaultOptions) {
      var _a2;
      return (queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) || ((_a2 = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a2 === void 0 ? void 0 : _a2.fetchPolicy) || "cache-first";
    }
    function toApolloError$1(result2) {
      return utilities.isNonEmptyArray(result2.errors) ? new errors.ApolloError({ graphQLErrors: result2.errors }) : result2.error;
    }
    function toQueryResult2(result2, previousData, observable, client) {
      var data = result2.data;
      result2.partial;
      var resultWithoutPartial = tslib.__rest(result2, ["data", "partial"]);
      var queryResult = tslib.__assign(tslib.__assign({ data }, resultWithoutPartial), { client, observable, variables: observable.variables, called: result2 !== ssrDisabledResult2 && result2 !== skipStandbyResult2, previousData });
      return queryResult;
    }
    function unsafeHandlePartialRefetch2(result2, observable, partialRefetch) {
      if (result2.partial && partialRefetch && !result2.loading && (!result2.data || Object.keys(result2.data).length === 0) && observable.options.fetchPolicy !== "cache-only") {
        observable.refetch();
        return tslib.__assign(tslib.__assign({}, result2), { loading: true, networkStatus: core.NetworkStatus.refetch });
      }
      return result2;
    }
    var ssrDisabledResult2 = utilities.maybeDeepFreeze({
      loading: true,
      data: void 0,
      error: void 0,
      networkStatus: core.NetworkStatus.loading
    });
    var skipStandbyResult2 = utilities.maybeDeepFreeze({
      loading: false,
      data: void 0,
      error: void 0,
      networkStatus: core.NetworkStatus.ready
    });
    function bindObservableMethods2(observable) {
      return {
        refetch: observable.refetch.bind(observable),
        reobserve: observable.reobserve.bind(observable),
        fetchMore: observable.fetchMore.bind(observable),
        updateQuery: observable.updateQuery.bind(observable),
        startPolling: observable.startPolling.bind(observable),
        stopPolling: observable.stopPolling.bind(observable),
        subscribeToMore: observable.subscribeToMore.bind(observable)
      };
    }
    var EAGER_METHODS2 = [
      "refetch",
      "reobserve",
      "fetchMore",
      "updateQuery",
      "startPolling",
      "stopPolling",
      "subscribeToMore"
    ];
    function useLazyQuery2(query, options) {
      var _a2;
      var execOptionsRef = React__namespace.useRef();
      var optionsRef = React__namespace.useRef();
      var queryRef = React__namespace.useRef();
      var merged = utilities.mergeOptions(options, execOptionsRef.current || {});
      var document = (_a2 = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a2 !== void 0 ? _a2 : query;
      optionsRef.current = options;
      queryRef.current = document;
      var queryHookOptions = tslib.__assign(tslib.__assign({}, merged), { skip: !execOptionsRef.current });
      var _b = useQueryInternals2(document, queryHookOptions), obsQueryFields = _b.obsQueryFields, useQueryResult = _b.result, client = _b.client, resultData = _b.resultData, observable = _b.observable, onQueryExecuted = _b.onQueryExecuted;
      var initialFetchPolicy = observable.options.initialFetchPolicy || getDefaultFetchPolicy2(queryHookOptions.defaultOptions, client.defaultOptions);
      var forceUpdateState = React__namespace.useReducer(function(tick) {
        return tick + 1;
      }, 0)[1];
      var eagerMethods = React__namespace.useMemo(function() {
        var eagerMethods2 = {};
        var _loop_1 = function(key2) {
          var method = obsQueryFields[key2];
          eagerMethods2[key2] = function() {
            if (!execOptionsRef.current) {
              execOptionsRef.current = /* @__PURE__ */ Object.create(null);
              forceUpdateState();
            }
            return method.apply(this, arguments);
          };
        };
        for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS2; _i < EAGER_METHODS_1.length; _i++) {
          var key = EAGER_METHODS_1[_i];
          _loop_1(key);
        }
        return eagerMethods2;
      }, [forceUpdateState, obsQueryFields]);
      var called = !!execOptionsRef.current;
      var result2 = React__namespace.useMemo(function() {
        return tslib.__assign(tslib.__assign(tslib.__assign({}, useQueryResult), eagerMethods), { called });
      }, [useQueryResult, eagerMethods, called]);
      var execute3 = React__namespace.useCallback(function(executeOptions) {
        execOptionsRef.current = executeOptions ? tslib.__assign(tslib.__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {
          fetchPolicy: initialFetchPolicy
        };
        var options2 = utilities.mergeOptions(optionsRef.current, tslib.__assign({ query: queryRef.current }, execOptionsRef.current));
        var promise = executeQuery2(resultData, observable, client, document, tslib.__assign(tslib.__assign({}, options2), { skip: false }), onQueryExecuted).then(function(queryResult) {
          return Object.assign(queryResult, eagerMethods);
        });
        promise.catch(function() {
        });
        return promise;
      }, [
        client,
        document,
        eagerMethods,
        initialFetchPolicy,
        observable,
        resultData,
        onQueryExecuted
      ]);
      var executeRef = React__namespace.useRef(execute3);
      useIsomorphicLayoutEffect2(function() {
        executeRef.current = execute3;
      });
      var stableExecute = React__namespace.useCallback(function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return executeRef.current.apply(executeRef, args);
      }, []);
      return [stableExecute, result2];
    }
    function executeQuery2(resultData, observable, client, currentQuery, options, onQueryExecuted) {
      var query = options.query || currentQuery;
      var watchQueryOptions = createMakeWatchQueryOptions2(client, query, options, false)(observable);
      var concast = observable.reobserveAsConcast(getObsQueryOptions2(observable, client, options, watchQueryOptions));
      onQueryExecuted(watchQueryOptions);
      return new Promise(function(resolve) {
        var result2;
        concast.subscribe({
          next: function(value) {
            result2 = value;
          },
          error: function() {
            resolve(toQueryResult2(observable.getCurrentResult(), resultData.previousData, observable, client));
          },
          complete: function() {
            resolve(toQueryResult2(result2, resultData.previousData, observable, client));
          }
        });
      });
    }
    function useMutation2(mutation, options) {
      var client = useApolloClient2(options === null || options === void 0 ? void 0 : options.client);
      parser2.verifyDocumentType(mutation, parser2.DocumentType.Mutation);
      var _a2 = React__namespace.useState({
        called: false,
        loading: false,
        client
      }), result2 = _a2[0], setResult3 = _a2[1];
      var ref = React__namespace.useRef({
        result: result2,
        mutationId: 0,
        isMounted: true,
        client,
        mutation,
        options
      });
      useIsomorphicLayoutEffect2(function() {
        Object.assign(ref.current, { client, options, mutation });
      });
      var execute3 = React__namespace.useCallback(function(executeOptions) {
        if (executeOptions === void 0) {
          executeOptions = {};
        }
        var _a3 = ref.current, options2 = _a3.options, mutation2 = _a3.mutation;
        var baseOptions = tslib.__assign(tslib.__assign({}, options2), { mutation: mutation2 });
        var client2 = executeOptions.client || ref.current.client;
        if (!ref.current.result.loading && !baseOptions.ignoreResults && ref.current.isMounted) {
          setResult3(ref.current.result = {
            loading: true,
            error: void 0,
            data: void 0,
            called: true,
            client: client2
          });
        }
        var mutationId = ++ref.current.mutationId;
        var clientOptions = utilities.mergeOptions(baseOptions, executeOptions);
        return client2.mutate(clientOptions).then(function(response) {
          var _a4, _b;
          var data = response.data, errors$1 = response.errors;
          var error = errors$1 && errors$1.length > 0 ? new errors.ApolloError({ graphQLErrors: errors$1 }) : void 0;
          var onError = executeOptions.onError || ((_a4 = ref.current.options) === null || _a4 === void 0 ? void 0 : _a4.onError);
          if (error && onError) {
            onError(error, clientOptions);
          }
          if (mutationId === ref.current.mutationId && !clientOptions.ignoreResults) {
            var result_1 = {
              called: true,
              loading: false,
              data,
              error,
              client: client2
            };
            if (ref.current.isMounted && !equal2.equal(ref.current.result, result_1)) {
              setResult3(ref.current.result = result_1);
            }
          }
          var onCompleted = executeOptions.onCompleted || ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onCompleted);
          if (!error) {
            onCompleted === null || onCompleted === void 0 ? void 0 : onCompleted(response.data, clientOptions);
          }
          return response;
        }).catch(function(error) {
          var _a4;
          if (mutationId === ref.current.mutationId && ref.current.isMounted) {
            var result_2 = {
              loading: false,
              error,
              data: void 0,
              called: true,
              client: client2
            };
            if (!equal2.equal(ref.current.result, result_2)) {
              setResult3(ref.current.result = result_2);
            }
          }
          var onError = executeOptions.onError || ((_a4 = ref.current.options) === null || _a4 === void 0 ? void 0 : _a4.onError);
          if (onError) {
            onError(error, clientOptions);
            return { data: void 0, errors: error };
          }
          throw error;
        });
      }, []);
      var reset = React__namespace.useCallback(function() {
        if (ref.current.isMounted) {
          var result_3 = {
            called: false,
            loading: false,
            client: ref.current.client
          };
          Object.assign(ref.current, { mutationId: 0, result: result_3 });
          setResult3(result_3);
        }
      }, []);
      React__namespace.useEffect(function() {
        var current = ref.current;
        current.isMounted = true;
        return function() {
          current.isMounted = false;
        };
      }, []);
      return [execute3, tslib.__assign({ reset }, result2)];
    }
    function useSubscription2(subscription, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      var hasIssuedDeprecationWarningRef = React__namespace.useRef(false);
      var client = useApolloClient2(options.client);
      parser2.verifyDocumentType(subscription, parser2.DocumentType.Subscription);
      if (!hasIssuedDeprecationWarningRef.current) {
        hasIssuedDeprecationWarningRef.current = true;
        if (options.onSubscriptionData) {
          globalThis.__DEV__ !== false && globals.invariant.warn(options.onData ? 52 : 53);
        }
        if (options.onSubscriptionComplete) {
          globalThis.__DEV__ !== false && globals.invariant.warn(options.onComplete ? 54 : 55);
        }
      }
      var skip = options.skip, fetchPolicy = options.fetchPolicy, errorPolicy = options.errorPolicy, shouldResubscribe = options.shouldResubscribe, context2 = options.context, extensions = options.extensions, ignoreResults = options.ignoreResults;
      var variables = useDeepMemo2(function() {
        return options.variables;
      }, [options.variables]);
      var recreate = function() {
        return createSubscription2(client, subscription, variables, fetchPolicy, errorPolicy, context2, extensions);
      };
      var _a2 = React__namespace.useState(options.skip ? null : recreate), observable = _a2[0], setObservable = _a2[1];
      var recreateRef = React__namespace.useRef(recreate);
      useIsomorphicLayoutEffect2(function() {
        recreateRef.current = recreate;
      });
      if (skip) {
        if (observable) {
          setObservable(observable = null);
        }
      } else if (!observable || (client !== observable.__.client || subscription !== observable.__.query || fetchPolicy !== observable.__.fetchPolicy || errorPolicy !== observable.__.errorPolicy || !equal2.equal(variables, observable.__.variables)) && (typeof shouldResubscribe === "function" ? !!shouldResubscribe(options) : shouldResubscribe) !== false) {
        setObservable(observable = recreate());
      }
      var optionsRef = React__namespace.useRef(options);
      React__namespace.useEffect(function() {
        optionsRef.current = options;
      });
      var fallbackLoading = !skip && !ignoreResults;
      var fallbackResult = React__namespace.useMemo(function() {
        return {
          loading: fallbackLoading,
          error: void 0,
          data: void 0,
          variables
        };
      }, [fallbackLoading, variables]);
      var ignoreResultsRef = React__namespace.useRef(ignoreResults);
      useIsomorphicLayoutEffect2(function() {
        ignoreResultsRef.current = ignoreResults;
      });
      var ret = useSyncExternalStore2(React__namespace.useCallback(function(update) {
        if (!observable) {
          return function() {
          };
        }
        var subscriptionStopped = false;
        var variables2 = observable.__.variables;
        var client2 = observable.__.client;
        var subscription2 = observable.subscribe({
          next: function(fetchResult) {
            var _a3, _b;
            if (subscriptionStopped) {
              return;
            }
            var result2 = {
              loading: false,
              data: fetchResult.data,
              error: toApolloError$1(fetchResult),
              variables: variables2
            };
            observable.__.setResult(result2);
            if (!ignoreResultsRef.current)
              update();
            if (result2.error) {
              (_b = (_a3 = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a3, result2.error);
            } else if (optionsRef.current.onData) {
              optionsRef.current.onData({
                client: client2,
                data: result2
              });
            } else if (optionsRef.current.onSubscriptionData) {
              optionsRef.current.onSubscriptionData({
                client: client2,
                subscriptionData: result2
              });
            }
          },
          error: function(error) {
            var _a3, _b;
            error = error instanceof core.ApolloError ? error : new core.ApolloError({ protocolErrors: [error] });
            if (!subscriptionStopped) {
              observable.__.setResult({
                loading: false,
                data: void 0,
                error,
                variables: variables2
              });
              if (!ignoreResultsRef.current)
                update();
              (_b = (_a3 = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a3, error);
            }
          },
          complete: function() {
            if (!subscriptionStopped) {
              if (optionsRef.current.onComplete) {
                optionsRef.current.onComplete();
              } else if (optionsRef.current.onSubscriptionComplete) {
                optionsRef.current.onSubscriptionComplete();
              }
            }
          }
        });
        return function() {
          subscriptionStopped = true;
          setTimeout(function() {
            subscription2.unsubscribe();
          });
        };
      }, [observable]), function() {
        return observable && !skip && !ignoreResults ? observable.__.result : fallbackResult;
      });
      return React__namespace.useMemo(function() {
        return tslib.__assign(tslib.__assign({}, ret), { restart: function() {
          globals.invariant(!optionsRef.current.skip, 56);
          setObservable(recreateRef.current());
        } });
      }, [ret]);
    }
    function createSubscription2(client, query, variables, fetchPolicy, errorPolicy, context2, extensions) {
      var options = {
        query,
        variables,
        fetchPolicy,
        errorPolicy,
        context: context2,
        extensions
      };
      var __ = tslib.__assign(tslib.__assign({}, options), { client, result: {
        loading: true,
        data: void 0,
        error: void 0,
        variables
      }, setResult: function(result2) {
        __.result = result2;
      } });
      var observable = null;
      return Object.assign(new core.Observable(function(observer) {
        if (!observable) {
          observable = client.subscribe(options);
        }
        var sub = observable.subscribe(observer);
        return function() {
          return sub.unsubscribe();
        };
      }), {
        __
      });
    }
    function useReactiveVar2(rv) {
      return useSyncExternalStore2(React__namespace.useCallback(function(update) {
        return rv.onNextChange(function onNext() {
          update();
          rv.onNextChange(onNext);
        });
      }, [rv]), rv, rv);
    }
    function useFragment2(options) {
      return wrapHook2("useFragment", _useFragment2, useApolloClient2(options.client))(options);
    }
    function _useFragment2(options) {
      var cache3 = useApolloClient2(options.client).cache;
      var diffOptions = useDeepMemo2(function() {
        var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, rest = tslib.__rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
        return tslib.__assign(tslib.__assign({}, rest), { returnPartialData: true, id: typeof from2 === "string" ? from2 : cache3.identify(from2), query: cache3["getFragmentDoc"](fragment, fragmentName), optimistic });
      }, [options]);
      var resultRef = useLazyRef2(function() {
        return diffToResult2(cache3.diff(diffOptions));
      });
      var stableOptions = useDeepMemo2(function() {
        return options;
      }, [options]);
      React__namespace.useMemo(function() {
        resultRef.current = diffToResult2(cache3.diff(diffOptions));
      }, [diffOptions, cache3]);
      var getSnapshot = React__namespace.useCallback(function() {
        return resultRef.current;
      }, []);
      return useSyncExternalStore2(React__namespace.useCallback(function(forceUpdate) {
        var lastTimeout = 0;
        var subscription = cache3.watchFragment(stableOptions).subscribe({
          next: function(result2) {
            if (equal__default(result2, resultRef.current))
              return;
            resultRef.current = result2;
            clearTimeout(lastTimeout);
            lastTimeout = setTimeout(forceUpdate);
          }
        });
        return function() {
          subscription.unsubscribe();
          clearTimeout(lastTimeout);
        };
      }, [cache3, stableOptions]), getSnapshot, getSnapshot);
    }
    function diffToResult2(diff2) {
      var result2 = {
        data: diff2.result,
        complete: !!diff2.complete
      };
      if (diff2.missing) {
        result2.missing = utilities.mergeDeepArray(diff2.missing.map(function(error) {
          return error.missing;
        }));
      }
      return result2;
    }
    var skipToken2 = Symbol.for("apollo.skipToken");
    function useSuspenseQuery2(query, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      return wrapHook2("useSuspenseQuery", _useSuspenseQuery2, useApolloClient2(typeof options === "object" ? options.client : void 0))(query, options);
    }
    function _useSuspenseQuery2(query, options) {
      var client = useApolloClient2(options.client);
      var suspenseCache = internal.getSuspenseCache(client);
      var watchQueryOptions = useWatchQueryOptions2({
        client,
        query,
        options
      });
      var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
      var _a2 = options.queryKey, queryKey = _a2 === void 0 ? [] : _a2;
      var cacheKey = tslib.__spreadArray([
        query,
        cache2.canonicalStringify(variables)
      ], [].concat(queryKey), true);
      var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
        return client.watchQuery(watchQueryOptions);
      });
      var _b = React__namespace.useState([queryRef.key, queryRef.promise]), current = _b[0], setPromise = _b[1];
      if (current[0] !== queryRef.key) {
        current[0] = queryRef.key;
        current[1] = queryRef.promise;
      }
      var promise = current[1];
      if (queryRef.didChangeOptions(watchQueryOptions)) {
        current[1] = promise = queryRef.applyOptions(watchQueryOptions);
      }
      React__namespace.useEffect(function() {
        var dispose = queryRef.retain();
        var removeListener = queryRef.listen(function(promise2) {
          setPromise([queryRef.key, promise2]);
        });
        return function() {
          removeListener();
          dispose();
        };
      }, [queryRef]);
      var skipResult = React__namespace.useMemo(function() {
        var error = toApolloError3(queryRef.result);
        return {
          loading: false,
          data: queryRef.result.data,
          networkStatus: error ? core.NetworkStatus.error : core.NetworkStatus.ready,
          error
        };
      }, [queryRef.result]);
      var result2 = fetchPolicy === "standby" ? skipResult : __use3(promise);
      var fetchMore = React__namespace.useCallback(function(options2) {
        var promise2 = queryRef.fetchMore(options2);
        setPromise([queryRef.key, queryRef.promise]);
        return promise2;
      }, [queryRef]);
      var refetch = React__namespace.useCallback(function(variables2) {
        var promise2 = queryRef.refetch(variables2);
        setPromise([queryRef.key, queryRef.promise]);
        return promise2;
      }, [queryRef]);
      var subscribeToMore = queryRef.observable.subscribeToMore;
      return React__namespace.useMemo(function() {
        return {
          client,
          data: result2.data,
          error: toApolloError3(result2),
          networkStatus: result2.networkStatus,
          fetchMore,
          refetch,
          subscribeToMore
        };
      }, [client, fetchMore, refetch, result2, subscribeToMore]);
    }
    function validateOptions2(options) {
      var query = options.query, fetchPolicy = options.fetchPolicy, returnPartialData = options.returnPartialData;
      parser2.verifyDocumentType(query, parser2.DocumentType.Query);
      validateFetchPolicy2(fetchPolicy);
      validatePartialDataReturn2(fetchPolicy, returnPartialData);
    }
    function validateFetchPolicy2(fetchPolicy) {
      if (fetchPolicy === void 0) {
        fetchPolicy = "cache-first";
      }
      var supportedFetchPolicies = [
        "cache-first",
        "network-only",
        "no-cache",
        "cache-and-network"
      ];
      globals.invariant(supportedFetchPolicies.includes(fetchPolicy), 57, fetchPolicy);
    }
    function validatePartialDataReturn2(fetchPolicy, returnPartialData) {
      if (fetchPolicy === "no-cache" && returnPartialData) {
        globalThis.__DEV__ !== false && globals.invariant.warn(58);
      }
    }
    function toApolloError3(result2) {
      return utilities.isNonEmptyArray(result2.errors) ? new core.ApolloError({ graphQLErrors: result2.errors }) : result2.error;
    }
    function useWatchQueryOptions2(_a2) {
      var client = _a2.client, query = _a2.query, options = _a2.options;
      return useDeepMemo2(function() {
        var _a3;
        if (options === skipToken2) {
          return { query, fetchPolicy: "standby" };
        }
        var fetchPolicy = options.fetchPolicy || ((_a3 = client.defaultOptions.watchQuery) === null || _a3 === void 0 ? void 0 : _a3.fetchPolicy) || "cache-first";
        var watchQueryOptions = tslib.__assign(tslib.__assign({}, options), { fetchPolicy, query, notifyOnNetworkStatusChange: false, nextFetchPolicy: void 0 });
        if (globalThis.__DEV__ !== false) {
          validateOptions2(watchQueryOptions);
        }
        if (options.skip) {
          watchQueryOptions.fetchPolicy = "standby";
        }
        return watchQueryOptions;
      }, [client, options, query]);
    }
    function useBackgroundQuery2(query, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      return wrapHook2("useBackgroundQuery", _useBackgroundQuery2, useApolloClient2(typeof options === "object" ? options.client : void 0))(query, options);
    }
    function _useBackgroundQuery2(query, options) {
      var client = useApolloClient2(options.client);
      var suspenseCache = internal.getSuspenseCache(client);
      var watchQueryOptions = useWatchQueryOptions2({ client, query, options });
      var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
      var _a2 = options.queryKey, queryKey = _a2 === void 0 ? [] : _a2;
      var didFetchResult = React__namespace.useRef(fetchPolicy !== "standby");
      didFetchResult.current || (didFetchResult.current = fetchPolicy !== "standby");
      var cacheKey = tslib.__spreadArray([
        query,
        cache2.canonicalStringify(variables)
      ], [].concat(queryKey), true);
      var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
        return client.watchQuery(watchQueryOptions);
      });
      var _b = React__namespace.useState(internal.wrapQueryRef(queryRef)), wrappedQueryRef = _b[0], setWrappedQueryRef = _b[1];
      if (internal.unwrapQueryRef(wrappedQueryRef) !== queryRef) {
        setWrappedQueryRef(internal.wrapQueryRef(queryRef));
      }
      if (queryRef.didChangeOptions(watchQueryOptions)) {
        var promise = queryRef.applyOptions(watchQueryOptions);
        internal.updateWrappedQueryRef(wrappedQueryRef, promise);
      }
      React__namespace.useEffect(function() {
        var id = setTimeout(function() {
          if (queryRef.disposed) {
            suspenseCache.add(cacheKey, queryRef);
          }
        });
        return function() {
          return clearTimeout(id);
        };
      });
      var fetchMore = React__namespace.useCallback(function(options2) {
        var promise2 = queryRef.fetchMore(options2);
        setWrappedQueryRef(internal.wrapQueryRef(queryRef));
        return promise2;
      }, [queryRef]);
      var refetch = React__namespace.useCallback(function(variables2) {
        var promise2 = queryRef.refetch(variables2);
        setWrappedQueryRef(internal.wrapQueryRef(queryRef));
        return promise2;
      }, [queryRef]);
      React__namespace.useEffect(function() {
        return queryRef.softRetain();
      }, [queryRef]);
      return [
        didFetchResult.current ? wrappedQueryRef : void 0,
        {
          fetchMore,
          refetch,
          subscribeToMore: queryRef.observable.subscribeToMore
        }
      ];
    }
    function useLoadableQuery2(query, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      var client = useApolloClient2(options.client);
      var suspenseCache = internal.getSuspenseCache(client);
      var watchQueryOptions = useWatchQueryOptions2({ client, query, options });
      var _a2 = options.queryKey, queryKey = _a2 === void 0 ? [] : _a2;
      var _b = React__namespace.useState(null), queryRef = _b[0], setQueryRef = _b[1];
      internal.assertWrappedQueryRef(queryRef);
      var internalQueryRef = queryRef && internal.unwrapQueryRef(queryRef);
      if (queryRef && (internalQueryRef === null || internalQueryRef === void 0 ? void 0 : internalQueryRef.didChangeOptions(watchQueryOptions))) {
        var promise = internalQueryRef.applyOptions(watchQueryOptions);
        internal.updateWrappedQueryRef(queryRef, promise);
      }
      var calledDuringRender = useRenderGuard2();
      var fetchMore = React__namespace.useCallback(function(options2) {
        if (!internalQueryRef) {
          throw new Error("The query has not been loaded. Please load the query.");
        }
        var promise2 = internalQueryRef.fetchMore(options2);
        setQueryRef(internal.wrapQueryRef(internalQueryRef));
        return promise2;
      }, [internalQueryRef]);
      var refetch = React__namespace.useCallback(function(options2) {
        if (!internalQueryRef) {
          throw new Error("The query has not been loaded. Please load the query.");
        }
        var promise2 = internalQueryRef.refetch(options2);
        setQueryRef(internal.wrapQueryRef(internalQueryRef));
        return promise2;
      }, [internalQueryRef]);
      var loadQuery = React__namespace.useCallback(function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        globals.invariant(!calledDuringRender(), 50);
        var variables = args[0];
        var cacheKey = tslib.__spreadArray([
          query,
          cache2.canonicalStringify(variables)
        ], [].concat(queryKey), true);
        var queryRef2 = suspenseCache.getQueryRef(cacheKey, function() {
          return client.watchQuery(tslib.__assign(tslib.__assign({}, watchQueryOptions), { variables }));
        });
        setQueryRef(internal.wrapQueryRef(queryRef2));
      }, [
        query,
        queryKey,
        suspenseCache,
        watchQueryOptions,
        calledDuringRender,
        client
      ]);
      var subscribeToMore = React__namespace.useCallback(function(options2) {
        globals.invariant(internalQueryRef, 51);
        return internalQueryRef.observable.subscribeToMore(options2);
      }, [internalQueryRef]);
      var reset = React__namespace.useCallback(function() {
        setQueryRef(null);
      }, []);
      return [loadQuery, queryRef, { fetchMore, refetch, reset, subscribeToMore }];
    }
    function useQueryRefHandlers2(queryRef) {
      var unwrapped = internal.unwrapQueryRef(queryRef);
      return wrapHook2("useQueryRefHandlers", _useQueryRefHandlers2, unwrapped ? unwrapped["observable"] : useApolloClient2())(queryRef);
    }
    function _useQueryRefHandlers2(queryRef) {
      internal.assertWrappedQueryRef(queryRef);
      var _a2 = React__namespace.useState(queryRef), previousQueryRef = _a2[0], setPreviousQueryRef = _a2[1];
      var _b = React__namespace.useState(queryRef), wrappedQueryRef = _b[0], setWrappedQueryRef = _b[1];
      var internalQueryRef = internal.unwrapQueryRef(queryRef);
      if (previousQueryRef !== queryRef) {
        setPreviousQueryRef(queryRef);
        setWrappedQueryRef(queryRef);
      } else {
        internal.updateWrappedQueryRef(queryRef, internal.getWrappedPromise(wrappedQueryRef));
      }
      var refetch = React__namespace.useCallback(function(variables) {
        var promise = internalQueryRef.refetch(variables);
        setWrappedQueryRef(internal.wrapQueryRef(internalQueryRef));
        return promise;
      }, [internalQueryRef]);
      var fetchMore = React__namespace.useCallback(function(options) {
        var promise = internalQueryRef.fetchMore(options);
        setWrappedQueryRef(internal.wrapQueryRef(internalQueryRef));
        return promise;
      }, [internalQueryRef]);
      return {
        refetch,
        fetchMore,
        subscribeToMore: internalQueryRef.observable.subscribeToMore
      };
    }
    function useReadQuery2(queryRef) {
      var unwrapped = internal.unwrapQueryRef(queryRef);
      return wrapHook2("useReadQuery", _useReadQuery2, unwrapped ? unwrapped["observable"] : useApolloClient2())(queryRef);
    }
    function _useReadQuery2(queryRef) {
      internal.assertWrappedQueryRef(queryRef);
      var internalQueryRef = React__namespace.useMemo(function() {
        return internal.unwrapQueryRef(queryRef);
      }, [queryRef]);
      var getPromise = React__namespace.useCallback(function() {
        return internal.getWrappedPromise(queryRef);
      }, [queryRef]);
      if (internalQueryRef.disposed) {
        internalQueryRef.reinitialize();
        internal.updateWrappedQueryRef(queryRef, internalQueryRef.promise);
      }
      React__namespace.useEffect(function() {
        return internalQueryRef.retain();
      }, [internalQueryRef]);
      var promise = useSyncExternalStore2(React__namespace.useCallback(function(forceUpdate) {
        return internalQueryRef.listen(function(promise2) {
          internal.updateWrappedQueryRef(queryRef, promise2);
          forceUpdate();
        });
      }, [internalQueryRef, queryRef]), getPromise, getPromise);
      var result2 = __use3(promise);
      return React__namespace.useMemo(function() {
        return {
          data: result2.data,
          networkStatus: result2.networkStatus,
          error: toApolloError3(result2)
        };
      }, [result2]);
    }
    exports.skipToken = skipToken2;
    exports.useApolloClient = useApolloClient2;
    exports.useBackgroundQuery = useBackgroundQuery2;
    exports.useFragment = useFragment2;
    exports.useLazyQuery = useLazyQuery2;
    exports.useLoadableQuery = useLoadableQuery2;
    exports.useMutation = useMutation2;
    exports.useQuery = useQuery2;
    exports.useQueryRefHandlers = useQueryRefHandlers2;
    exports.useReactiveVar = useReactiveVar2;
    exports.useReadQuery = useReadQuery2;
    exports.useSubscription = useSubscription2;
    exports.useSuspenseQuery = useSuspenseQuery2;
  }
});

export {
  tslib_es6_exports,
  init_tslib_es6,
  OperationTypeNode,
  Kind,
  print,
  graphql_exports,
  init_graphql2 as init_graphql,
  Observable,
  init_Observable,
  ApolloLink,
  init_ApolloLink,
  split,
  parseAndCheckHttpResponse,
  init_parseAndCheckHttpResponse,
  serializeFetchParameter,
  init_serializeFetchParameter,
  fallbackHttpConfig,
  defaultPrinter,
  selectHttpOptionsAndBodyInternal,
  init_selectHttpOptionsAndBody,
  createSignalIfSupported,
  init_createSignalIfSupported,
  selectURI,
  init_selectURI,
  rewriteURIForGET,
  init_rewriteURIForGET,
  InMemoryCache,
  ApolloClient,
  ApolloProvider,
  useFragment,
  client_exports,
  init_client,
  require_globals,
  require_utilities,
  require_cache,
  require_core,
  require_core2,
  require_hooks
};
//# sourceMappingURL=chunk-3TST5VV5.js.map
