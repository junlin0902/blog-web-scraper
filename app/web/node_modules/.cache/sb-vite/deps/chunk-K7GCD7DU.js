import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  FetchConfigProvider,
  GraphQLHooksProvider,
  fragmentRegistry,
  useFetchConfig
} from "./chunk-7CKJ3ULP.js";
import {
  useNoAuth
} from "./chunk-LKKP6PRA.js";
import {
  require_context,
  require_persisted_queries,
  require_printer
} from "./chunk-2S742LIG.js";
import {
  ApolloClient,
  ApolloLink,
  ApolloProvider,
  InMemoryCache,
  Kind,
  Observable,
  OperationTypeNode,
  createSignalIfSupported,
  defaultPrinter,
  fallbackHttpConfig,
  init_ApolloLink,
  init_Observable,
  init_client,
  init_createSignalIfSupported,
  init_graphql,
  init_parseAndCheckHttpResponse,
  init_rewriteURIForGET,
  init_selectHttpOptionsAndBody,
  init_selectURI,
  init_serializeFetchParameter,
  parseAndCheckHttpResponse,
  print,
  require_core,
  require_core2,
  require_hooks,
  require_utilities,
  rewriteURIForGET,
  selectHttpOptionsAndBodyInternal,
  selectURI,
  serializeFetchParameter,
  split
} from "./chunk-3TST5VV5.js";
import {
  require_react
} from "./chunk-52LGRYSO.js";
import {
  __export,
  __publicField,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-QGZREBOA.js";

// ../node_modules/@redwoodjs/web/dist/apollo/index.js
var import_dist49 = __toESM(require_dist());
var import_dist50 = __toESM(require_dist2());
var import_dist51 = __toESM(require_dist3());
var import_react = __toESM(require_react());
init_client();
var import_core2 = __toESM(require_core2());
var import_context = __toESM(require_context());
var import_persisted_queries = __toESM(require_persisted_queries());
var import_hooks2 = __toESM(require_hooks());
var import_utilities2 = __toESM(require_utilities());
var import_printer = __toESM(require_printer());

// ../node_modules/@redwoodjs/web/dist/apollo/typeOverride.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);

// ../node_modules/@redwoodjs/web/dist/bundled/apollo-upload-client.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// ../node_modules/apollo-upload-client/createUploadLink.mjs
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
init_ApolloLink();
init_createSignalIfSupported();
init_parseAndCheckHttpResponse();
init_rewriteURIForGET();
init_selectHttpOptionsAndBody();
init_selectURI();
init_serializeFetchParameter();
init_Observable();

// ../node_modules/extract-files/extractFiles.mjs
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);

// ../node_modules/is-plain-obj/index.js
var import_dist4 = __toESM(require_dist());
var import_dist5 = __toESM(require_dist2());
var import_dist6 = __toESM(require_dist3());
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// ../node_modules/extract-files/extractFiles.mjs
function extractFiles(value, isExtractable, path = "") {
  if (!arguments.length) throw new TypeError("Argument 1 `value` is required.");
  if (typeof isExtractable !== "function")
    throw new TypeError("Argument 2 `isExtractable` must be a function.");
  if (typeof path !== "string")
    throw new TypeError("Argument 3 `path` must be a string.");
  const clones = /* @__PURE__ */ new Map();
  const files = /* @__PURE__ */ new Map();
  function recurse(value2, path2, recursed) {
    if (isExtractable(value2)) {
      const filePaths = files.get(value2);
      filePaths ? filePaths.push(path2) : files.set(value2, [path2]);
      return null;
    }
    const valueIsList = Array.isArray(value2) || typeof FileList !== "undefined" && value2 instanceof FileList;
    const valueIsPlainObject = isPlainObject(value2);
    if (valueIsList || valueIsPlainObject) {
      let clone = clones.get(value2);
      const uncloned = !clone;
      if (uncloned) {
        clone = valueIsList ? [] : (
          // Replicate if the plain object is an `Object` instance.
          value2 instanceof /** @type {any} */
          Object ? {} : /* @__PURE__ */ Object.create(null)
        );
        clones.set(
          value2,
          /** @type {Clone} */
          clone
        );
      }
      if (!recursed.has(value2)) {
        const pathPrefix = path2 ? `${path2}.` : "";
        const recursedDeeper = new Set(recursed).add(value2);
        if (valueIsList) {
          let index = 0;
          for (const item of value2) {
            const itemClone = recurse(
              item,
              pathPrefix + index++,
              recursedDeeper
            );
            if (uncloned) clone.push(itemClone);
          }
        } else
          for (const key in value2) {
            const propertyClone = recurse(
              value2[key],
              pathPrefix + key,
              recursedDeeper
            );
            if (uncloned)
              clone[key] = propertyClone;
          }
      }
      return clone;
    }
    return value2;
  }
  return {
    clone: recurse(value, path, /* @__PURE__ */ new Set()),
    files
  };
}

// ../node_modules/apollo-upload-client/formDataAppendFile.mjs
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
function formDataAppendFile(formData, fieldName, file) {
  "name" in file ? formData.append(fieldName, file, file.name) : formData.append(fieldName, file);
}

// ../node_modules/apollo-upload-client/isExtractableFile.mjs
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);

// ../node_modules/extract-files/isExtractableFile.mjs
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
function isExtractableFile(value) {
  return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob;
}

// ../node_modules/apollo-upload-client/createUploadLink.mjs
function createUploadLink({
  uri: fetchUri = "/graphql",
  useGETForQueries,
  isExtractableFile: customIsExtractableFile = isExtractableFile,
  FormData: CustomFormData,
  formDataAppendFile: customFormDataAppendFile = formDataAppendFile,
  print: print4 = defaultPrinter,
  fetch: customFetch,
  fetchOptions,
  credentials,
  headers,
  includeExtensions
} = {}) {
  const linkConfig = {
    http: { includeExtensions },
    options: fetchOptions,
    credentials,
    headers
  };
  return new ApolloLink((operation) => {
    const context = (
      /**
       * @type {import("@apollo/client/core/types.js").DefaultContext & {
       *   clientAwareness?: {
       *     name?: string,
       *     version?: string,
       *   },
       * }}
       */
      operation.getContext()
    );
    const {
      // Apollo Studio client awareness `name` and `version` can be configured
      // via `ApolloClient` constructor options:
      // https://www.apollographql.com/docs/graphos/metrics/client-awareness/#setup
      clientAwareness: { name, version } = {},
      headers: headers2
    } = context;
    const contextConfig = {
      http: context.http,
      options: context.fetchOptions,
      credentials: context.credentials,
      headers: {
        // Client awareness headers can be overridden by context `headers`.
        ...name && { "apollographql-client-name": name },
        ...version && { "apollographql-client-version": version },
        ...headers2
      }
    };
    const { options, body } = selectHttpOptionsAndBodyInternal(
      operation,
      print4,
      fallbackHttpConfig,
      linkConfig,
      contextConfig
    );
    const { clone, files } = extractFiles(body, customIsExtractableFile, "");
    let uri = selectURI(operation, fetchUri);
    if (files.size) {
      if (options.headers)
        delete options.headers["content-type"];
      const RuntimeFormData = CustomFormData || FormData;
      const form = new RuntimeFormData();
      form.append("operations", serializeFetchParameter(clone, "Payload"));
      const map = {};
      let i = 0;
      files.forEach((paths) => {
        map[++i] = paths;
      });
      form.append("map", JSON.stringify(map));
      i = 0;
      files.forEach((_paths, file) => {
        customFormDataAppendFile(form, String(++i), file);
      });
      options.body = form;
    } else {
      if (useGETForQueries && // If the operation contains some mutations GET shouldnâ€™t be used.
      !operation.query.definitions.some(
        (definition) => definition.kind === "OperationDefinition" && definition.operation === "mutation"
      ))
        options.method = "GET";
      if (options.method === "GET") {
        const { newURI, parseError } = rewriteURIForGET(uri, body);
        if (parseError)
          return new Observable((observer) => {
            observer.error(parseError);
          });
        uri = newURI;
      } else options.body = serializeFetchParameter(clone, "Payload");
    }
    const { controller } = createSignalIfSupported();
    if (typeof controller !== "boolean") {
      if (options.signal)
        options.signal.aborted ? (
          // Signal already aborted, so immediately abort.
          controller.abort()
        ) : (
          // Signal not already aborted, so setup a listener to abort when it
          // does.
          options.signal.addEventListener(
            "abort",
            () => {
              controller.abort();
            },
            {
              // Prevent a memory leak if the user configured abort controller
              // is long lasting, or controls multiple things.
              once: true
            }
          )
        );
      options.signal = controller.signal;
    }
    const runtimeFetch = customFetch || fetch;
    return new Observable((observer) => {
      let cleaningUp;
      runtimeFetch(uri, options).then((response) => {
        operation.setContext({ response });
        return response;
      }).then(parseAndCheckHttpResponse(operation)).then((result) => {
        observer.next(result);
        observer.complete();
      }).catch((error) => {
        if (!cleaningUp) {
          if (error.result && error.result.errors && error.result.data)
            observer.next(error.result);
          observer.error(error);
        }
      });
      return () => {
        cleaningUp = true;
        if (typeof controller !== "boolean") controller.abort();
      };
    });
  });
}

// ../node_modules/@redwoodjs/web/dist/apollo/sseLink.js
var sseLink_exports = {};
__export(sseLink_exports, {
  SSELink: () => SSELink,
  isLiveQuery: () => isLiveQuery,
  isSubscription: () => isSubscription
});
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
var import_core = __toESM(require_core(), 1);
var import_utilities = __toESM(require_utilities(), 1);
init_graphql();

// ../node_modules/graphql-sse/lib/index.mjs
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);

// ../node_modules/graphql-sse/lib/common.mjs
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);

// ../node_modules/graphql-sse/lib/utils.mjs
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);
function isObject(val) {
  return typeof val === "object" && val !== null;
}

// ../node_modules/graphql-sse/lib/common.mjs
var TOKEN_HEADER_KEY = "x-graphql-event-stream-token";
function validateStreamEvent(e) {
  e = e;
  if (e !== "next" && e !== "complete")
    throw new Error(`Invalid stream event "${e}"`);
  return e;
}
function parseStreamData(e, data) {
  if (data) {
    try {
      data = JSON.parse(data);
    } catch {
      throw new Error("Invalid stream data");
    }
  }
  if (e === "next" && !data)
    throw new Error('Stream data must be an object for "next" events');
  return data || null;
}

// ../node_modules/graphql-sse/lib/handler.mjs
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
init_graphql();

// ../node_modules/graphql-sse/lib/client.mjs
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);

// ../node_modules/graphql-sse/lib/parser.mjs
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);
var ControlChars;
(function(ControlChars2) {
  ControlChars2[ControlChars2["NewLine"] = 10] = "NewLine";
  ControlChars2[ControlChars2["CchunkiageReturn"] = 13] = "CchunkiageReturn";
  ControlChars2[ControlChars2["Space"] = 32] = "Space";
  ControlChars2[ControlChars2["Colon"] = 58] = "Colon";
})(ControlChars || (ControlChars = {}));
function createParser() {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  let message = { event: "", data: "" };
  let pending = [];
  const decoder = new TextDecoder();
  return function parse2(chunk) {
    if (buffer === void 0) {
      buffer = chunk;
      position = 0;
      fieldLength = -1;
    } else {
      const concat = new Uint8Array(buffer.length + chunk.length);
      concat.set(buffer);
      concat.set(chunk, buffer.length);
      buffer = concat;
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === ControlChars.NewLine) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case ControlChars.Colon:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case ControlChars.CchunkiageReturn:
            discardTrailingNewline = true;
          case ControlChars.NewLine:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      } else if (lineStart === lineEnd) {
        if (message.event || message.data) {
          if (!message.event)
            throw new Error("Missing message event");
          const event = validateStreamEvent(message.event);
          const data = parseStreamData(event, message.data);
          pending.push({
            event,
            data
          });
          message = { event: "", data: "" };
        }
      } else if (fieldLength > 0) {
        const line = buffer.subarray(lineStart, lineEnd);
        const field = decoder.decode(line.subarray(0, fieldLength));
        const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);
        const value = decoder.decode(line.subarray(valueOffset));
        switch (field) {
          case "event":
            message.event = value;
            break;
          case "data":
            message.data = message.data ? message.data + "\n" + value : value;
            break;
        }
      }
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
      const messages = [...pending];
      pending = [];
      return messages;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}

// ../node_modules/graphql-sse/lib/client.mjs
function createClient(options) {
  const {
    singleConnection = false,
    lazy = true,
    lazyCloseTimeout = 0,
    onNonLazyError = console.error,
    /**
     * Generates a v4 UUID to be used as the ID using `Math`
     * as the random number generator. Supply your own generator
     * in case you need more uniqueness.
     *
     * Reference: https://gist.github.com/jed/982883
     */
    generateID = function generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    },
    retryAttempts = 5,
    retry = async function randomisedExponentialBackoff(retries2) {
      let retryDelay = 1e3;
      for (let i = 0; i < retries2; i++) {
        retryDelay *= 2;
      }
      await new Promise((resolve) => setTimeout(resolve, retryDelay + // add random timeout from 300ms to 3s
      Math.floor(Math.random() * (3e3 - 300) + 300)));
    },
    credentials = "same-origin",
    referrer,
    referrerPolicy,
    onMessage,
    on: clientOn
  } = options;
  const fetchFn = options.fetchFn || fetch;
  const AbortControllerImpl = options.abortControllerImpl || AbortController;
  const client = /* @__PURE__ */ (() => {
    let disposed = false;
    const listeners = [];
    return {
      get disposed() {
        return disposed;
      },
      onDispose(cb) {
        if (disposed) {
          setTimeout(() => cb(), 0);
          return () => {
          };
        }
        listeners.push(cb);
        return () => {
          listeners.splice(listeners.indexOf(cb), 1);
        };
      },
      dispose() {
        if (disposed)
          return;
        disposed = true;
        for (const listener of [...listeners]) {
          listener();
        }
      }
    };
  })();
  let connCtrl, conn, locks = 0, retryingErr = null, retries = 0;
  async function getOrConnect() {
    try {
      if (client.disposed)
        throw new Error("Client has been disposed");
      return await (conn !== null && conn !== void 0 ? conn : conn = (async () => {
        var _a, _b, _c;
        if (retryingErr) {
          await retry(retries);
          if (connCtrl.signal.aborted)
            throw new Error("Connection aborted by the client");
          retries++;
        }
        (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connecting) === null || _a === void 0 ? void 0 : _a.call(clientOn, !!retryingErr);
        connCtrl = new AbortControllerImpl();
        const unlistenDispose = client.onDispose(() => connCtrl.abort());
        connCtrl.signal.addEventListener("abort", () => {
          unlistenDispose();
          conn = void 0;
        });
        const url = typeof options.url === "function" ? await options.url() : options.url;
        if (connCtrl.signal.aborted)
          throw new Error("Connection aborted by the client");
        const headers = typeof options.headers === "function" ? await options.headers() : (_b = options.headers) !== null && _b !== void 0 ? _b : {};
        if (connCtrl.signal.aborted)
          throw new Error("Connection aborted by the client");
        let res;
        try {
          res = await fetchFn(url, {
            signal: connCtrl.signal,
            method: "PUT",
            credentials,
            referrer,
            referrerPolicy,
            headers
          });
        } catch (err) {
          throw new NetworkError(err);
        }
        if (res.status !== 201)
          throw new NetworkError(res);
        const token = await res.text();
        headers[TOKEN_HEADER_KEY] = token;
        const connected = await connect({
          signal: connCtrl.signal,
          headers,
          credentials,
          referrer,
          referrerPolicy,
          url,
          fetchFn,
          onMessage: (msg) => {
            var _a2;
            (_a2 = clientOn === null || clientOn === void 0 ? void 0 : clientOn.message) === null || _a2 === void 0 ? void 0 : _a2.call(clientOn, msg);
            onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg);
          }
        });
        (_c = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connected) === null || _c === void 0 ? void 0 : _c.call(clientOn, !!retryingErr);
        connected.waitForThrow().catch(() => conn = void 0);
        return connected;
      })());
    } catch (err) {
      conn = void 0;
      throw err;
    }
  }
  if (singleConnection && !lazy) {
    (async () => {
      locks++;
      for (; ; ) {
        try {
          const { waitForThrow } = await getOrConnect();
          await waitForThrow();
        } catch (err) {
          if (client.disposed)
            return;
          if (!(err instanceof NetworkError))
            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);
          conn = void 0;
          if (!retryAttempts || retries >= retryAttempts)
            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);
          retryingErr = err;
        }
      }
    })();
  }
  function subscribe2(request, sink, on) {
    if (!singleConnection) {
      const control2 = new AbortControllerImpl();
      const unlisten2 = client.onDispose(() => {
        unlisten2();
        control2.abort();
      });
      (async () => {
        var _a, _b, _c, _d, _e;
        let retryingErr2 = null, retries2 = 0;
        for (; ; ) {
          try {
            if (retryingErr2) {
              await retry(retries2);
              if (control2.signal.aborted)
                throw new Error("Connection aborted by the client");
              retries2++;
            }
            (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connecting) === null || _a === void 0 ? void 0 : _a.call(clientOn, !!retryingErr2);
            (_b = on === null || on === void 0 ? void 0 : on.connecting) === null || _b === void 0 ? void 0 : _b.call(on, !!retryingErr2);
            const url = typeof options.url === "function" ? await options.url() : options.url;
            if (control2.signal.aborted)
              throw new Error("Connection aborted by the client");
            const headers = typeof options.headers === "function" ? await options.headers() : (_c = options.headers) !== null && _c !== void 0 ? _c : {};
            if (control2.signal.aborted)
              throw new Error("Connection aborted by the client");
            const { getResults } = await connect({
              signal: control2.signal,
              headers: {
                ...headers,
                "content-type": "application/json; charset=utf-8"
              },
              credentials,
              referrer,
              referrerPolicy,
              url,
              body: JSON.stringify(request),
              fetchFn,
              onMessage: (msg) => {
                var _a2, _b2;
                (_a2 = clientOn === null || clientOn === void 0 ? void 0 : clientOn.message) === null || _a2 === void 0 ? void 0 : _a2.call(clientOn, msg);
                (_b2 = on === null || on === void 0 ? void 0 : on.message) === null || _b2 === void 0 ? void 0 : _b2.call(on, msg);
                onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg);
              }
            });
            (_d = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connected) === null || _d === void 0 ? void 0 : _d.call(clientOn, !!retryingErr2);
            (_e = on === null || on === void 0 ? void 0 : on.connected) === null || _e === void 0 ? void 0 : _e.call(on, !!retryingErr2);
            for await (const result of getResults()) {
              retryingErr2 = null;
              retries2 = 0;
              sink.next(result);
            }
            return control2.abort();
          } catch (err) {
            if (control2.signal.aborted)
              return;
            if (!(err instanceof NetworkError))
              throw err;
            if (!retryAttempts || retries2 >= retryAttempts)
              throw err;
            retryingErr2 = err;
          }
        }
      })().then(() => sink.complete()).catch((err) => sink.error(err));
      return () => control2.abort();
    }
    locks++;
    const control = new AbortControllerImpl();
    const unlisten = client.onDispose(() => {
      unlisten();
      control.abort();
    });
    (async () => {
      const operationId = generateID();
      request = {
        ...request,
        extensions: { ...request.extensions, operationId }
      };
      let complete = null;
      for (; ; ) {
        complete = null;
        try {
          const { url, headers, getResults } = await getOrConnect();
          let res;
          try {
            res = await fetchFn(url, {
              signal: control.signal,
              method: "POST",
              credentials,
              referrer,
              referrerPolicy,
              headers: {
                ...headers,
                "content-type": "application/json; charset=utf-8"
              },
              body: JSON.stringify(request)
            });
          } catch (err) {
            throw new NetworkError(err);
          }
          if (res.status !== 202)
            throw new NetworkError(res);
          complete = async () => {
            let res2;
            try {
              const control2 = new AbortControllerImpl();
              const unlisten2 = client.onDispose(() => {
                unlisten2();
                control2.abort();
              });
              res2 = await fetchFn(url + "?operationId=" + operationId, {
                signal: control2.signal,
                method: "DELETE",
                credentials,
                referrer,
                referrerPolicy,
                headers
              });
            } catch (err) {
              throw new NetworkError(err);
            }
            if (res2.status !== 200)
              throw new NetworkError(res2);
          };
          for await (const result of getResults({
            signal: control.signal,
            operationId
          })) {
            retryingErr = null;
            retries = 0;
            sink.next(result);
          }
          complete = null;
          return control.abort();
        } catch (err) {
          if (control.signal.aborted)
            return await (complete === null || complete === void 0 ? void 0 : complete());
          if (!(err instanceof NetworkError)) {
            control.abort();
            throw err;
          }
          if (lazy) {
            conn = void 0;
          }
          if (!retryAttempts || retries >= retryAttempts) {
            control.abort();
            throw err;
          }
          retryingErr = err;
        } finally {
          if (control.signal.aborted && --locks === 0) {
            if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {
              setTimeout(() => {
                if (!locks)
                  connCtrl.abort();
              }, lazyCloseTimeout);
            } else {
              connCtrl.abort();
            }
          }
        }
      }
    })().then(() => sink.complete()).catch((err) => sink.error(err));
    return () => control.abort();
  }
  return {
    subscribe: subscribe2,
    iterate(request, on) {
      const pending = [];
      const deferred = {
        done: false,
        error: null,
        resolve: () => {
        }
      };
      const dispose = subscribe2(request, {
        next(val) {
          pending.push(val);
          deferred.resolve();
        },
        error(err) {
          deferred.done = true;
          deferred.error = err;
          deferred.resolve();
        },
        complete() {
          deferred.done = true;
          deferred.resolve();
        }
      }, on);
      const iterator = async function* iterator2() {
        for (; ; ) {
          if (!pending.length) {
            await new Promise((resolve) => deferred.resolve = resolve);
          }
          while (pending.length) {
            yield pending.shift();
          }
          if (deferred.error) {
            throw deferred.error;
          }
          if (deferred.done) {
            return;
          }
        }
      }();
      iterator.throw = async (err) => {
        if (!deferred.done) {
          deferred.done = true;
          deferred.error = err;
          deferred.resolve();
        }
        return { done: true, value: void 0 };
      };
      iterator.return = async () => {
        dispose();
        return { done: true, value: void 0 };
      };
      return iterator;
    },
    dispose() {
      client.dispose();
    }
  };
}
var NetworkError = class extends Error {
  constructor(msgOrErrOrResponse) {
    let message, response;
    if (isResponseLike(msgOrErrOrResponse)) {
      response = msgOrErrOrResponse;
      message = "Server responded with " + msgOrErrOrResponse.status + ": " + msgOrErrOrResponse.statusText;
    } else if (msgOrErrOrResponse instanceof Error)
      message = msgOrErrOrResponse.message;
    else
      message = String(msgOrErrOrResponse);
    super(message);
    this.name = this.constructor.name;
    this.response = response;
  }
};
function isResponseLike(val) {
  return isObject(val) && typeof val["ok"] === "boolean" && typeof val["status"] === "number" && typeof val["statusText"] === "string";
}
async function connect(options) {
  const { signal, url, credentials, headers, body, referrer, referrerPolicy, fetchFn, onMessage } = options;
  const waiting = {};
  const queue = {};
  let res;
  try {
    res = await fetchFn(url, {
      signal,
      method: body ? "POST" : "GET",
      credentials,
      referrer,
      referrerPolicy,
      headers: {
        ...headers,
        accept: "text/event-stream"
      },
      body
    });
  } catch (err) {
    throw new NetworkError(err);
  }
  if (!res.ok)
    throw new NetworkError(res);
  if (!res.body)
    throw new Error("Missing response body");
  let error = null;
  let waitingForThrow;
  (async () => {
    var _a;
    try {
      const parse2 = createParser();
      for await (const chunk of toAsyncIterator(res.body)) {
        if (typeof chunk === "string")
          throw error = new Error(`Unexpected string chunk "${chunk}"`);
        let msgs;
        try {
          msgs = parse2(chunk);
        } catch (err) {
          throw error = err;
        }
        if (!msgs)
          continue;
        for (const msg of msgs) {
          try {
            onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg);
          } catch (err) {
            throw error = err;
          }
          const operationId = msg.data && "id" in msg.data ? msg.data.id : "";
          if (!(operationId in queue))
            queue[operationId] = [];
          switch (msg.event) {
            case "next":
              if (operationId)
                queue[operationId].push(msg.data.payload);
              else
                queue[operationId].push(msg.data);
              break;
            case "complete":
              queue[operationId].push("complete");
              break;
            default:
              throw error = new Error(`Unexpected message event "${msg.event}"`);
          }
          (_a = waiting[operationId]) === null || _a === void 0 ? void 0 : _a.proceed();
        }
      }
      if (Object.keys(waiting).length) {
        throw new Error("Connection closed while having active streams");
      }
    } catch (err) {
      if (!error && Object.keys(waiting).length) {
        error = new NetworkError(err);
      } else {
        error = err;
      }
      waitingForThrow === null || waitingForThrow === void 0 ? void 0 : waitingForThrow(error);
    } finally {
      Object.values(waiting).forEach(({ proceed }) => proceed());
    }
  })();
  return {
    url,
    headers,
    waitForThrow: () => new Promise((_, reject) => {
      if (error)
        return reject(error);
      waitingForThrow = reject;
    }),
    async *getResults(options2) {
      var _a;
      const { signal: signal2, operationId = "" } = options2 !== null && options2 !== void 0 ? options2 : {};
      try {
        for (; ; ) {
          while ((_a = queue[operationId]) === null || _a === void 0 ? void 0 : _a.length) {
            const result = queue[operationId].shift();
            if (result === "complete")
              return;
            yield result;
          }
          if (error)
            throw error;
          if (signal2 === null || signal2 === void 0 ? void 0 : signal2.aborted)
            throw new Error("Getting results aborted by the client");
          await new Promise((resolve) => {
            const proceed = () => {
              signal2 === null || signal2 === void 0 ? void 0 : signal2.removeEventListener("abort", proceed);
              delete waiting[operationId];
              resolve();
            };
            signal2 === null || signal2 === void 0 ? void 0 : signal2.addEventListener("abort", proceed);
            waiting[operationId] = { proceed };
          });
        }
      } finally {
        delete queue[operationId];
      }
    }
  };
}
function toAsyncIterator(val) {
  if (typeof Object(val)[Symbol.asyncIterator] === "function") {
    val = val;
    return val[Symbol.asyncIterator]();
  }
  return async function* () {
    const reader = val.getReader();
    let result;
    do {
      result = await reader.read();
      if (result.value !== void 0)
        yield result.value;
    } while (!result.done);
  }();
}

// ../node_modules/@redwoodjs/web/dist/apollo/sseLink.js
var mapCredentialsHeader = (httpLinkCredentials) => {
  if (!httpLinkCredentials) {
    return void 0;
  }
  switch (httpLinkCredentials) {
    case "omit":
    case "same-origin":
    case "include":
      return httpLinkCredentials;
    default:
      return void 0;
  }
};
var mapReferrerPolicyHeader = (referrerPolicy) => {
  if (!referrerPolicy) {
    return void 0;
  }
  switch (referrerPolicy) {
    case "no-referrer":
    case "no-referrer-when-downgrade":
    case "same-origin":
    case "origin":
    case "strict-origin":
    case "origin-when-cross-origin":
    case "strict-origin-when-cross-origin":
    case "unsafe-url":
      return referrerPolicy;
    default:
      return void 0;
  }
};
var hasTrustedDocument = (operation) => {
  var _a, _b;
  return (_b = (_a = operation.extensions) == null ? void 0 : _a.persistedQuery) == null ? void 0 : _b.sha256Hash;
};
var isSubscription = (definition) => {
  return definition.kind === Kind.OPERATION_DEFINITION && definition.operation === OperationTypeNode.SUBSCRIPTION;
};
var isLiveQuery = (definition) => {
  var _a;
  if (definition.kind !== Kind.OPERATION_DEFINITION || definition.operation !== OperationTypeNode.QUERY) {
    return false;
  }
  return !!((_a = definition.directives) == null ? void 0 : _a.find((d) => d.name.value === "live"));
};
var SSELink = class extends import_core.ApolloLink {
  constructor(options) {
    super();
    __publicField(this, "client");
    const { url, auth, headers, httpLinkConfig } = options;
    const { credentials, referrer, referrerPolicy } = (httpLinkConfig == null ? void 0 : httpLinkConfig.headers) || {};
    this.client = createClient({
      url,
      headers: async () => {
        const token = await auth.tokenFn();
        if (!token) {
          return { ...headers };
        }
        return {
          Authorization: `Bearer ${token}`,
          "auth-provider": auth.authProviderType,
          ...headers
        };
      },
      credentials: mapCredentialsHeader(credentials),
      referrer,
      referrerPolicy: mapReferrerPolicyHeader(referrerPolicy)
    });
  }
  request(operation) {
    return new import_utilities.Observable((sink) => {
      let request;
      if (hasTrustedDocument(operation)) {
        delete operation.query;
        request = { ...operation };
      } else {
        request = {
          ...operation,
          query: print(operation.query)
        };
      }
      return this.client.subscribe(request, {
        next: sink.next.bind(sink),
        complete: sink.complete.bind(sink),
        error: sink.error.bind(sink)
      });
    });
  }
};

// ../node_modules/@redwoodjs/web/dist/apollo/useCache.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);
var import_hooks = __toESM(require_hooks(), 1);
var useCache = () => {
  const client = (0, import_hooks.useApolloClient)();
  const cache = client.cache;
  const extract = (optimistic = false) => cache.extract(optimistic);
  const identify = (object) => {
    return { id: cache.identify(object) };
  };
  const modify = (object, fields) => {
    return cache.modify({ ...identify(object), fields });
  };
  const evict = (object) => {
    return cache.evict(identify(object));
  };
  const resetStore = () => {
    return client.resetStore();
  };
  const clearStore = () => {
    return client.clearStore();
  };
  return { cache, evict, extract, identify, modify, resetStore, clearStore };
};

// ../node_modules/@redwoodjs/web/dist/apollo/index.js
var { SSELink: SSELink2, isSubscription: isSubscription2, isLiveQuery: isLiveQuery2 } = sseLink_exports;
var ApolloProviderWithFetchConfig = ({ config, children, useAuth = useNoAuth, logLevel }) => {
  (0, import_core2.setLogVerbosity)(logLevel);
  const { getToken, type: authProviderType } = useAuth();
  const data = {
    mostRecentRequest: void 0,
    mostRecentResponse: void 0
  };
  const updateDataApolloLink = new ApolloLink((operation, forward) => {
    const { operationName, query, variables } = operation;
    data.mostRecentRequest = {};
    data.mostRecentRequest.operationName = operationName;
    data.mostRecentRequest.operationKind = query == null ? void 0 : query.kind.toString();
    data.mostRecentRequest.variables = variables;
    data.mostRecentRequest.query = query && (0, import_printer.print)(operation.query);
    return forward(operation).map((result) => {
      data.mostRecentResponse = result;
      return result;
    });
  });
  const withToken = (0, import_context.setContext)(async () => {
    const token = await getToken();
    return { token };
  });
  const { headers, uri } = useFetchConfig();
  const authMiddleware = new ApolloLink((operation, forward) => {
    const { token } = operation.getContext();
    const authHeaders = token ? {
      "auth-provider": authProviderType,
      authorization: `Bearer ${token}`
    } : {};
    operation.setContext(() => ({
      headers: {
        ...operation.getContext().headers,
        ...headers,
        // Duped auth headers, because we may remove the `FetchConfigProvider` at a later date.
        ...authHeaders
      }
    }));
    return forward(operation);
  });
  const { httpLinkConfig, link: redwoodApolloLink, ...rest } = config ?? {};
  const uploadLink = createUploadLink({
    uri,
    ...httpLinkConfig
    // The upload link types don't match the ApolloLink types, even though it comes from Apollo
    // because they use ESM imports and we're using the default ones.
  });
  const uploadOrSSELink = typeof SSELink2 !== "undefined" ? split(
    ({ query }) => {
      const definition = (0, import_utilities2.getMainDefinition)(query);
      return isSubscription2(definition) || isLiveQuery2(definition);
    },
    new SSELink2({
      url: uri,
      auth: { authProviderType, tokenFn: getToken },
      httpLinkConfig,
      headers
    }),
    uploadLink
  ) : uploadLink;
  const terminatingLink = split(
    ({ query }) => {
      var _a;
      const documentQuery = query;
      return ((_a = documentQuery == null ? void 0 : documentQuery["__meta__"]) == null ? void 0 : _a["hash"]) !== void 0;
    },
    (0, import_persisted_queries.createPersistedQueryLink)({
      generateHash: (document) => document["__meta__"]["hash"]
    }).concat(uploadOrSSELink),
    uploadOrSSELink
  );
  const redwoodApolloLinks = [
    { name: "withToken", link: withToken },
    { name: "authMiddleware", link: authMiddleware },
    { name: "updateDataApolloLink", link: updateDataApolloLink },
    { name: "httpLink", link: terminatingLink }
  ];
  let link = redwoodApolloLink;
  link ?? (link = ApolloLink.from(redwoodApolloLinks.map((l) => l.link)));
  if (typeof link === "function") {
    link = link(redwoodApolloLinks);
  }
  const client = new ApolloClient({
    // Default options for every Cell. Better to specify them here than in `beforeQuery` where it's too easy to overwrite them.
    // See https://www.apollographql.com/docs/react/api/core/ApolloClient/#example-defaultoptions-object.
    defaultOptions: {
      watchQuery: {
        // The `fetchPolicy` we expect:
        //
        // > Apollo Client executes the full query against both the cache and your GraphQL server.
        // > The query automatically updates if the result of the server-side query modifies cached fields.
        //
        // See https://www.apollographql.com/docs/react/data/queries/#cache-and-network.
        fetchPolicy: "cache-and-network",
        // So that Cells rerender when refetching.
        // See https://www.apollographql.com/docs/react/data/queries/#inspecting-loading-states.
        notifyOnNetworkStatusChange: true
      }
    },
    link,
    ...rest
  });
  const extendErrorAndRethrow = (error, _errorInfo) => {
    error["mostRecentRequest"] = data.mostRecentRequest;
    error["mostRecentResponse"] = data.mostRecentResponse;
    throw error;
  };
  return import_react.default.createElement(ApolloProvider, { client }, import_react.default.createElement(ErrorBoundary, { onError: extendErrorAndRethrow }, children));
};
var ErrorBoundary = class extends import_react.default.Component {
  componentDidCatch(...args) {
    this.setState({});
    this.props.onError(...args);
  }
  render() {
    return this.props.children;
  }
};
var RedwoodApolloProvider = ({
  graphQLClientConfig,
  fragments,
  useAuth = useNoAuth,
  logLevel = "debug",
  children
}) => {
  const { cacheConfig, ...config } = graphQLClientConfig ?? {};
  if (fragments) {
    fragmentRegistry.register(...fragments);
  }
  const cache = new InMemoryCache({
    fragments: fragmentRegistry,
    possibleTypes: cacheConfig == null ? void 0 : cacheConfig.possibleTypes,
    ...cacheConfig
  }).restore((globalThis == null ? void 0 : globalThis.__REDWOOD__APOLLO_STATE) ?? {});
  return import_react.default.createElement(FetchConfigProvider, { useAuth }, import_react.default.createElement(
    ApolloProviderWithFetchConfig,
    {
      config: { cache, ...config },
      useAuth,
      logLevel
    },
    import_react.default.createElement(
      GraphQLHooksProvider,
      {
        useQuery: import_hooks2.useQuery,
        useMutation: import_hooks2.useMutation,
        useSubscription: import_hooks2.useSubscription,
        useBackgroundQuery: import_hooks2.useBackgroundQuery,
        useReadQuery: import_hooks2.useReadQuery,
        useSuspenseQuery: import_hooks2.useSuspenseQuery
      },
      children
    )
  ));
};

export {
  useCache,
  RedwoodApolloProvider
};
//# sourceMappingURL=chunk-K7GCD7DU.js.map
